/* ProteinEvolver.c
// Programmer:	Miguel Arenas, David Posada and Ugo Bastolla.
// Copyright 2008-2012.
// 
// Simulation of protein evolution along phylogenies accounting for structural stability
//
// ProteinEvolver evolves proteins under realistic models of evolution along a phylogeny. First, the phylogeny can be simulated using the coalescent 
//  modified with demographics and migration implemented in CoalEvol (Arenas and Posada, in prep). 
//  Then, proteins can be evolved under a wide set of realistic site-dependent and site-independent substitution models of evolution.
//
//								
//
//// HISTORY: 
//
// Version 1.0.0 (June 2012)
//		- Implementation of Pop_evol (code developed by Ugo Bastolla) in ProteinEvolver, a mutational model to evolve DNA sequences accounting for structural protein stability (DNA -> AA -> DNA) and the HKY substitution model.
//
// Version 1.0.1 (July-August 2012)
//		- pdb from input file.
//		- Seed for structural protein stability substitution model comes now from the main input file (parameters).
//
// Version 1.0.2 (August 2012)
//		- Structural protein stability accounting for rates of change among all nucleotide states (GTR and GTnR).		
//
// Version 1.0.3 (September 2012)
//		- Solved bug in the "Compute_load" function. Other warnings from Pop_Evol were solved.
//		- Solved bug in GTR and GTnR models for PopEvol section (in "Mutate_nuc" and "Compute_load" functions).
//		- Structural protein stability substitution model crossed with any empirical substitution model (Blosum62, CpRev, Dayhoff, DayhoffDCMUT, HIVb, HIVw, JTT, JonesDCMUT, LG, Mtart, Mtmam, Mtrev24, RtRev, VT, WAG, UserEAAM).		
//		- Validation. User-specified tree was inferred by Hyphy from the simulated alignmets (for both DNA and amino acid data) under the structural protein stability substitution model.
//
// Version 1.0.4 (September 2012)
//		- Coalescent with recombination is allowed for the simulation under structural protein stability substitution models. 
//			When a recombination occurs, the evolution stops at the first parental recombinant node and go in other direction. Later, when the other parental recombinat node is reached, there is a combination
//			of the material, according to the recombination breakpoint, to generate the material for the descendant node, which continues the evolution.
//			Recombination can be homogeneous (recombination rate is constant among all sites) or heterogeneous (recombination hotspots, functions developed by David Posada). 
//			However, recombination cannot be applied using user-specified input trees and structural protein stability substitution models because part of a protein cannot be evolved under such a substitution model.
//			
// Version 1.0.5 (September 2012)
//		- Included options to print the energy output files per branch produced by the structural protein stability substitution models.
//		- Print information about the attempted mutations in the structural protein stability substitution models.
//
// Version 1.1.0 (September-December 2012)
//		- Proportion of invariable sites +I and variable substitution rates per site (heterogeneity) according to a gamma distribution +G, for the structural protein stability substitution models.
//		- Heterogeneity by a user-defined vector. Each site can evolve under a particular rate user-defined. This is compatible with the specification of +G.
//		- Print number and mean of the introduced substitution events and, those nonsynonymous for DNA structural protein evolution models.
//		- Maximun number of characters for the name of taxas is 10.
//		- More robust generation of the random seed.
//		- Work with bigger input trees (MAX_LINE).
//
// Version 1.2.0 (September-December 2012)
//		- Implementation of the neutral evolution model to evolve sequences accounting for the protein structure. Here population size is not required, follow this with the variable "NEUTRAL".
//      - A bug in the simulation of proteins accounting for structural constaints was fixed. Bug related with the computation of DeltaG. October 2015.
//
//
 //		ABC version (January 2019)
 //		- Adaptation to ABC
//
 */


#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <ctype.h>
#include <limits.h>
#include <sys/timeb.h>

#ifndef macintosh
	#include <sys/types.h>
	#include <sys/stat.h>
#endif
#ifdef MAC
	#include <sioux.h>
	#include <console.h>
	#include <unix.h>
#endif

#ifdef MPI
	#include "mpi.h"
	#define nmaxproc 16
	#define comm MPI_COMM_WORLD
#endif

#define PROGRAM_NAME		"ProteinEvolverABC"
#define VERSION_NUMBER		"1.2.0"
#define	NO					0
#define	YES					1
#define NUMCOD				61
#define NUMAA				20
#define	pos(i,j,n)			((i)*(n)+(j))
#define post(i,j,n)			((j)*(n)+(i))
#define INCREMENT_NODES		500
#define INCREMENT_SEGMENTS	500
#define USER_INPUT
#undef	USER_INPUT
#define HUDSON_UNITS
#undef	HUDSON_UNITS
#define	MAX_NAME			6000
#define MAX_TREES			200
#define MAX_TAXA			500
#define MAX_LINE			60000
#define MAX_tnodeS			(2*MAX_TAXA-1)
#define	MAX_CHILDREN		10

/* Pop_evol */
#define N_CHAR 400          // Max. length of file names
#define EXT_AVE "_ave.dat"  // Extension for output file with averages
#define EXT_DNA "_dna.dat"  // Extension for output file with dna statistics
#define EXT_OUT "_stab.dat" // Extension for output file with folding
#define RANDOMLIMIT				(RANDOMTYPE)2147483647
#define INVRANDOMLIMITFLOATING	(double)(1.0/2147483648.0)
#define MULTIPLIER				(RANDOMTYPE)16807
#define ATOM_MAX 7000000
#define RES_MAX 10000
#define FILE_MSG   "message.out"
#define L_MAX 40000       /* Maximal length of a chain */
#define AA 0.1
#define BB 4.0
#define Q0 0.1
#define IJ_MIN 3  // Minimum value of |i-j| for contacts
#define NCMAX 24    // Maximum number of contacts per residue
#define NUC_CODE "ATGC"
#define NUC_CHAR "ATGC"
/*#define AMIN_CODE "AEQDNLGKSVRTPIMFYCWH"*/
#define N_PROT_MAX 10000
#define N_PARAM 211
#define N_STR 100
#define DUMM 1000000
/* PopEvol AMIN_CODE */
#define AMIN_CODE "AEQDNLGKSVRTPIMFYCWHX"
/* ProteinEvolver AMIN_CODE, it does no like to PopEvol.. */
/*#define AMIN_CODE "ARNDCQEGHILKMFPSTWYVX"*/ 
#define PDBEXT     ".pdb" /*.ent.Z*/
#define PDBCAT     "zcat"  /* zcat */
#define PDBTMP     "pdb.dat"

float DeltaG_thr;     // Threshold for neutral evolution
float Coeff_thr=0.98; // DeltaG_thr=Coeff_thr*DeltaG_PDB
int INI_NEUTRAL=1;    // Initialize neutral threshold?

typedef struct segment
	{
	struct	segment *before1, *before2, *after1, *after2;
	int		sIndex;
	int		sStart;
	int		sEnd;
	int		sIndexNode;
	}
	TreeSegment;
	
typedef struct node
	{
	struct node		*left, *right, *anc1, *anc2, *outgroup, *sib;
	int				index, label, isOutgroup; 
	int			   	numSegNode;
	double			length, time;
	int				indexOldMigPop;
	int				indexCurrentMigPop;
	int 			class, breakp, passNumber, breakCodon, whereBreakCodon;
	int				NetLabelPrint;
	int				MRCAfrom, MRCAto;
	int				GMRCA_ancestral;
	int				*SitesNonAncHere;
	double			BBM0omg;
	}
	TreeNode;

typedef struct nodex
	{
	struct nodex	*left, *right, *anc1, *outgroup;
	int				index, label, isOutgroup, NetIndex;
	int				indexOldMigPop; 
	double			length, time;
	int				MRCAfrom, MRCAto;
	/*struct Pij*/ /* Future: Because each node can has several Pij matrixes, a Pij per category.. */
	}
	TreeNodex;

typedef struct QijOmegaCat
	{
	double Root_C_cat[NUMCOD];
	double Cijk_C_cat[NUMCOD*NUMCOD*NUMCOD*NUMCOD];
	}
	Qij_OmegaCat;

typedef struct sample
	{	
	float		time;
	int		size;
	int		*member;
	}
	SampleSt;


typedef struct tnode
    {
    struct tnode	*parent, *child[MAX_CHILDREN];
    double		length;
    int			index, label;
    int			numChildren;
	char			*name;
	double			BBM0omg;
	}
    Treetnode;

typedef struct
    {
    struct	Treetnode *tnode;	
	int		begin;
	int		end;
	}
    Tree;



typedef struct {
  //float x,y,z;
  float r[3];
  float B_factor;
  char name[5];
  int last_rot_axe; // last axis counted from protein start
  int res;
  char aa;
  int i_next, i_num;
  float anisou[3][3];
  float occupancy;
  int chain;
} atom;

struct axe{
  float v[3];                    // axe versor
  float offset[3];               // orign of the axis
  double global_shift[3];        // glob_shift[k]=<r-offset[k]>_i>k X axe[k]
  double global_rot[3];          // 
  double local_rot[3];
  double local_shift[3];         // glob_shift-
  float shift[3];
  char type;
  int res;
  int atom1, atom2;              // atoms that define the axe
  int first_rot_atom;            // first and last atoms moved by the axe
  int last_rot_atom;
  int first_rot_kin;             // first reference atom moved by the axe
  int last_rot_kin;
  int chain;
};

struct interaction{
  int i1, i2; // atom2 > atom1
  float r2, rmin, sec_der;
  int type;
};

struct residue{
  atom *atom_ptr;
  int n_atom;
  char chain;
  char pdbres[6];
  char amm;
  short i_aa;
  short exo;
  short n_cont;
  float PE;
  float asa;
  float B_factor;
  float B_NM;
};

struct chain{
  int ini_atom;
  int natoms;
  int ini_axe;
  int mainaxes;
  int ini_side;
  int nsides;
  int ini_res;
  int nres;
  int nref;
  int ini_cart;
  int ncart;
  char label;
  int *alignres;
};


struct contact{
  short res1;
  short res2;
};

struct protein{
  char name[40];
  int length;
  int n_cont;
  short **contact;
  struct contact *cont_list;
};

struct state{
  short first;
  float energy;
  float overlap;
  float alpha;
  short n_cont;
  short **cont;
  struct protein *prot_ptr;
};


typedef unsigned long RANDOMTYPE;
extern struct residue seq[RES_MAX];
extern struct protein prot[N_PROT_MAX], target;
//extern float **interactions;



/* Read */
static void 	PrintTitle (FILE *file);
static void 	PrintDate (FILE *file);
static void		PrintUsage();
#ifdef USER_INPUT
static void 	UserInput (long int *seed);
#endif
static void		ReadUntil (FILE *fv, char stopChar, char *what);
static void		PrintRunSettings (FILE *filep, long int seed);
static void		ReadParametersFromFile ();
static void		ReadEAAMfromFile ();
static void		ReadECMfromFile ();
static void		ReadHetRecfromFile ();
static void		ReadHetVectorfromFile ();
static void		ReadParametersFromCommandLine (int argc, char **argv);
	/* Nucleotide Models */
static void 	HKY (double Pij[4][4], double time, double kappa, double rate, double p_i[4]);
static void 	GTR (double Pij[4][4], double branchLength, double varRate, double p_i[4]);
static void		GTnR (double Pij[4][4], double branchLength, double varRate, double p_i[4]);
static void 	SubstitutionMatrix (double ch_prob[4][4], double time, double kappa, double rate, double p_i[4]);
/*static void		SimulateDataForSite (TreeNodex *p, int siteNum, int numSites, double mutationRate, double kappa, double p_i[4], double rate, long int *seed, char *MRCAsequence);*/
/*static void		EvolveSequenceOnTree (long int *seed, double mutationRate, double kappa, double alpha, double p_i[4], int numSites, int *arrayIndBreakpointsOrd, char *MRCAsequence);*/
static void		EvolveSequenceOnTree_NEW (long int *seed, double mutationRate, double kappa, double alpha, double p_i[4], int numNuc, int indNumRE, int *arrayIndBreakpointsOrd, char *MRCAsequence, int numSites, int dataSetNum, char *dirStability);
static void		EvolveSequenceOnTree_NEW_AA (long int *seed, double mutationRate, double alpha, double p_i_aa[20], int numNuc, int indNumRE, int *arrayIndBreakpointsOrd, char *MRCAsequence, int numSites, int dataSetNum, char *dirStability);
static char		WhichNuc (int nucId);
static int		WhichNucNumber (char siteLetter);
static int		WhichAANumber (char siteLetter);
static char 	WhichAA (int A_A);
static int		TellMeGMRCALabel (TreeNode *p);
static void 	SimulateDataForSite_Nucleotide_RECURSIVE_NET (TreeNode *p, int siteNucleotide, int numSites, double mutationRate, double rate, double kappa, long int *seed);
static void 	SimulateDataForSite_AA_RECURSIVE_NET (TreeNode *p, int siteNucleotide, int numSites, double mutationRate, double rate, long int *seed);

/*static void 	SetMatrix(double Pij[4][4], double len);*/
/*static void 	SetVector(double *vector, short base, double len);*/
/* Codon Models */
/*static void		SimulateDataForSite_Codon (TreeNode *p, int siteCodon, int numSites, double mutationRate, int numOmegaCat, double rate, long int *seed);*/
static void		EvolveSequenceOnTree_Codon (long int *seed, double mutationRate, double alpha, int numNuc, int indNumRE, int *arrayIndBreakpointsOrd, char *MRCAsequence, int numOmegaCat, int numSites);
static void 	SimulateDataForSite_Codon_RECURSIVE_NET (TreeNode *p, int siteCodon, int numSites, double mutationRate, int numOmegaCat, double rate, long int *seed, int Cbroke);
static int		CombineTwoCodons (int InCodon1, int InCodon2, int brokePosition);
static void		CodonModel (double Pij[NUMCOD][NUMCOD], double branchLength, double varRate);
static void		CodonModel_Cat (double Pij[NUMCOD][NUMCOD], double branchLength, double varRate);
static void		CodonModel_specialBranches (double Pij[NUMCOD][NUMCOD], double branchLength, double varRate, long int *seed, int siteCodon, int label1, int label2, int index1, int index2, double BBM0w);
static void		AAevolModel (double Pij[NUMAA][NUMAA], double branchLength, double varRate);
static int		EnterCodonMRCA_Freq (TreeNode *p, int siteNum, int sitePosition, int numNuc, int out_C[4], int codon[3]);
static int		EnterCodonMRCA_File (TreeNode *p, int siteNum, int numNuc, char *MRCAsequence, int out_C[4]);
static int		makeCodonFromNuc (int x, int y, int z);
static double	codonTable_frequencies_MRCA (int cod);
static double	codonTable_frequencies (int cod);
static void		buildCodonMatrix_Qij_Cijk ();
static void		buildCodonMatrix_MG94_Qij_Cijk ();
static void		buildCodonMatrix_EmpiricalCodonModel_Qij_Cijk ();
static void		buildAAMatrix_Qij_Cijk ();
static double	giveAAcontribution (int x, int y);
static int		numdif_codon (int codon1, int codon2);
static void		number_to_codon (int ind, char out[]);
static void		number_to_codon_MRCA(int ind, int codon[]);
static void 	number_to_codon2(int ind, int out[]);
static int		codonTable_DnDs(int cod);
static int		codon_tr_tv (int indi, int indj);
static double	codon_NRmat(int indi, int indj);
static double	codon_Rmat(int indi, int indj);
static void		Empirical_AA_model ();
static void		Empirical_Codon_model (); 
static int		gammasCalculate (double alpha_d, int numCategories);
	/* Eigen */
static int		EigenREV (double Root[], double Cijk[]);
static int		EigenREV_Codon (double Root_C[], double Cijk_C[]);
static int		EigenREV_AA (double Root_AA[], double Cijk_AA[]);
/*static double *CalcREprobs (int numSequences, int rateType);*/
	/* Print Sequences */
static void 	PrintSequences (/*int replicate*/);
static void 	PrintAncestralSequences (/*int replicate*/);
static void 	PrintSequences_C (/*int replicate*/);
static void 	PrintAncestralSequences_C (/*int replicate*/);
static void 	PrintSequences_AA (/*int replicate*/);
static void 	PrintAncestralSequences_AA (/*int replicate*/);
static void 	PrintOutMRCAFiles_C (/*int replicate*/);
static void 	PrintOutMRCAFiles_C_Conc (/*int replicate*/);
static void 	PrintOutMRCAFiles (/*int replicate*/);
static void 	PrintOutMRCAFiles_Conc (/*int replicate*/);
static void 	PrintOutMRCAFiles_AA (/*int replicate*/);
static void 	PrintOutMRCAFiles_AA_Conc (/*int replicate*/);
static void		PrintOutGMRCAFiles_Codon_AncestralMat();
static void 	PrintSequences_FASTA (/*int replicate*/);
static void 	PrintAncestralSequences_FASTA (/*int replicate*/);
static void 	PrintSequences_AA_FASTA (/*int replicate*/);
static void 	PrintAncestralSequences_AA_FASTA (/*int replicate*/);
static void 	PrintSequences_C_FASTA (/*int replicate*/);
static void 	PrintAncestralSequences_C_FASTA (/*int replicate*/);
static void 	PrintSequences_NEXUS (/*int replicate*/);
static void 	PrintAncestralSequences_NEXUS (/*int replicate*/);
static void 	PrintSequences_AA_NEXUS (/*int replicate*/);
static void 	PrintAncestralSequences_AA_NEXUS (/*int replicate*/);
static void 	PrintSequences_C_NEXUS (/*int replicate*/);
static void 	PrintAncestralSequences_C_NEXUS (/*int replicate*/);
static void 	PrintNEXUS_initial ();
static void 	PrintNEXUS_end ();
	/* Random and others */
static double	RndGamma (double s, long int *seed);
static double	RndGamma1 (double s, long int *seed);
static double	RndGamma2 (double s, long int *seed);
static double	RandomGamma (double shape, long int *seed);
static double	RandomGamma1 (double s, long int *seed);
static double	RandomGamma2 (double s, long int *seed);
static double	RandomBeta (double p, double q, long int *seed);
/*static void	RandomizeArray(int array[], int first, int last);*/
/*static int	Rand (int max);*/
/*static double Rndu (void);*/
static double 	RandomUniform (long int *seed);
static double	RandomExponential (double mean, long int *seed);
 				/* hotspot recombination */
static int 		RandomUniformTo (int max, long int *seed);
/* static int	RandomPoisson (double lambda, long int *seed); */ /* not used */
static double 	RandomNormal (double mean, double variance, long int *seed);
	/* Total Segments Functions */
static void		MakeCoalescenceTree (int numSequences, int numSites, int numNuc, int N, double recombinationRate, int numPopulations, long int *seed);
static void		MakeCoalescenceTreeHotspotRec (int numSequences, int numSites, int numNuc, int N, double recombinationRate, int numPopulations, long int *seed);
static int		bbin (double dat, double *v);
static int		bbinDemes (double dat, double *v, int n);
static int		bbinInOmegaCat (double dat, double *v, int n);
static int		bbin_EnterMRCA (double dat, double *v);
static int		CalcIndividualGi (int Individual, TreeNode *nodes, int *activeGametes, int numNuc, int *S_MRCA, int sizeNode);
/*static int	CalcIndividualGi_HotSpots (int Individual, TreeNode *nodes, int *activeGametes, int numNuc, int *S_MRCA, int sizeNode);*/
static int		IsValidBreakSite (int *activeGametes, TreeNode *nodes, int whichInd, int whichSite, int *S_MRCA);
static int		CountsForExpNumRec (int *activeGametes, int whichInd, int whichSite, TreeNode *nodes, int *S_MRCA, int sizeNode); 
static int		recSegmentsGeneratesLeft (int nodeValue, TreeSegment *s, TreeSegment *n, int numNuc, int whichSite, int *actSegIndex);
static int		recSegmentsGeneratesRight (int nodeValue, TreeSegment *s, TreeSegment *m, int numNuc, int whichSite, int *actSegIndex);
static int		recSegmentsGeneratesLeftBrokenCodon (int nodeValue, TreeSegment *s, TreeSegment *n, int numNuc, int whichSite, int LeftLess, int RightHigh, int *actSegIndex);
static int		recSegmentsGeneratesRightBrokenCodon (int nodeValue, TreeSegment *s, TreeSegment *m, int numNuc, int whichSite, int LeftLess, int RightHigh, int *actSegIndex);
static int		overLapSegmentsCoalMRCA (TreeNode *p, TreeNode *q, int sizeNode_p, int sizeNode_q, int site);
static void		buildTreeCoal (TreeNode *p, TreeNodex *f, int numSequences, int *numActNodex);
static void		buildTreeInit (TreeNode *p, TreeNodex *f, int numNuc, int *arrayIndBreakpointsOrd, int whoBreakp, int numSequences, int *numActNodex);
static void		buildTreeEnd (TreeNode *p, TreeNodex *f, int numNuc, int *arrayIndBreakpointsOrd, int whoBreakp, int numSequences, int *numActNodex);
static void		buildTreeIntern (TreeNode *p, TreeNodex *f, int numNuc, int *arrayIndBreakpointsOrd, int whoBreakp, int numSequences, int *numActNodex);
static int		IndexSeg (TreeNodex *f);
static int		IndexSegNet (TreeNodex *f);
static int		LabelSeg (TreeNodex *f);
static void		ListTimesSeg (TreeNodex *f);
static void		PrintTimesSeg ();
static void		PrintTreesSeg (int replicate, int indNumRE, int numNuc, int *arrayIndBreakpointsOrd);
static void		WriteTreeSeg (TreeNodex *f);
static void		RelabelNodesSeg (TreeNodex *f);
static double	roundit(double d, int dig);
long double		roundl(long double x);
static void		WriteTreeSegCodonModel (TreeNodex *f, int *listVisitedNodes, int currentNumber);
/* hotspost recombination */
static int 		GammaHotspots (double lambda, double interval, long int *seed);
static int 		PoissonHotspots (double lambda, long int *seed);
static void		UniformHotspots (int numberHotspots, long int *seed);
static void 	SimRecombinationPDF (double *counts, long int *seed);
/* user-specified trees */
static void		ReadUntilExclusive (FILE *fv, char stopChar, char *what);
static void		ReadTree (FILE *fp, Treetnode *treeRoot);
static void		CheckTree ();
static void		Initializetnodes(Treetnode *p, int howManytnodes);
static void		FinishTree (Treetnode *p);
static void		Labeltnodes ();
static void		WriteTree (FILE *fp, Treetnode *p);
static void		Listtnodes (FILE* fp, int numSequences, Treetnode *p);
static int		Dex (Treetnode *p);
static int		Lab (Treetnode *p);
static char		*PrintChildren (Treetnode *p);
static char		*AllocCharArray (int length, char *name);
static void		EvolveSequenceOnTree_UserTrees_Nt (long int *seed, double kappa, double alpha, double p_i[4], int numSites, int numNuc, char *MRCAsequence, int dataSetNum, char *dirStability);
static void		EvolveSequenceOnTree_UserTrees_AA (long int *seed, double alpha, double p_i_aa[20], int numSites, int numNuc, char *MRCAsequence, int dataSetNum, char *dirStability);
static void		EvolveSequenceOnTree_UserTrees_Codon (long int *seed, double alpha, int numSites, int numNuc, char *MRCAsequence, int numOmegaCat);
static void		SimulateDataForSite_UserTrees_Nt (Treetnode *p, int siteNum, int numSites, int numNuc, double kappa, double p_i[4], double siteRate, long int *seed, char *MRCAsequence);
static void		SimulateDataForSite_UserTrees_AA (Treetnode *p, int siteNum, int numSites, int numNuc, double p_i_aa[20], double siteRate, long int *seed, char *MRCAsequence);
static void		SimulateDataForSite_UserTrees_Codon (Treetnode *p, int siteNum, int numSites, int numNuc, double siteRate, long int *seed, char *MRCAsequence, int *codonMRCASeqx);
static void		PrintSequences_UserTrees ();
static void		PrintSequences_Ancestral_UserTrees ();
static void		PrintSequences_UserTrees_FASTA ();
static void		PrintSequences_Ancestral_UserTrees_FASTA ();
static void		PrintSequences_UserTrees_NEXUS ();
static void		PrintSequences_Ancestral_UserTrees_NEXUS ();
static void		PrintOutMRCAFiles_userTrees ();
static void		PrintSequences_UserTrees_AA ();
static void		PrintSequences_Ancestral_UserTrees_AA ();
static void		PrintSequences_UserTrees_FASTA_AA ();
static void		PrintSequences_Ancestral_UserTrees_FASTA_AA ();
static void		PrintSequences_UserTrees_NEXUS_AA ();
static void		PrintSequences_Ancestral_UserTrees_NEXUS_AA ();
static void		PrintOutMRCAFiles_userTrees_AA ();
static void		PrintSequences_UserTrees_Cod ();
static void		PrintSequences_Ancestral_UserTrees_Cod ();
static void		PrintSequences_UserTrees_FASTA_Cod ();
static void		PrintSequences_Ancestral_UserTrees_FASTA_Cod ();
static void		PrintSequences_UserTrees_NEXUS_Cod ();
static void		PrintSequences_Ancestral_UserTrees_NEXUS_Cod ();
static void		PrintOutMRCAFiles_userTrees_Cod ();
static void		PrintRunSettings_userTrees (FILE *filep, long int seed);
/*static void 	AsignDNDSbranches (Treetnode *p, int howManytnodes, double dNdSbranches[MAX_tnodeS]);*/
/* protein stability substitution models */
char			*Pop_evolDNA (double branchLength, char *current_seq, int numSites, int dataSetNum, int Labelbranch, char *dirStability, int AlmostRootNode, long int *seed);
char			*Pop_evolAA (double branchLength, char *current_seq, int numSites, int dataSetNum, int Labelbranch, char *dirStability, int AlmostRootNode, long int *seed);
static void 	SimulateDataForSite_Nucleotide_RECURSIVE_NET_Pop_Evol (TreeNode *p, int siteNucleotide, int numSites, double mutationRate, double kappa, long int *seed, int dataSetNum, char *dirStability);
static void		SimulateDataForSite_UserTrees_Nt_Pop_Evol (Treetnode *p, int siteNum, int numSites, int numNuc, double kappa, double p_i[4], double siteRate, long int *seed, char *MRCAsequence, int dataSetNum, char *dirStability);
static void 	SimulateDataForSite_AA_RECURSIVE_NET_Pop_Evol (TreeNode *p, int siteNucleotide, int numSites, double mutationRate, long int *seed, int dataSetNum, char *dirStability);
static void		SimulateDataForSite_UserTrees_AA_Pop_Evol (Treetnode *p, int siteNum, int numSites, int numNuc, double p_i_aa[20], long int *seed, char *MRCAsequence, int dataSetNum, char *dirStability);
int 			Get_para (/*int argc, char **argv,*/ char *file_pdb, char chain[], char *file_seq, char *file_str, int *N_pop, float *TEMP, float *s0, float *sC0, float *sC1, long *IT_MAX, float *freq_nuc, float *trans_ratio, int *REM3, char *dir_out, int *bvalue, int *NEUTRAL);
static int		Read_parameters(char *FILE_IN, char *file_pdb, char *chain, char *file_seq, char *file_str, int *N_pop, float *TEMP, float *s0, float *sC0, float *sC1, int *REM3, long *IT_MAX, float *freq_nuc, float *trans_ratio, int *bvalue, int *NEUTRAL);
void			help ();
int 			Code_AA (char res);
static int 		Code_AA2 (char res);
int				Code_nuc (char nuc);
char 			Amin_code (int), Nuc_code(int);
int 			Transition (char nuc);
/*void 			Read_nuc_freq(char *file_nuc_freq, float *freq_nuc, float *trans_ratio, float *mut_rate);*/
unsigned long 	randomgenerator (void);
void 			InitRandom ( RANDOMTYPE);
RANDOMTYPE 		Random ();
double 			RandomFloating ();
int 			Get_pdb(struct protein *prot, short **aa_seq, char *file, char *chain);
static void 	GetPdbId(char *pdb_file_in, char *pdbid);
static int 		Contact_alpha(struct residue res_i, struct residue res_j);
static int 		Contact_beta (struct residue res_i, struct residue res_j);
static int 		Contact (struct residue res_i, struct residue res_j);
static 			atom *Find_atom (struct residue seq, char code[2]);
static short 	**Store_map (int N_res, struct residue *seq, short *num_cont, int N_cont, struct contact *Contact_list, int l_cont);
struct contact 	*Contact2Contlist (short **contact, int nres, int ncont);
short 			**Compute_map (int N_res, struct residue *seq, int *N_cont);
void 			Average_B (struct residue *seq, int N);
int 			Read_coord (char *pdb_name, int *nmr, struct residue *seq, atom *atoms, char *chain_to_read, int *ANISOU);
int 			Get_target (char *file_str, char *name_tar, int *len_tar);
void 			Contact_statistics (double ***Cont_freq, double ***C2, double ***C23, double ***C3, double *A2, double *A3, int len_nat, char *file_str, char *dirStability, char *file_seq, int print);
float 			G_misf_2_TEMP (double E1, double E2, double A2);
float 			G_misf_3_TEMP (double E1, double E2, double A2, double E23, double E3, double A3);
float 			Compute_Tfreeze_3 (float K2, float K3, float SC);
void 			Fill_C_nat (int length, short **contact);
float 			Compute_DG_REM3 (short *aa_seq, int L, double *E_nat, double *E1_misf, double *E2_misf, double *E23_misf, double *E3_misf, char *file_str, char *dirStability, char *file_seq);
float 			Mutate_DG_REM3 (short *aa_seq, int L, int res_mut, short aa_new, double *E_nat, double *E1, double *E2, double *E23, double *E3);
float 			Compute_DG_REM2 (short *aa_seq, int L, double *E_nat, double *E1_misf, double *E2_misf, char *file_str, char *dirStability, char *file_seq);
float 			Mutate_DG_REM2 (short *aa_seq, int L, int res_mut, short aa_new, double *E_nat, double *E1, double *E2);
float 			Print_DG_REM3 (double E_nat, double E1, double E2, double E23, double E3, char *name);
float 			Print_DG_REM2 (double E_nat, double E1, double E2, char *name);
float 			Print_DG_REM3_NoPrint (double E_nat, double E1, double E2, double E23, double E3);
float 			Print_DG_REM2_NoPrint (double E_nat, double E1, double E2);
char 			*Read_sequence2 (int *len_dna, char *current_seq, int numSites);
int  			Compare_amm_dna (char *dna_seq, int len_dna, short *aa_seq, int len_amm, char **codon, char *coded_aa);
int 			Translate_new (char *dna_seq, short *aa_seq, int length, char **codon, char *coded_aa);
char 			*Extract_dna (int *len_dna, int len_amm, short *aa_seq, char **codon, char *coded_aa);
void 			Extract_triplet (char *dna_seq, short *aa_seq, int i, char *coded_aa, char **codon);
int 			Check_file (char *name);
char 			Maiuscule (char), Minuscule (char);
FILE 			*Open_file_r (char *name, char *code_name, char *message);
float 			Read_column (char **s, char *string, int i);
/*void 			Read_hydro_list (char *file_hydro, char *hydro_name, float *hydro);*/
void 			Ini_count (char *dna_seq, int len_dna, int *count);
void 			Ini_count_AA (short *aa_seq, int len_amm, int *countAA);
int 			Mutate_seq (char *dna_seq, int len_dna, char **codon, char *coded_aa, short *aa_seq, int len_nat, float *freq_nuc, float tt_ratio, int *count, float *rate, int *nuc_mut, char *nuc_new, int *res_mut, int *aa_new, long int *seed);
int 			Mutate_seq_AA (short *aa_seq, int len_nat, int *countAA, float *rateAA, int *res_mut, int *aa_new, long int *seed);
int 			Compute_rates (float *rate, float *freq_nuc, float trans_ratio, char *dna_seq, long int *seed);
int 			Compute_ratesAA (float *rateAA, short *aa_seq, long int *seed);
char 			Mutate_nuc (char nuc, float *freq_nuc, float *rate, float tt_ratio);
char 			Mutate_aa (char aa, float *rateAA);
void 			Print_ave (FILE *file_ave, double it_sum, float t_indip, int N_pop, double f_sum, double f_dev, double E_sum, double E_dev, double DG_sum, double DG_dev, float seq_entr, double num_syn_subst, double num_aa_subst, double Tload_sum, double Tload_dev, double Mload_sum, double Mload_dev, int Nload, int NEUTRAL);
void 			Print_ave_AA (FILE *file_ave, double it_sum, float t_indip, int N_pop, double f_sum, double f_dev, double E_sum, double E_dev, double DG_sum, double DG_dev, float seq_entr, double num_syn_subst, double num_aa_subst, double Tload_sum, double Tload_dev, double Mload_sum, double Mload_dev, int Nload, int NEUTRAL);
void 			Print_mean (FILE *file_out, float sum, float dev, float n_sum, float t_indip);
void 			Print_final (char *name_file, double it_sum, float TEMP, float s0, int N_pop, float *freq_nuc, double f_ave, double f_dev, double E_ave, double E_dev, double DG_ave, double DG_dev, float seq_entr, double seq_entr_dev, double Tload_sum, double Tload_dev, double Mload_sum, double Mload_dev, int Nload, double num_syn_subst, double num_aa_subst, char *dna_seq, int len_dna, int NEUTRAL);
void 			Print_final_AA (char *name_file, double it_sum, float TEMP, float s0, int N_pop, double f_ave, double f_dev, double E_ave, double E_dev, double DG_ave, double DG_dev, float seq_entr, double seq_entr_dev, double Tload_sum, double Tload_dev, double Mload_sum, double Mload_dev, int Nload, double num_syn_subst, double num_aa_subst, short *aa_seq, int len_amm, int NEUTRAL);
void 			Read_ene_par (char *, float **interactions);
int 			Read_ene_new (char *, float **interactions);
/*char 			*Read_sequence (int *len_dna, char *inseq);*/
FILE 			*open_file (char *, char *, short *, int, char *fit_def);
FILE 			*open_file_AA (char *, char *, short *, int, char *fit_def);
void 			Output_name (char *file_name, char *dir, char *name, float TEMP, float S0, int N_pop, float *freq_nuc, char *dirStability, char *file_seq, int NEUTRAL);
void 			Output_name_AA (char *file_name, char *dir, char *name, float TEMP, float S0, int N_pop, char *dirStability, char *file_seq, int NEUTRAL);
int 			Print_dna (char *, FILE *, int);
int 			Get_name (char *name, char *name_seq, int N);
float 			Sequence_entropy (int **aa_distr, int L);
void 			Compute_freq_codons (float *freq_nuc, float *freq_aa, char **codon, char *coded_aa);
void 			Compute_load (double *translation_load, double *mutation_load, short *aa_seq, int len_amm, char *dna_seq, int len_dna, float fitness_wt, double E_nat, double E1, double E2, double E23, double E3, float Conf_entropy, char **codon, char *coded_aa);
void 			Compute_load_AA (double *translation_load, double *mutation_load, short *aa_seq, int len_amm, float fitness_wt, double E_nat, double E1, double E2, double E23, double E3, float Conf_entropy);
int 			Selection (float fitness, float fitness_old, int N_pop);
float 			Sequence_entropy_mut (float *freq_nuc, char **codon, char *coded_aa);
float 			Sequence_entropy_mut_AA ();
/*void 			Read_mut_mat (char *file_mut_mat, float **nuc_mut_mat);*/
int 			Coded_aaf (char *i_codon, char **codon, char *coded_aa);
int 			Codon_num (char *cod, char **codon);
int 			** Allocate_mat2_i (int n1, int n2);
float  			**Allocate_mat2_f (int n1, int n2);
double 			**Allocate_mat2_d (int n1, int n2);
void 			Empty_matrix_i (int **matrix, int N);
void 			Empty_matrix_f (float **matrix, int N);
void 			Empty_matrix_d (double **matrix, int N);
/*extern 		Threading (short *, float *, float *, float, float *, int);
extern 			Ini_thread (char *, int);*/
int				Read_structures (char *file_prot, struct protein *prot);
static short 	Write_residue (char *res_type_old, atom *first_atom, short i_atom, struct residue *ptr_tmp, int n_exo, int res_num, char icode, char chain, int hetatm);
static int 		Next_residue (int *N_res, int *start, struct residue *seq, atom *first_atom, short *i_atom, char *res_type_old, int *res_num_old, char *icode_old, char *chain_old, int *hetatm_old, int n_exo, char *res_type, int res_num, char icode, char chain, int hetatm);
static char 	Code_3_1 (char *res);
int 			Get_compression (char *pdb_name);
short 			**Contact_matrix (struct residue *seq, int N_res, int *N_cont, char l_cont, int ij_min);
int				AdaptOrderToPopEvol (int myValue);



/* Global variables */
Treetnode		*currentTreeRoot;
Tree			*tree;
TreeSegment		*segments;
TreeNode		*nodes, **treeRootInit;
TreeNodex		*nodex, **treeRootNodex;
Qij_OmegaCat	*QijOmegas;
long int		userSeed;
int				*matrix, *matrixC, *MRCA, *matrixCnuc,/*tipLabel,*/ intLabel, *outgroup, *breakpoint, *arrayIndBreakpointsOrd;
int				*S_MRCA, actSegIndex, *OnlyAncS_MRCA;
int				numSequences, N, numSites, numNuc, numDataSets, numRE, indNumRE, recNotToCount, numCA, numMU, noisy, numIndividuals, numCodons, numMIG, numCONV, numREbreakCod, numStopCodonREC; 
int				doRateHet, equalBaseFreq, equalBaseFreqCod, equalBaseFreqAA;
double 			cumNumRE, cumNumREntc, cumNumCA, cumNumMU, meanNumRE, meanNumREtc, meanNumCA, meanNumMU, meanNumMIG, expNumRE, rho, cumNumMIG, cumNumCONV, meanNumCONV, cumNumREbreakCod, cumNumStopCodonREC, meanNumREbreakCod, meanNumStopCodonREC;
double			kappa, titv, alpha, p_i[4], p_i_codon[12], p_i_aa[20], pinv, mutationRate, migrationRate, OmegaRateHet, OmegaRateHetM6_0, OmegaRateHetM6_1, OmegaM6_0, OmegaM6_1, OmegaInitM6_0, OmegaInitM6_1, OmegaRateHetM910_1, OmegaM910_1, OmegaInitM910_1;
double			SynRate, NonSynRate;
double 			recombinationRate;
double 			Rmat[6], Qij[16], Cijk[256], Root[4], mr, tstv, NRmat[12];
double 			Qij_p[16], Cijk_p[256], Root_p[4], mr_p, tstv_p;
double 			Rmat_C[NUMCOD+2], Qij_CC[NUMCOD*NUMCOD], Cijk_C[NUMCOD*NUMCOD*NUMCOD*NUMCOD], Root_C[NUMCOD], Qij_C[NUMCOD][NUMCOD], OmegaInit;
double			Qij_CF[NUMCOD];
double 			omega;
char			alignmentFile[20], treeFile[20], timesFile[20], model[100], modelB[100], modelS[100], breakpointFile[20], MRCAFile[20], screenFile[20], settingsFile[20], MRCAfilePrint[20], ConcMRCAfilePrint[20], OmegasPerSiteFile[30], GMRCAancFilePrint[20];
static double	outgroupBranchLength, expTMRCA;
static int		thereisOutgroup, zeroRec, doExponential, doPrintTrees, doPrintTimes, doPrintBreakpoints, doHKY, doGTR, doCodonModel, doPrintAncestralSequences, 
				doSeparatedSequences, doCountsForExpNumRec, doDemographics, doMRCAFile, doCodon_HKY, doCodon_GTR, doMigration, doOmegaCat, doOmegaProb, doOmegaRateHetCont, 
				doOmegaRateHetDisc, doMPI, doGTnR, doCodon_NGTR, doBadReplicate, doConvergDemes, doConvNext, doSettingsFile, doOutMRCAfiles, doBranchNetfiles, doPrintOmegasPerSitefiles, doPrintFASTA, doPrintNEXUS,
				ThisBreakpIsTrapped, doGMRCAsamp;
static int		*Nbegin, *Nend, *cumDuration, numPeriods;
static double	*periodGrowth, growthRate;
int				fixedNumRecEvents, doFixNumRecEvents;
double			counterTime, counterTimeInit, actualTGMRCA, countTMRCA, countTMRCAReps, varianceGMRCArep, varianceTrep, varianceErep, *convDemTimes, *convDemTimes_old;
int				numNodex, numPopulations, numOmegaCat, *numNodesInitPopul, *initPopulation, numConvergDemes, *deme_a, *deme_b, nextConvNumber, *deme_a_old, *deme_b_old, *currentConvDem, totCurrentConv, distance, *NodesMRCAposit;
static double	*varTimeGMRCA, *varTimeT, *omegaVal, *omegaProb, *gammaRates, *omegaValGammaRate;
static int		*varEvent;
int				freqNumber, nextAvailable, doRepitEvol;
static int		nDIGITS;
int				numEqual2, numEqual1, numDifCodSameAA, numDifCodDifAA, numNonSyn0, numNonSyn1, numNonSyn2;
double 			cumNumEqual2, cumNumEqual1, cumNumDifCodSameAA, cumNumDifCodDifAA, meanNumEqual2, meanNumEqual1, meanNumDifCodSameAA, meanNumDifCodDifAA, meanNumNonSyn0, cumNumNonSyn0, meanNumNonSyn1, cumNumNonSyn1, meanNumNonSyn2, cumNumNonSyn2;
int 			numNetLabelPrint;
int 			numMU_S, numMU_NS; 
double			cumNumMU_S, cumNumMU_NS, meanNumMU_S, meanNumMU_NS, expVarTMRCA;
static int		doM1, doM8, doM7, doM0, doM6, doM9, doM10, doMG94;
double			M1_P0_omeg0, M1_P1_omeg1, M1_omega0, M6_P0, M6_P1, M910_P0, M910_P1;
int				M1_FinalSite_omega, ProbCategory, GammCategory, formatNumber, M6_FinalSite_omega, M910_FinalSite_omega;
double 			M8_P0_beta, M8_P1_omega, M8_p_beta, M8_q_beta, M8_omegaP1, M8_omegaP0, M8_FinalSite_omega, omegaGammaDisc;
double			M7_p_beta, M7_q_beta, M7_FinalSite_omega, M910_p_beta, M910_q_beta;
int 			Nscaling;
SampleSt		*datedSample, tempSample;
static int		doDatedTips, numTipDates;
static double	generationTime, latestSamplingTime;
int				*SitesNonAncHere;
int				numNodes;
double 			Rmat_AA[NUMAA+2], Qij_AAa[NUMAA*NUMAA], Cijk_AA[NUMAA*NUMAA*NUMAA*NUMAA], Root_AA[NUMAA], Qij_AA[NUMAA][NUMAA];
double			AA_EM_Pi[NUMAA];
char			AAinputFile[30], AAfilePrint[30], AAmodel[30], networkOut[30], ECodonModel[30], GY94xAAmodel[30], HetRecFile[30], ProtStabDNAFile[30], ProtStabAAFile[30], HetVectorFile[30];
int				NumberFrequencies, numAA;
static int		doAAmodel, doFreqGiven, doAAinputFile, doGY94xAAmodel;
static int		doBlosum62, doCpRev, doDayhoff, doDayhoffDCMUT, doHIVb, doHIVw, doJTT, doJonesDCMUT, doLG, doMtart, doMtmam, doMtrev24, doRtRev, doVT, doWAG, doEAAMUser;
static int		doECMinputFile, doECM, doECMrest, doECMunrest, doECMuser, doECMSchn;
double			Qij_AAuser[NUMAA][NUMAA], FreqsAAUser[NUMAA];
double			Qij_CodUser[NUMCOD][NUMCOD], FreqsCodUser[NUMCOD];
static int		doGY94xBlosum62, doGY94xCpRev, doGY94xDayhoff, doGY94xDayhoffDCMUT, doGY94xHIVb, doGY94xHIVw, doGY94xJTT, doGY94xJonesDCMUT, doGY94xLG, doGY94xMtart, doGY94xMtmam, doGY94xMtrev24, doGY94xRtRev, doGY94xVT, doGY94xWAG, doGY94xEAAMUser;
static int		doVariableDnDsBranches, doBBM0;
int				BBmodelNumber, BBnumOmegaCat, BBBcounter;
static double	*BBomegaVal, *BBomegaProb;
double			BBOmegaRateHet, BBomega, BBOmegaInit, BBM7_p_beta, BBM7_q_beta;
int				migrationModel;
static int		doMigrationIsland, doMigrationSTST, doMigrationIslCont;
static int		doMigRatePeriods, numMigRatePeriods, *MigTbegin;
static double	*periodMigrationRate;
static double	expNumMU, expVarNumMU, theta;

static int		*hotspot;
static int		numREblock, numHotspots; 
static int		doHetRecFile, doBlockRecombination;
static double	meanNumHotspots, meanC01, meanNumREblock, cumC01, cumNumREtc, cumNumREblock, cumNumHotspots;
static double	cumNumRESq, cumC01Sq, cumNumREtcSq, cumNumREblockSq, cumNumHotspotsSq;
static double	varNumRE, varNumREtc, varC01, varNumREblock, varNumHotspots;
static double	blockRecombinationRate, globalRecombinationRate, hotspotImprecision, expNumPoissonHotspots, expNumHotspots, fixedNumHotspots, alphaRec, tau, C01;
static int		hotspotHeterogeneity, hotspotInterference, interferenceInterval, hotspotUniform, hotspotWidth, numPointsRecPDF, numSitesOutside;
int				giBegin, giEnd;
static int		doGivenUserTrees, taxonNamesAreChars;
char			treeFileName[30];
static int		numTrees, TiptnodeNum, InttnodeNum, numtnodes;
static char		*treeString, *taxonName;
static int		doProtStabDNAFile, doProtStabAAFile, doHetVectorFile;

static int		doMutationalBranches;
static int 		bvalue;
int 			ini_print;
int 			REM3;
static long 	IT_MAX;
static int 		N_pop;
static int 		NEUTRAL;
static float 	freq_nuc[4], tt_ratio;
static char 	/*file[N_CHAR],*/ seq_name[N_CHAR], dir_out[N_CHAR];
static char 	seq_name[N_CHAR];
static int 		len_amm, len_dna;
static int 		count[4];
static float 	rate[4];
static float 	rateAA[20];
static int 		countAA[20];
unsigned long 	iran;
RANDOMTYPE 		random_array[16384];
RANDOMTYPE 		*random_which1, *random_which2, *random_which3, *random_which4, *random_which5;
RANDOMTYPE 		*random_end;
atom 			atom_read[ATOM_MAX];
float 			cont_thr_a=8, cont_thr_a2;
float 			cont_thr_b=8, cont_thr_b2;
float 			cont_thr_c=4.5, cont_thr_c2;
int 			init_map=0;
int 			Verbose;
char 			cont_type;
float 			cont_thr, cont_thr2;
float 			TEMP;
float 			sC1, sC0, SC, s0, Conf_entropy, K2Thr, TEMP2;
int 			LEN;
//float conf_entropy;
int 			INI_STAT=0;
int 			**C_nat=NULL;
double 			**Cont_freq=NULL, **C2=NULL, **C23=NULL, **C3=NULL;
double 			A2, A3;
struct 			protein prot[N_PROT_MAX], target;
struct 			residue seq[RES_MAX];
/*float 			**interactions;*/
char 			FILE_CODE_DEF[N_CHAR], FILE_ENE_DEF[N_CHAR]; 
char 			FILE_CODE[N_CHAR], FILE_ENE[N_CHAR], FILE_STR[N_CHAR], FILE_PDB[N_CHAR];
char 			coded_aa[64]="FFLLLLLLIIIMVVVVSSSSPPPPTTTTAAAAYYHHQQNNKKDDEECCWRRRRSSRRGGGG***";
char 			*codon[64]={"TTT","TTC","TTA","TTG","CTT","CTC","CTA","CTG","ATT","ATC","ATA","ATG","GTT","GTC","GTA","GTG","TCT","TCC","TCA","TCG","CCT","CCC","CCA","CCG","ACT","ACC","ACA","ACG","GCT","GCC","GCA","GCG","TAT","TAC","CAT","CAC","CAA","CAG","AAT","AAC","AAA","AAG","GAT","GAC","GAA","GAG","TGT","TGC","TGG","CGT","CGC","CGA","CGG","AGT","AGC","AGA","AGG","GGT","GGC","GGA","GGG","TAA","TAG","TGA"};
char 			AA_code[]="AEQDNLGKSVRTPIMFYCWH";
float 			Econt[20][20]={
{-0.0557,0.1317,-0.0416,0.1008,0.1033,-0.1703,0.1919,0.0712,0.0625,-0.1401,0.0936,0.0346,0.1388,-0.0777,-0.0764,-0.1279,-0.1555,-0.1011,-0.0764,0.0340},
{0.1317,0.1305,-0.0407,0.1551,0.1139,0.0809,0.2339,-0.2569,0.0711,0.1023,-0.3422,0.0553,0.2239,0.1180,0.0692,0.0777,-0.0467,0.1269,-0.1029,-0.0939},
{-0.0416,-0.0407,-0.0539,-0.0420,-0.0050,-0.0234,0.1598,-0.0620,0.1154,0.0917,-0.0165,-0.0305,0.0972,-0.0595,-0.1043,-0.0243,-0.1439,0.0536,-0.0637,0.0043},
{0.1008,0.1551,-0.0420,0.0888,0.0110,0.2647,0.1180,-0.1256,0.0419,0.2954,-0.1857,0.1030,0.2238,0.1830,-0.0190,0.0927,-0.1004,0.1158,-0.0163,-0.0695},
{0.1033,0.1139,-0.0050,0.0110,-0.0921,0.0783,0.1107,-0.0399,0.1280,0.1214,-0.0119,0.0281,0.1407,0.1636,0.0153,-0.0063,-0.1071,-0.0845,-0.0284,0.0318},
{-0.1703,0.0809,-0.0234,0.2647,0.0783,-0.4961,0.0973,0.0455,0.1023,-0.4563,-0.0586,-0.0309,0.0559,-0.5078,-0.1988,-0.5337,-0.2524,-0.1383,-0.2483,-0.0270},
{0.1919,0.2339,0.1598,0.1180,0.1107,0.0973,0.2071,0.2049,0.1077,0.1613,-0.0288,0.1787,0.2047,0.1373,-0.0582,0.0833,-0.0082,-0.0947,-0.1628,0.0971},
{0.0712,-0.2569,-0.0620,-0.1256,-0.0399,0.0455,0.2049,0.1218,0.1654,0.0566,0.0861,0.0538,0.0984,0.0593,0.0925,-0.0567,-0.1259,0.0144,-0.1084,0.0422},
{0.0625,0.0711,0.1154,0.0419,0.1280,0.1023,0.1077,0.1654,0.0803,0.1640,0.0385,0.0206,0.1512,0.0364,0.0150,0.0480,0.0095,-0.0461,-0.0691,-0.0065},
{-0.1401,0.1023,0.0917,0.2954,0.1214,-0.4563,0.1613,0.0566,0.1640,-0.5019,0.0402,0.0005,0.1056,-0.4254,-0.2081,-0.3974,-0.2779,-0.2521,-0.2751,0.0047},
{0.0936,-0.3422,-0.0165,-0.1857,-0.0119,-0.0586,-0.0288,0.0861,0.0385,0.0402,0.0304,-0.0078,-0.0681,-0.0283,0.0006,-0.1048,-0.1249,0.0023,-0.1833,-0.0280},
{0.0346,0.0553,-0.0305,0.1030,0.0281,-0.0309,0.1787,0.0538,0.0206,0.0005,-0.0078,0.0056,0.1827,-0.0833,0.0094,-0.1126,-0.1353,-0.0116,0.0057,0.0737},
{0.1388,0.2239,0.0972,0.2238,0.1407,0.0559,0.2047,0.0984,0.1512,0.1056,-0.0681,0.1827,0.1050,0.0799,-0.0148,-0.0813,-0.1144,0.0614,-0.0966,0.0420},
{-0.0777,0.1180,-0.0595,0.1830,0.1636,-0.5078,0.1373,0.0593,0.0364,-0.4254,-0.0283,-0.0833,0.0799,-0.5836,-0.2286,-0.3736,-0.3122,-0.2275,-0.1931,-0.0361},
{-0.0764,0.0692,-0.1043,-0.0190,0.0153,-0.1988,-0.0582,0.0925,0.0150,-0.2081,0.0006,0.0094,-0.0148,-0.2286,-0.1078,-0.1790,-0.1626,-0.0505,-0.0879,-0.0380},
{-0.1279,0.0777,-0.0243,0.0927,-0.0063,-0.5337,0.0833,-0.0567,0.0480,-0.3974,-0.1048,-0.1126,-0.0813,-0.3736,-0.1790,-0.3033,-0.4673,-0.2999,-0.3542,-0.1262},
{-0.1555,-0.0467,-0.1439,-0.1004,-0.1071,-0.2524,-0.0082,-0.1259,0.0095,-0.2779,-0.1249,-0.1353,-0.1144,-0.3122,-0.1626,-0.4673,-0.2607,-0.2543,-0.3373,-0.1866},
{-0.1011,0.1269,0.0536,0.1158,-0.0845,-0.1383,-0.0947,0.0144,-0.0461,-0.2521,0.0023,-0.0116,0.0614,-0.2275,-0.0505,-0.2999,-0.2543,-0.7318,-0.1057,-0.0478},
{-0.0764,-0.1029,-0.0637,-0.0163,-0.0284,-0.2483,-0.1628,-0.1084,-0.0691,-0.2751,-0.1833,0.0057,-0.0966,-0.1931,-0.0879,-0.3542,-0.3373,-0.1057,-0.1076,-0.0191},
{0.0340,-0.0939,0.0043,-0.0695,0.0318,-0.0270,0.0971,0.0422,-0.0065,0.0047,-0.0280,0.0737,0.0420,-0.0361,-0.0380,-0.1262,-0.1866,-0.0478,-0.0191,-0.0021}
};
static char 	res_exo[400][5], res_std[400][5];
static int 		n_atom;
char 			chain[]="\0\0\0";
double			AA_EM_Pi_PopEvol[NUMAA], Qij_AA_PopEvol[NUMAA][NUMAA];
int				printPopEvolOutputFiles, numMutationAttemptsRep, CountDNAsubsRep, TotalCountDNAsubsRep, CountDNAsubsNSRep, TotalCountDNAsubsNSRep;
double			cumMutationAttempts, meanMutationAttempts;	
static double	*vectorHetRates, *rateAASite, *rateSite;	

static int		NumReplicateABC;

FILE			*fpAlignment, *fpTrees, *fpTimes, *fpSNP, *fpBreakpoints, *fpMRCA, *fpScreen, *fpmpi, *fpSettings, *fpMRCAprint, *fpBranchNet, *fpConcMRCAprint, *fpOmegasPerSitePrint, *fpGMRCAancPrint;
FILE			*fpUserRatesEAAM, *fpUserRatesECM, *fpUserHetRec, *fpInputTrees, *fpout, *fperr, *fpHetVectorFile;

// ************************** Variables for MPI *********************

#ifdef MPI

  MPI_Status  status;
  int p, rank, lcola, ierror, root, rep;
  MPI_Request request,requests[nmaxproc];
  int fila, filas[nmaxproc], nodo, indice, resto;
  int zero=0;
  int ii, flag, nada;
  
//    INTEGER tipo,tipoi,corte,count
//    INTEGER ndims,dims(nmaxdims),nlz,iii,kk,nil,ii,jj
//    INTEGER ncapt,counts(nmaxproc),disps(nmaxproc)

#endif     

// ************************************************************************


/******************** MAIN *******************/
int main(int argc, char **argv)
{
	int			dataSetNum, i, k, j, w, sum, pass, sorted, mmm;
	long int	seed, seedFirst, originalSeed;
	double		a, b, a2;
	float 		start, secs;
	char		File[80];
	char		dir[80], dirStability[80];
	char		*MRCAsequence;				/* this array will contain the MRCA sequence from inputFile */
	double		*fragmentTMRCAfraction;		/* this array will have the TMRCA of the agments */
	double		specMigPropPopul;
	char		ch;
	FILE 		*fp;
	struct 		timeb tmb;
	
	fpout = stdout;
	fperr = stderr;

	/* defaults */
	numMU_S = numMU_NS = mmm = 0;
	cumNumMU_S = cumNumMU_NS = meanNumMU_S = meanNumMU_NS = meanNumREtc = 0.0;
	varianceGMRCArep = varianceTrep = varianceErep = 0.0;
	MRCAsequence = NULL;
	numDataSets = 10; /* the number of samples to simulate */
	numSequences = 6; /* number of gametes in each data set */
	N = 1000; /* effective population size */
	numPeriods = 0;	/* number of distinct demographic periods */						
	recombinationRate = 0.0; /* recombination rate per site per generation */
	numSites = 201;
	numNuc = 201;
	numCodons = 67;
	mutationRate = 1e-7; /* mutation rate per site per generation */
	doGTR = NO;
	doHKY = NO;
	doCodonModel = NO;
	doCodon_HKY = NO;
	doCodon_GTR = NO;
	doCodon_NGTR = NO;
	doOmegaCat = NO;
	numOmegaCat = 0;
	doOmegaRateHetCont = NO;
	doOmegaRateHetDisc = NO;
	doM6 = NO;
	doM9 = NO;
	doM10 = NO;
	doMG94 = NO;
	titv = -1;
	omega = OmegaInit = -1;
	doMigration = NO;
	migrationRate = -1;
	numPopulations = 1;
	doConvergDemes = NO;
	doConvNext = NO;
	numConvergDemes = 0;
	growthRate = 0;
	doRateHet = NO;
	alpha = 0.0;
	pinv = 0.0;
	equalBaseFreq = YES;
	p_i[0] = 0.25;
	p_i[1] = 0.25;
	p_i[2] = 0.25;
	p_i[3] = 0.25;
	equalBaseFreqCod = YES;
	equalBaseFreqAA = YES;
	for (i = 0; i < 12; i++)
		p_i_codon[i] = 0.25;
	for (i = 0; i < 20; i++)
		p_i_aa[i] = 0.05;
	for (i = 0; i < 6; i++)
		Rmat[i] = -1;
	for (i = 0; i < 12; i++)
		NRmat[i] = -1;
	noisy = 1;
	thereisOutgroup = NO;
	outgroupBranchLength = 0.1;
	doDemographics = NO;					
	doExponential = NO;						
	doMRCAFile = NO;
	doPrintTrees = NO;
	doPrintTimes = NO;
	doPrintBreakpoints = NO;
	strcpy(alignmentFile, "sequences");		/* alignmentFile = alignment (char type)*/
	strcpy(MRCAfilePrint, "GMRCA");
	strcpy(ConcMRCAfilePrint, "MRCA");
	strcpy(GMRCAancFilePrint, "ancGMRCA");
	/*strcpy(BranchNetFilePrint, "");*/
	strcpy(OmegasPerSiteFile, "SimulateOmegasPerSite");
	doPrintAncestralSequences = NO;
	doSeparatedSequences = NO;				/* it writes the sequences in diferents files, a file per replicate */
	doFixNumRecEvents = NO;					/* do a number of desired recombination events */
	fixedNumRecEvents = 0;
	seed = time(NULL);						/* seed for the random number */
	userSeed = 0;							/* seed entered by the user */
	freqNumber = 4;
	doCountsForExpNumRec = YES;		
	i = k = 0;
	b = specMigPropPopul = 0.0;
	Nscaling = 2; /* controls the scaling of time in Nscaling generations 1=haploids 2=diploids */
	numNodes = 0;
	BBmodelNumber = -1;
	BBBcounter = 0;
	migrationModel = -1;
	doBadReplicate = NO;
	doMPI = NO;
	doRepitEvol = NO;
	doGMRCAsamp = NO;
	doPrintFASTA = NO;
	doPrintNEXUS = NO;
	doDatedTips = NO;			/* contemporaneous samples */
	NumberFrequencies = 4;
	doFreqGiven = NO;
	doAAmodel = NO;
	doBlosum62 = NO;
	doCpRev = NO;
	doDayhoff = NO;
	doDayhoffDCMUT = NO;
	doHIVb = NO;
	doHIVw = NO;
	doJTT = NO;
	doJonesDCMUT = NO;
	doLG = NO;
	doMtart = NO;
	doMtmam = NO;
	doMtrev24 = NO;
	doRtRev = NO;
	doVT = NO;
	doWAG = NO;
	doEAAMUser = NO;
	doAAinputFile = NO;
	doECM = NO;
	doECMuser = NO;
	doECMrest = NO;
	doECMunrest = NO;
	doECMSchn = NO;
	doECMinputFile = NO;
	doGY94xAAmodel = NO;
	doGY94xBlosum62 = NO;
	doGY94xCpRev = NO;
	doGY94xDayhoff = NO;
	doGY94xDayhoffDCMUT = NO;
	doGY94xHIVb = NO;
	doGY94xHIVw = NO;
	doGY94xJTT = NO;
	doGY94xJonesDCMUT = NO;
	doGY94xLG = NO;
	doGY94xMtart = NO;
	doGY94xMtmam = NO;
	doGY94xMtrev24 = NO;
	doGY94xRtRev = NO;
	doGY94xVT = NO;
	doGY94xWAG = NO;
	doGY94xEAAMUser = NO;
	doBranchNetfiles = NO;
	doPrintOmegasPerSitefiles = NO; /* print omegas per site in a file */
	doOutMRCAfiles = NO; /* print MRCA and GMRCA */
	doVariableDnDsBranches = NO;
	doBBM0 = NO;
	doMigrationIsland = NO;
	doMigrationSTST = NO;
	doMigrationIslCont = NO;
	doMigRatePeriods = NO;
	/* Heterogeneous recombination */
	doHetRecFile = NO; 
	doBlockRecombination = NO; /* whether we will do heterogeneous recombination */
	blockRecombinationRate = 0; /* expected recombination rate at the hotspots sites */
	expNumPoissonHotspots = 0;  /* expected number of hotspots for a given sample in the absence of interference */
	expNumHotspots = 0;			/* expected number of hotspots considering interference */
	fixedNumHotspots = 0;		/* fixed number of hotspots for all samples */
	hotspotImprecision = 0;		/* variance of a Normal distribution around the hotspot center */
	hotspotWidth = 1;			/* the width of the hotspots when they are uniform */
	interferenceInterval = 1;	/* interference between hotspots [0-1:cluster, 1:no interference, >1: pushed away] */
	numPointsRecPDF = 10000;	/* number of points for the probability density function for recombination */
	hotspotHeterogeneity = NO;	/* whether there is hotspot heterogeneity */
	hotspotInterference = NO;	/* whether there is hotspot interference */
	hotspotUniform = NO;		/* whether hotspots are uniform */
	alphaRec = 0.5;				/* shape of the gamma distribution for hotspot recombination heterogeneity */
	doSettingsFile = NO; /* option only from the code (by the moment) */
	doGivenUserTrees = NO;	
	/* structural protein stability model */
	doProtStabDNAFile = NO;
	REM3=0; /* Second or third cumulant of the energy? */
	IT_MAX=1;
	N_pop=100;
	NEUTRAL=1; /* If (1), neutral evolution, otherwise population size dependent */
	tt_ratio=2;
	bvalue =-1;
	doProtStabAAFile = NO;
	printPopEvolOutputFiles=0;
	numMutationAttemptsRep=0;
	cumMutationAttempts=0.0;
	meanMutationAttempts=0.0;
	doHetVectorFile = NO;
	CountDNAsubsRep=0;
	TotalCountDNAsubsRep=0;
	CountDNAsubsNSRep=0;
	TotalCountDNAsubsNSRep=0;
    NumReplicateABC = 0;

    

// ***********************   MPI Inicializations    ****************************
#ifdef MPI
 
  MPI_Init(&argc,&argv);

        lcola=1;
        root=0;

// Number of processors
   MPI_Comm_size( MPI_COMM_WORLD, &p);
   if (p<2) {
   	printf("\n***ERROR: At least 2 processors are needed for parallel execution\n\n");
        MPI_Finalize();	 
	exit(1);
   }
   if (p>nmaxproc) {
   	printf("\n***ERROR: Number of processors higher than the maximum (%d) \n\n",nmaxproc);
        MPI_Finalize();	 
	exit(1);
   }
   

// Determine Process number
   MPI_Comm_rank( MPI_COMM_WORLD, &rank);

        printf("Procesor  %d of %d\n",rank,p);	//Depuracion, puede eliminarse
	doMPI = YES; // Deberia no ser necesaria, aunque por si acaso se puede dejar de momento			Ok.
#endif
// ************************************************************************


		/* arguments from external place */
	/* in macintosh the arguments are read from a file. For the other OS
	arguments are given at the command line */
	#ifdef MAC
	/*	_fcreator = 'R*ch';
		_ftype = 'TEXT';*/
		if ((fp = freopen("parameters", "r", stdin)) == NULL)				/* input from parameters file and it reads */
			{
			/* Anadido Mifuel: Para imprimir por pantalla del master.. */
			#ifdef MPI 
					fprintf (stderr, "\n%d: ERROR: Can't read parameters file.",rank);
			#else
				fprintf (stderr, "\nERROR: Can't read parameters file.");
			#endif
			PrintUsage();
			}
		ReadParametersFromFile();
		Sioux();
		fclose(fp);
	#else
	ReadParametersFromCommandLine (argc, argv);								/* input from external arguments */
		if (argc < 2)
			{
			if ((fp = freopen("parameters", "r", stdin)) != NULL) 	
				ReadParametersFromFile();
			else
				{
				/* Anadido Mifuel: Para imprimir por pantalla del master.. */
				#ifdef MPI
					fprintf (stderr, "%d, \nERROR: No parameters specified (use command line or parameter file)",rank);
				#else
					fprintf (stderr, "\nERROR: No parameters specified (use command line or parameter file)");
				#endif
				PrintUsage();
				}
			}
	#endif 
	/* to compile default input files in NO */			
	#ifdef USER_INPUT /* ask the user to input parameter values */
		UserInput(&seed);
	#endif


	/***** Define model *****/
	if (NumberFrequencies != 4 && NumberFrequencies != 12 && NumberFrequencies != 20)
		{
		#ifdef MPI
			if (rank==root)
				fprintf(stderr, "%d, \n ERROR: Bad number of frequencies (%d), it should be 4, 12 or 20 (check -f -p)", rank, NumberFrequencies);
			#else
				fprintf(stderr, "\n ERROR: Bad number of frequencies (%d), it should be 4, 12 or 20 (check -f -p)", NumberFrequencies);
			#endif
			PrintUsage();
		}


	OmegaInit = omega;
	if (OmegaInit >= 0.0 || numOmegaCat > 0 || doM1 == YES || doM8 == YES || doM7 == YES || doM6 == YES || doM9 == YES || doM10 == YES || doMG94 == YES) /* codon model */
		{
		doCodonModel = YES;
		if (titv >= 0.0)
			doCodon_HKY = YES;
		for (i = 0; i < 6; i++)
			{
			if (Rmat[i] >= 0)
				{
				doCodon_GTR = YES;
				if (doCodon_HKY == YES)
					{
					#ifdef MPI
					if (rank==root)
						fprintf(stderr, "\n Introduce only a titv or only a R-matrix or only a N-Rmatrix ");
					#else
						fprintf(stderr, "\n Introduce only a titv or only a R-matrix or only a N-Rmatrix ");
					#endif
					PrintUsage();
					}
				break;
				}
			}
		for (i = 0; i < 12; i++)
			{
			if (NRmat[i] >= 0)
				{
				doCodon_NGTR = YES;
				if (doCodon_HKY == YES || doCodon_GTR == YES)
					{
					#ifdef MPI
					if (rank==root)
						fprintf(stderr, "\n Introduce only a titv or only a R-matrix or only a N-Rmatrix ");
					#else
						fprintf(stderr, "\n Introduce only a titv or only a R-matrix or only a N-Rmatrix ");
					#endif
					PrintUsage();
					}
				break;
				}
			}
		if (doCodon_HKY == NO && doCodon_GTR == NO && doCodon_NGTR == NO) /* default model */
			{
			doCodon_HKY = YES;
			titv = 0.5;
			}

		if (NumberFrequencies == 20)
			{
			#ifdef MPI
					if (rank==root)
						fprintf(stderr, "\n 20 frequencies in a codon model? ");
					#else
						fprintf(stderr, "\n 20 frequencies in a codon model? ");
					#endif
					PrintUsage();
			}


		if (doGY94xBlosum62 == YES || doGY94xCpRev == YES || doGY94xDayhoff == YES || doGY94xDayhoffDCMUT == YES || doGY94xHIVb == YES || doGY94xHIVw == YES || doGY94xJTT == YES || doGY94xJonesDCMUT == YES 
				|| doGY94xLG == YES || doGY94xMtart == YES || doGY94xMtmam == YES || doGY94xMtrev24 == YES || doGY94xRtRev == YES || doGY94xVT == YES || doGY94xWAG == YES || doGY94xEAAMUser == YES) /* GY94 x amino acid matrix */ 
			{
			if (doMG94 == YES)
				{
				#ifdef MPI
					if (rank==root)
						fprintf(stderr, "\n MG94 (-m0) codon model or GY94xAA (-m1-m10 and _aaModelName) codon model? ");
					#else
						fprintf(stderr, "\n MG94 (-m0) codon model or GY94xAA (-m1-m10 and _aaModelName) codon model? ");
					#endif
					PrintUsage();
				}			

			doGY94xAAmodel = YES;

			if (doGY94xBlosum62 == NO && doGY94xCpRev == NO && doGY94xDayhoff == NO && doGY94xDayhoffDCMUT == NO && doGY94xHIVb == NO && doGY94xHIVw == NO && doGY94xJTT == NO && doGY94xJonesDCMUT == NO 
				&& doGY94xLG == NO && doGY94xMtart == NO && doGY94xMtmam == NO && doGY94xMtrev24 == NO && doGY94xRtRev == NO && doGY94xVT == NO && doGY94xWAG == NO && doGY94xEAAMUser == NO)
				{
				fprintf(stderr, "PARAMETER ERROR: Amino acid matrix not implemented for this GY94 codon model(-@) (%s) \n\n", GY94xAAmodel);
				PrintUsage();
				}

			if (doGY94xEAAMUser == YES) /* Qij_AAuser[NUMAA][NUMAA], FreqsAAUser[NUMAA]; from function ReadEAAMfromFile*/
				{
				#ifdef MAC
				/*_fcreator = 'R*ch';
				_ftype = 'TEXT';*/
				/*if ((fpUserRatesEAAM = freopen("UserRatesEAAM", "r", stdin)) == NULL)*/
				/*if ((fpUserRatesEAAM = fopen(AAmodel, "r")) == NULL) */
				if ((fpUserRatesEAAM = freopen(GY94xAAmodel, "r", stdin)) == NULL) 	
					{
					fprintf (stderr, "Can't open amino acid EM file: %s \n", GY94xAAmodel);
					PrintUsage();
					}
				ReadEAAMfromFile();
				Sioux();
				fclose(fpUserRatesEAAM);
				#else

				if ((fpUserRatesEAAM = freopen(GY94xAAmodel, "r", stdin)) != NULL)
					ReadEAAMfromFile();
				else				
					{
					fprintf (stderr, "Can't open amino acid EM file: %s \n", GY94xAAmodel);
					PrintUsage();
					}
				fclose(fpUserRatesEAAM);
				#endif 
				}	
			}



		if (doVariableDnDsBranches == YES && doM0 == YES && BBmodelNumber > 3)
			{
			#ifdef MPI
			if (rank==root)
				fprintf(stderr, "\n Variable dN/dS per branch for M0 requires a distribution (-l, between 1-3)");

			#else
				fprintf(stderr, "\n Variable dN/dS per branch for M0 requires a distribution (-l, between 1-3)");
			#endif
			PrintUsage();
			}
		
		if (doVariableDnDsBranches == YES && doMG94 == YES)
			{
			#ifdef MPI
			if (rank==root)
				fprintf(stderr, "\n Variable dN/dS per branch (-l) does not work for MG94 codon model (-m0)");

			#else
				fprintf(stderr, "\n Variable dN/dS per branch (-l) does not work for MG94 codon model (-m0)");
			#endif
			PrintUsage();
			}

		if (doECMrest == YES || doECMunrest == YES || doECMuser == YES || doECMSchn == YES)
			{
			#ifdef MPI
			if (rank==root)
				fprintf(stderr, "\n GY94/MG94 codon model (-m0-m10) or empirical codon models (-z)? ");

			#else
				fprintf(stderr, "\n GY94/MG94 codon model (-m0-m10) or empirical codon models (-z)? ");
			#endif
			PrintUsage();
			}

		if (doBlosum62 == YES || doCpRev == YES || doDayhoff == YES || doDayhoffDCMUT == YES || doHIVb == YES || doHIVw == YES || doJTT == YES || doJonesDCMUT == YES 
				|| doLG == YES || doMtart == YES || doMtmam == YES || doMtrev24 == YES || doRtRev == YES || doVT == YES || doWAG == YES || doEAAMUser == YES)
			{
			#ifdef MPI
			if (rank==root)
				fprintf(stderr, "\n Codon model or amino acid model? ");
			#else
					
			fprintf(stderr, "\n Codon model or amino acid model? ");
			#endif
			PrintUsage();
			}

		}
	else if (doECMrest == YES || doECMunrest == YES || doECMuser == YES || doECMSchn == YES) /* empirical codon model */
		{
		doCodonModel = YES;
		doECM = YES;
			

		if (NumberFrequencies == 20)
			{
			#ifdef MPI
					if (rank==root)
						fprintf(stderr, "\n 20 frequencies in a codon model? ");
					#else
						fprintf(stderr, "\n 20 frequencies in a codon model? ");
					#endif
					PrintUsage();
			}

		if (doVariableDnDsBranches == YES)
			{
			#ifdef MPI
			if (rank==root)
				fprintf(stderr, "\n Variable dN/dS per branch is not allowed for empirical models ");
			#else
			fprintf(stderr, "\n Variable dN/dS per branch is not allowed for empirical models ");
			#endif
			PrintUsage();
			}

		if (doGY94xBlosum62 == YES || doGY94xCpRev == YES || doGY94xDayhoff == YES || doGY94xDayhoffDCMUT == YES || doGY94xHIVb == YES || doGY94xHIVw == YES || doGY94xJTT == YES || doGY94xJonesDCMUT == YES 
				|| doGY94xLG == YES || doGY94xMtart == YES || doGY94xMtmam == YES || doGY94xMtrev24 == YES || doGY94xRtRev == YES || doGY94xVT == YES || doGY94xWAG == YES || doGY94xEAAMUser == YES) /* GY94 x amino acid matrix */ 
			{
		
			#ifdef MPI
			if (rank==root)
				fprintf(stderr, "\n Codon model with amino acid constrains (-_) is not allowed for empirical models (-z)");
			#else
			fprintf(stderr, "\n Codon model with amino acid constrains (-_) is not allowed for empirical models (-z)");
			#endif
			PrintUsage();
			}


		if (doECMuser == YES)
			{		
			#ifdef MAC
			/*_fcreator = 'R*ch';
			_ftype = 'TEXT';*/
			/*if ((fpUserRatesECM = freopen("UserRatesECM", "r", stdin)) == NULL)*/
			/*if ((fpUserRatesECM = fopen(ECodonModel, "r")) == NULL) */
			if ((fpUserRatesECM = freopen(ECodonModel, "r", stdin)) == NULL) 	
				{
				fprintf (stderr, "Can't open codon EM file: %s \n", ECodonModel);
				PrintUsage();
				}
			ReadECMfromFile();
			Sioux();
			fclose(fpUserRatesECM);
			#else

			if ((fpUserRatesECM = freopen(ECodonModel, "r", stdin)) != NULL)
				ReadECMfromFile();
			else				
				{
				fprintf (stderr, "Can't open codon EM file: %s \n", ECodonModel);
				PrintUsage();
				}
			fclose(fpUserRatesECM);
			#endif 
			}	

		if (doBlosum62 == YES || doCpRev == YES || doDayhoff == YES || doDayhoffDCMUT == YES || doHIVb == YES || doHIVw == YES || doJTT == YES || doJonesDCMUT == YES 
				|| doLG == YES || doMtart == YES || doMtmam == YES || doMtrev24 == YES || doRtRev == YES || doVT == YES || doWAG == YES || doEAAMUser == YES)
			{
			#ifdef MPI
			if (rank==root)
				fprintf(stderr, "\n Codon model or amino acid model? ");
			#else
					
			fprintf(stderr, "\n Codon model or amino acid model? ");
			#endif
			PrintUsage();
			} 

		}
	else if (doBlosum62 == YES || doCpRev == YES || doDayhoff == YES || doDayhoffDCMUT == YES || doHIVb == YES || doHIVw == YES || doJTT == YES || doJonesDCMUT == YES 
				|| doLG == YES || doMtart == YES || doMtmam == YES || doMtrev24 == YES || doRtRev == YES || doVT == YES || doWAG == YES || doEAAMUser == YES || doProtStabAAFile == YES) /* amino acid model */ 
		{
		doAAmodel = YES;

		if (doBlosum62 == NO && doCpRev == NO && doDayhoff == NO && doDayhoffDCMUT == NO && doHIVb == NO && doHIVw == NO && doJTT == NO && doJonesDCMUT == NO 
				&& doLG == NO && doMtart == NO && doMtmam == NO && doMtrev24 == NO && doRtRev == NO && doVT == NO && doWAG == NO && doEAAMUser == NO && doProtStabAAFile == NO)
			{
			fprintf(stderr, "PARAMETER ERROR: Amino acid model not implemented (-@) (%s) \n\n", AAmodel);
			PrintUsage();
			}
		if (NumberFrequencies == 12)
			{
			#ifdef MPI
				if (rank==root)
					fprintf(stderr, "%d, \n ERROR: Bad number of frequencies (%d), it should be 20 for amino acid data (check -f -p)", rank, NumberFrequencies);
				#else
					fprintf(stderr, "\n ERROR: Bad number of frequencies (%d), it should be 20 for amino acid data (check -f -p)", NumberFrequencies);
				#endif
				PrintUsage();
			}

		if (doVariableDnDsBranches == YES)
			{
			#ifdef MPI
			if (rank==root)
				fprintf(stderr, "\n Variable dN/dS per branch is not allowed for amino acid models ");
			#else
			fprintf(stderr, "\n Variable dN/dS per branch is not allowed for amino acid models ");
			#endif
			PrintUsage();
			}

		if (doEAAMUser == YES)
			{
		
			#ifdef MAC
			/*_fcreator = 'R*ch';
			_ftype = 'TEXT';*/
			/*if ((fpUserRatesEAAM = freopen("UserRatesEAAM", "r", stdin)) == NULL)*/
			/*if ((fpUserRatesEAAM = fopen(AAmodel, "r")) == NULL) */
			if ((fpUserRatesEAAM = freopen(AAmodel, "r", stdin)) == NULL) 	
				{
				fprintf (stderr, "Can't open amino acid EM file: %s \n", AAmodel);
				PrintUsage();
				}
			ReadEAAMfromFile();
			Sioux();
			fclose(fpUserRatesEAAM);
			#else

			if ((fpUserRatesEAAM = freopen(AAmodel, "r", stdin)) != NULL)
				ReadEAAMfromFile();
			else				
				{
				fprintf (stderr, "Can't open amino acid EM file: %s \n", AAmodel);
				PrintUsage();
				}
			fclose(fpUserRatesEAAM);
			#endif 
			}	
		}
	else				/* nucleotide model */
		{
		if (doVariableDnDsBranches == YES)
			{
			#ifdef MPI
				if (rank==root)
					fprintf(stderr, "\n Variable dN/dS per branch is not allowed for nucleotide models ");
				#else
					fprintf(stderr, "\n Variable dN/dS per branch is not allowed for nucleotide models ");
				#endif
			PrintUsage();
			}

		if (titv >= 0.0)
			doHKY = YES;
		if (freqNumber != 4)
			{
			fprintf (stderr, "PARAMETER ERROR: Bad number of enter frequencies for a nucleotide substitution model (%d)\n\n", freqNumber);
			PrintUsage();
			}
		for (i = 0; i < 6; i++)
			{
			if (Rmat[i] >= 0)
				{
				doGTR = YES;
				if (doHKY == YES)
					{
					#ifdef MPI
					if (rank==root)
						fprintf(stderr, "\n Introduce only a titv or only a R-matrix or only a N-Rmatrix ");
					#else
						fprintf(stderr, "\n Introduce only a titv or only a R-matrix or only a N-Rmatrix ");
					#endif
					PrintUsage();
					}
				break;
				}
			}
		for (i = 0; i < 12; i++)
			{
			if (NRmat[i] >= 0)
				{
				doGTnR = YES;
				if (doHKY == YES || doGTR == YES)
					{
					#ifdef MPI
					if (rank==root)
						fprintf(stderr, "\n Introduce only a titv or only a R-matrix or only a N-Rmatrix ");
					#else
						fprintf(stderr, "\n Introduce only a titv or only a R-matrix or only a N-Rmatrix ");
					#endif
					PrintUsage();
					}
				break;
				}
			}
		if (doHKY == NO && doGTR == NO && doGTnR == NO) /* default model */
			{
			doHKY = YES;
			titv = 0.5;
			}
		}

	if (doGY94xBlosum62 == YES || doGY94xCpRev == YES || doGY94xDayhoff == YES || doGY94xDayhoffDCMUT == YES || doGY94xHIVb == YES || doGY94xHIVw == YES || doGY94xJTT == YES || doGY94xJonesDCMUT == YES 
				|| doGY94xLG == YES || doGY94xMtart == YES || doGY94xMtmam == YES || doGY94xMtrev24 == YES || doGY94xRtRev == YES || doGY94xVT == YES || doGY94xWAG == YES || doGY94xEAAMUser == YES) /* GY94 x amino acid matrix */ 
		{
		if (doCodonModel == NO || doECM == YES)
			{
			#ifdef MPI
			if (rank==root)
				fprintf(stderr, "\n Codon model with amino acid constrains requires (-_) and a GY94 codon model (-m1-m10)");
			#else
				
				fprintf(stderr, "\n Codon model with amino acid constrains requires (-_) and a GY94 codon model (-m1-m10)");
				#endif
				PrintUsage();
			}

		}



	if (migrationRate < 0 && doMigRatePeriods == NO) /* migration model */
		doMigration = NO;
	else
		{
		doMigration = YES;
		
		if (migrationModel == 1)
			doMigrationIsland = YES;
		else if (migrationModel == 2)
			doMigrationSTST = YES;
		else if (migrationModel == 3)
			doMigrationIslCont = YES;
		else
			{
			#ifdef MPI
			if (rank==root)				
				fprintf (stderr, "PARAMETER ERROR: A migration model (-q) also requires migration rates (-t), and viceversa \n\n");
			#else
				fprintf (stderr, "PARAMETER ERROR: A migration model (-q) also requires migration rates (-t), and viceversa \n\n");
			#endif
			PrintUsage();
			}
		}
	if (migrationModel >= 1 && doMigration == NO)
		{
		#ifdef MPI
		if (rank==root)				
			fprintf (stderr, "PARAMETER ERROR: A migration model (-q) also requires migration rates (-t), and viceversa \n\n");
		#else
			fprintf (stderr, "PARAMETER ERROR: A migration model (-q) also requires migration rates (-t), and viceversa \n\n");
		#endif
		PrintUsage();
		}




	if (numConvergDemes > 0) /* convergence of demes */
		{
		doConvergDemes = YES;
		if (doMigration == NO)
			{
			#ifdef MPI
			if (rank==root)				
				fprintf (stderr, "PARAMETER ERROR: Using convergencies demes events it will need a migration model (-q -t) also\n\n");
			#else
				fprintf (stderr, "PARAMETER ERROR: Using convergencies demes events it will need a migration model (-q -t) also\n\n");
			#endif
			PrintUsage();
			}
		for (i=1; i<=numConvergDemes; i++)
			{
			if (deme_a_old[i] > (2*numPopulations-1))
				{
				#ifdef MPI
				if (rank==root)				
					fprintf (stderr, "PARAMETER ERROR: Bad number of deme in convergencies demes events (%d)\n\n", deme_a_old[i]);
				#else
					fprintf (stderr, "PARAMETER ERROR: Bad number of deme in convergencies demes events (%d)\n\n", deme_a_old[i]);
				#endif
				PrintUsage();
				}
			if (deme_b_old[i] > (2*numPopulations-1))
				{
				#ifdef MPI
				if (rank==root)	
					fprintf (stderr, "PARAMETER ERROR: Bad number of deme in convergencies demes events (%d)\n\n", deme_b_old[i]);
				#else
					fprintf (stderr, "PARAMETER ERROR: Bad number of deme in convergencies demes events (%d)\n\n", deme_b_old[i]);
				#endif
				PrintUsage();
				}
			}
		if (doMigration == NO)
			{
			#ifdef MPI
			if (rank==root)
				fprintf (stderr, "PARAMETER ERROR: Cannot have convergence of demes events (-%%) without migration model (-q)\n\n");
			#else
				fprintf (stderr, "PARAMETER ERROR: Cannot have convergence of demes events (-%%) without migration model (-q)\n\n");
			#endif
			PrintUsage();
			}
		}


	if (growthRate != 0)
		doExponential = YES;
	else
		doExponential = NO;
	if (numPeriods == 0)
		doDemographics = NO;
	else
		doDemographics = YES;
	if (doExponential == YES && doDemographics == YES)
		{
		#ifdef MPI
		if (rank==root)
			fprintf (stderr, "PARAMETER ERROR: Cannot have both demographics periods and other demographics (-g)\n\n");
		#else
			fprintf (stderr, "PARAMETER ERROR: Cannot have both demographics periods and other demographics (-g)\n\n");
		#endif
		PrintUsage();
		}


	/* Recombination hotspots */
	if (doHetRecFile == YES)
		{		
		#ifdef MAC
		/*_fcreator = 'R*ch';
		_ftype = 'TEXT';*/
		/*if ((fpUserHetRec = freopen("UserHetRec", "r", stdin)) == NULL)*/
		/*if ((fpUserHetRec = fopen(HetRecFile, "r")) == NULL) */
		if ((fpUserHetRec = freopen(HetRecFile, "r", stdin)) == NULL) 	
			{
			fprintf (stderr, "Can't open HetRec file: %s \n", HetRecFile);
			PrintUsage();
			}
		ReadHetRecfromFile();
		Sioux();
		fclose(fpUserHetRec);
		#else

		if ((fpUserHetRec = freopen(HetRecFile, "r", stdin)) != NULL)
			ReadHetRecfromFile();
		else				
			{
			fprintf (stderr, "Can't open HetRec file: %s \n", HetRecFile);
			PrintUsage();
			}
		fclose(fpUserHetRec);
		#endif

		doBlockRecombination = YES; 
		}


	/** input tree/s from user **/
	if (doGivenUserTrees == YES)
		{
		numSequences = 0;
		if ((fpInputTrees = fopen(treeFileName, "r")) == NULL) 
			{
			fprintf (stderr, "Can't open tree file: %s.\n", treeFileName);
			PrintUsage();
			}
		/*fprintf (stderr, "\n\nTrees input file: %s.\n\n", treeFileName);*/


		/* memory allocation for trees */
		tree = (Tree *) calloc (MAX_TREES, sizeof (Tree));
		if (tree == NULL)
			{
			/*fprintf (stderr, "Could not allocate tree (%lu bytes)", MAX_TREES * sizeof (Tree));*/
			fprintf (stderr, "Could not allocate tree");
    		PrintUsage();
			}
		for (i=0; i<MAX_TREES; i++)
			{
			tree[i].tnode = calloc (2*MAX_tnodeS, sizeof (Treetnode));
			if (tree[i].tnode == NULL)
				{
				/*fprintf (stderr, "Could not allocate tree[i].tnode (%lu bytes)", 2*MAX_tnodeS * sizeof (Treetnode));*/
				fprintf (stderr, "Could not allocate tree[i].tnode");
	    		PrintUsage();
				}
			}

		/* read treefile  */
		i = 0;
		while ((ch=getc(fpInputTrees)) != EOF)
			{
			ungetc(ch,fpInputTrees);
			if (fscanf(fpInputTrees, "%d %d", &tree[i].begin, &tree[i].end) != 2)
				{
				fprintf (stderr, "Cannot read segment limits for tree %d", i+1);
				PrintUsage();
				}
			if (tree[i].begin > tree[i].end)
				{
				fprintf (stderr, "tree %d, begin segment (%d) > end segment (%d)", i+1, tree[i].begin, tree[i].end);
				PrintUsage();
				}
			if (i > 0)
				if (tree[i].begin <= tree[i-1].end)
					{
					fprintf (stderr, "tree %d begin segment (%d) <= tree %d end segment (%d)", i+1, tree[i].begin, i, tree[i-1].end);
					PrintUsage();
					}	
		
			ReadUntilExclusive(fpInputTrees, '(', "opening parenthesis");
			ReadTree(fpInputTrees, (Treetnode *)tree[i].tnode);
			TiptnodeNum = 1;
	    	InttnodeNum = numSequences + 1;
			FinishTree ((Treetnode *)tree[i].tnode);
			i++;
			}
		free (treeString);
		numTrees = i;

		/*if (noisy > 2)
			fprintf (stderr, " %d trees from %s\n", numTrees, treeFileName);*/

		/* Here the number of sites is specified in the input tree file, OK! */
		numSites = tree[numTrees-1].end;

		/* label tnodes according to indexes in the first tree  */
		if (numTrees > 1)
			Labeltnodes ();

		}


	/* Heterogeneity by a user-defined vector */
	if (doHetVectorFile == YES)
		{
		vectorHetRates = (double *) calloc(numSites+1,(long) sizeof(double));
		if (!vectorHetRates)
			{
			fprintf (stderr, "Could not allocate vectorHetRates (%lu bytes)\n", (numSites+1)  * (long) sizeof (double));
			exit (1);
			}
		
		#ifdef MAC
		/*_fcreator = 'R*ch';
		_ftype = 'TEXT';*/
		/*if ((fpHetVectorFile = freopen("HetVectorFile", "r", stdin)) == NULL)*/
		/*if ((fpHetVectorFile = fopen(HetVectorFile, "r")) == NULL) */
		if ((fpHetVectorFile = freopen(HetVectorFile, "r", stdin)) == NULL) 	
			{
			fprintf (stderr, "Can't open HetVectorFile file: %s \n", HetVectorFile);
			PrintUsage();
			}
		ReadHetVectorfromFile();
		Sioux();
		fclose(fpHetVectorFile);
		#else

		if ((fpHetVectorFile = freopen(HetVectorFile, "r", stdin)) != NULL)
			ReadHetVectorfromFile();
		else				
			{
			fprintf (stderr, "Can't open HetVectorFile file: %s \n", HetVectorFile);
			PrintUsage();
			}
		fclose(fpHetVectorFile);
		#endif

		}

	if (doProtStabDNAFile == YES && doProtStabAAFile == YES)
		{
		fprintf (stderr, "Can't specify both DNA and AA simulations by the structural protein stability substitution model (check arguments -z and -m, specify only one) \n");
		PrintUsage();
		}


	
	/**********/
	/* MPI introducing */
#ifdef MPI
	if (rank==root)  // jmourino: Para que solo escriba por pantalla el procesador master			
		fprintf(stderr, "\n In MPI version, it writes an outputfile per replicate. In next versions, it will concatenate those output files\n ");
		
#endif

	/*********/
	
	start = clock();
#ifdef MPI													
      	if (rank==root)  // jmourino: Para que solo escriba por pantalla el procesador master (Tengo la duda de crear Results en el caso que no haya NFS, que lo tendran que hacer todos)
	{
#endif
//	PrintTitle(stderr);		/* write title */
// 	PrintDate(stderr);		/* write date */
	mkdir("Results",S_IRWXU);	/* Create "Results" folder (with type S_IRWXU (read, write and execute)) */ 
	/*mkdir("Results",0);*/
#ifdef MPI													
	}
#endif

	#ifdef MAC					
		strcpy (dir,":Results:");	/* Copy the string in char variable dir = Results (char), is different mac vs windows */
	#else
		strcpy (dir,"Results/");
	#endif


	if (doGivenUserTrees == YES)
		{
		if (noisy > 1)
			{
			#ifdef MPI
			if (rank==root)
				fprintf (stderr, "\n>> Reading trees .. \n");
			#else
				fprintf (stderr, "\n>> Reading trees .. \n");
			#endif
			}
		
		if (noisy > 2)
			{
			#ifdef MPI
			if (rank==root)
				fprintf (stderr, " %d trees from %s\n", numTrees, treeFileName);
			#else
				fprintf (stderr, " %d trees from %s\n", numTrees, treeFileName);
			#endif
			}
		
		/* Print trees  */
		if (noisy > 2)
		for (i=0; i<numTrees; i++)
			{
			fprintf (fperr, "%4d - %4d ", tree[i].begin, tree[i].end);
			WriteTree (fperr, (Treetnode *)tree[i].tnode);	
			fprintf (fperr,";\n");
			}

		}


	if (doM0 == YES && doVariableDnDsBranches == NO && doPrintOmegasPerSitefiles == YES) /* For printing a warning */ 
		{
		doPrintOmegasPerSitefiles = NO;
		#ifdef MPI
		if (rank==root)
			fprintf(stderr, "\n * You are not using an appropriate model (M0) for writing a simulated omega per site/branch \n ");
		#else
			fprintf(stderr, "\n * You are not using an appropriate model (M0) for writing a simulated omega per site/branch \n ");
		#endif
		}
	if (doCodonModel == NO || doECM == YES || doMG94 == YES) /* For printing a warning */
		{
		if (doPrintOmegasPerSitefiles == YES)
			{
			doPrintOmegasPerSitefiles = NO;
			#ifdef MPI
			if (rank==root)
				fprintf(stderr, "\n * You are not using an appropriate model for writing a simulated omega per site/branch \n ");

			#else
			fprintf(stderr, "\n * You are not using an appropriate model for writing a simulated omega per site/branch \n ");
			#endif
			}
		}


	/*fprintf(stderr, "\n originalSeed = %lu \n", originalSeed);*/

	/* Anadido Miguel: Aqui se abren los archivos cuando NO se usa MPI */		
#ifndef MPI			
		if (doSeparatedSequences == NO)
			{
			sprintf(File,"%s%09d", alignmentFile, NumReplicateABC);			/* File = dir alignmentFile */
			if ((fpAlignment = fopen(File, "w")) == NULL)		/* if fpAlignment can't open */
				{
				fprintf(stderr, "Can't open %s.\n", File);
				exit(-1);
				}
			}
		if (doPrintBreakpoints == YES && doGivenUserTrees == NO)	
			{
			sprintf(File,"%s%09d", breakpointFile, NumReplicateABC);
			if ((fpBreakpoints = fopen(File, "w")) == NULL) /* if fpBreakpoints can't open */
				{
				fprintf(stderr, "Can't open %s.\n", File);
				exit(-1);
				}
			}
		if (doPrintTrees == YES && doGivenUserTrees == NO)		/* if treeFile " " */
			{
			sprintf(File,"%s%09d", treeFile, NumReplicateABC);
			if ((fpTrees = fopen(File, "w")) == NULL) 
				{
				fprintf(stderr, "Can't open %s.\n", File);
				exit(-1);
				}
			}
		if (doPrintTimes == YES && doGivenUserTrees == NO)		/* if timesFile " " */
			{
			sprintf(File,"%s%09d", timesFile, NumReplicateABC);
			if ((fpTimes = fopen(File, "w")) == NULL) 
				{
				fprintf(stderr, "Can't open %s.\n", File);
				exit(-1);
				}
			}
		if (doSettingsFile == YES)							/* For the programmer, if Settings file " " */
			{
			strcpy(settingsFile, "settings");
			sprintf(File,"%s%09d", settingsFile, NumReplicateABC);
			if ((fpSettings = fopen(File, "w")) == NULL) 
				{
				fprintf(stderr, "Can't open %s.\n", File);
				exit(-1);
				}
			}
		
#endif
	/* Input Trees from file - print to times file. The same for MPI than for no-MPI because it does not depend on the replicates */
	if (doGivenUserTrees == YES && doPrintTimes == YES)
		{
		sprintf(File,"%s%s", dir, timesFile);
		if ((fpTimes = fopen(File, "w")) == NULL) 
			{
			fprintf(stderr, "Can't open %s.\n", File);
			exit(-1);
			}

		for (i=0; i<numTrees; i++)
			{
			fprintf (fpTimes, "Tree %d : %d - %d", i+1, tree[i].begin, tree[i].end);
			Listtnodes(fpTimes, numSequences, (Treetnode *)tree[i].tnode);
			fprintf (fpTimes,"\n\n");
			}
		/*fclose(fpTimes);*/
		}
	if (doGivenUserTrees == YES && doPrintTrees == YES)	
		{
		sprintf(File,"%s%s", dir, treeFile);
		if ((fpTrees = fopen(File, "w")) == NULL) 
			{
			fprintf(stderr, "Can't open %s.\n", File);
			exit(-1);
			}
		
		for (i=0; i<numTrees; i++)
			{
			fprintf (fpTrees, "%4d - %4d ", tree[i].begin, tree[i].end);
			WriteTree (fpTrees, (Treetnode *)tree[i].tnode);	
			fprintf (fpTrees,";\n");
			}
		}

	kappa=(titv*(p_i[0]+p_i[2])*(p_i[1]+p_i[3]))/(p_i[0]*p_i[2] + p_i[1]*p_i[3]);
	/* titv = kappa * (p_i[0]*p_i[2] + p_i[1]*p_i[3]) / ((p_i[0]+p_i[2])*(p_i[1]+p_i[3])); */
	/*fprintf(stderr, "\n kappa = %lf.\n", kappa);*/
	if (doCodonModel == YES) /* numSites is the number of nucleotides, codons or amino acids */
		{
		numNuc = numSites*3;
		numCodons = numSites;
		}
	else if (doAAmodel == YES)
		{
		numAA = numSites;
		numNuc = numSites; /* this is only informative than the unit is the aa for some calculations like rho, etc.. */
		}
	else
		numNuc = numSites;



	/* calculate expected number of recombination events per gene */
	a = 0;
	a2 = 0;
	for (i=1; i<numSequences; i++)
		{
		a += 1.0/(double)i;
		a2 += 1.0/(double)pow(i,2);
		}

	rho = 2.0 * Nscaling * N * recombinationRate * /*numSites*/numNuc;	/* rho is the recombination rate per gene per 4*N generations */

	expNumHotspots = expNumPoissonHotspots / (double) (interferenceInterval);
	if (fixedNumHotspots == 0)
		tau = 2.0 * Nscaling * blockRecombinationRate * expNumHotspots; /* corresponds to the block recombination */ /* MA mod: tau = 4.0 * N * blockRecombinationRate * expNumHotspots; */
	else
		tau = 2.0 * Nscaling * blockRecombinationRate * fixedNumHotspots; /* corresponds to the block recombination */ /* MA mod: tau = 4.0 * N * blockRecombinationRate * fixedNumHotspots; */
	/*fprintf (stderr, "\n\n expNumHotspots, expNumPoissonHotspots, interferenceInterval, blockRecombinationRate, tau =  %3.2f, %3.2f, %d, %lf, %lf \n", expNumHotspots, expNumPoissonHotspots, interferenceInterval, blockRecombinationRate, tau);*/


	if (hotspotUniform == NO)
		numSitesOutside = 10 * sqrt (hotspotImprecision);
	else
		numSitesOutside =  hotspotWidth / 2.0;

	expNumRE = (rho + tau) * a;
	/*fprintf (stderr, "\n\nExpected number of rec events       =  %3.2f\n", expNumRE);*/


	theta = 2.0 * Nscaling * N * mutationRate * numSites;
	expNumMU = theta * a;
	expVarNumMU =  theta * a + pow(theta,2) * a2;


	expTMRCA = 2 * (1 - 1.0/numSequences)* Nscaling * N; /* multiply by 2N to get time in number of generations */
	expVarTMRCA = 0.0;
    for (i=2; i<= numSequences; i++)
       expVarTMRCA += (2.0 * Nscaling) / (pow(i,2) * pow(i-1,2)) * pow(Nscaling * N,2); /* Ma mod: expVarTMRCA += 4.0 / (pow(i,2) * pow(i-1,2)) * pow(Nscaling * N,2); */


	if (fixedNumHotspots == 0)
		globalRecombinationRate = recombinationRate + blockRecombinationRate*expNumHotspots/(double)numNuc;
	else
		globalRecombinationRate = recombinationRate + blockRecombinationRate*fixedNumHotspots/(double)numNuc;

	

	/* make sure dated tips are well specified  find the latest time, which will be time 0.0 going backwards in time 
		and sort samples */
	if (doDatedTips == YES)
		{
		sum = 0;
		for (i=0; i<numTipDates; i++)
			{
			sum += datedSample[i].size;
			if (datedSample[i].time > latestSamplingTime)
				latestSamplingTime = datedSample[i].time;
			}
		if (sum != numSequences)	
			{
			fprintf (stderr,"ERROR: the sum of the dated samples (%d) is not the same as the number of sequences (%d)", sum, numSequences);	
			exit(1);
			}
	
		/* set times in generation for dated tips; the youngest sample will be generation 0 */		
		for (i=0; i<numTipDates; i++)
			datedSample[i].time = (latestSamplingTime - datedSample[i].time) * generationTime;
				/* to get generations back (assumes generation time and sampling times are in the same unit, e.g., years) */

		/* sort the samples from older to younger */
		pass = 1;
		do 
			{
			sorted = YES;
			for (i=0; i<(numTipDates-pass); i++)
				{
				if (datedSample[i].time < datedSample[i+1].time)
					{		
					tempSample = datedSample[i+1];
					datedSample[i+1] = datedSample[i];
					datedSample[i]  = tempSample;
					sorted = NO;
					}
				}
			pass++;
			}	while (sorted == NO);

		i = 0;
		}
	




  	/* Set seed and spin wheels of pseudorandom number generator */
	/*seed = (unsigned int) clock();*/
	ftime(&tmb);
	/*fprintf(stderr, "\n seed = %lu; userSeed = %lu \n", seed, userSeed);
	printf("tmb.time     = %ld (seconds), %ld \n", tmb.time, fabs(tmb.time));
  	printf("tmb.millitm  = %ld (mlliseconds), %ld \n", tmb.millitm, fabs(tmb.millitm));*/
	seed = seed + fabs(tmb.millitm); 
    /*fprintf(stderr, "\n seed = %lu; userSeed = %lu \n", seed, userSeed);*/

	if (userSeed > 0)
		seed = userSeed;
	originalSeed = seed;
	for (i=0; i<10; i++)	
		RandomUniform(&seed);		/* function that generates random seed */  //jmourino: Esto tienen sentido realmente?  Por ahora,lo dejamos asi
	seedFirst = seed;
	/*fprintf(stderr, "\n seedFirst = %lu \n", seedFirst);*/
	
	/* default */
	cumNumRE = 0.0;
	cumNumCA = 0.0;
	cumNumMU = 0.0;
	cumNumREntc = 0.0;
	cumNumMIG = 0.0;
	cumNumCONV = 0.0;
	cumNumREbreakCod = 0.0;
	cumNumStopCodonREC = 0.0;
	cumNumEqual2 = 0.0;
	cumNumEqual1 = 0.0;
	cumNumDifCodSameAA = 0.0;
	cumNumDifCodDifAA = 0.0;
	cumNumNonSyn0 = 0.0;
	cumNumNonSyn1 = 0.0;
	cumNumNonSyn2 = 0.0;
	zeroRec = 0;
	countTMRCAReps = 0.0;
	counterTime = 0.0;
	cumNumRESq = cumNumREtc = cumNumREtcSq = cumC01 = cumC01Sq = cumNumREblock = cumNumREblockSq	= 0.0;
	cumNumREntc = cumNumHotspots = 0;
	cumNumHotspotsSq = 0;



	/* preparing populations to migrations */
	if (doMigration == YES)
		{
		i = j = w = 0;
		numNodesInitPopul = (int *) calloc((numPopulations+1),(long) sizeof(int));
		if (!numNodesInitPopul)
			{
			#ifdef MPI
				fprintf (stderr, "%d: Could not allocate numNodesInitPopul (%lu)\n", rank, (numPopulations+1) * (long) sizeof(int)); /* casting with loing to avoid warnings in different OS */
			#else
				fprintf (stderr, "Could not allocate numNodesInitPopul (%lu)\n", (numPopulations+1) * (long) sizeof(int)); /* casting with loing to avoid warnings in different OS */
			#endif
			exit (-1);
			}
		
		for (i = 1; i <= numPopulations; i++)
			numNodesInitPopul[i] = initPopulation[i];
		
		for (i = 1; i <= numPopulations; i++)
			j = j + numNodesInitPopul[i];
		
		j = 0;
		for (i = 1; i <= numPopulations; i++)
			j = j + numNodesInitPopul[i];
		if (j != numSequences)
			{
			#ifdef MPI
				fprintf(stderr, "\n%d: Warning in program. Migration in main.",rank);
				fprintf(stderr, "\n%d: Are you applying migration and a fixed tree at the same time?.",rank);
			#else
				fprintf(stderr, "\nWarning in program. Migration in main.");
				fprintf(stderr, "\nAre you applying migration and a fixed tree at the same time?.");
			#endif
			exit (-1);
			}
		i = j = w = 0;
		}
	
	/* Variance memories */
	varEvent = (int *) calloc(numDataSets,(long) sizeof(int));
	if (!varEvent)
		{
		#ifdef MPI
			fprintf (stderr, "%d: Could not allocate varEvent (%lu bytes)\n", rank, numDataSets *(long) sizeof(int));
		#else
			fprintf (stderr, "Could not allocate varEvent (%lu bytes)\n", numDataSets *(long) sizeof(int));
		#endif
		exit (1);
		}
	varTimeGMRCA = (double *) calloc(numDataSets,(long) sizeof(double));
	if (!varTimeGMRCA)
		{
		#ifdef MPI
			fprintf (stderr, "%d: Could not allocate varTimeGMRCA (%lu bytes)\n", rank, numDataSets  * (long) sizeof (double));
		#else
			fprintf (stderr, "Could not allocate varTimeGMRCA (%lu bytes)\n", numDataSets  * (long) sizeof (double));
		#endif
		exit (1);
		}
	varTimeT = (double *) calloc(numDataSets,(long) sizeof(double));
	if (!varTimeT)
		{
		#ifdef MPI
			fprintf (stderr, "%d: Could not allocate varTimeT (%lu bytes)\n", rank, numDataSets  * (long) sizeof (double));
		#else
			fprintf (stderr, "Could not allocate varTimeT (%lu bytes)\n", numDataSets  * (long) sizeof (double));
		#endif
		exit (1);
		}
	
	if (doCodonModel == YES) /* making Qij for codon models */
		{
		if (doOmegaCat == NO && doOmegaRateHetCont == NO && doOmegaRateHetDisc == NO && doM6 == NO && doM9 == NO && doM10 == NO && doMG94 == NO)
			buildCodonMatrix_Qij_Cijk ();
		if (doMG94 == YES) /* only for MG94 codon model */
			buildCodonMatrix_MG94_Qij_Cijk ();
		if (doECM == YES) /* only empirical codon models */
			buildCodonMatrix_EmpiricalCodonModel_Qij_Cijk ();

		if (doOmegaCat == YES)
			{
			QijOmegas = (Qij_OmegaCat *) calloc (numOmegaCat, sizeof(Qij_OmegaCat));
			if (!QijOmegas)
				{
				#ifdef MPI
					fprintf (stderr, "%d: Could not allocate QijOmegas (%lu)\n", rank, numOmegaCat  * (long) sizeof(Qij_OmegaCat));
				#else		
					fprintf (stderr, "Could not allocate QijOmegas (%lu)\n", numOmegaCat  * (long) sizeof(Qij_OmegaCat));
				#endif		
				exit (1);
				}
			
			for (j=1; j<=numOmegaCat; j++)
				{
				omega = omegaVal[j];
				buildCodonMatrix_Qij_Cijk ();
				
				for (w=0;w<NUMCOD;w++)
					QijOmegas[j-1].Root_C_cat[w] = Root_C[w];
				for (w=0;w<NUMCOD*NUMCOD*NUMCOD*NUMCOD;w++)
					QijOmegas[j-1].Cijk_C_cat[w] = Cijk_C[w];
				}			
			}
		
		if (doOmegaRateHetDisc == YES)
			{
			QijOmegas = (Qij_OmegaCat *) calloc (numOmegaCat, sizeof(Qij_OmegaCat));
			if (!QijOmegas)
				{
				#ifdef MPI
					fprintf (stderr, "%d: Could not allocate QijOmegas (%lu)\n", rank, numOmegaCat  * (long) sizeof(Qij_OmegaCat));
				#else
					fprintf (stderr, "Could not allocate QijOmegas (%lu)\n", numOmegaCat  * (long) sizeof(Qij_OmegaCat));
				#endif
				exit (1);
				}
				
			gammaRates =  (double*) calloc (numOmegaCat, sizeof (double));  
			if (gammaRates == NULL)
				{
				#ifdef MPI
						fprintf (stderr, "%d: Could not allocate %s (%lu bytes)", "gammaRates", rank, numOmegaCat  * (long) sizeof (double));
				#else
						fprintf (stderr, "Could not allocate %s (%lu bytes)", "gammaRates", numOmegaCat  * (long) sizeof (double));
				#endif
				exit(0);
				}
			
			omegaValGammaRate = (double *) calloc((numOmegaCat+1),(long) sizeof(double));
			if (!omegaValGammaRate)
				{
				fprintf (stderr, "PARAMETER ERROR: omegaValGammaRate. Could not allocate omega values of categories (%lu bytes)\n", numOmegaCat *(long) sizeof(double));
				exit (1);
				}
			
			/*fprintf (stderr, " categories %d\n", numOmegaCat);*/

			gammasCalculate (OmegaRateHet, numOmegaCat);
		
			for (j=1; j<=numOmegaCat; j++)
				{
				omegaGammaDisc = OmegaInit*gammaRates[j-1];

				omega = roundit(omegaGammaDisc,5);
				omegaValGammaRate[j] = omega;

				buildCodonMatrix_Qij_Cijk ();
				
				for (w=0;w<NUMCOD;w++)
					QijOmegas[j-1].Root_C_cat[w] = Root_C[w];
				for (w=0;w<NUMCOD*NUMCOD*NUMCOD*NUMCOD;w++)
					QijOmegas[j-1].Cijk_C_cat[w] = Cijk_C[w];
				}			
			}
		}
	
	if (doAAmodel == YES && doProtStabAAFile == NO) /* making Qij for amino acid models */
		{
		buildAAMatrix_Qij_Cijk (); /* same model for all amino acid sites */
		}



	
	if (doMRCAFile == YES) /* From MRCA file */ 
		{
		MRCAsequence = (char *) calloc((numNuc+1), sizeof(char)); 
		if (!MRCAsequence)
			{
			#ifdef MPI
				fprintf (stderr, "%d: Could not allocate MRCAsequence (%lu bytes)\n", rank, (numNuc+1)  * (long) sizeof(char));
			#else
				fprintf (stderr, "Could not allocate MRCAsequence (%lu bytes)\n", (numNuc+1)  * (long) sizeof(char));
			#endif
			exit (-1);
			}
					
		if ((fpMRCA = fopen(MRCAFile, "r+")) == NULL) /* if MRCAFile can't open */
			{
			#ifdef MPI
				fprintf(stderr, "%d: Can't open %s.\n", rank, MRCAFile);
			#else
				fprintf(stderr, "Can't open %s.\n", MRCAFile);
			#endif
			exit(-1);
			}
		else /* It can open MRCAFile */
			{
			i = 0;
			fscanf(fpMRCA, "%s", MRCAsequence); /* copy MRCA file into the MRCAsequence array */
			fclose(fpMRCA); 


			if (doAAmodel == NO)
				{
				do 
					i++;
				while (MRCAsequence[i] == 'A' || MRCAsequence[i] == 'C' || MRCAsequence[i] == 'G' || MRCAsequence[i] == 'T');
				/*fprintf (stderr, "\n\n NO AA \n\n");*/
				}
			else
				{
				do 
					i++;
				while (MRCAsequence[i] == 'A' || MRCAsequence[i] == 'R' || MRCAsequence[i] == 'N' || MRCAsequence[i] == 'D' || MRCAsequence[i] == 'C' || MRCAsequence[i] == 'Q' || MRCAsequence[i] == 'E' || MRCAsequence[i] == 'G' || MRCAsequence[i] == 'H' || MRCAsequence[i] == 'I' || MRCAsequence[i] == 'L' || MRCAsequence[i] == 'K' || MRCAsequence[i] == 'M' || MRCAsequence[i] == 'F' || MRCAsequence[i] == 'P' || MRCAsequence[i] == 'S' || MRCAsequence[i] == 'T' || MRCAsequence[i] == 'W' || MRCAsequence[i] == 'Y' || MRCAsequence[i] == 'V');
				/*fprintf (stderr, "\n\n YES AA \n\n");*/
				}
				/* 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 */
				/* A R N D C Q E G H I L K M F P S T W Y V */ 


		
			/* Active this whether we want to see the MRCA sequence from MRCA File */
			/*fprintf (stderr, "\n\n MRCA sequence is: ");
			for (k = 0; k < i; k++)
				fprintf (stderr, "%c", MRCAsequence[k]);
			fprintf(stderr, "\nsites = %d\n", i);
			fprintf(stderr, "\n\n");
			fprintf (stderr, "%s", MRCAsequence);
			fprintf(stderr, "\n\n");*/
			/*fprintf(stderr, "\n LongMRCA File = %d, Log Seq nuc = %d \n", i, numNuc);*/


			if (i != numNuc)
				{
				#ifdef MPI
					if (rank==root)		// Lo escribe el cero o todos? Si todos hay que quitar esta linea.			No entiendo muy bien que quieres decir. Si entra en este "if (i != numNuc)" el programa se para, communicando el error (hay dos parmetros de entrada incompatibles). Aqui todavia deberia estar funcionando solo el master.
						{
						fprintf(stderr, "\nWarning in MRCA file (numNuc/numAA (from parametersFile) is different to numNuc/numAA (from MRCAFile)), verify:");
						fprintf(stderr, "\n1. num (MRCAFile) = %d, num (parametersFile) = %d", i, numNuc);
						fprintf(stderr, "\nor");
						fprintf(stderr, "\n2. A site of MRCA file is different to any nucleotide (A C G T) or any amino acid (A R N D C Q E G H I L K M F P S T W Y V)");
						}
				#else
					{
					fprintf(stderr, "\nWarning in MRCA file (numNuc/numAA (from parametersFile) is different to numNuc/numAA (from MRCAFile)), verify:");
					fprintf(stderr, "\n1. num (MRCAFile) = %d, num (parametersFile) = %d", i, numNuc);
					fprintf(stderr, "\nor");
					fprintf(stderr, "\n2. A site of MRCA file is different to any nucleotide (A C G T) or any amino acid (A R N D C Q E G H I L K M F P S T W Y V)");
					}
				#endif
				exit (-1);
				}
			}
		}
	i = j = w = 0;




// ****************************************************************************
// ************************* Cola de iteraciones ******************************
// ****************************************************************************

#ifdef MPI
        MPI_Barrier(comm);

// ****************************************************************************
        if (rank!=root) {   // CLIENT
// ****************************************************************************

      		MPI_Recv(&fila,1,MPI_INT,root,rank,comm,&status); //recibo numero de replicas
          do {
            MPI_Recv(&rep,1,MPI_INT,root,rank,comm,&status); /// recibo numero de replica

            // recibo datos (en principio no hace falta)
		
		if (p > numDataSets)
			{
			printf("Warning!. There are more processors (%d) than replicates (%d)", p, numDataSets);
			exit (-1);
			}
			
		// CALCULOS (las fila replicas)
		for (dataSetNum=rep; dataSetNum<rep+fila; dataSetNum++){
		printf("%d: calculo fila %d (%d de %d) en procesador %d\n",rank, dataSetNum, dataSetNum-rep+1, fila, rank);
#else

	  for (dataSetNum = 0; dataSetNum < numDataSets; dataSetNum++)		/**** FOR EACH REPLICATE ****/
		{

#endif		
		seed = seedFirst+dataSetNum+10; /* De esta forma la semilla sera la misma para secuencial que para MPI */ /* Variable seed among processors for MPI */
		do /* it will be a good replicate?. It will be running til a nice replicate (with the chosen number of recombinations) */
		{
		/* fprintf (stderr, "\n replicate = %d\n", dataSetNum+1); */
		
		#ifdef MPI
			{
			/*seed = seedFirst+dataSetNum+10;*/ 

			fprintf(stderr, "\n--------- IN MPI ----------\n");

			strcpy(screenFile, "screen");
			sprintf(File,"%s%05d", screenFile, dataSetNum+1);					/* To write the screen information of the loop, for this replicate */
			if	((fpScreen = fopen(File, "w")) == NULL) /* if fpScreen can't open */
				{
				fprintf(stderr, "Can't open %s.\n", File);
				exit(-1);
				}

			if (doSeparatedSequences == NO)
				{
                sprintf(File,"%s%09d", alignmentFile, NumReplicateABC);			/* File = dir alignmentFile */
				if ((fpAlignment = fopen(File, "w")) == NULL)		/* if fpAlignment can't open */
					{
					fprintf(fpScreen, "Can't open %s.\n", File);
					exit(-1);
					}
				}
			if (doPrintBreakpoints == YES && doGivenUserTrees == NO)	
				{
                sprintf(File,"%s%05d%09d", breakpointFile, dataSetNum+1, NumReplicateABC);
				if	((fpBreakpoints = fopen(File, "w")) == NULL) /* if fpBreakpoints can't open */
					{
					fprintf(fpScreen, "Can't open %s.\n", File);
					exit(-1);
					}
				}
			if (doPrintTrees == YES && doGivenUserTrees == NO)							/* if treeFile " " */
				{
                sprintf(File,"%s%05d%09d", treeFile, dataSetNum+1, NumReplicateABC);
				if ((fpTrees = fopen(File, "w")) == NULL)
					{
					fprintf(fpScreen, "Can't open %s.\n", File);
					exit(-1);
					}
				}
			if (doPrintTimes == YES && doGivenUserTrees == NO)							/* if timesFile " " */
				{
				fprintf(stderr, "\n - MPI.opening TIMES -");
				
                sprintf(File,"%s%05d%09d", timesFile, dataSetNum+1, NumReplicateABC);
				if ((fpTimes = fopen(File, "w")) == NULL)
					{
					fprintf(fpScreen, "Can't open %s.\n", File);
					exit(-1);
					}
				}
			}
		#endif

	/* Printing options in the parallelization area */ 
	#ifdef MPI
       fpmpi = fpScreen;
    #else
       fpmpi = stderr;
    #endif

		if (noisy == 0)
			{
			#ifdef MPI
			//fprintf (fpmpi, "\nReplicate #%3d/%d", dataSetNum+1, numDataSets);
            fprintf (fpmpi, "\nSimulation # %d", NumReplicateABC); // sequences000000104
			#else
			//fprintf (fpmpi, "\rReplicate #%3d/%d", dataSetNum+1, numDataSets);
            fprintf (fpmpi, "\rSimulation # %d", NumReplicateABC);
			fflush (stdout);
			#endif
			}
		varEvent[dataSetNum] = 0;			
		varTimeGMRCA[dataSetNum] = varTimeT[dataSetNum] = 0.0;
		counterTimeInit = 0.0;
		actSegIndex = numRE = C01 = numREblock = indNumRE = recNotToCount = numCA = numMU = numMIG = numCONV = 0;
		numMU_S = numMU_NS = 0;
		actualTGMRCA = countTMRCA = 0.0;
		numEqual2 = numEqual1 = numDifCodSameAA = numDifCodDifAA = numNonSyn0 = numNonSyn1 = numNonSyn2 = 0;
		BBBcounter = 0;		
		numMutationAttemptsRep = 0;
		CountDNAsubsRep = 0;
		CountDNAsubsNSRep = 0;

		if (doBranchNetfiles == YES && doGivenUserTrees == NO)							/* outfiles network-branches */
			{
			sprintf(File,"%s%s%05d", dir, networkOut, dataSetNum+1);
			if ((fpBranchNet = fopen(File, "w")) == NULL) 
				{
				fprintf(stderr, "Can't open %s.\n", File);
				exit(-1);
				}
			}
		
		NodesMRCAposit = (int *) calloc((numNuc+1),(long) sizeof(int)); /* this array will contain the labels of the MRCA nodes for each position */
		if (!NodesMRCAposit)
			{
			fprintf (fpmpi, "Could not allocate NodesMRCAposit (%lu)\n",(numNuc+1) * (long) sizeof(int)); /* casting with loing to avoid warnings in different OS */
			exit (-1);
			}

		if (doGivenUserTrees == NO)
			{
			if (noisy > 1)
				fprintf (fpmpi, "\n\n>> Start making coalescent fragments trees .. \n");
		
			if (doBlockRecombination == YES)
				MakeCoalescenceTreeHotspotRec (numSequences, numSites, numNuc, N, recombinationRate, numPopulations, &seed);			/* Make the coalescence tree, topology, with hotsposts of recombination */
			else
				MakeCoalescenceTree (numSequences, numSites, numNuc, N, recombinationRate, numPopulations, &seed);			/* Make the coalescence tree, topology */
			/* check whether we want to keep this replicate, It is possible to choose those replicates with a fix recombinations number*/
			}
		/*exit (1);*/ 
		

		
		if (doGivenUserTrees == NO)
			{
			/*matrix = (int *)calloc((2*(numSequences+1) * (numNuc+1)),(long) sizeof(int));
			if (!matrix)
				{
				fprintf (fpmpi, "Could not allocate matrix (%lu bytes)\n", (2*(numSequences+1) * (numNuc+1))  * (long) sizeof(int));
				exit (1);
				}*/
			matrix = (int *)calloc(((nextAvailable+1) * (numNuc+1)),(long) sizeof(int));		/* matrix is a vector with long = 2*(numSequences+1) * numSites */
			if (!matrix)
				{
				fprintf (fpmpi, "Could not allocate matrix (%lu bytes)\n", ((nextAvailable+1) * (numNuc+1))  * (long) sizeof(int));
				exit (1);
				}
			for (i = 0; i < (nextAvailable+1) * (numNuc+1); i++)
				matrix[i] = -1;	
			/*fprintf (fpmpi, "\nMatrix tiene num de labelnodes, tamanho = %d \n", nextAvailable+1);*/

			if (doCodonModel == YES)
				{
				matrixC = (int *)calloc(((nextAvailable+1) * (numSites+2)),(long) sizeof(int));		
				if (!matrixC)
					{
					fprintf (fpmpi, "Could not allocate matrixC (%lu bytes)\n", ((nextAvailable+1) * (numSites+2))  * (long) sizeof(int));
					exit (1);
					}
				/*matrixC = (int *)calloc((2*(numSequences+1) * (numSites+2)),(long) sizeof(int));		
				if (!matrixC)
					{
					fprintf (fpmpi, "Could not allocate matrixC (%lu bytes)\n", (2*(numSequences+1) * (numSites+2))  * (long) sizeof(int));
					exit (1);
					}*/
				for (i = 0; i < (nextAvailable+1) * (numSites+2); i++)
					matrixC[i] = -1;
				}
			}
		else
			{
			matrix = (int *) calloc (2*(numSequences+1)*(numNuc+1),(long) sizeof(int));
			if (!matrix)
				{
				fprintf (fpmpi, "Could not allocate matrix (%lu bytes)\n", (2*(numSequences+1)*(numNuc+1))  * (long) sizeof(int));
				exit (1);
				}
			for (i = 0; i < (2*(numSequences+1)*(numNuc+1)); i++)
				matrix[i] = -1;	

			if (doCodonModel == YES)
				{
				matrixC = (int *)calloc(2*(numSequences+1)*(numSites+2),(long) sizeof(int));		
				if (!matrixC)
					{
					fprintf (fpmpi, "Could not allocate matrixC (%lu bytes)\n", (2*(numSequences+1)*(numSites+2))  * (long) sizeof(int));
					exit (1);
					}
				for (i = 0; i < (2*(numSequences+1)*(numSites+2)); i++)
					matrixC[i] = -1;
				}
			}

		if (doFixNumRecEvents == NO || numRE == fixedNumRecEvents || doGivenUserTrees == YES)  /* This replicate is good */
			{
			if (noisy > 1)
				{
				//fprintf (fpmpi, "\n>> Simulating sequences for fragments trees .. \n\n");
				fprintf (fpmpi, "\n>> Simulating sequences .. \n\n");
				}

			if (doSeparatedSequences == YES)
				{
				if (doPrintFASTA == NO && doPrintNEXUS == NO) /* phylip */
					{
                    sprintf(File,"%s%09d", alignmentFile, NumReplicateABC);			/* File = dir alignmentFile */
					if ((fpAlignment = fopen(File, "w")) == NULL)		/* if fpAlignment can't open */
						{
						fprintf(fpmpi, "Can't open %s.\n", File);
						exit(-1);
						}
					}
				if (doPrintFASTA == YES && doPrintNEXUS == NO) /* fasta */
					{
                    sprintf(File,"%s%09d.fas", alignmentFile, NumReplicateABC);			/* File = dir alignmentFile */
					if ((fpAlignment = fopen(File, "w")) == NULL)		/* if fpAlignment can't open */
						{
						fprintf(fpmpi, "Can't open %s.\n", File);
						exit(-1);
						}
					}
				if (doPrintNEXUS == YES && doPrintFASTA == NO) /* nexus */
					{
                    sprintf(File,"%s%09d.nex", alignmentFile, NumReplicateABC);			/* File = dir alignmentFile */
					if ((fpAlignment = fopen(File, "w")) == NULL)		/* if fpAlignment can't open */
						{
						fprintf(fpmpi, "Can't open %s.\n", File);
						exit(-1);
						}
					}
				}

			if (doPrintOmegasPerSitefiles == YES)
				{
                sprintf(File,"%s%05d%09d", OmegasPerSiteFile, dataSetNum+1, NumReplicateABC);			/* File = dir  */
				if ((fpOmegasPerSitePrint = fopen(File, "w")) == NULL)		/* if it can't open */
					{
					fprintf(fpmpi, "Can't open %s.\n", File);
					exit(-1);
					}
				}
			
			if (doOutMRCAfiles == YES)							
				{
				if (doGivenUserTrees == NO)
					{
                    sprintf(File,"%s%05d%09d", MRCAfilePrint, dataSetNum+1, NumReplicateABC); /* GMRCA */
					if ((fpMRCAprint = fopen(File, "w")) == NULL)
						{
						fprintf(stderr, "Can't open %s.\n", File);
						exit(-1);
						}
					}
				
                sprintf(File,"%s%05d%09d", ConcMRCAfilePrint, dataSetNum+1, NumReplicateABC); /* catMRCA */
				if ((fpConcMRCAprint = fopen(File, "w")) == NULL)
					{
					fprintf(stderr, "Can't open %s.\n", File);
					exit(-1);
					}
				
				if (doCodonModel == YES && doGMRCAsamp == YES)
					{
                    sprintf(File,"%s%05d%09d", GMRCAancFilePrint, dataSetNum+1, NumReplicateABC); /* ancestral material GMRCA */
					if ((fpGMRCAancPrint = fopen(File, "w")) == NULL)
						{
						fprintf(stderr, "Can't open %s.\n", File);
						exit(-1);
						}

					}	

				}
			/*exit(-2);*/
									


			/*********** Generating sequences ***********/
			if (doGivenUserTrees == NO)
				{
				do
					{
					if (doCodonModel == YES) /* codon model */
						{
						EvolveSequenceOnTree_Codon (&seed, mutationRate, alpha, numNuc, indNumRE, arrayIndBreakpointsOrd, MRCAsequence, numOmegaCat, numSites);
						}
					else if (doAAmodel == YES) /* AA model */
						{
						EvolveSequenceOnTree_NEW_AA (&seed, mutationRate, alpha, p_i_aa, numNuc, indNumRE, arrayIndBreakpointsOrd, MRCAsequence, numSites, dataSetNum, dirStability);
						}
					else /* nucleotide model */
						{
						/*EvolveSequenceOnTree (&seed, mutationRate, kappa, alpha, p_i, numSites, arrayIndBreakpointsOrd, MRCAsequence);*/
						EvolveSequenceOnTree_NEW (&seed, mutationRate, kappa, alpha, p_i, numNuc, indNumRE, arrayIndBreakpointsOrd, MRCAsequence, numSites, dataSetNum, dirStability);
						}
					} while (doRepitEvol == YES);	/* it repit the evolve sequence while there are some stop codon by recombination in the codon*/	
				}
			else
				{
				if (doCodonModel == YES) /* codon model */
					{
					EvolveSequenceOnTree_UserTrees_Codon (&seed, alpha, numSites, numNuc, MRCAsequence, numOmegaCat);
					}
				else if (doAAmodel == YES) /* AA model */
					{
					EvolveSequenceOnTree_UserTrees_AA (&seed, alpha, p_i_aa, numSites, numNuc, MRCAsequence, dataSetNum, dirStability);
					}
				else /* nucleotide model */
					{
					/*fprintf (fpmpi, "\n Going to EvolveSequenceOnTree_UserTrees_Nt \n\n");*/
					EvolveSequenceOnTree_UserTrees_Nt (&seed, kappa, alpha, p_i, numSites, numNuc, MRCAsequence, dataSetNum, dirStability);
					}
				}
			/*fprintf (fpmpi, "\n OK, done. Sequences simulated. \n\n");*/



			cumNumMU += numMU;
			cumNumMU_S += numMU_S;
			cumNumMU_NS += numMU_NS;			
			cumNumRE += numRE;
			cumNumRESq += pow(numRE,2);
			cumC01 += C01;
			cumC01Sq += pow(C01,2);
			cumNumREtc += (numRE - recNotToCount);
			cumNumREtcSq += pow((numRE - recNotToCount),2);
			cumNumREblock += numREblock;
			cumNumREblockSq += pow(numREblock,2);
			cumNumREntc += recNotToCount;
			cumNumCA += numCA;
			cumNumREbreakCod += numREbreakCod;
			cumNumStopCodonREC += numStopCodonREC;
			cumNumEqual2 += numEqual2;
			cumNumEqual1 += numEqual1;
			cumNumDifCodSameAA += numDifCodSameAA;
			cumNumDifCodDifAA += numDifCodDifAA;
			cumNumNonSyn0 += numNonSyn0;
			cumNumNonSyn1 += numNonSyn1;
			cumNumNonSyn2 += numNonSyn2;
			cumNumHotspots += numHotspots;
			cumNumHotspotsSq += pow(numHotspots,2);
			cumMutationAttempts	+= numMutationAttemptsRep;
			if (doMigration == YES)
				{
				cumNumMIG += numMIG;
				if (doConvergDemes == YES)
					cumNumCONV += numCONV;
				}
			if (numRE == 0)
				zeroRec++;				/* zeroRep = number of replicates with 0 recombination events */
			TotalCountDNAsubsRep += CountDNAsubsRep;
			TotalCountDNAsubsNSRep += CountDNAsubsNSRep;
			
			/* Average time to MRCA into this replicate with one or several trees */
			if (doGivenUserTrees == NO)
				{			
				if (numRE == 0) /* there aren't recombinations */
					{
					fragmentTMRCAfraction = (double *) calloc(1,(long) sizeof(double));
					if (!fragmentTMRCAfraction)
						{
						fprintf (fpmpi, "Could not allocate fragmentTMRCAfraction (%lu bytes)\n", 1 *(long) sizeof(double));
						exit (-1);
						}
					fragmentTMRCAfraction[0] = treeRootNodex[0]->time;
					countTMRCA = fragmentTMRCAfraction[0];
					}
				else
					{
					fragmentTMRCAfraction = (double *) calloc((indNumRE+1),(long) sizeof(double));
					if (!fragmentTMRCAfraction)
						{
						fprintf (fpmpi, "Could not allocate fragmentTMRCAfraction (%lu bytes)\n", (indNumRE+1) *(long) sizeof(double));
						exit (-1);
						}
					for (i = 0; i <= indNumRE; i++) /* it calculates the time to MRCA */
						{
						if (i == 0)
							fragmentTMRCAfraction[i] = treeRootNodex[0]->time*(arrayIndBreakpointsOrd[0]-1)/numNuc;
						if (i == indNumRE)
							fragmentTMRCAfraction[i] = treeRootNodex[indNumRE]->time*(numNuc-arrayIndBreakpointsOrd[indNumRE-1]+1)/numNuc;
						if (i > 0 && i < indNumRE)
							fragmentTMRCAfraction[i] = treeRootNodex[i]->time*(arrayIndBreakpointsOrd[i]-1 - arrayIndBreakpointsOrd[i-1] + 1)/numNuc;
						countTMRCA = countTMRCA + fragmentTMRCAfraction[i];
						}
					}
				free (fragmentTMRCAfraction);

				countTMRCAReps = countTMRCAReps + countTMRCA;
				counterTime = counterTime + counterTimeInit;
				}
                
                
                

			/*************** output files *************/
			
			if (doGivenUserTrees == NO)
				{
				/*fprintf (fpmpi, "\n nextAvailable = %d", nextAvailable);*/
				if (doCodonModel == YES)
					{
					if (doPrintFASTA == NO && doPrintNEXUS == NO) /* phylip */
						{
						if (doPrintAncestralSequences == YES)
							PrintAncestralSequences_C (/*dataSetNum*/);
						else
							PrintSequences_C (/*dataSetNum*/);
						}
					if (doPrintFASTA == YES && doPrintNEXUS == NO) /* fasta */
						{
						if (doPrintAncestralSequences == YES)
							PrintAncestralSequences_C_FASTA (/*dataSetNum*/);
						else
							PrintSequences_C_FASTA (/*dataSetNum*/);
						}
					if (doPrintNEXUS == YES && doPrintFASTA == NO) /* nexus */
						{
						if (doPrintAncestralSequences == YES)
							PrintAncestralSequences_C_NEXUS (/*dataSetNum*/);
						else
							PrintSequences_C_NEXUS (/*dataSetNum*/);
						}
	
					if (doOutMRCAfiles == YES)
						{
						PrintOutMRCAFiles_C(/*dataSetNum*/);
						PrintOutMRCAFiles_C_Conc(/*dataSetNum*/);
						if (doGMRCAsamp == YES)
							PrintOutGMRCAFiles_Codon_AncestralMat();
						}
					}
				else if (doAAmodel == YES) /* Print from amino acid models */
					{
					if (doPrintFASTA == NO && doPrintNEXUS == NO) /* phylip */
						{
						if (doPrintAncestralSequences == YES)
							PrintAncestralSequences_AA (/*dataSetNum*/);
						else
							PrintSequences_AA (/*dataSetNum*/);
						}
					if (doPrintFASTA == YES && doPrintNEXUS == NO) /* fasta */
						{
						if (doPrintAncestralSequences == YES)
							PrintAncestralSequences_AA_FASTA (/*dataSetNum*/);
						else
							PrintSequences_AA_FASTA (/*dataSetNum*/);
						}
					if (doPrintNEXUS == YES && doPrintFASTA == NO) /* nexus */
						{
						if (doPrintAncestralSequences == YES)
							PrintAncestralSequences_AA_NEXUS (/*dataSetNum*/);
						else
							PrintSequences_AA_NEXUS (/*dataSetNum*/);
						}				

					if (doOutMRCAfiles == YES)
						{
						PrintOutMRCAFiles_AA(/*dataSetNum*/);
						PrintOutMRCAFiles_AA_Conc();
						}

					}
				else /* Print from nucleotide models */
					{
					if (doPrintFASTA == NO && doPrintNEXUS == NO) /* phylip */
						{
						if (doPrintAncestralSequences == YES)
							PrintAncestralSequences (/*dataSetNum*/);
						else
							PrintSequences (/*dataSetNum*/);
						}
					if (doPrintFASTA == YES && doPrintNEXUS == NO) /* fasta */
						{
						if (doPrintAncestralSequences == YES)
							PrintAncestralSequences_FASTA (/*dataSetNum*/);
						else
							PrintSequences_FASTA (/*dataSetNum*/);
						}
					if (doPrintNEXUS == YES && doPrintFASTA == NO) /* nexus */
						{
						if (doPrintAncestralSequences == YES)
							PrintAncestralSequences_NEXUS (/*dataSetNum*/);
						else
							PrintSequences_NEXUS (/*dataSetNum*/);
						}				
	
					if (doOutMRCAfiles == YES)
						{
						PrintOutMRCAFiles(/*dataSetNum*/);
						PrintOutMRCAFiles_Conc();
						}
					}
				}
			else /* sequences from user-specified trees */
				{
				if (doCodonModel == YES)
					{
					if (doPrintFASTA == NO && doPrintNEXUS == NO) /* phylip */
						{
						if (doPrintAncestralSequences == YES)
							PrintSequences_Ancestral_UserTrees_Cod ();
						else
							PrintSequences_UserTrees_Cod ();
						}
					if (doPrintFASTA == YES && doPrintNEXUS == NO) /* fasta */
						{
						if (doPrintAncestralSequences == YES)
							PrintSequences_Ancestral_UserTrees_FASTA_Cod ();
						else
							PrintSequences_UserTrees_FASTA_Cod ();
						}
					if (doPrintNEXUS == YES && doPrintFASTA == NO) /* nexus */
						{
						if (doPrintAncestralSequences == YES)
							PrintSequences_Ancestral_UserTrees_NEXUS_Cod ();
						else
							PrintSequences_UserTrees_NEXUS_Cod ();
						}
	
					if (doOutMRCAfiles == YES)
						PrintOutMRCAFiles_userTrees_Cod ();
					}
				else if (doAAmodel == YES) /* Print from amino acid models */
					{
					if (doPrintFASTA == NO && doPrintNEXUS == NO) /* phylip */
						{
						if (doPrintAncestralSequences == YES)
							PrintSequences_Ancestral_UserTrees_AA (/*dataSetNum*/);
						else
							PrintSequences_UserTrees_AA ();
						}
					if (doPrintFASTA == YES && doPrintNEXUS == NO) /* fasta */
						{
						if (doPrintAncestralSequences == YES)
							PrintSequences_Ancestral_UserTrees_FASTA_AA ();
						else
							PrintSequences_UserTrees_FASTA_AA ();
						}
					if (doPrintNEXUS == YES && doPrintFASTA == NO) /* nexus */
						{
						if (doPrintAncestralSequences == YES)
							PrintSequences_Ancestral_UserTrees_NEXUS_AA ();
						else
							PrintSequences_UserTrees_NEXUS_AA ();
						}				

					if (doOutMRCAfiles == YES)
						PrintOutMRCAFiles_userTrees_AA ();

					}
				else /* Print from nucleotide models */
					{
					if (doPrintFASTA == NO && doPrintNEXUS == NO) /* phylip */
						{
						if (doPrintAncestralSequences == YES)
							PrintSequences_Ancestral_UserTrees (); /*PrintAncestralSequences ();*/
						else
							PrintSequences_UserTrees (); /*PrintSequences ();*/
							
						}
					if (doPrintFASTA == YES && doPrintNEXUS == NO) /* fasta */
						{
						if (doPrintAncestralSequences == YES)
							PrintSequences_Ancestral_UserTrees_FASTA ();
						else
							PrintSequences_UserTrees_FASTA ();
						}
					if (doPrintNEXUS == YES && doPrintFASTA == NO) /* nexus */
						{
						if (doPrintAncestralSequences == YES)
							PrintSequences_Ancestral_UserTrees_NEXUS ();
						else
							PrintSequences_UserTrees_NEXUS ();
						}				
	
					if (doOutMRCAfiles == YES)
						PrintOutMRCAFiles_userTrees ();
					}

				}
                
            /* fprintf (fpmpi, "\n print output files. \n\n"); */
            if (doPrintTrees == YES && doGivenUserTrees == NO)
            PrintTreesSeg(dataSetNum, indNumRE, numNuc, arrayIndBreakpointsOrd);
            if (doPrintTimes == YES && doGivenUserTrees == NO)
            PrintTimesSeg(dataSetNum, indNumRE, numNuc, arrayIndBreakpointsOrd);
            /*fprintf (fpmpi, "\n print output files 2. \n\n");*/
			/*fprintf (fpmpi, "\n Output files printed. \n\n");*/
			/**********/
			

			varEvent[dataSetNum] = numCA+numRE+numMIG+numCONV;
			#ifdef HUDSON_UNITS
				varTimeGMRCA[dataSetNum] = actualTGMRCA/(2*Nscaling*N); /* Hudson units (/2*Nscaling*N) */
			#else
				varTimeGMRCA[dataSetNum] = actualTGMRCA;
			#endif
			varTimeT[dataSetNum] = countTMRCA;
				
			if (noisy > 0)
				{
				fprintf (fpmpi, "\nData set %d",dataSetNum+1);

				if (doGivenUserTrees == NO)
					{
					fprintf (fpmpi, "\nNumber of total recombination events =  %d", numRE);
					if (doCountsForExpNumRec == YES)
						fprintf (fpmpi, "\nNumber of count recombination events =  %d", numRE - recNotToCount);
				
					if (doBlockRecombination == YES)
						{
						fprintf (stderr,"\n recombination hotspots = %d", numHotspots);

						if (numHotspots > 0)
							fprintf (stderr,": ");
						for (i=0; i<numHotspots; i++)
							fprintf (stderr, "%d ", hotspot[i]+1);
						}

					if ((numRE > 0) && (doCodonModel == YES))
						{
						fprintf (fpmpi, "\n Countable number of recombinations breaking codons           =  %d", numREbreakCod);
						fprintf (fpmpi, "\n Countable number of stop codons generated/restarted by InRec =  %d", numStopCodonREC);
					
						/*fprintf (fpmpi, "\n numEqual2           =  %d", numEqual2);
						fprintf (fpmpi, "\n numEqual1           =  %d", numEqual1);
						fprintf (fpmpi, "\n numDifCodSameAA     =  %d", numDifCodSameAA);
						fprintf (fpmpi, "\n numDifCodDifAA      =  %d", numDifCodDifAA);*/
						fprintf (fpmpi, "\n Countable number of recombinations with 0 nonsynonymous changes =  %d (%3.2f%%)", numNonSyn0, 1.00*numNonSyn0*100/numRE);
						fprintf (fpmpi, "\n Countable number of recombinations with 1 nonsynonymous changes =  %d (%3.2f%%)", numNonSyn1, 1.00*numNonSyn1*100/numRE);
						fprintf (fpmpi, "\n Countable number of recombinations with 2 nonsynonymous changes =  %d (%3.2f%%)", numNonSyn2, 1.00*numNonSyn2*100/numRE);
						/*numEqual2, numEqual1, numDifCodSameAA, numDifCodDifAA; numNonSyn*/
						}
					fprintf (fpmpi, "\nNumber of coalescence events  =  %d", numCA);
					if (doMigration == YES)
						{
						fprintf (fpmpi, "\nNumber of migration events    =  %d", numMIG);
						if (doConvergDemes == YES)
							fprintf (fpmpi, "\nNumber of convergence events  =  %d", numCONV);
						}
					}
				if (doProtStabDNAFile == NO && doProtStabAAFile == NO)
					fprintf (fpmpi, "\nNumber of substitution events =  %d", numMU);
				if (doCodonModel == YES)
					{
					fprintf (fpmpi, "\n  synonymous changes =  %d (%3.2f%%)", numMU_S, 1.00*numMU_S*100/numMU);
					fprintf (fpmpi, "\n  nonsynonymous changes =  %d (%3.2f%%)", numMU_NS, 1.00*numMU_NS*100/numMU);
					}
				if (doProtStabDNAFile == YES || doProtStabAAFile == YES)
					{
					fprintf (fpmpi, "\nNumber of introduced substitution events          =  %d", CountDNAsubsRep);
					if (doProtStabDNAFile == YES)
						fprintf (fpmpi, "\n Number of introduced nonsynonymous substitution events =  %d", CountDNAsubsNSRep);
					fprintf (fpmpi, "\nNumber of observed substitution events (branches) =  %d", numMU);
					fprintf (fpmpi, "\nNumber of mutation attempts                       =  %d", numMutationAttemptsRep);
					}
				
				if (doGivenUserTrees == NO)
					{
					if (numRE > 0)
						{
						fprintf (fpmpi, "\nTime to GMRCA                 =  %3.2f", actualTGMRCA);
						fprintf (fpmpi, "\nAverage Time to MRCA          =  %3.2f\n\n", countTMRCA);
						}
					else	
						fprintf (fpmpi, "\nTime to MRCA                  =  %3.2f\n\n", countTMRCA);
					/*fprintf (fpmpi, "\n");*/		
					}
				else
					fprintf (fpmpi, "\n\n\n");
				}
			doBadReplicate = NO; /* This is a good replicate */
			
			/* Breakpoints */
			if (doPrintBreakpoints == YES && doGivenUserTrees == NO)
				{
				fprintf (fpBreakpoints, "replicate %d:\t", dataSetNum+1);
				for (i=0; i<numRE; i++)
					fprintf (fpBreakpoints, " %d", breakpoint[i]);
				fprintf (fpBreakpoints, "\n");
				}
			/* Only when it does NOT run MPI */
			#ifndef MPI
			if (doSeparatedSequences == YES)
				fclose(fpAlignment);
			

			if (doOutMRCAfiles == YES)
				{
				if (doGivenUserTrees == NO)
					fclose (fpMRCAprint);

				fclose (fpConcMRCAprint);

				if (doCodonModel == YES && doGMRCAsamp == YES)
					{
					fclose(fpGMRCAancPrint);
					}	

				}
			

			if (doBranchNetfiles == YES && doGivenUserTrees == NO)
				fclose (fpBranchNet);
			if (doPrintOmegasPerSitefiles == YES)
				fclose (fpOmegasPerSitePrint);
			#endif
			}
		else			/* we don't want to keep this replicate */
			{
			if (noisy > 0)
				{
				fprintf (fpmpi, "\nData set discarded ");
				fprintf (fpmpi, "(rec events =  %d)\n", numRE);	
				}

			/* Only when it does NOT run MPI */
			/*#ifndef MPI
			dataSetNum--;
			#endif*/
			doBadReplicate = YES; /* This is a bad replicate, it will try again */
			if (doBranchNetfiles == YES && doGivenUserTrees == NO)
				fclose (fpBranchNet);
			}

		/* free memory */
		if (doGivenUserTrees == NO)
			{
			/*for (mmm=0; mmm<nextAvailable; mmm++)*/
			for (mmm=0; mmm<numNodes; mmm++)
				{
				free (nodes[mmm].SitesNonAncHere);
				}
			/* free (SitesNonAncHere); */
		
			free (nodex);
			free (treeRootNodex);
			free (arrayIndBreakpointsOrd);
			free (treeRootInit);
			free (segments);
			free (nodes);	
			/* free memory */		
			free (breakpoint);
			}
		free (matrix);
		if (doCodonModel == YES)
			free (matrixC);
		free (NodesMRCAposit);

		
#ifdef MPI
			fprintf(stderr, "\n--------- IN MPI ----------\n");
			if (doSeparatedSequences == NO)
				{
				fclose(fpAlignment);
				fprintf(fpmpi, "\n Sequences printed to file \"%s\"", alignmentFile);
				}
			else
				fprintf(fpmpi, "\n Sequences printed to files \"%s\"", alignmentFile);

			if (doPrintTrees == YES && doGivenUserTrees == NO)
				{
				fprintf(fpmpi, "\n Trees printed to file \"%s\"", treeFile);
				fclose(fpTrees);
				}
			if (doPrintTimes == YES && doGivenUserTrees == NO)
				{
				fprintf(stderr, "\n MPI.closing TIMES ");
				fprintf(fpmpi, "\n Times printed to file \"%s\"", timesFile);
				fclose(fpTimes);
				}
			if (doPrintBreakpoints == YES && doGivenUserTrees == NO)
				{
				fprintf(fpmpi, "\n Breakpoints printed to file \"%s\"", breakpointFile);
				fclose(fpBreakpoints);
				}
			fclose(fpScreen);
#endif

		
		} while (doBadReplicate == YES);
		/*fprintf (stderr, "\n FINAL_replicate = %d\n", dataSetNum+1);*/
		
		} /*** END OF REPLICATES ***/  // Vale para ambos (tanto como si es MPI como si no)			Ok.

#ifdef MPI

            MPI_Isend(&nada,1,MPI_INT,root,rank,comm,&request); // digo que termine
            MPI_Wait(&request,&status);

            // envio datos
		printf("%d: * envio a %d %d filas desde %d\n", rank, root, fila, rep);
   	    MPI_Send(&varEvent[rep],fila,MPI_INT,root,rank,comm);
   	    MPI_Send(&varTimeGMRCA[rep],fila,MPI_DOUBLE,root,rank,comm);
   	    MPI_Send(&varTimeT[rep],fila,MPI_DOUBLE,root,rank,comm);

	    MPI_Recv(&fila,1,MPI_INT,root,rank,comm,&status); //recibo numero de replicas

          } while (fila!=0);

	}	// END CLIENT


#endif


#ifdef MPI

// ***********************************************************************************
         else {     // SERVER
// ***********************************************************************************

          for (fila=0; fila<(lcola*(p-2)+1); fila=fila+lcola) {    // jmourino: Hay que controlar que no haya mas procesadores que rplicas			Ok.
	    printf("mando fila=%d \n",fila);
            nodo=(fila)/lcola+1;
   	    MPI_Send(&lcola,1,MPI_INT,nodo,nodo,comm); // mando numero de replicas

            MPI_Send(&fila,1,MPI_INT,nodo,nodo,comm); // mando numero de replica

            // envio datos iniciales

            MPI_Irecv(&nada, 1, MPI_INT, nodo, nodo,comm, &request);  // recepcion asincrona para cuando acabe)

            requests[nodo-1]=request;
            filas[nodo-1]=fila;
          } //for

          for (fila=((p-1)*lcola); fila<(numDataSets-lcola+1); fila=fila+lcola)  { // mientras queden replicas
 	    MPI_Waitany(p-1, requests, &indice, &status); // cuando acabe alguna 
	    printf("acabo en %d la fila %d \n",indice+1,filas[indice]);

            //recibo datos
		printf("%d: * recibo desde %d, %d filas desde %d\n", rank, indice+1, lcola, filas[indice]);
   	    MPI_Recv(&varEvent[filas[indice]],lcola,MPI_INT,indice+1,indice+1,comm,&status);
   	    MPI_Recv(&varTimeGMRCA[filas[indice]],lcola,MPI_DOUBLE,indice+1,indice+1,comm,&status);
   	    MPI_Recv(&varTimeT[filas[indice]],lcola,MPI_DOUBLE,indice+1,indice+1,comm,&status);

   	    MPI_Send(&lcola,1,MPI_INT,indice+1,indice+1,comm); // mando numero de replicas
            MPI_Send(&fila,1,MPI_INT,indice+1,indice+1,comm); // mando numero de replica
	    printf("mando fila=%d \n",fila);

            // mando datos

            MPI_Irecv(&nada, 1, MPI_INT, indice+1, indice+1, comm, &request);  // recepcion asincrona para cuando acabe
            requests[indice]=request;
            filas[indice]=fila;
          } //for

//    		R E S T O 

       resto=numDataSets-(fila);
       printf("resto=%d\n",resto);
       flag=0;
       if (resto > 0) {
	 flag=1;
         printf("resto=%d\n",resto);
	 MPI_Waitany(p-1, requests, &indice, &status); // cuando acabe alguna 
	 printf("resto: acabo en %d la fila %d \n",indice+1,filas[indice]);

            // recibo datos
		printf("%d: * recibo desde %d, %d filas desde %d\n", rank, indice+1, lcola, filas[indice]);
   	    MPI_Recv(&varEvent[filas[indice]],lcola,MPI_INT,indice+1,indice+1,comm,&status);
   	    MPI_Recv(&varTimeGMRCA[filas[indice]],lcola,MPI_DOUBLE,indice+1,indice+1,comm,&status);
   	    MPI_Recv(&varTimeT[filas[indice]],lcola,MPI_DOUBLE,indice+1,indice+1,comm,&status);


  	  MPI_Send(&resto,1,MPI_INT,indice+1,indice+1,comm); // mando resto de replicas
          MPI_Send(&fila,1,MPI_INT,indice+1,indice+1,comm); // mando numero de replica
          printf("resto: mando fila=%d \n",fila);

            // mando datos

          MPI_Irecv(&nada, 1, MPI_INT, indice+1, indice+1,comm, &request);  // recepcion asincrona para cuando acabe
          filas[indice]=fila;
          MPI_Wait(&request,&status);
 	  printf("rresto: acabo en %d la fila %d \n",indice+1,filas[indice]);
        
            // recibo datos
		printf("%d: * recibo desde %d, %d filas desde %d\n", rank, indice+1, resto, fila);
  	    MPI_Recv(&varEvent[fila],resto,MPI_INT,indice+1,indice+1,comm,&status);
   	    MPI_Recv(&varTimeGMRCA[fila],resto,MPI_DOUBLE,indice+1,indice+1,comm,&status);
   	    MPI_Recv(&varTimeT[fila],resto,MPI_DOUBLE,indice+1,indice+1,comm,&status);

  	MPI_Send(&zero,1,MPI_INT,indice+1,indice+1,comm); // mando cero para terminar
       }


//    Recojo las que quedan

          for (fila=0; fila < (p-1-flag); fila ++)  { 	// recojo los que quedan
	    MPI_Waitany(p-1, requests, &indice, &status); // cuando acabe alguna 
	    printf("acabo en %d la fila %d \n",indice+1,filas[indice]);

            // recibo datos
		printf("%d: * recibo desde %d, %d filas desde %d\n", rank, indice+1, lcola, filas[indice]);
   	    MPI_Recv(&varEvent[filas[indice]],lcola,MPI_INT,indice+1,indice+1,comm,&status);
   	    MPI_Recv(&varTimeGMRCA[filas[indice]],lcola,MPI_DOUBLE,indice+1,indice+1,comm,&status);
   	    MPI_Recv(&varTimeT[filas[indice]],lcola,MPI_DOUBLE,indice+1,indice+1,comm,&status);

    	    MPI_Send(&zero,1,MPI_INT,indice+1,indice+1,comm); // mando cero para terminar
          }

        } // END SERVER

#endif			

// ****************************************************************************
// *********************** Fin Cola de iteraciones ****************************
// ****************************************************************************


	
	/*  MPI Global variables */
		/* data average */
#ifdef MPI

int				tzeroRec;
double 			tcumNumRE, tcumNumREntc, tcumNumCA, tcumNumMU, tcumNumMIG, tcountTMRCAReps, tcounterTime, tcumNumCONV, tcumNumREbreakCod, tcumNumStopCodonREC, tcumNumEqual2, tcumNumEqual1, tcumNumDifCodSameAA, tcumNumDifCodDifAA, tcumNumNonSyn0, tcumNumNonSyn1, tcumNumNonSyn2; 


//		printf("\n%d: Valores antes: %f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f \n",rank,cumNumCA,cumNumRE,cumNumREntc,cumNumMU,cumNumMIG,zeroRec,countTMRCAReps,counterTime, cumNumCONV, cumNumREbreakCod, cumNumStopCodonREC, cumNumEqual2, cumNumEqual1, cumNumDifCodSameAA, cumNumDifCodDifAA, cumNumNonSyn0, cumNumNonSyn1, cumNumNonSyn2); 
		MPI_Reduce(&cumNumCA,&tcumNumCA,1, MPI_DOUBLE,MPI_SUM,root,comm);
		MPI_Reduce(&cumNumRE,&tcumNumRE,1, MPI_DOUBLE,MPI_SUM,root,comm);
		MPI_Reduce(&cumNumREntc,&tcumNumREntc,1, MPI_DOUBLE,MPI_SUM,root,comm); 
		MPI_Reduce(&cumNumMU,&tcumNumMU,1, MPI_DOUBLE,MPI_SUM,root,comm);
		MPI_Reduce(&cumNumMIG,&tcumNumMIG,1, MPI_DOUBLE,MPI_SUM,root,comm);
		MPI_Reduce(&cumNumCONV,&tcumNumCONV,1, MPI_DOUBLE,MPI_SUM,root,comm);
		MPI_Reduce(&cumNumREbreakCod,&tcumNumREbreakCod,1, MPI_DOUBLE,MPI_SUM,root,comm);
		MPI_Reduce(&cumNumStopCodonREC,&tcumNumStopCodonREC,1, MPI_DOUBLE,MPI_SUM,root,comm);
		MPI_Reduce(&cumNumEqual2,&tcumNumEqual2,1, MPI_DOUBLE,MPI_SUM,root,comm);
		MPI_Reduce(&cumNumEqual1,&tcumNumEqual1,1, MPI_DOUBLE,MPI_SUM,root,comm);
		MPI_Reduce(&cumNumDifCodSameAA,&tcumNumDifCodSameAA,1, MPI_DOUBLE,MPI_SUM,root,comm);
		MPI_Reduce(&cumNumDifCodDifAA,&tcumNumDifCodDifAA,1, MPI_DOUBLE,MPI_SUM,root,comm);
		MPI_Reduce(&cumNumNonSyn0,&tcumNumNonSyn0,1, MPI_DOUBLE,MPI_SUM,root,comm);
		MPI_Reduce(&cumNumNonSyn1,&tcumNumNonSyn1,1, MPI_DOUBLE,MPI_SUM,root,comm);
		MPI_Reduce(&cumNumNonSyn2,&tcumNumNonSyn2,1, MPI_DOUBLE,MPI_SUM,root,comm);
		
		MPI_Reduce(&zeroRec,&tzeroRec,1, MPI_INT,MPI_SUM,root,comm);
		MPI_Reduce(&countTMRCAReps,&tcountTMRCAReps,1, MPI_DOUBLE,MPI_SUM,root,comm);
		MPI_Reduce(&counterTime,&tcounterTime,1, MPI_DOUBLE,MPI_SUM,root,comm);

		if (rank==root) {
			cumNumCA = tcumNumCA;
			cumNumRE = tcumNumRE;
			cumNumREntc = tcumNumREntc; 
			cumNumMU = tcumNumMU;
			cumNumMIG = tcumNumMIG;
			cumNumCONV = tcumNumCONV;
			cumNumREbreakCod = tcumNumREbreakCod;
			cumNumStopCodonREC = tcumNumStopCodonREC;
			cumNumEqual2 = tcumNumEqual2;
			cumNumEqual1 = tcumNumEqual1;
			cumNumDifCodSameAA = tcumNumDifCodSameAA;
			cumNumDifCodDifAA = tcumNumDifCodDifAA;
			cumNumNonSyn0 = tcumNumNonSyn0;
			cumNumNonSyn1 = tcumNumNonSyn1;
			cumNumNonSyn2 = tcumNumNonSyn2;
			zeroRec = tzeroRec;
			countTMRCAReps = tcountTMRCAReps;
			counterTime = tcounterTime;

		}
	
//	printf("\n%d: Valores despues: %f,%f,%f,%f,%d,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f \n",rank,cumNumCA,cumNumRE,cumNumREntc,cumNumMU,cumNumMIG,zeroRec,countTMRCAReps,counterTime,cumNumCONV, cumNumREbreakCod, cumNumStopCodonREC, cumNumEqual2, cumNumEqual1, cumNumDifCodSameAA, cumNumDifCodDifAA, cumNumNonSyn0, cumNumNonSyn1, cumNumNonSyn2); 
#endif		

		
//		for (i = 0; i < numDataSets; i++)
//			{
//		printf("\n%d: Vectores: %d, %f,%f\n",varEvent[i],varTimeGMRCA[i],varTimeT[i] );
//			varEvent[i] = 0;
//			varTimeGMRCA[i] = 0.0;
//			varTimeT[i] = 0.0;
//			}
		
		
				
		meanNumRE = cumNumRE / numDataSets;				
		meanNumREtc = (cumNumRE - cumNumREntc) / numDataSets;
		meanC01  = cumC01 /  numDataSets;
		meanNumREblock  = cumNumREblock / numDataSets;
		meanNumHotspots = cumNumHotspots / numDataSets;
		meanNumCA = cumNumCA / numDataSets;
		meanNumMU = cumNumMU / numDataSets;
		meanNumMU_S = cumNumMU_S / numDataSets;
		meanNumMU_NS = cumNumMU_NS / numDataSets;

		if (doMigration == YES)
			{
			meanNumMIG = cumNumMIG / numDataSets;
			if (doConvergDemes == YES)
				meanNumCONV = cumNumCONV / numDataSets;
			}
		meanNumREbreakCod = cumNumREbreakCod / numDataSets;
		meanNumStopCodonREC = cumNumStopCodonREC / numDataSets;		
		meanNumEqual2 = cumNumEqual2 / numDataSets;	
		meanNumEqual1 = cumNumEqual1 / numDataSets;
		meanNumDifCodSameAA = cumNumDifCodSameAA / numDataSets;
		meanNumDifCodDifAA = cumNumDifCodDifAA / numDataSets;
		meanNumNonSyn0 = cumNumNonSyn0 /numDataSets;
		meanNumNonSyn1 = cumNumNonSyn1 /numDataSets;
		meanNumNonSyn2 = cumNumNonSyn2 /numDataSets;
		meanMutationAttempts = cumMutationAttempts /numDataSets;

		varNumRE = (1.0 / (double) (numDataSets-1)) * (cumNumRESq - pow(cumNumRE,2) / (double) numDataSets);
		varNumREtc = (1.0 / (double) (numDataSets-1)) * (cumNumREtcSq - pow(cumNumREtc,2) / (double) numDataSets);
		varC01 = (1.0 / (double) (numDataSets-1)) * (cumC01Sq - pow(cumC01,2) / (double) numDataSets);
		varNumREblock = (1.0 / (double) (numDataSets-1)) * (cumNumREblockSq - pow(cumNumREblock,2) / (double) numDataSets);
		varNumHotspots = (1.0 / (double) (numDataSets-1)) * (cumNumHotspotsSq - pow(cumNumHotspots,2) / (double) numDataSets);
		


#ifdef MPI	 
		fprintf(stderr, "\n--------- IN MPI ----------\n");  
		if (noisy > 0)	/* De esta forma escribira la funcion para MPI por la pantalla del procesador master */
	        if (rank==root)  // jmourino: Para que solo escriba por pantalla el procesador master
				{
				if (doGivenUserTrees == NO)
					PrintRunSettings (stdout, originalSeed);		/* this function writes the value of all variables */
				else
					PrintRunSettings_userTrees (stdout, originalSeed);		/* this function writes the value of all variables */
				}
#else
		if (noisy > 0) /* De esta forma escribira la funcion para Secuencial por la pantalla de ejecucion */
			{
			if (doGivenUserTrees == NO)
				PrintRunSettings (stdout, originalSeed);		/* this function writes the value of all variables */
			else
				PrintRunSettings_userTrees (stdout, originalSeed);		/* this function writes the value of all variables */
			}
		if (doSettingsFile == YES)
			fclose(fpSettings);
#endif


#ifdef MPI													
      	if (rank==root)  // jmourino: Para que solo escriba por pantalla el procesador master			
		{
#endif
//		fprintf(stderr, "\n\n\n*** Simulations finished ***");
//		fprintf(stderr, "\n\nOutput files are in folder \"Results\":");
#ifdef MPI
		}	
#endif																														
	

	if (doMRCAFile == YES) 
		free (MRCAsequence);
	free(varEvent);
	free(varTimeGMRCA);
	free(varTimeT);
	if (doDemographics == YES)
		{
		free (Nbegin);
		free (Nend);
		free (cumDuration);
		free (periodGrowth);
		}
	if (doMigration == YES)
		{
		free (initPopulation);
		free (numNodesInitPopul);
		if (doMigRatePeriods == YES)
			{
			free (MigTbegin);
			free (periodMigrationRate);
			}
		}
	if (doCodonModel == YES)
		{
		if (doOmegaCat == YES)
			{
			free (QijOmegas);
			free (omegaVal); 
			free (omegaProb); 
			}
		if (doOmegaRateHetDisc == YES)
			{
			free (QijOmegas);
			free (gammaRates);
			free (omegaValGammaRate);
			}
		if (doVariableDnDsBranches == YES && doBBM0 == YES && BBmodelNumber == 1)
			{
			free (BBomegaVal);
			free (BBomegaProb);
			}
		}
	if (doConvergDemes == YES)
		{
		free (convDemTimes_old);
		free (deme_a_old);
		free (deme_b_old);
		}	

	if (doDatedTips == YES)
		{
		for (j=0; j<numTipDates; j++)
			{
			free (datedSample[j].member);
			}
		free (datedSample);
		}

	if (doHetVectorFile == YES)
		free (vectorHetRates);



#ifdef MPI													
      	if (rank==root)  // jmourino: Para que solo escriba por pantalla el procesador master			
	{
#endif


	/* closing files */
#ifndef MPI
		
		if (doPrintTimes == YES)
			{			
			fprintf(stderr, "\n Times printed to file \"%s\"", timesFile);
			/*fclose(fpTimes);*/
			}
		
		if (doSeparatedSequences == NO)
			{
//			fprintf(stderr, "\n Sequences printed to file \"%s\"", alignmentFile);
			fclose(fpAlignment);
			}
//		else
//			fprintf(stderr, "\n Sequences printed to files \"%s\"", alignmentFile);

		if (doPrintTrees == YES)
			{
			fprintf(stderr, "\n Trees printed to file \"%s\"", treeFile);
			fclose(fpTrees);
			}
		
		if (doPrintBreakpoints == YES && doGivenUserTrees == NO)
			{
			fprintf(stderr, "\n Breakpoints printed to file \"%s\"", breakpointFile);
			fclose(fpBreakpoints);
			}

		if (doSettingsFile == YES)
			fprintf(stderr, "\n Settings printed to file \"%s\"", settingsFile);
		if (doOutMRCAfiles == YES)
			{
			fprintf(stderr, "\n MRCAs printed to files \"%s\"", ConcMRCAfilePrint);
			if (doGivenUserTrees == NO)
				fprintf(stderr, "\n GMRCAs printed to files \"%s\"", MRCAfilePrint);

			if (doCodonModel == YES && doGMRCAsamp == YES)
				{
				fprintf(stderr, "\n GMRCAs of ancestral material were printed to files \"%s\"", GMRCAancFilePrint);
				}	
			}
		if (doBranchNetfiles == YES && doGivenUserTrees == NO)
			fprintf(stderr, "\n Branches of the network printed to files \"%s\"", networkOut);
		if (doPrintOmegasPerSitefiles == YES)
			fprintf(stderr, "\n Simulated Omegas per site printed to files \"%s\"", OmegasPerSiteFile);
		if (printPopEvolOutputFiles > 1)
			fprintf(stderr, "\n Information about the evolution by the structural protein stability substitution model printed in folder \"ProteinStability\"");
				
#endif

	/* execution time */
	secs = (double)(clock() - start) / CLOCKS_PER_SEC;
//	fprintf(stderr, "\n\n\n___________________________________________________________________");
//	fprintf(stderr, "\nTime processing: %G seconds\n", secs);
//	fprintf(stderr, "\nIf you need help type '-?' in the command line of the program\n\n");
#ifdef MPI
	}	
#endif


#ifdef MPI

// Finalizo MPI
MPI_Finalize();	 	

#endif

	return (1);
}




/***************************** ReadUntilExclusive *******************************/
/* reads until finds the stopChar but returns it to the stream */
/* Function from Mosaic code, by David Posada */
void ReadUntilExclusive (FILE *fv, char stopChar, char *what)
{
	char ch;
	
	ch=fgetc(fv);
	while (!feof(fv) && ch!=stopChar) 
		ch=fgetc(fv);

	/* return the stopChar */
	ungetc(ch,fv);

	if (feof(fv) || ch!=stopChar) 
		{
		fprintf(fperr, "%s missing", what);
		exit(0);
		}
}





/***************************** ReadTree  *********************************/
/*	Reads a tree in Newick format, rooted or unroored, binary or with
	polytomies, and with or without branch lengths */
/* Function from Mosaic code, by David Posada */
static void ReadTree (FILE *fp, Treetnode *treeRoot)
{
    int			taxonNumber, nexttnode, numDigits;
	int			i, j;
	int			digit, digit1, digit2, digit3;
	char		*temp;
	Treetnode	*p, *q;
	
	/* intialized */
	taxonNumber = -1;
	p = treeRoot + 0;
	

	treeString = AllocCharArray (MAX_LINE, "treeString");
	temp = AllocCharArray (MAX_NAME, "temp");
	
	taxonNamesAreChars = NO;
	currentTreeRoot = treeRoot;
	
	/*fprintf (stderr, "\nReading tree ... ");*/
	fgets (treeString, MAX_LINE, fp);
	if (treeString == NULL)
		{
		fprintf(fperr, "Error: Could not read tree");
		exit(0);
		}
		
	/*fprintf (stderr, "OK");
	fprintf (stderr, "\n%s", treeString);*/
	
	/*fprintf (stderr, "\nChecking tree ... ");*/
	CheckTree();
	/*fprintf (stderr, "OK");*/

	Initializetnodes (treeRoot, MAX_tnodeS);

    numSequences = 0;
    nexttnode = 0;   
    i = 0;      
    do      
        {
        if (treeString[i] == '(')
            {
            if (nexttnode == 0)
                {
                p = treeRoot + nexttnode;
                /*p.isRoot = true;*/
				nexttnode++;
                }
            else
                {
				q = treeRoot + nexttnode;
				p->child[p->numChildren++] = q;
				q->parent = p;
				p = q;
				nexttnode++;
                }
            }
        else if (treeString[i] == ')')
            {
            q = p->parent;
            p = q;     
            }
        else if (treeString[i] == ',')
            {
            q = p->parent;
            p = q;
            }
		else if (treeString[i] == ':')
	        {
	        i++;
            for (j=0; j<10; j++)
                temp[j] = ' ';
            j = 0;
	        while (treeString[i] != ',' && treeString[i] != ')' && treeString[i] != ':' && treeString[i] != ';' && treeString[i] != '(')
	        	temp[j++] = treeString[i++];
	        i--;
	        sscanf (temp, "%lf", &p->length);
			}
        else
        	/* now read taxon names*/
        	{
           if (0) /* let's read every name as a word */
            /* if (isdigit(treeString[i]) == YES)*/ /* taxon names are numbers */
            	{
	            numDigits = 0;
	            digit1 = digit2 = digit3 = 0;
	            while (treeString[i] != ',' && treeString[i] != ')' && treeString[i] != ':')
	                    {
	                    if      (treeString[i] == '0') digit = 0;
	                    else if (treeString[i] == '1') digit = 1;
	                    else if (treeString[i] == '2') digit = 2;
	                    else if (treeString[i] == '3') digit = 3;
	                    else if (treeString[i] == '4') digit = 4;
	                    else if (treeString[i] == '5') digit = 5;
	                    else if (treeString[i] == '6') digit = 6;
	                    else if (treeString[i] == '7') digit = 7;
	                    else if (treeString[i] == '8') digit = 8;
	                    else if (treeString[i] == '9') digit = 9;
	                    if      (numDigits == 0) digit1 = digit;
	                    else if (numDigits == 1) digit2 = digit;
	                    else if (numDigits == 2) digit3 = digit;
	                    numDigits++;
	                    i++;
	                    }
	            i--;
	            if (numDigits == 1)
	            	taxonNumber = digit1;
	            else if (numDigits == 2)
					taxonNumber = 10*digit1 + digit2;
	            else if (numDigits == 3)
	            	taxonNumber = 100*digit1 + 10*digit2 + digit3;
				}
			else /* taxon names are letters */
	            {
				taxonName = AllocCharArray (MAX_NAME, "taxonName");
	           	taxonNamesAreChars = YES;
	            j = 0;
	            while (treeString[i] != ',' && treeString[i] != ')' && treeString[i] != ':')
	            	taxonName[j++] = treeString[i++];
	            i--;
				}

            q = treeRoot + nexttnode;
			p->child[p->numChildren++] = q;
			q->parent = p;
			q->index = taxonNumber;
			strcpy(q->name,taxonName);
            p = q;
           	nexttnode++;
            numSequences++;
 			free (taxonName);
           }
        i++;
        } while (treeString[i] != ';');

	numtnodes = nexttnode;

	/* reallocate tree tnodes */
	treeRoot = (Treetnode *) realloc (treeRoot, numtnodes * sizeof (Treetnode));
	if (treeRoot == NULL)
		{
		/*fprintf (stderr, "Could not reallocate treeRoot (%lu bytes)", numtnodes * sizeof (Treetnode));*/
		fprintf (stderr, "Could not reallocate treeRoot");
    	exit (-2);
		}

	free (temp);
}





/***************** CheckTree *******************/
/*  Checks for an error in the input tree
	Prints message when there is an error in the
	tree and prints correct part of the tree */
/* Function from Mosaic code, by David Posada */
void CheckTree ()
{
	int		i, k;
	int		thereIsError, numLeftPar, numRightPar;
	
	thereIsError = NO;
    numLeftPar = 1;
    numRightPar = 0;
	i = 1;

	do
		{
		/*fprintf (stderr,"\n\n> Letter #i: %d // character: %c\n", i, treeString[i]);*/

		if (treeString[i] == '(')
			{
			if (treeString[i-1] != '(' && treeString[i-1] != ',')
				{
				thereIsError = YES;
				fprintf (stderr,"\nERROR1\n");
				}
			if (treeString[i+1] != '(' && isalnum(treeString[i+1]) == NO)
				{
				thereIsError = YES;
				fprintf (stderr,"\nERROR2\n");
				}
			numLeftPar++;
			}
		else if (treeString[i] == ')')
			{
			if (treeString[i-1] != ')' && isalnum(treeString[i-1]) == NO)
				{
				thereIsError = YES;
				fprintf (stderr,"\nERROR3\n");
				}
/*			if (treeString[i+1] != ')' && treeString[i+1] != ',' && treeString[i+1] != ':') */
			if (treeString[i+1] != ')' && treeString[i+1] != ',' && treeString[i+1] != ':' && treeString[i+1] != ';')
				{
				thereIsError = YES;
				fprintf (stderr,"\nERROR4\n");
				}
			if (treeString[i+1] == ';' && i == strlen(treeString)-3)
				thereIsError = NO;
			numRightPar++;
			}
		else if (treeString[i] == ',')
			{
			if (treeString[i-1] != ')' && isalnum(treeString[i-1]) == NO)
				{
				thereIsError = YES;
				fprintf (stderr,"\nERROR5\n");
				}
			if (treeString[i+1] != '(' && isalnum(treeString[i+1]) == NO)
				{
				thereIsError = YES;
				fprintf (stderr,"\nERROR6\n");
				}
			}	
		else if (treeString[i] == ':')
			{
			if (treeString[i-1] != ')' && isalnum(treeString[i-1]) == NO)
				{
				thereIsError = YES;
				fprintf (stderr,"\nERROR7\n");
				}
			if (isdigit(treeString[i+1]) == NO)
				{
				thereIsError = YES;
				fprintf (stderr,"\nERROR8\n");
				}
			}	

		if (thereIsError == YES)
			{
			fprintf (stderr,"\nERROR: There is something wrong in the tree\n");
			for (k=0; k<=i; k++)
				fprintf (stderr,"%c", treeString[k]);
			fprintf (stderr," <- HERE");	
			exit (-1);
			}
		
		i++;
	
		} while (treeString[i] != ';');

	if (numLeftPar != numRightPar)
		{
		fprintf (stderr, "Tree seems unbalanced (%d left and %d right parentheses)", numLeftPar, numRightPar);
		exit (-1);
		}
	if (strrchr(treeString, ':') == NULL)
		{
		fprintf (stderr, "Tree does not have branch lengths");
		exit (-1);
		}
}






/************************ Initializetnodes **********************/
/* Initializes tree tnodes */

void Initializetnodes (Treetnode *p, int howManytnodes)
{
	int		i, j;
	
    for (i=0; i<howManytnodes; i++)
        {
        p[i].parent = NULL;
        p[i].numChildren = 0;
		for (j=0; j<MAX_CHILDREN; j++)
			p[i].child[j] = NULL;
		p[i].index = -999;
		p[i].label = -999;
		p[i].length = 0;
		p[i].BBM0omg = 1.0;
      	p[i].name = AllocCharArray (MAX_NAME, "p[i].name");
		strcpy(p[i].name,"na");
	    }       
}




/****************** FinishTree **************************/
/*	Reindex tnodes, count tnodes to tips, 
	and initialize components */
/* Function from Mosaic code, by David Posada */
void FinishTree (Treetnode *p)
{     
    int i; 
    
    if (p != NULL)
        {
		for (i=0; i<p->numChildren; i++)
       		FinishTree (p->child[i]);
		if (p->numChildren == 0)
            {
			p->index = TiptnodeNum++;
				p->label = p->index;
			}
		else
			p->index = InttnodeNum++;
				p->label = p->index;
		}
}



/****************** Labeltnodes **************************/
/*	Label tnodes in all trees respect to the indexes in 
	the first tree */

void Labeltnodes ()
{     
	int			i, j, k;
	Treetnode	*p, *q, *rootP, *rootQ;
	
	rootP = (Treetnode *)tree[0].tnode;

	for (i=1; i<numTrees; i++)
		{
		rootQ = (Treetnode *)tree[i].tnode;
		for (j=0; j<2*numSequences; j++)
			{
			q = rootQ + j;
			if (q->numChildren == 0)
				{
				for (k=0; k<2*numSequences; k++)
					{
					p = rootP + k;
					if (p->numChildren == 0)
						{
						if (strcmp(q->name, p->name) == 0)
							q->label = p->label;
						}
					}
				}
			}
		}
}





/****************** WriteTree **************************/
/*   Output tree in parenthetical (Newick) format */
/* Function from Mosaic code, by David Posada */
void WriteTree (FILE *fp, Treetnode *p)
{
	int		i;
	
	if (p->numChildren == 0)
		{
		if (taxonNamesAreChars == YES)
			{
			fprintf (fp, "%s", p->name);
			fprintf (fp, ":%6.4f", p->length);
			}		
		else
			{
			fprintf (fp, "%d", p->index);
			fprintf (fp, ":%6.4f", p->length);
			}		
		
		}
	else
		{
		fprintf (fp, "(");
		for (i=0; i<p->numChildren; i++)
			{
			WriteTree(fp, p->child[i]);
			if (i != p->numChildren-1)
				fprintf (fp, ",");
			}
		if (p->parent != NULL)
			fprintf (fp, ")%d:%6.4f", Lab(p), p->length);
		else
			fprintf (fp, ")");
		}
}




/******************** Listtnodes ***********************/
/* Outputs a list of tnodes with times and branch lengths */

void Listtnodes (FILE *fp, int numSequences, Treetnode *root)

{
	int			i;
	Treetnode	*p;

	fprintf (fp, "\n----------------- nodes -----------------");
	fprintf (fp, "\n   class  name              index   label  length   parent   children");
	fprintf (fp, "\n---------------------------------------------------------------\n");
	
	for (i=0; i<2*numSequences; i++)
		{
		p = root + i;

		if (p->parent != NULL &&  p->numChildren > 1)
			fprintf (fp, "%8s  %-15s   %4d    %4d    %6.2lf    %4d    %s\n", "internal", p->name, Dex(p), Lab(p), p->length, Dex(p->parent), PrintChildren(p));
		else if (p->parent != NULL &&  p->numChildren == 0)
			fprintf (fp, "%8s  %-15s   %4d    %4d    %6.2lf    %4d         %s\n", "tip", p->name, Dex(p), Lab(p), p->length, Dex(p->parent), PrintChildren(p));
		else if (p->parent == NULL &&  p->numChildren > 1)
			fprintf (fp, "%8s  %-15s   %4d    %4d    %6.2lf    %4d    %s\n", "root", p->name, Dex(p), Lab(p), p->length, Dex(p->parent), PrintChildren(p));		
		}
}


/****************** PrintChildren **************************/
/* Returns a string with the index of all children of the given tnode */
/* Function from Mosaic code, by David Posada */
char  *PrintChildren (Treetnode *p)
{
	int		i;
	char	*string = AllocCharArray(MAX_CHILDREN*MAX_NAME, "string");
	char	*stringFinal = AllocCharArray(MAX_CHILDREN*MAX_NAME, "stringFinal");
			
	if (p == NULL)
		{
		sprintf (stringFinal, "-1");
		return stringFinal;
		}
	else
		{	
		for (i=0; i<p->numChildren; i++)
			{
			sprintf (string, "%d", Dex(p->child[i]));
			strcat (stringFinal, string);
			if (i != (p->numChildren)-1)
				strcat (stringFinal, ", ");
			}
		}

	free (string);
	
	return stringFinal;
}



/****************** Dex **************************/
/* Returns the index of a given tnode */

int Dex (Treetnode *p)
{
	return (p == NULL) ? -1 : p->index;
}



/****************** Lab **************************/
/* Returns the label of a given tnode */

int Lab (Treetnode *p)
{
	return (p == NULL) ? -1 : p->label;
}




/**************************** AllocCharArray ********************************/
/*	Allocates a contiguous array of characters  */

char *AllocCharArray (int length, char *name)
{
	char	*array;
	
	array =   (char*) calloc (length, sizeof (char));   
	if (array == NULL)
		{
		/*fprintf (fpmpi, "Could not allocate %s (%lu bytes)", name, length*sizeof (char));*/
		fprintf (fpmpi, "Could not allocate %s", name);
		exit (1);
		}

	return array;   
}	 








/************************* MakeCoalescenceTree ************************/
/* Builds a genealogy for each site under the coalescent with or without
 recombination and migration */ /* this function go by events */ 
 
void MakeCoalescenceTree (int numSequences, int numSites, int numNuc, int N, double recombinationRate, int numPopulations, long int *seed)
	{
	int			tt, e, c, d, i, j, w, k, a, b, aa, bb, aaa, bbb, ss, step, position, overFirst, overEnd, sss, *activeGametes, isCoalescence, whichInd, 
				whichSite, hasPassedBreakPoint,
				firstInd, secondInd, newInd, firstHalf, secondHalf, foundSuperflousNode, eventNum, numActiveGametes, 
				legalBreakpoint, cum_gi, period, isRecombination, isMigration, whichDeme, arrivedDeme, currentBigDeme, currentDemesNumber;
	int			minInit_qq, minInit_pp, maxEnd_pp, maxEnd_qq;
	int			actNumSegments, numTotalSegments, labelNodes;
	double		rateCA, rateRE, rate, rateMIG, timeRE, timeCA, timeMIG, currentTime, eventTime, probRecIndividual, timeCONV, variable1, variable2;
	TreeNode	*p, *q, *r;
	TreeSegment *s, *n, *m, *z;
	TreeNodex	*f, *g, *h;
	long int 	Gi;
	int			*gi; 
	int			*arrayIndBreakpoints, *numSegTrees, *coalVectorCountStarts, *coalVectorCountEnds;
	int			*coalEqualSegInit_p, *coalEqualSegInit_q, *coalEqualSegEnd_p, *coalEqualSegEnd_q;
	int			*initialVector_pp, *initialVector_qq, *endVector_pp, *endVector_qq;
	int			*endsVectorRec, *startsVectorRec;
	int			sizeNode, sizeNode_p, sizeNode_q, out;
	int			numActNodex, countNumTrees;
	double		ran;
	double		*cumPopulPart;
	int			many, memoryBreakp, maxSegNode;
	int			nodeValue;
	int			*cumInitPopul, *numParcialActiveGametes, *GiPartial, *ArrivedDemesOptions, *CurrentDemesState, *stud;
	double		*rateREpartial, *rateCApartial, *rateMIGpartial, *ratePartial, *cumPopulTase;
	int			currentSample, saveThis;	
	int			doBreakpBroken, LeftLess, LeftHigh, RightLess, RightHigh, LeftLess2, RightHigh2, mmm, stateHere_P, stateHere_Q, sigue, Ok_SMRCA_Codon, AncGMRCA_obtained;
	int			controlConvSTST1, summConvSTST1, controlConvSTST2, summConvSTST2, OkValue, OkValue1, OkValue2, OkValueCI, newOkValueCI;	
	double		currentMigrationRate;

	
	/* defaults */
	isCoalescence = NO;
	isRecombination = NO;
	isMigration = NO;
	minInit_qq = minInit_pp = maxEnd_pp = maxEnd_qq = newInd = whichDeme = labelNodes = ss = saveThis = 0;
	numNodex = 0;
	maxSegNode = 1;
	currentSample = -1;
	m = NULL;
	n = NULL;
	ratePartial = NULL;
	rateREpartial = NULL;
	rateCApartial = NULL;
	rateMIGpartial = NULL;
	cumPopulTase = NULL;
	GiPartial = NULL;
	numParcialActiveGametes = NULL;
	cumInitPopul = NULL;
	ArrivedDemesOptions = NULL;
	CurrentDemesState = NULL;
	numNodes = 5000;
	memoryBreakp = /*numSites*/ numNuc;
	timeCONV = 0;
	currentBigDeme = 0;
	eventTime = 0.0;
	variable1 = 0.0;
	variable2 = 0.0;
	numREbreakCod = 0;
	numStopCodonREC = 0;
	numNetLabelPrint = 0;
	doBreakpBroken = NO;
	LeftLess = LeftHigh = RightLess = RightHigh = LeftLess2 = RightHigh2 = -1;
	stateHere_P = stateHere_Q = -2;
	mmm = sigue = Ok_SMRCA_Codon = 0;
	AncGMRCA_obtained = NO;
	overFirst = overEnd = sizeNode_p = sizeNode_q = sizeNode = out = numActNodex = many = c = 0;
	controlConvSTST1 = summConvSTST1 = controlConvSTST2 = summConvSTST2 = newOkValueCI = 0;
	OkValueCI = 1;

	currentDemesNumber = numPopulations;

	/** Initial memories **/
	/*distance = numSites*2+2; is the max segments number in a node */
	if (recombinationRate == 0.00)
		distance = 1;
	else /* recombinationRate > 0 */
		{
		if (/*numSites*/numNuc < 400)
			distance = /*numSites*/numNuc*4;
		if (/*numSites*/numNuc >= 400 && /*numSites*/numNuc <= 1000)
			distance = /*numSites*/numNuc*3;
		if (/*numSites*/numNuc > 1000)
			distance = /*numSites*/numNuc*1.5;
		if (/*numSites*/numNuc > 10000)
			distance = /*numSites*/numNuc*0.5;
		if (/*numSites*/numNuc > 100000)
			distance = /*numSites*/numNuc*0.005;
		}

	/* initial segments from numSites and rec rate */
	if (recombinationRate == 0.00) 
		maxSegNode = 1;
	else /* recombinationRate > 0 */
		{
		if (/*numSites*/numNuc < 400)
			{
			if (recombinationRate <= 0.00001)
				maxSegNode = /*numSites*/numNuc*2;
			if (recombinationRate <= 0.0001 && recombinationRate > 0.00001)
				maxSegNode = /*numSites*/numNuc*4;
			if (recombinationRate > 0.0001)
				maxSegNode = /*numSites*/numNuc*5;
			}
		else if (/*numSites*/numNuc >= 400 && /*numSites*/numNuc <= 1000)
			{
			maxSegNode = /*numSites*/numNuc*3;
			if (recombinationRate <= 0.00001)
				maxSegNode = /*numSites*/numNuc*2;			
			if (/*numSites*/numNuc > 800)
				{
				if (recombinationRate <= 0.00001)
					{
					maxSegNode = /*numSites*/numNuc;
					}
				else
					{
					maxSegNode = /*numSites*/numNuc*3;
					if (recombinationRate > 0.0001)
						fprintf(fpmpi, "\nrecombination rate is very high");	
					}
				}
			}
		else if (/*numSites*/numNuc > 1000 && /*numSites*/numNuc <= 10000)  /* NEW */
			{			

			if (recombinationRate <= 0.000001)
				{
				maxSegNode = /*numSites*/numNuc*1.5; /* NEW */
				numNodes = 5000;
				}
			if (recombinationRate <= 0.00001 && recombinationRate > 0.000001)
				{
				maxSegNode = /*numSites*/numNuc*2.3; /* NEW */
				numNodes = 5000;
				}
			if (recombinationRate <= 0.0001 && recombinationRate > 0.00001)
				maxSegNode = /*numSites*/numNuc*2.5;
			if (recombinationRate > 0.0001)
				{
				maxSegNode = /*numSites*/numNuc*3;	
				fprintf(fpmpi, "\nrecombination rate is very high");
				}
			}
		else if (/*numSites*/numNuc > 10000 && /*numSites*/numNuc <= 100000) /* large seqs.1 NEW */
			{
			
			if (recombinationRate <= 0.000001)
				{
				maxSegNode = /*numSites*/numNuc*0.5; /* NEW */
				numNodes = 1000;
				}
			if (recombinationRate <= 0.00001 && recombinationRate > 0.000001)
				{
				maxSegNode = /*numSites*/numNuc*0.5; /* NEW */
				numNodes = 6500;
				}
			if (recombinationRate > 0.0001)
				{
				maxSegNode = /*numSites*/numNuc*1.0;	
				fprintf(fpmpi, "\nrecombination rate is very high");
				}
			}
		else if (/*numSites*/numNuc > 100000 && /*numSites*/numNuc <= 1000000) /* large seqs.2 NEW */
			{
			
			if (recombinationRate <= 0.000001)
				{
				maxSegNode = /*numSites*/numNuc*0.005; /* NEW */
				numNodes = 350;
				}
			if (recombinationRate <= 0.00001 && recombinationRate > 0.000001)
				{
				maxSegNode = /*numSites*/numNuc*0.5; /* NEW */
				numNodes = 5000;
				}
			if (recombinationRate > 0.0001)
				{
				maxSegNode = /*numSites*/numNuc*1.0;	
				fprintf(fpmpi, "\nrecombination rate is very high");
				}
			}
		else
			{
			if (recombinationRate <= 0.00001)
				maxSegNode = /*numSites*/numNuc;
			if (recombinationRate <= 0.0001 && recombinationRate > 0.00001)
				maxSegNode = /*numSites*/numNuc*2;
			if (recombinationRate > 0.0001)
				{
				maxSegNode = /*numSites*/numNuc*3;	
				fprintf(fpmpi, "\nrecombination rate is very high");
				}
			}
		if (N > 1000)
			{
			maxSegNode = maxSegNode*1.5;
			if (N > 10000)
				maxSegNode = maxSegNode*1.5;
			if (N > 50000)
				maxSegNode = maxSegNode*1.1;
			}
		}

	if (doMigration == YES) /* migration implies more rec events because lineages can be isolated for long times */
		{
		if (doMigrationIsland == YES)
			numNodes = numNodes * 1.5;
		if (doMigrationSTST == YES)
			numNodes = numNodes * 1.6;
		if (doMigrationIslCont == YES)
			numNodes = numNodes * 1.7;
		}


	if (numNodes <= numSequences) /* if there are more sequences than nodes in the initial step */
		numNodes = numSequences + 5000;

	numTotalSegments = (numNodes*maxSegNode)+/*numSites*/numNuc;
	/*fprintf(stderr, "\n numTotalSegments = %d \n", numTotalSegments);*/
	
	if (doMigration == YES) /* memory for migrations */
		{
		cumInitPopul = (int *)calloc((numPopulations+numConvergDemes+1),(long) sizeof(int));
		if (!cumInitPopul)
			{
			fprintf (fpmpi, "Could not allocate cumInitPopul (%lu bytes)\n", (numPopulations+numConvergDemes+1)  * (long) sizeof(int));
			exit (1);
			}
		numParcialActiveGametes = (int *) calloc((numPopulations+numConvergDemes+1),(long) sizeof(int));
		if (!numParcialActiveGametes)
			{
			fprintf (fpmpi, "Could not allocate numParcialActiveGametes (%lu bytes)\n", (numPopulations+numConvergDemes+1)  * (long) sizeof(int));
			exit (1);
			}
			
		GiPartial = (int *)calloc((numPopulations+numConvergDemes+1),(long) sizeof(int));
		if (!GiPartial)
			{
			fprintf (fpmpi, "Could not allocate GiPartial (%lu bytes)\n", (numPopulations+numConvergDemes+1)  * (long) sizeof(int));
			exit (1);
			}
		
		cumPopulTase =  (double*) calloc ((numPopulations+numConvergDemes+1), sizeof (double));  
		if (cumPopulTase == NULL)
			{
			fprintf (fpmpi, "Could not allocate cumPopulTase (%lu bytes)", (numPopulations+numConvergDemes+1)  * (long) sizeof(int));
			exit(1);
			}
		rateREpartial =  (double*) calloc ((numPopulations+numConvergDemes+1), sizeof (double));  
		if (rateREpartial == NULL)
			{
			fprintf (fpmpi, "Could not allocate rateREpartial (%lu bytes)", (numPopulations+numConvergDemes+1) * (long) sizeof (double));
			exit(1);
			}
		rateCApartial =  (double*) calloc ((numPopulations+numConvergDemes+1), sizeof (double));  
		if (rateCApartial == NULL)
			{
			fprintf (fpmpi, "Could not allocate rateCApartial (%lu bytes)", (numPopulations+numConvergDemes+1) * (long) sizeof (double));
			exit(1);
			}
		rateMIGpartial =  (double*) calloc ((numPopulations+numConvergDemes+1), sizeof (double));  
		if (rateMIGpartial == NULL)
			{
			fprintf (fpmpi, "Could not allocate rateMIGpartial (%lu bytes)", (numPopulations+numConvergDemes+1) * (long) sizeof (double));
			exit(1);
			}
		ratePartial =  (double*) calloc ((numPopulations+numConvergDemes+1), sizeof (double));  
		if (ratePartial == NULL)
			{
			fprintf (fpmpi, "Could not allocate ratePartial (%lu bytes)", (numPopulations+numConvergDemes+1) * (long) sizeof (double));
			exit(1);
			}
	
		for (i = 0; i < numPopulations+numConvergDemes+1; i++)
			{
			rateREpartial[i] = 0.00;
			rateCApartial[i] = 0.00;
			rateMIGpartial[i] = 0.00;
			ratePartial[i] = 0.00;
			cumPopulTase[i] = 0.00;
			cumInitPopul[i] = 0.00;
			numParcialActiveGametes[i] = 0.00;
			GiPartial[i] = 0.00;
			}
		}
		
	/* allocate space for tree */


	segments = (TreeSegment *) calloc (numTotalSegments, sizeof(TreeSegment)); /* segments */
	if (!segments)
		{
		fprintf (fpmpi, "Could not allocate segments (%lu bytes)\n", numTotalSegments  * (long) sizeof(TreeSegment));
		fprintf (fpmpi, "\n Too much memory is required, try again by less recombinationRate or less numSites or less numSequences.\n");			
		exit (1);
		}
		
	nodes = (TreeNode *) calloc (numNodes, sizeof(TreeNode)); /* nodes */
	if (!nodes)
		{
		fprintf (fpmpi, "Could not allocate nodes (%lu bytes)\n", numNodes  * (long) sizeof(TreeNode));
		exit (1);
		}
	
	
	
	for (mmm=0; mmm<numNodes; mmm++)
		{
		/*printf("\n   Allocating node %d", mmm+1);*/
		nodes[mmm].SitesNonAncHere = (int *) calloc (numNuc+1, sizeof(int));
		if (!nodes[mmm].SitesNonAncHere)
			{
			fprintf (fpmpi, "Could not allocate nodes[mmm].SitesNonAncHere (%lu)\n", (numNuc+1) * (long) sizeof(int));
			exit (1);
			}
		/*printf("\n      allocated %d units for node %d", (numNuc+1), mmm+1);*/
		}
	/*printf("\nFinished allocating nodes...\n");*/



	activeGametes = (int *) calloc (numNodes,(long) sizeof(int)); /* active nodes */
	if (!activeGametes)
		{
		fprintf (fpmpi, "Could not allocate activeGametes (%lu bytes)\n", numNodes *(long) sizeof(int));
		exit (1);
		}
		
	treeRootInit = (TreeNode **) calloc(1, sizeof(TreeNode *)); /* nodes pointers */
	if (!treeRootInit)
		{
		fprintf (fpmpi, "Could not allocate treeRootInit (%lu bytes)\n", 1  * (long) sizeof(TreeNode));
		exit (1);
		}
	stud = (int *)calloc(numSites,(long) sizeof(int));
	if (!stud)
		{			
		fprintf (fpmpi, "Could not allocate stud (%lu bytes)\n", numSites * (long) sizeof(int));
		exit (1);
		}
	for (w = 1; w < numSites; w++) 
		stud[w-1] = w*3+1; 	/* The breakpoints between codons. "stud" is an array with the possible breakpoints beetween codons*/



	
	/* allocate space for S_MRCA vector = [n1, n2, ..., ni,...nk] 
   	where n is the number of sequences and k is the number of sites
   	When an element of MRCS reaches 1, means that the site i found its MRCA */
	/* The MRCA vector has got the number of coalescences n, when 1 coalescence happen n=n-1. In the last coalescent n<=1, we are in the MRCA */
	S_MRCA = (int *) calloc((numNuc+1),(long) sizeof(int));
	if (!S_MRCA)
		{
		fprintf (fpmpi, "Could not allocate S_MRCA (%lu bytes)\n", (numNuc+1) *(long) sizeof(int));
		exit (-1);
		}
	OnlyAncS_MRCA = (int *) calloc((numNuc+1),(long) sizeof(int));
	if (!OnlyAncS_MRCA)
		{
		fprintf (fpmpi, "Could not allocate OnlyAncS_MRCA (%lu bytes)\n", (numNuc+1) *(long) sizeof(int));
		exit (-1);
		}


	/* allocate space for recombination breakpoints */
	breakpoint = (int *) calloc(memoryBreakp,(long) sizeof(int));
	if (!breakpoint)
		{
		fprintf (fpmpi, "Could not allocate breakpoint (%lu bytes)\n", memoryBreakp*(long) sizeof(int));
		exit (-1);
		}

	/* set everything to null */
	for (i=0; i<numNodes; i++)
		{
		nodes[i].left = NULL;
		nodes[i].right = NULL;
		nodes[i].anc1 = NULL;
		nodes[i].anc2 = NULL;
		nodes[i].outgroup = NULL;
		nodes[i].sib = NULL;
		nodes[i].time = 0;
		nodes[i].length = 0;
		nodes[i].BBM0omg = 1.0;
		nodes[i].index = 0;
		nodes[i].indexOldMigPop = 0;
		nodes[i].indexCurrentMigPop = 0;
		nodes[i].numSegNode = 0;
		nodes[i].label = 0;
		nodes[i].isOutgroup = NO;
		nodes[i].class = 0;
		nodes[i].breakp = NO;
		nodes[i].passNumber = 0;
		nodes[i].breakCodon = NO;
		nodes[i].breakCodon = 0;
		nodes[i].NetLabelPrint = 0;
		nodes[i].MRCAfrom = -1;
		nodes[i].MRCAto = -1;
		nodes[i].GMRCA_ancestral = NO;
		for (mmm=0; mmm<=numNuc; mmm++)
			nodes[i].SitesNonAncHere[mmm] = 0;
		}


	/* set times in generation for dated tips; the latest sample will be generation 0 */		
	if (doDatedTips == YES)
		{
		/* NEW */
		numActiveGametes = 0;
		actNumSegments = 0;

		if (doMigration == YES)
			{
			if (noisy > 1)
				fprintf (fpmpi,"\n Initial relation nodes-demes:");

			for (i = 1; i <= numPopulations; i++)
				{
				cumInitPopul[i] = cumInitPopul[i-1] + numNodesInitPopul[i];
				/*numParcialActiveGametes[i] = numNodesInitPopul[i];*/ /* do not active here */
				numParcialActiveGametes[i] = 0;
				/*fprintf (fpmpi,"\n cumInitPopul[i]: %d", cumInitPopul[i]);*/
				/*fprintf (fpmpi,"\n numParcialActiveGametes[i]: %d", numParcialActiveGametes[i]);*/
				}
			}

		for (j = 0; j < numSequences; j++)		
			{
			p = nodes + j;
			/*fprintf (stderr, "\n >> nodes + %d", j);*/
			/*activeGametes[numActiveGametes] = j;*/ /* do not active here */
			p->index = j;
			p->label = j;
			p->NetLabelPrint = numNetLabelPrint;
			/*fprintf (fpmpi,"\n numNetLabelPrint = %d", numNetLabelPrint);*/
			numNetLabelPrint++;		
			labelNodes = j;
			p->class = 1;
			p->GMRCA_ancestral = NO;
			p->numSegNode = 1;				/* initial, each node contain 1 segment */
			/*fprintf (fpmpi,"\n TIP, The node %d with class %d", p->index, p->class);*/
			
			if (doMigration == YES) /* initial nodes - populations */
				{
				if ((j+1) <= cumInitPopul[1])
					{
					p->indexOldMigPop = 1;
					p->indexCurrentMigPop = 1;
					}
				else
					{
					for (k = 1; k <= numPopulations; k++)
						{
						if ((j+1) > cumInitPopul[k] && (j+1) <= cumInitPopul[k+1])
							{
							p->indexOldMigPop = k+1;
							p->indexCurrentMigPop = k+1;
							break;
							}
						}
					k = 0;
					}
				if (noisy > 1)
					fprintf (fpmpi,"\n > The node %d belongs to deme %d", p->index, p->indexOldMigPop);
				}
			
			for (mmm=1; mmm<=numNuc; mmm++)
				p->SitesNonAncHere[mmm] = 0;

			for (i = 0; i < p->numSegNode; i++) /* segments of the tip */
				{
				s = segments + post(i,j,distance);	
				s->before1 = NULL;
				s->before2 = NULL;
				s->after1 = NULL;
				s->after2 = NULL;			
				s->sIndexNode = j;
				s->sIndex = actSegIndex;
				s->sStart = 1;
				s->sEnd = numNuc;
				
				actSegIndex++;
				}
			/*numActiveGametes++;*/ /* do not active here */
			}
		labelNodes++;
		/*nextAvailable = numActiveGametes;*/ /* do not active here */
		actNumSegments = numSequences;
		/* end NEW */

		for (i=0; i<numTipDates; i++)
			{
			for (j=0; j<datedSample[i].size; j++)
				{
				p = nodes + datedSample[i].member[j]-1;
				p->time =  datedSample[i].time;

				/*fprintf (stderr, "\n > nodes + %d", datedSample[i].member[j]-1);*/
				/*for (k=0; k<numSites; k++)
					{
					p = nodes + pos(datedSample[i].member[j]-1,k,numSites);
					p->time =  datedSample[i].time; 
					}*/ 	/* to get generations back (assumes generation time and sampling times are in the same unit, e.g., years) */
				}
			}
		/*debug */
		if (noisy > 1)
			fprintf (stderr, "\nTime Tips:");
		for (j=0; j<numSequences; j++)
			{
			p = nodes + j;
			if (noisy > 1)
				fprintf (stderr, "\n => node %d, sampling time %f", j, p->time);
			/*for (k=0; k<3; k++)
				{
				p = nodes + pos(j,k,numSites);
				fprintf (stderr, "\n%d =>seq %d, site %d, sampling time %f", p, j+1, k+1, p->time);
				}*/
			
			/* check - Fix only converge demes respect to tip dates (with less time than the time of the convergence of deme) s*/
			if (doConvergDemes == YES) 
				{
				ss=0;
				for (ss=1; ss<=numConvergDemes; ss++)
					{
					if (convDemTimes_old[ss] <= p->time)
						{
						fprintf (fpmpi,"\n\n Warning. Tip dates AND Convergence of demes.\n The time of any tip date (%f) cannot be higher than the time of the convergence of demes (%f)", p->time, convDemTimes_old[ss]);
						PrintUsage();
						}
					
					}
				ss=0;
				}
			}				
		}

			
		


	/* set up MRCA vector */
	for (i = 0; i <= numNuc; i++)
		{
		S_MRCA[i] = numSequences; /* MRCA[i] = numSequences; example initial values: MRCA[0] = 10, MRCA[1] = 10, MRCA[2] = 10 .. */
		OnlyAncS_MRCA[i] = numSequences; /* MRCA[i] = numSequences; example initial values: MRCA[0] = 10, MRCA[1] = 10, MRCA[2] = 10 .. */
		}
		



	/* tip of the trees */ /* set up initial nodes */
	if (doDatedTips == YES) /** active oldest sample for dated tips **/
		{
		currentSample = numTipDates - 1;
		if (noisy > 2)
			fprintf (stderr, "\nActivating initial sample %d (with time = %6.4f):", currentSample,datedSample[currentSample].time);

		numActiveGametes = 0;

		for (j=0; j<datedSample[currentSample].size; j++)
			{
			if (noisy > 2)
				fprintf (stderr, " %d", datedSample[currentSample].member[j]-1);

			/*fprintf (stderr, "\n > Activated nodes + %d \n", datedSample[currentSample].member[j]-1);*/
			p = nodes + datedSample[currentSample].member[j]-1;
			p->index = datedSample[currentSample].member[j]-1;
			activeGametes[numActiveGametes] = datedSample[currentSample].member[j]-1; 
			numActiveGametes++;
			
			if (doMigration == YES)
				{			
				for (i = 1; i <= numPopulations; i++) 
					{
					if (p->indexOldMigPop == i)
						{
						numParcialActiveGametes[i]++;
						}
					}
				}
			}
		nextAvailable = numSequences;  /* to keep the indexes 1 to numSequences for tips */
		if (doMigration == YES && noisy > 2)
			{
			fprintf (fpmpi,"\nInitial demes (with time = %6.4f): \n", datedSample[currentSample].time);			
			for (i = 1; i <= numPopulations; i++) 
				fprintf (fpmpi," Deme %d with %d nodes\n", i, numParcialActiveGametes[i]);
			}
		/*labelNodes++;
		actNumSegments = numActiveGametes-1;*/
		}	
	else /** Here, not tip dates **/
		{
		numActiveGametes = 0;
		actNumSegments = 0;
		
		if (doMigration == YES)
			{
			for (i = 1; i <= numPopulations; i++)
				{
				cumInitPopul[i] = cumInitPopul[i-1] + numNodesInitPopul[i];
				numParcialActiveGametes[i] = numNodesInitPopul[i];
				/*fprintf (fpmpi,"\n numParcialActiveGametes[i]: %d \n", numParcialActiveGametes[i]);*/
				}
			if (noisy > 1)
				fprintf (fpmpi,"\n Initial relation nodes-demes:");
			}
	
		for (j = 0; j < numSequences; j++)		
			{
			p = nodes + j;
			activeGametes[numActiveGametes] = j;
			p->index = j;
			p->label = j;
		
			p->NetLabelPrint = numNetLabelPrint;
			/*fprintf (fpmpi,"\n numNetLabelPrint = %d", numNetLabelPrint);*/
			numNetLabelPrint++;		

			labelNodes = j;
			p->class = 1;
			p->GMRCA_ancestral = NO;
		
			p->numSegNode = 1;				/* initial, each node contain 1 segment */
			if (doMigration == YES) /* initial nodes - populations */
				{
				if ((j+1) <= cumInitPopul[1])
					{
					p->indexOldMigPop = 1;
					p->indexCurrentMigPop = 1;
					}
				else
					{
					for (k = 1; k <= numPopulations; k++)
						{
						if ((j+1) > cumInitPopul[k] && (j+1) <= cumInitPopul[k+1])
							{
							p->indexOldMigPop = k+1;
							p->indexCurrentMigPop = k+1;
							break;
							}
						}
					k = 0;
					}
				if (noisy > 1)
					fprintf (fpmpi,"\n > The node %d belongs to deme %d", p->index, p->indexOldMigPop);
				
				for (mmm=1; mmm<=numNuc; mmm++)
					p->SitesNonAncHere[mmm] = 0;
				}

			/*fprintf (fpmpi,"\n TIP, The node %d with class %d", p->index, p->class);*/

			for (i = 0; i < p->numSegNode; i++) /* segments of the tip */
				{
				s = segments + post(i,j,distance);	
				s->before1 = NULL;
				s->before2 = NULL;
				s->after1 = NULL;
				s->after2 = NULL;			
				s->sIndexNode = j;
				s->sIndex = actSegIndex;
				s->sStart = 1;
				s->sEnd = numNuc;
				
				actSegIndex++;
				}
			numActiveGametes++;
			}
	
		labelNodes++;
		nextAvailable = numActiveGametes;
		actNumSegments = numSequences;
		}
	

	if (doDatedTips == YES)
		{
		if (noisy > 2)
			{
			fprintf (stderr, "\nActive nodes (%d):", numActiveGametes); 
			for (i=0; i<numActiveGametes; i++)
				fprintf (stderr," %d",activeGametes[i]);
			fprintf (stderr,"   Next node available = %d ", nextAvailable);
			}
		if (noisy > 2)
			{			
			fprintf (fpmpi, "\n\n Initial MRCA in the nodes:\n");
			for (i=0; i<numActiveGametes; i++)
				{
				for (j=1; j<=numNuc; j++)
					{
					p = nodes + activeGametes[i];
					/*p = nodes + pos(activeGametes[i],j,numNuc);*/
					if (j == 1)
						fprintf (fpmpi, "%4d -- (MRCA:)", p->index);
					fprintf (fpmpi, "%d", S_MRCA[j]);
					}
				fprintf (fpmpi, "\n");
				}
			}	
		}
	else
		{
		/* print out ancestral (active) status for each site */
		if (noisy > 2)
			{			
			fprintf (fpmpi, "\n\n Initial MRCA in the nodes:\n");
			for (i=0; i<numActiveGametes; i++)
				{
				for (j=1; j<=numNuc; j++)
					{
					p = nodes + activeGametes[i];
					/*p = nodes + pos(activeGametes[i],j,numNuc);*/
					if (j == 1)
						fprintf (fpmpi, "%4d -- (MRCA:)", p->index);
					fprintf (fpmpi, "%d", S_MRCA[j]);
					}
				fprintf (fpmpi, "\n");
				}
			}	
		}




	/*** make coalescence tree ***/	
	if (doMigration == YES) /* Coalescence with migration */
		{		
		eventNum = 0;		
		currentTime = 0.0;
		period = 1;
		
		if (doConvergDemes == YES) /* these arrays are for the convergence demes events */
			{
			deme_a = (int *) calloc(numConvergDemes+1,(long) sizeof(int));
			if (!deme_a)
				{
				fprintf (stderr, "PARAMETER ERROR: Could not allocate deme_a of convergencies demes events (%lu bytes)\n", (numConvergDemes+1) *(long) sizeof(int));
				exit (1);
				}
			deme_b = (int *) calloc(numConvergDemes+1,(long) sizeof(int));
			if (!deme_b)
				{
				fprintf (stderr, "PARAMETER ERROR: Could not allocate deme_b of convergencies demes events (%lu bytes)\n", (numConvergDemes+1) *(long) sizeof(int));
				exit (1);
				}
			convDemTimes = (double*) calloc ((numConvergDemes+1), sizeof (double)); 
			if (convDemTimes == NULL)
				{
				fprintf (stderr, "PARAMETER ERROR: Could not allocate convDemTimes of convergencies demes events (%lu bytes)\n", (numConvergDemes+1) *(long) sizeof(double));
				exit (1);
				}
			currentConvDem = (int *) calloc(numConvergDemes+1,(long) sizeof(int));
			if (!currentConvDem)
				{
				fprintf (stderr, "PARAMETER ERROR: Could not allocate currentConvDem of convergencies demes events (%lu bytes)\n", (numConvergDemes+1) *(long) sizeof(int));
				exit (1);
				}
			CurrentDemesState = (int *)calloc((2*numPopulations),(long) sizeof(int));
			if (!CurrentDemesState)
				{
				fprintf (fpmpi, "Could not allocate CurrentDemesState (%lu bytes)\n", (2*numPopulations)  * (long) sizeof(int));
				exit (1);
				}
			for (k = 1; k <= 2*numPopulations-1; k++)
				CurrentDemesState[k] = 0;
			CurrentDemesState[0] = 0;
			for (k = 1; k <= numPopulations; k++)
				CurrentDemesState[k] = k;
			for (k=1; k<=numConvergDemes; k++)
				{
				deme_a[k] = deme_a_old[k];
				deme_b[k] = deme_b_old[k];
				convDemTimes[k] = convDemTimes_old[k];
				/*fprintf(stderr, "\n\n deme_a[%d] = %d \n", k, deme_a[k]);
				fprintf(stderr, "\n\n deme_b[%d] = %d \n", k, deme_b[k]);
				fprintf(stderr, "\n\n convDemTimes[%d] = %lf \n", k, convDemTimes[k]);*/
				}
			k = 0;
			}

		while (numActiveGametes > 1)
			{
			/* print out MRCA vector */
			/*if (noisy == 8)
				{	
				fprintf(stderr,"S_MRCA [] = ");
				for (j=1; j<=numNuc; j++)
					fprintf (stderr,"%d ", S_MRCA[j]);
				fprintf(stderr,"\n");
				}*/

			/*for (i = 1; i <= 2*numPopulations-1; i++)
				fprintf (fpmpi,"\n CurrentDemesState[%d] = %d\n", i, CurrentDemesState[i]);*/  /* to see the active demes */

			Gi = 0;
			/* allocate memory for each node gi */
			gi = (int *) calloc(numActiveGametes,(long) sizeof(int));
			if (!gi)
				{
				fprintf (fpmpi, "Could not allocate gi (%lu bytes)\n", numActiveGametes *(long) sizeof(int));	
				exit (-1);
				}
			/* calculate gi for each node and total Gi */	
			/* Gi is the total number of ancestral sites, gi is a vector with ancestral and not found MRCA sites */
		
			for (i = 0; i < numActiveGametes; i++)
				{
				p = nodes + activeGametes[i];
				sizeNode = p->numSegNode;
				gi[i] = CalcIndividualGi (i, nodes, activeGametes, numNuc, S_MRCA, sizeNode);
				Gi += gi[i];
				if (noisy == 4)
					fprintf (fpmpi,"\n%d \n", gi[i]);
				}	
			if (noisy == 4)
				fprintf (fpmpi," Gi = %lu ", Gi);
			for (k = 1; k <= numPopulations+currentBigDeme; k++)
				GiPartial[k] = 0;
			
			if (noisy == 4)
				fprintf (fpmpi, "\n");
			for (i = 0; i < numActiveGametes; i++)
				{
				p = nodes + activeGametes[i];
				for (j = 1; j <= numPopulations+currentBigDeme; j++)
					{
					if (p->indexCurrentMigPop == j)
						GiPartial[j] = GiPartial[j] + gi[i];
					}
				if (noisy > 2)
					fprintf (fpmpi, " \nNode %d of deme %d", p->index, p->indexCurrentMigPop);
				}

			

			if (doMigRatePeriods == YES) /* variable migration rate with time */ 
				{
				currentMigrationRate = -1.0;				

				for (i = 1; i <= numMigRatePeriods-1; i++) /* [t1 0.001] [t2 100 0.001 0.005] [t3 100 1000 0.001 0.005 0.001] */
					{
					if (currentTime < MigTbegin[i])
						{
						currentMigrationRate = periodMigrationRate[i];
						break;
						}
					}

				if (currentMigrationRate == -1.0)
					currentMigrationRate = periodMigrationRate[numMigRatePeriods];
				
				if (noisy == 3)
					fprintf (fpmpi, "\nCurrent migration rate = %lf", currentMigrationRate);
				}
			else /* migration rate is constant with time */
				currentMigrationRate = migrationRate; 
			
			/*fprintf (fpmpi, " \n\n PROOF variable Mig rate: currentTime = %lf, currentMigrationRate = %lf", currentTime, currentMigrationRate);*/






			if (noisy == 3)
				fprintf (fpmpi, "\n");			

			/* get rates for events */  
			rateRE = rateCA = rateMIG = rate = 0;
			for (i = 1; i <= numPopulations+currentBigDeme; i++)
				{
				rateREpartial[i] = (double) GiPartial[i] * (double) Nscaling * (double) N * recombinationRate;
				rateRE = rateRE + rateREpartial[i];
				/*fprintf (fpmpi, " \nrateREpartial[%d] = %lf", i, rateREpartial[i]);*/

				rateCApartial[i] = (double) numParcialActiveGametes[i] * ((double) numParcialActiveGametes[i] - 1) / 2.0;
				rateCA = rateCA + rateCApartial[i];
				/*fprintf (fpmpi, " \nrateCApartial[%d] = %lf", i, rateCApartial[i]);*/
				
				rateMIGpartial[i] = 0.00;
				rateMIGpartial[i] = (double) numParcialActiveGametes[i] * (double) Nscaling * (double) N * currentMigrationRate;
				/*fprintf (fpmpi, " \n numParcialActiveGametes[i] = %d, Nscaling = %d, N = %d, currentMigrationRate = %lf", numParcialActiveGametes[i], Nscaling, N, currentMigrationRate);*/
				if (doConvergDemes == YES && currentDemesNumber <= 1)  /* No more migrations because there is only one deme */
					rateMIGpartial[i] = 0.00;
				rateMIG = rateMIG + rateMIGpartial[i];
				/*fprintf (fpmpi, " \nnumParcialActiveGametes[%d] = %d", i, numParcialActiveGametes[i]);
				fprintf (fpmpi, " \nrateMIGpartial [%d] = %lf", i, rateMIGpartial[i]);*/

				ratePartial[i] = rateREpartial[i] + rateCApartial[i] + rateMIGpartial[i];
				rate = rate + ratePartial[i];
				}
			rate = rateRE + rateCA + rateMIG;
			/* find out time for coalescence */
			if (doDemographics == YES)
				{
				periodGrowth[period] = -log (Nend[period] / (double) Nbegin[period]) / (double) (cumDuration[period] - cumDuration[period-1]);
				/*fprintf (fpmpi, "\n>>>>1 period growth  = %f (period = %d)", periodGrowth[period], period);*/
				if (isnan(periodGrowth[period]) == YES)
					{						
					fprintf (fpmpi, "\nERROR: period growth (%f) is NaN", periodGrowth[period]);
					fprintf (fpmpi, "\n      This might suggest that the growth rate is too negative");
					fprintf (fpmpi, "\n      and the coalescent time is therefore infinite.");
					fprintf (fpmpi, "\n      Try a smaller value");				
					exit (1);
					}

				if (Nend[period] == Nbegin[period])
					{
					timeCA = RandomExponential (rateCA, seed) * Nscaling * (double) Nbegin[period];
					}
				else
					{
					timeCA = log (1 + RandomExponential (rateCA, seed) * periodGrowth[period] * Nscaling * Nbegin[period] * 
			               exp (-periodGrowth[period] * (currentTime - cumDuration[period-1]))) / periodGrowth[period];
					}

				/*	When growth rate is very negative, coalescent time may be infinite
					this results in log (-x) => timCA = NaN. If this not the last period
					just jump to the next. If this is the last period, we have to exit
					the program */
				if (isnan(timeCA) == YES)
					{
					if (period < numPeriods) 
						{
						currentTime = cumDuration[period];
						period++;
						periodGrowth[period] = -log (Nend[period] / (double) Nbegin[period]) / (double) (cumDuration[period] - cumDuration[period-1]);
						continue;
						}
					else
						{
						fprintf (fpmpi, "\nERROR: Coalescent time (%f) is infinite ", timeCA);
						fprintf (fpmpi, "\n      This might suggest that the growth rate is too negative");
						fprintf (fpmpi, "\n      and the coalescent time is therefore infinite.");
						fprintf (fpmpi, "\n      Try a smaller value");
						exit (1);
						}
					}
				}
			else
				{
				timeCA = RandomExponential (rateCA, seed) * Nscaling * N;
				if (doExponential == YES)
					{
					timeCA = log (exp(growthRate*currentTime) + growthRate * timeCA) / growthRate - currentTime;
		
					/*	When growth rate is very negative, coalescent time may be infinite
						this results in log (-x) => timeCA = NaN. We have to exit
						the program */
					if (isnan(timeCA) == YES)
						{				
						fprintf (fpmpi, "\nERROR: Coalescent time (%f) is infinite ", timeCA);
						fprintf (fpmpi, "\n      This might suggest that the growth rate is too negative");
						fprintf (fpmpi, "\n      and the coalescent time is therefore infinite.");
						fprintf (fpmpi, "\n      Try a smaller value");
						exit (1);
						}
					}
				}

			/* find out time for recombination */
			timeRE = RandomExponential (rateRE, seed) * Nscaling * N; /* It doesn't depend of demographics because the node doesnt depend of another node to make this event */
			/* find out time for migration */
			timeMIG = RandomExponential (rateMIG, seed) * Nscaling * N; /* It doesn't depend of demographics because the node doesnt depend of another node to make this event */
			/*fprintf (fpmpi, " \ntimeMIG = %lf, rateMIG = %lf, Nscaling = %d, N = %d, RandExp = %lf", timeMIG, rateMIG, Nscaling, N, RandomExponential (rateMIG, seed));*/
			/* find out time for convergence of demes */	/* It doesn't depend of demographics because the node doesnt depend of another node to make this event */		
			w = j = d = totCurrentConv = 0;
			if (doConvergDemes == YES)
				{
				for (k=1; k<=numConvergDemes; k++)
					currentConvDem[k] = 0;
			
				for (k=1; k<=numConvergDemes; k++) /* looking for the event nearer (with less time and future) */
					{ 
					if (convDemTimes[k] >= currentTime && convDemTimes[k] >= 0)
						{
						if (d == 0)
							j = k;
						d++;
						if (convDemTimes[k] >= currentTime && convDemTimes[k] < j)
							j = k;
						}
					}
				if (d > 0) /* there are convergences */
					{
					//fprintf(fpmpi,"\n proximo de menor tiempo = %d, con tiempo %lf", j, convDemTimes[j]);
					nextConvNumber = j;
					timeCONV = convDemTimes[nextConvNumber] - currentTime;
					/*fprintf(fpmpi,"\n timeCONV = %lf", timeCONV);*/
					}
				else
					timeCONV = 0; /* there is no more convergences */
				}
			/*fprintf(fpmpi,"\n timeCA = %lf, timeRE = %lf, timeMIG = %lf \n", timeCA,timeRE,timeMIG);*/





			if (doDatedTips == YES)
				{
				if (doConvergDemes == YES && timeCONV > 0)
					{
					if (timeCA < timeRE && timeCA < timeMIG && timeCA < timeCONV) /* coalescence event */
						{
						isCoalescence = YES;
						isRecombination = NO;
						isMigration = NO;
						doConvNext = NO;
						eventTime = timeCA;
						}
					else if (timeRE < timeCA && timeRE < timeMIG && timeRE < timeCONV) /* recombination event */
						{
						isCoalescence = NO;
						isRecombination = YES;
						isMigration = NO;
						doConvNext = NO;
						eventTime = timeRE;
						}
					else if (timeMIG < timeCA && timeMIG < timeRE && timeMIG < timeCONV) /* migration event */
						{
						isCoalescence = NO;
						isRecombination = NO;
						isMigration = YES;
						doConvNext = NO;

						eventTime = timeMIG;
						}
					else if (timeCONV < timeCA && timeCONV < timeRE && timeCONV < timeMIG) /* convergence between demes event */
						{
						isCoalescence = NO;
						isRecombination = NO;
						isMigration = NO;
						doConvNext = YES;
						eventTime = timeCONV;
						}
					else
						{
						fprintf(fpmpi, "\n\n Warning choosing the type of event");
						fprintf(fpmpi, "\n Check:: \n 1. Do you have a migration rate = 0 starting by more than one demes and without convergence events for the demes? \n 2. Do you have a migration rate = 0 without convergence events for ALL demes IN TIME BEFORE? \n When two demes converg the result deme has a new number that (if there are more demes) it should be converged or migrated. So, e.g. -%%2 1 2 200 3 4 500, in 200 1 more 2 make 5, then in 500 3 and 4 make 6, so finally you have deme 5 and deme 6 as independent demes, it is a problem with migration rate = 0 \n So, if you are working with migration rate = 0 it is recomending convergence all demes, including the new demes (e.g. - %%3 1 2 200 3 4 500 5 6 2000) ");
						fprintf(fpmpi, "\n 3. If migration rate is different than 0: Check if you are using tip dates and convergence of demes, the sample could belongs to a time older than the existence of its user-given deme. To solve this problem try to erase this tip date (this sample time = 0.00) or to modify the time of the tip node to a value younger than the convergence of demes \n");
						exit (-1);
						}

					}
				if (doConvergDemes == NO || timeCONV == 0)
					{
					if (timeCA < timeRE && timeCA < timeMIG) /* coalescence event */
						{
						isCoalescence = YES;
						isRecombination = NO;
						isMigration = NO;
						eventTime = timeCA;
						}
					else if (timeRE < timeCA && timeRE < timeMIG) /* recombination event */
						{
						isCoalescence = NO;
						isRecombination = YES;
						isMigration = NO;
						eventTime = timeRE;
						}
					else if (timeMIG < timeCA && timeMIG < timeRE) /* migration event */
						{
						isCoalescence = NO;
						isRecombination = NO;
						isMigration = YES;
			
						eventTime = timeMIG;
						}
					else
						{
						fprintf(fpmpi, "\n\n Warning choosing the type of event");
						fprintf(fpmpi, "\n Check::: \n 1. Do you have a migration rate = 0 starting by more than one demes and without convergence events for the demes? \n 2. Do you have a migration rate = 0 without convergence events for ALL demes IN TIME BEFORE? \n When two demes converg the result deme has a new number that (if there are more demes) it should be converged or migrated. So, e.g. -%%2 1 2 200 3 4 500, in 200 1 more 2 make 5, then in 500 3 and 4 make 6, so finally you have deme 5 and deme 6 as independent demes, it is a problem with migration rate = 0 \n So, if you are working with migration rate = 0 it is recomending convergence all demes, including the new demes (e.g. - %%3 1 2 200 3 4 500 5 6 2000) ");
						fprintf(fpmpi, "\n 3. If migration rate is different than 0: Check if you are using tip dates and convergence of demes, the sample could belongs to a time older than the existence of its user-given deme. To solve this problem try to erase this tip date (this sample time = 0.00) or to modify the time of the tip node to a value younger than the convergence of demes \n");
						exit (-1);
						}

					}
				}
			
			if (doDatedTips == YES)
				{
				/* if doing dated tips, check whether we need to activate a new sample, update sampling period and start again */
				if ((currentTime + eventTime) > datedSample[currentSample-1].time && currentSample > 0)
					{
					currentSample--;
					/* activate nodes from this sample */
					if (noisy > 2)
						fprintf (stderr, "\nCumulative time = %6.4f  > sample %d time = %6.4f. Activating tips:", currentTime + eventTime, currentSample, datedSample[currentSample].time);
					
					for (i=0; i<datedSample[currentSample].size; i++)
						{
						if (noisy > 2)
							fprintf (stderr, " %d", datedSample[currentSample].member[i]-1);

						p = nodes + datedSample[currentSample].member[i]-1;
						p->index = datedSample[currentSample].member[i]-1;
						activeGametes[numActiveGametes] = datedSample[currentSample].member[i]-1;  

						numActiveGametes++;
											
						for (ss = 1; ss <= numPopulations /*+ numCONV*/; ss++) 
							{
							if (p->indexOldMigPop == ss)
								{
								numParcialActiveGametes[ss]++;
								/*fprintf (stderr, "\n AQUI numParcialActiveGametes[%d] = %d \n", ss, numParcialActiveGametes[ss]);*/ 
								}
							}
						}
					currentTime = datedSample[currentSample].time;

					if (noisy > 2)
						{
						fprintf (stderr, "\nActive nodes (%d):", numActiveGametes); 
						for (i=0; i<numActiveGametes; i++)
							fprintf (stderr," %d",activeGametes[i]);
						fprintf (stderr,"\nNext node available = %d", nextAvailable);
						fprintf (stderr, "\nSample %d activated and going back to currentTime = %6.4f", currentSample, currentTime);
						}
					continue; /* start again*/
					}
				}

			

			if (doConvergDemes == YES && timeCONV > 0)
				{
				/* event is a coalescence, a recombination or a migration? */
				if (timeCA < timeRE && timeCA < timeMIG && timeCA < timeCONV) /* coalescence event */
					{
					isCoalescence = YES;
					isRecombination = NO;
					isMigration = NO;
					doConvNext = NO; /* new */
					eventTime = timeCA;

					/*	if this period is not the last one and if the event time is outside the current interval,
						update period and start again */
					if (doDemographics == YES && period < numPeriods && (currentTime + eventTime) > cumDuration[period])
						{
						currentTime = cumDuration[period];
						period++;
						periodGrowth[period] = -log (Nend[period] / (double) Nbegin[period]) / (double) (cumDuration[period] - cumDuration[period-1]);
						continue;
						}	
			
					numCA++;
					}
				else if (timeRE < timeCA && timeRE < timeMIG && timeRE < timeCONV) /* recombination event */
					{
					isCoalescence = NO;
					isRecombination = YES;
					isMigration = NO;
					doConvNext = NO; /* new */
					eventTime = timeRE;	

					/*	if this period is not the last one and if the event time is outside the current interval,
						update period and start again */
					if (doDemographics == YES && period < numPeriods && (currentTime + eventTime) > cumDuration[period])
						{
						currentTime = cumDuration[period];
						period++;
						periodGrowth[period] = -log (Nend[period] / (double) Nbegin[period]) / (double) (cumDuration[period] - cumDuration[period-1]);
						continue;
						}	
					numRE++;
				
					/* reallocate space for recombination breakpoints */
					if (numRE >= (memoryBreakp-1))
						{
						memoryBreakp += 50;
					 
						breakpoint = (int *) realloc(breakpoint, memoryBreakp *(long) sizeof(int));
						if (!breakpoint)
							{	
							fprintf (fpmpi, "Could not reallocate breakpoint \n");
							exit (-1);
							}
						if (noisy == 4)
							fprintf (fpmpi, "\n...Doing reallocation of breakponts (1)\n");
						}
				
					if (numRE > (numNuc+1) && many == 0)
						{
						if (noisy > 1)
							fprintf (fpmpi, "\n\n Many recombinations %d (more recombinations that sites)!\n", numRE);
						
						many++;
						}
					}
				else if (timeMIG < timeCA && timeMIG < timeRE && timeMIG < timeCONV) /* migration event */
					{
					isCoalescence = NO;
					isRecombination = NO;
					isMigration = YES;
					doConvNext = NO;

					eventTime = timeMIG;	

					/*	if this period is not the last one and if the event time is outside the current interval,
						update period and start again */
					if (doDemographics == YES && period < numPeriods && (currentTime + eventTime) > cumDuration[period])
						{
						currentTime = cumDuration[period];
						period++;
						periodGrowth[period] = -log (Nend[period] / (double) Nbegin[period]) / (double) (cumDuration[period] - cumDuration[period-1]);
						continue;
						}	
					numMIG++;
					}
				else if (timeCONV < timeCA && timeCONV < timeRE && timeCONV < timeMIG) /* convergence between demes event */
					{
					isCoalescence = NO;
					isRecombination = NO;
					isMigration = NO;
					doConvNext = YES;
					eventTime = timeCONV;

					convDemTimes[nextConvNumber] = -1; /* erasing the event */	
					/*	if this period is not the last one and if the event time is outside the current interval,
						update period and start again */
					if (doDemographics == YES && period < numPeriods && (currentTime + eventTime) > cumDuration[period])
						{
						currentTime = cumDuration[period];
						period++;
						periodGrowth[period] = -log (Nend[period] / (double) Nbegin[period]) / (double) (cumDuration[period] - cumDuration[period-1]);
						continue;
						}	
					numCONV++;
					}
				else
					{
					fprintf(fpmpi, "\n\n Warning choosing the type of event");
					fprintf(fpmpi, "\n Check: \n 1. Do you have a migration rate = 0 starting by more than one demes and without convergence events for the demes? \n 2. Do you have a migration rate = 0 without convergence events for ALL demes IN TIME BEFORE? \n When two demes converg the result deme has a new number that (if there are more demes) it should be converged or migrated. So, e.g. -%%2 1 2 200 3 4 500, in 200 1 more 2 make 5, then in 500 3 and 4 make 6, so finally you have deme 5 and deme 6 as independent demes, it is a problem with migration rate = 0 \n So, if you are working with migration rate = 0 it is recomending convergence all demes, including the new demes (e.g. - %%3 1 2 200 3 4 500 5 6 2000) ");
					fprintf(fpmpi, "\n 3. If migration rate is different than 0: Check if you are using tip dates and convergence of demes, the sample could belongs to a time older than the existence of its user-given deme. To solve this problem try to erase this tip date (this sample time = 0.00) or to modify the time of the tip node to a value younger than the convergence of demes \n");
					exit (-1);
					}
				}
			if (doConvergDemes == NO || timeCONV == 0)
				{
				doConvNext = NO;
				/* event is a coalescence, a recombination or a migration? */
				if (timeCA < timeRE && timeCA < timeMIG) /* coalescence event */
					{
					isCoalescence = YES;
					isRecombination = NO;
					isMigration = NO;
					eventTime = timeCA;
					
					/*	if this period is not the last one and if the event time is outside the current interval,
						update period and start again */
					if (doDemographics == YES && period < numPeriods && (currentTime + eventTime) > cumDuration[period])
						{
						currentTime = cumDuration[period];
						period++;
						periodGrowth[period] = -log (Nend[period] / (double) Nbegin[period]) / (double) (cumDuration[period] - cumDuration[period-1]);
						continue;
						}	
			
					numCA++;
					}
				else if (timeRE < timeCA && timeRE < timeMIG) /* recombination event */
					{
					isCoalescence = NO;
					isRecombination = YES;
					isMigration = NO;
					eventTime = timeRE;
										
					/*	if this period is not the last one and if the event time is outside the current interval,
						update period and start again */
					if (doDemographics == YES && period < numPeriods && (currentTime + eventTime) > cumDuration[period])
						{
						currentTime = cumDuration[period];
						period++;
						periodGrowth[period] = -log (Nend[period] / (double) Nbegin[period]) / (double) (cumDuration[period] - cumDuration[period-1]);
						continue;
						}	
					numRE++;
				
					/* reallocate space for recombination breakpoints */
					if (numRE >= (memoryBreakp-1))
						{
						memoryBreakp += 50;
					 
						breakpoint = (int *) realloc(breakpoint, memoryBreakp *(long) sizeof(int));
						if (!breakpoint)
							{	
							fprintf (fpmpi, "Could not reallocate breakpoint \n");
							exit (-1);
							}
						if (noisy == 4)
							fprintf (fpmpi, "\n...Doing reallocation of breakponts (1)\n");
						}
				
					if (numRE > (numNuc+1) && many == 0)
						{
						if (noisy > 1)
							fprintf (fpmpi, "\n\n Many recombinations %d (more recombinations than sites)!\n", numRE);
						
						many++;
						}
					}
				else if (timeMIG < timeCA && timeMIG < timeRE) /* migration event */
					{
					isCoalescence = NO;
					isRecombination = NO;
					isMigration = YES;
			
					eventTime = timeMIG;	

					/*	if this period is not the last one and if the event time is outside the current interval,
						update period and start again */
					if (doDemographics == YES && period < numPeriods && (currentTime + eventTime) > cumDuration[period])
						{
						currentTime = cumDuration[period];
						period++;
						periodGrowth[period] = -log (Nend[period] / (double) Nbegin[period]) / (double) (cumDuration[period] - cumDuration[period-1]);
						continue;
						}	
					numMIG++;
					}
				else
					{
					fprintf(fpmpi, "\n\n Warning choosing the type of event");
					fprintf(fpmpi, "\n Check: \n 1. Do you have a migration rate = 0 starting by more than one demes and without convergence events for the demes? \n 2. Do you have a migration rate = 0 without convergence events for ALL demes IN TIME BEFORE? \n When two demes converg the result deme has a new number that (if there are more demes) it should be converged or migrated. So, e.g. -%%2 1 2 200 3 4 500, in 200 1 more 2 make 5, then in 500 3 and 4 make 6, so finally you have deme 5 and deme 6 as independent demes, it is a problem with migration rate = 0 \n So, if you are working with migration rate = 0 it is recomending convergence all demes, including the new demes (e.g. - %%3 1 2 200 3 4 500 5 6 2000) ");
					fprintf(fpmpi, "\n 3. If migration rate is different than 0: Check if you are using tip dates and convergence of demes, the sample could belongs to a time older than the existence of its user-given deme. To solve this problem try to erase this tip date (this sample time = 0.00) or to modify the time of the tip node to a value younger than the convergence of demes \n");
					exit (-1);
					}
				}




			/** it chooses the deme for this event **/
			if (isCoalescence == YES)
				{
				for (k = 1; k <= numPopulations+currentBigDeme; k++)
					cumPopulTase[k] = 0;
				cumPopulTase[0] = 0;
				w = 0;
						
				for (k = 1; k <= numPopulations+currentBigDeme; k++)
					{
					cumPopulTase[k] = cumPopulTase[k-1] + rateCApartial[k];
					w = w + numParcialActiveGametes[k];
					}
				/* (cumPopulTase[numPopulations+currentBigDeme] must to be similar to rateCA) */
				if (w != numActiveGametes)
					{
					fprintf(fpmpi, "\n 1 The sum of partial active gametes is different than total gametes number, w %d != numActiveGametes %d. In choose the deme", w, numActiveGametes);
					exit (-1);
					}
				for (k = 1; k <= numPopulations+currentBigDeme; k++)
					cumPopulTase[k] = cumPopulTase[k]/cumPopulTase[numPopulations+currentBigDeme];
					
				ran = RandomUniform(seed);
				whichDeme = bbinDemes(ran, cumPopulTase, numPopulations+currentBigDeme);
				w = 0;
				}
		
			if (isMigration == YES) /* the choice of the deme which send migrants should not depend on the migration model. Model affects to the choice of the deme who receive the migrants.. */
				{
				for (k = 1; k <= numPopulations+currentBigDeme; k++)
					cumPopulTase[k] = 0;
				cumPopulTase[0] = 0;
				w = 0;
			
				for (k = 1; k <= numPopulations+currentBigDeme; k++)
					{
					cumPopulTase[k] = cumPopulTase[k-1] + rateMIGpartial[k];
					w = w + numParcialActiveGametes[k];
					}
				/* (cumPopulTase[numPopulations+currentBigDeme] must to be similar to rateMIG) */
				if (w != numActiveGametes)
					{
					fprintf(fpmpi, "\n 2The sum of partial active gametes is different than total gametes number, w %d != numActiveGametes %d. In choose the deme", w, numActiveGametes);
					exit (-1);
					}

				for (k = 1; k <= numPopulations+currentBigDeme; k++)
					cumPopulTase[k] = cumPopulTase[k]/cumPopulTase[numPopulations+currentBigDeme];
				/*fprintf(fpmpi, "\n cumPopulTase[numPopulations+currentBigDeme] = %lf", cumPopulTase[numPopulations+currentBigDeme]);*/
				ran = RandomUniform(seed);
				whichDeme = bbinDemes(ran, cumPopulTase, numPopulations+currentBigDeme);
				w = 0;
				}
			/* for event of convergent demes we do not have to choose the deme to converge.. */
			




			/** set time **/
			currentTime += eventTime; /* the time is accumulated */
			if (noisy > 3)
				fprintf(fpmpi, "\n\n");
			eventNum++;
			if (noisy > 1 && doConvNext == NO)
				fprintf (fpmpi, "\n\n*** Event %3d *** rate = %lf, currentTime = %lf\n", eventNum, rate, currentTime);
			if (noisy > 1 && doConvNext == YES)
				fprintf (fpmpi, "\n\n*** Event %3d *** currentTime = %lf\n", eventNum, currentTime);

				
			/*** if RECOMBINATION ***/
			if (isRecombination == YES) 
				{
				if (noisy == 4)
					fprintf(fpmpi, "\n* Recombination *");
					
				w = 0;
				for (k = 1; k <= numPopulations+currentBigDeme; k++)
					w = w + numParcialActiveGametes[k];
				if (w != numActiveGametes)
					{
					fprintf(fpmpi, "\n 3The sum of partial active gametes is different than total gametes number, w %d != numActiveGametes %d. In choose the deme", w, numActiveGametes);
					exit (-1);
					}	
				w = 0;
				
				/* Which node has the recombination? */
					/* assign probability to each node based on their gi's values */
				cum_gi = 0;
				probRecIndividual = Gi * RandomUniform(seed); /* it calculate the individual probability for the breakpoint */
				for (whichInd=0; whichInd<numActiveGametes; whichInd++)
					{
					cum_gi += gi[whichInd];				/* accumulate gi into cum_gi. whichInd is the choose node. */
					if (probRecIndividual < cum_gi)    /* ok whether the node is choosen */
						break;
					}
			
				if (whichInd >= numActiveGametes)
					{
					fprintf (fpmpi, "\n\nERROR: whichInd out of range1!: whichInd = %d\n", whichInd);
					exit (-1);
					}
			
				/* select a valid breakpoint among potential recombining locations */
				/* to be a potential recombining site, a site has to have ancestral material non-MRCA before and after it */
				legalBreakpoint = NO;
				while (legalBreakpoint == NO)
					{
					do /* oct2009 */
						{
						whichSite = (/*numSites*/numNuc) * RandomUniform(seed); /* it choose a site */
						if (whichSite == 1)
							whichSite = numNuc;
						} while (whichSite == 0);
					/* oct2009 */

					if (whichSite > numNuc)
						{
						fprintf (fpmpi, "\n\nERROR: whichSite out of range! : whichSite = %d\n", whichSite);
						exit (-1);
						}
					p = nodes + activeGametes[whichInd];
					sizeNode = p->numSegNode;
					if	(IsValidBreakSite (activeGametes, nodes, whichInd, whichSite, S_MRCA) == YES)
						legalBreakpoint = YES;
					}
				
				/* should this recombination event be counted in the expected number of recombinations E(R)? */
				/* for E(R) count only events with breakpoints as 1|1, 1|0 or 0|1  (i.e., not 0|0)         */
				/* if 1 represent a site that did found already its MRCA count it as a 0 */
				ThisBreakpIsTrapped = NO;
				if (doCountsForExpNumRec == YES)
					{
					p = nodes + activeGametes[whichInd];
					sizeNode = p->numSegNode;	
					if (CountsForExpNumRec (activeGametes, whichInd, whichSite, nodes, S_MRCA, sizeNode) == NO)
						{
						recNotToCount++;
						ThisBreakpIsTrapped = YES;
						/*fprintf(fpmpi,"..not to count.."); */
						}
					}
			
				/* copy whichIndividual to a new space in memory */
				hasPassedBreakPoint = NO;
			
			
				firstHalf = nextAvailable++; /* firstHalf is the first node that was created by the recombination */
				if (nextAvailable >= numNodes) /* if there aren't enough nodes it go into and it addition more */
					{
					/* ReallocNodes(&numNodes, activeGametes); */
					numNodes += INCREMENT_NODES;
					numTotalSegments += (INCREMENT_NODES*maxSegNode)+numNuc;
					
					segments = (TreeSegment *) realloc (segments, numTotalSegments  * (long) sizeof(TreeSegment)); 
					if (!segments)
						{
						fprintf (fpmpi, "Could not reallocate segments (%lu bytes)\n", ((numNodes*distance)+numNuc)  * (long) sizeof(TreeSegment));
						exit (1);
						}
					nodes = (TreeNode *) realloc (nodes, numNodes  * (long) sizeof(TreeNode));
					if (!nodes)
						{
						fprintf (fpmpi, "Could not reallocate nodes (%lu bytes)\n", numNodes  * (long) sizeof(TreeNode));
						exit (-1);
						}
					activeGametes = (int *) realloc (activeGametes, numNodes *(long) sizeof(int));
					if (!activeGametes)
						{
						fprintf (fpmpi, "Could not reallocate activeGametes (%lu bytes)\n", numNodes *(long) sizeof(int));
						exit (-1);
						}
					if (noisy == 4)
						fprintf (fpmpi, "\n\n...Doing reallocation of nodes (1)\n");
					}
									
				secondHalf = nextAvailable++; /* secondhalf is the second node that was created by the recombination */
				if (nextAvailable >= numNodes) /* if there aren't enough nodes it go into and it addition more */
					{
					/* ReallocNodes(&numNodes, activeGametes); */
					numNodes += INCREMENT_NODES;
					numTotalSegments += (INCREMENT_NODES*maxSegNode)+numNuc;
					
					segments = (TreeSegment *) realloc (segments, numTotalSegments  * (long) sizeof(TreeSegment));
					if (!segments)
						{
						fprintf (fpmpi, "Could not reallocate segments (%lu bytes)\n", ((numNodes*distance)+numNuc)  * (long) sizeof(TreeSegment));
						exit (1);
						}
					nodes = (TreeNode *) realloc (nodes, numNodes  * (long) sizeof(TreeNode));
					if (!nodes)
						{
						fprintf (fpmpi, "Could not reallocate nodes (%lu bytes)\n", numNodes  * (long) sizeof(TreeNode));
						exit (-1);
						}
					activeGametes = (int *) realloc (activeGametes, numNodes *(long) sizeof(int));
					if (!activeGametes)
						{
						fprintf (fpmpi, "Could not reallocate activeGametes (%lu bytes)\n", numNodes *(long) sizeof(int));
						exit (-1);
						}
					if (noisy == 4)
						fprintf (fpmpi, "\n\n...Doing reallocation of nodes (1)\n");
					}
								
				
				p = nodes + activeGametes[whichInd];
				q = nodes + firstHalf;	/* parent1 (new) */
				r = nodes + secondHalf; /* parent2 (new) */
				if (p->numSegNode > maxSegNode) /* checking */
					{
					fprintf (fpmpi, "\n\nWarning, too many segments in this node. max = %d", maxSegNode);
					fprintf (fpmpi, "\n p->numSegNode = %d",p->numSegNode);	
					exit(9);
					}
				q->index = firstHalf;
				r->index = secondHalf;

				if (doBranchNetfiles == YES)
					{
					q->NetLabelPrint = numNetLabelPrint;
					/*numNetLabelPrint++;*/
					r->NetLabelPrint = numNetLabelPrint;
					numNetLabelPrint++;
					}

				q->numSegNode = r->numSegNode = p->numSegNode;		/* Good if there are not nill segments.. then, in its case, it will be modify */
				q->indexOldMigPop = q->indexCurrentMigPop = p->indexCurrentMigPop; /* demes evolution */
				r->indexOldMigPop = r->indexCurrentMigPop = p->indexCurrentMigPop;


				q->class = 3;
				r->class = 3;
				q->GMRCA_ancestral = NO;
				r->GMRCA_ancestral = NO;
				q->breakp = whichSite;		
				r->breakp = whichSite;			
				q->time = currentTime;
				r->time = currentTime;
				q->sib = r;
				r->sib = q;
				q->left = p;
				r->left = p;
				p->anc1 = q;
				p->anc2 = r;				

				k = 0;
				for (w = 1; w < numSites; w++)
					{
					//fprintf (fpmpi, "\nstud[%d] = %d", w-1, stud[w-1]);
					if (whichSite == stud[w-1]) /* The breakpoints BETWEEN codons. "stud" is an array with the possible breakpoints beetween codons*/
						k++;

					/* exception for trapped material, any breakpoint here does not break material codons */
					if (ThisBreakpIsTrapped == YES)
						{
						k++;
						/*fprintf (fpmpi, "\n ThisBreakpIsTrapped \n");*/
						}
					}
				if (k == 0) /* broken codon, this indicates the position of rupture of the codon.. */
					{
					//q->breakCodon = YES;
					//r->breakCodon = YES;
					variable1 = whichSite/3.00 + 0.4;
					//fprintf (fpmpi, "\n variable1 = %lf", variable1);
					q->breakCodon = fabs(variable1);
					r->breakCodon = fabs(variable1);
					numREbreakCod++;
					variable2 = fmod(whichSite,3.00);
					if (variable2 == 0)
						q->whereBreakCodon = 2;
					else
						q->whereBreakCodon = 1;
					r->whereBreakCodon = 3;



					

					/* oct2009 */
					/* int			doBreakpBroken, LeftLess, LeftHigh, RightLess, RightHigh; */
					if (doCodonModel == YES)
						doBreakpBroken = YES;
					LeftLess = LeftHigh = RightLess = RightHigh = LeftLess2 = RightHigh2 = -1;

					if (q->whereBreakCodon == 1) /* first codon position breakp */
						{
						RightHigh = q->breakCodon * 3;
						RightLess = RightHigh - 1;
						LeftLess = RightLess - 1; 
						LeftHigh = RightLess - 1;
						
						
						q->SitesNonAncHere[LeftLess+1] = 1;
						q->SitesNonAncHere[LeftLess+2] = 1;
						r->SitesNonAncHere[RightLess-1] = 1;

						/*fprintf (fpmpi, "\n LeftLess+2 = %d; RightLess-1 = %d \n", LeftLess+2, RightLess-1);*/
						for (mmm=1; mmm<=numNuc; mmm++)
							{
							if (mmm <= RightLess-1)
								q->SitesNonAncHere[mmm] = p->SitesNonAncHere[mmm]; 
							if (mmm > RightLess-1 && mmm <= LeftLess+2)
								q->SitesNonAncHere[mmm] = 1;
							if (mmm > LeftLess+2)
								q->SitesNonAncHere[mmm] = -1;

							if (mmm < RightLess-1)
								r->SitesNonAncHere[mmm] = -1; 
							if (mmm == RightLess-1)
								r->SitesNonAncHere[mmm] = 1;
							if (mmm > RightLess-1)
								r->SitesNonAncHere[mmm] =  p->SitesNonAncHere[mmm];
							}	
						}
					else if (q->whereBreakCodon == 2) /* second codon position breakp */
						{
						RightHigh = q->breakCodon * 3;
						RightLess = q->breakCodon * 3;
						LeftHigh = RightLess - 1;
						LeftLess = LeftHigh - 1;


						q->SitesNonAncHere[LeftHigh+1] = 1;
						r->SitesNonAncHere[RightLess-1] = 1;	
						r->SitesNonAncHere[RightLess-2] = 1;
						
						/*fprintf (fpmpi, "\n LeftHigh+1 = %d; RightLess-2 = %d \n", LeftHigh+1, RightLess-2);*/
						for (mmm=1; mmm<=numNuc; mmm++)
							{
							if (mmm < LeftHigh+1)
								q->SitesNonAncHere[mmm] = p->SitesNonAncHere[mmm]; 
							if (mmm == LeftHigh+1)
								q->SitesNonAncHere[mmm] = 1;
							if (mmm > LeftHigh+1)
								q->SitesNonAncHere[mmm] = -1;

							if (mmm >= LeftHigh+1)
								r->SitesNonAncHere[mmm] = p->SitesNonAncHere[mmm]; 
							if (mmm >= RightLess-2 && mmm < LeftHigh+1)
								r->SitesNonAncHere[mmm] = 1;
							if (mmm < RightLess-2)
								r->SitesNonAncHere[mmm] = -1;

							}	
						}
					else
						{
						fprintf (fpmpi, "error at q->whereBreakCodon intra codon Rec _ Main (%d != 1 or 2)\n", q->whereBreakCodon);
						exit (-1);
						}
					/* fprintf (fpmpi, "\n Left (Less-High) %d-%d; Right (Less-High) %d-%d \n", LeftLess, LeftHigh, RightLess, RightHigh);	*/				
					if (LeftLess == -1 || LeftHigh == -1 || RightLess == -1 || RightHigh == -1)
						{
						fprintf (fpmpi, "\n Error (value = -1): Left (Less-High) %d-%d; Right (Less-High) %d-%d \n", LeftLess, LeftHigh, RightLess, RightHigh);					
						exit (-1);
						}


					}
				if (k > 0 || doCodonModel == NO) /* inter codon rec */
					{
					doBreakpBroken = NO;

					for (mmm=1; mmm<=numNuc; mmm++)
						{
						if (mmm >= whichSite)
							{
							q->SitesNonAncHere[mmm] = -1; /* non anc mat */
							}
						if (mmm < whichSite)
							{
							q->SitesNonAncHere[mmm] = p->SitesNonAncHere[mmm]; /* non anc mat */
							}

						if (mmm < whichSite)
							{
							r->SitesNonAncHere[mmm] = -1; /* non anc mat */
							}
						if (mmm >= whichSite)
							{
							r->SitesNonAncHere[mmm] = p->SitesNonAncHere[mmm]; /* non anc mat */
							}
						}	
					}
				/* oct2009 */

				/*for (mmm=1; mmm<=numNuc; mmm++)
					{
					fprintf (fpmpi, "\n Initial. Site %d. Node: %d, p->SitesNonAncHere = %d \n", mmm, p->index, p->SitesNonAncHere[mmm]);
					}
				for (mmm=1; mmm<=numNuc; mmm++)
					{
					fprintf (fpmpi, "\n Site %d. Node: %d, q->SitesNonAncHere = %d;  Node %d, r->SitesNonAncHere = %d \n", mmm, q->index, q->SitesNonAncHere[mmm], r->index, r->SitesNonAncHere[mmm]);
					}*/
				

				/*fprintf (fpmpi, "\n r->index = %d, r->time = %lf, r->class = %d, r->breakp = %d, r->breakCodon = %d, r->whereBreakCodon = %d", r->index, r->time, r->class, r->breakp, r->breakCodon, r->whereBreakCodon);
				fprintf (fpmpi, "\n q->index = %d, q->time = %lf, q->class = %d, q->breakp = %d, q->breakCodon = %d, q->whereBreakCodon = %d\n", q->index, q->time, q->class, q->breakp, q->breakCodon, q->whereBreakCodon);*/
				k = 0;	
			


				if (noisy == 4)
					{
					fprintf (fpmpi, "\nNode index %d with breakpoint on %d site", p->index, whichSite);
					fprintf (fpmpi, "\nThis node contains %d fragment(s):", p->numSegNode);
					}
				
				for (w = 0; w < p->numSegNode; w++)
					{
					s = segments + post(w,p->index,distance);
					if (post(w,p->index,distance) > numTotalSegments) /* checking */
						{
						fprintf (fpmpi, "\n post = %d > numTotalSegments = %d", post(w,p->index,distance), numTotalSegments);
						exit (-7);
						}
					if (noisy == 4)
						{
						fprintf (fpmpi, "\ns->sIndex = %d", s->sIndex);
						fprintf (fpmpi, "\ns->sStart = %d", s->sStart);
						fprintf (fpmpi, "\ns->sEnd = %d",s->sEnd);
						}
					}
				if (noisy == 4)
					fprintf (fpmpi, "\n\n>> Process evolution..");
					
					
				a = b = aa = bb = aaa = bbb = out = 0;
				startsVectorRec = (int *) calloc((p->numSegNode),(long) sizeof(int));
				if (!startsVectorRec)
					{
					fprintf (fpmpi, "Could not allocate startsVectorRec (%lu bytes)\n", (p->numSegNode) *(long) sizeof(int));	
					exit (-1);
					}
				endsVectorRec = (int *) calloc((p->numSegNode),(long) sizeof(int));
				if (!endsVectorRec)
					{
					fprintf (fpmpi, "Could not allocate endsVectorRec (%lu bytes)\n", (p->numSegNode) *(long) sizeof(int));
					exit (-1);
					}
			
				for (i = 0; i < p->numSegNode; i++)					/* for each segment */
					{
					s = segments + post(i,p->index,distance);										
					startsVectorRec[i] = s->sStart;
					endsVectorRec[i] = s->sEnd;
				
					/* first half */
					if (s->sStart >= whichSite)
						{
						if (noisy == 4)
							fprintf (fpmpi, "\nNil segment in Left, don't make it");
							
						q->numSegNode--;
						a++;
						out = 1;
						} 
				
					if (s->sStart == 1 && s->sEnd >= (whichSite-1) && out == 0)
						{
						if (aa > 0)
							{
							if (noisy == 4)
								fprintf (fpmpi, "\nRepit segment in Left, don't make it");
								
							q->numSegNode--;
							out = 1;
							}
						aa++;
						}
					
					for (w = 0; w < i+1; w++)
						{
						if (out == 0 && s->sStart != 1 && s->sStart == startsVectorRec[w] && s->sStart < whichSite && w != i && s->sEnd >= (whichSite-1) && endsVectorRec[w] >= (whichSite-1) && startsVectorRec[w] != 0)
							{
							if (noisy == 4)
								fprintf (fpmpi, "\nRepit segment in Left, don't make it");
								
							q->numSegNode--;
							aaa++;
							out = 1;
							}
						}
					
					if (out == 0 && s->sStart < whichSite)
						{
						if (aa == 0 && aaa == 0)
							{							
							if (post(i-a-aa-aaa,q->index,distance) > numTotalSegments) /* checking */
								{
								fprintf (fpmpi, "\n post = %d > numTotalSegments = %d", post(i-a-aa-aaa,q->index,distance), numTotalSegments);
								exit (-7);
								}
							
							n = segments + post(i-a-aa-aaa,q->index,distance);
							n->sIndexNode = firstHalf;
							}
						if (aa > 0 && aaa == 0)
							{
							if (post(i+1-a-aa-aaa,q->index,distance) > numTotalSegments) /* checking */
								{
								fprintf (fpmpi, "\n post = %d > numTotalSegments = %d", post(i+1-a-aa-aaa,q->index,distance), numTotalSegments);
								exit (-7);
								}
							
							n = segments + post(i+1-a-aa-aaa,q->index,distance);
							n->sIndexNode = firstHalf;
							}
						if (aaa > 0 && aa > 0)
							{
							if (post(i+1-a-aa-aaa,q->index,distance) > numTotalSegments) /* checking */
								{
								fprintf (fpmpi, "\n post = %d > numTotalSegments = %d", post(i+1-a-aa-aaa,q->index,distance), numTotalSegments);
								exit (-7);
								}
							
							n = segments + post(i+1-a-aa-aaa,q->index,distance);
							n->sIndexNode = firstHalf;
							}
						if (aaa > 0 && aa == 0)
							{
							if (post(i+0-a-aa-aaa,q->index,distance) > numTotalSegments) /* checking */
								{
								fprintf (fpmpi, "\n post = %d > numTotalSegments = %d", post(i+0-a-aa-aaa,q->index,distance), numTotalSegments);
								exit (-7);
								}
							
							n = segments + post(i+0-a-aa-aaa,q->index,distance);
							n->sIndexNode = firstHalf;
							}
						/* n = s; initial, the new segments are similar to the old segments */
						nodeValue = firstHalf;


						if (doBreakpBroken == YES && s->sStart < whichSite && s->sEnd >= whichSite)
							{
							w = recSegmentsGeneratesLeftBrokenCodon(nodeValue, s, n, numNuc, whichSite, LeftLess, RightHigh, &actSegIndex); /* it makes the segments of the left node */
							LeftLess2 = LeftLess;
							RightHigh2 = RightHigh;
							}
						else
							{
							w = recSegmentsGeneratesLeft(nodeValue, s, n, numNuc, whichSite, &actSegIndex); /* it makes the segments of the left node */
							}


						if (w != 1)
							{
							fprintf (fpmpi, "Warning in recSegmentsGeneratesLeft");
							exit (-1);
							}
						actNumSegments++;
						if (n->sStart == 0 && n->sEnd == 0) /* unreal segments */
							{
							fprintf (fpmpi, "\nNot to be here. Segment Left start and end = 0");
							
							n->before1 = n->before2 = n->after1 = n->after2 = NULL;
							actNumSegments--;
							exit(-1);
							}
						if (noisy == 4)			
							{
							fprintf (fpmpi, "\nAfter rec. left");
							fprintf (fpmpi, "\nq->seg->sIndex = %d", n->sIndex);
							fprintf (fpmpi, "\nq->seg->sStart = %d", n->sStart);
							fprintf (fpmpi, "\nq->seg->sEnd = %d\n", n->sEnd);
							}
						}
					w = out = 0;
				
					/* second half */
					if (s->sEnd < whichSite)
						{
						if (noisy == 4)
							fprintf (fpmpi, "\nNil segment in Right, don't make it");
							
						r->numSegNode--;
						b++;
						out = 1;
						}
					if (s->sStart <= whichSite && s->sEnd == numNuc && out == 0)
						{
						if (bb > 0)
							{
							if (noisy == 4)
								fprintf (fpmpi, "\nRepit segment in Right, don't make it");
								
							r->numSegNode--;
							out = 1;
							}
						bb++;
						}
					for (w = 0; w < i+1; w++)
						{
						if (out == 0 && s->sEnd != numNuc && s->sEnd == endsVectorRec[w] && s->sEnd > whichSite && w != i && s->sStart <= whichSite && startsVectorRec[w] <= whichSite && endsVectorRec[w] != 0)
							{
							if (noisy == 4)
								fprintf (fpmpi, "\nRepit segment in Right, don't make it");
								
							r->numSegNode--;
								
							bbb++;
							out = 1;
							}
						}
					for (w = 0; w < i+1; w++)
						{
						if (out == 0 && s->sEnd == endsVectorRec[w] && s->sEnd >= whichSite && w != i && s->sStart <= whichSite && startsVectorRec[w] <= whichSite && endsVectorRec[w] != 0)
							{
							if (noisy == 4)
								fprintf (fpmpi, "\nRepit segment in Right, don't make it");
								
							r->numSegNode--;
								
							bbb++;
							out = 1;
							}
						}
					if (out == 0 && s->sEnd >= whichSite)
						{
						if (bb == 0 && bbb == 0)
							{
							if (post(i-b-bb-bbb,r->index,distance) > numTotalSegments) /* checking */
								{
								fprintf (fpmpi, "\n post = %d > numTotalSegments = %d", post(i-b-bb-bbb,r->index,distance), numTotalSegments);
								exit (-7);
								}
							
							m = segments + post(i-b-bb-bbb,r->index,distance);
							m->sIndexNode = secondHalf;
							}
						if (bb > 0 && bbb == 0)
							{
							if (post(i+1-b-bb-bbb,r->index,distance) > numTotalSegments) /* checking */
								{
								fprintf (fpmpi, "\n post = %d > numTotalSegments = %d", post(i+1-b-bb-bbb,r->index,distance), numTotalSegments);
								exit (-7);
								}
							
							m = segments + post(i+1-b-bb-bbb,r->index,distance);
							m->sIndexNode = secondHalf;
							}
						if (bb > 0 && bbb > 0)
							{
							if (post(i+1-b-bb-bbb,r->index,distance) > numTotalSegments) /* checking */
								{
								fprintf (fpmpi, "\n post = %d > numTotalSegments = %d", post(i+1-b-bb-bbb,r->index,distance), numTotalSegments);
								exit (-7);
								}
							
							m = segments + post(i+1-b-bb-bbb,r->index,distance);
							m->sIndexNode = secondHalf;
							}
						if (bb == 0 && bbb > 0)
							{
							if (post(i+0-b-bb-bbb,r->index,distance) > numTotalSegments) /* checking */
								{
								fprintf (fpmpi, "\n post = %d > numTotalSegments = %d", post(i+0-b-bb-bbb,r->index,distance), numTotalSegments);
								exit (-7);
								}
							
							m = segments + post(i+0-b-bb-bbb,r->index,distance);
							m->sIndexNode = secondHalf;
							}
						/* m = s; initial, the new segments are similar to the old segments */
						nodeValue = secondHalf;


						if (doBreakpBroken == YES && s->sStart < whichSite && s->sEnd >= whichSite)
							{
							w = recSegmentsGeneratesRightBrokenCodon(nodeValue, s, m, numNuc, whichSite, LeftLess, RightHigh, &actSegIndex);
							LeftLess2 = LeftLess;
							RightHigh2 = RightHigh;
							}
						else
							{
							w = recSegmentsGeneratesRight(nodeValue, s, m, numNuc, whichSite, &actSegIndex);
							}


						if (w != 1)
							{
							fprintf (fpmpi, "Warning in recSegmentsGeneratesRight");
							exit (-1);
							}
					
						actNumSegments++;
						if (m->sStart == 0 && m->sEnd == 0) /* unreal segments */
							{
							fprintf (fpmpi, "\nNot to be here. Segment Right start and end = 0");
							
							m->before1 = m->before2 = m->after1 = m->after2 = NULL;
							actNumSegments--;
							exit(-1);
							}
						if (noisy == 4)
							{
							fprintf (fpmpi, "\nAfter rec. right");
							fprintf (fpmpi, "\nr->seg->sIndex = %d", m->sIndex);
							fprintf (fpmpi, "\nr->seg->sStart = %d", m->sStart);
							fprintf (fpmpi, "\nr->seg->sEnd = %d\n", m->sEnd);
							} 
						}
					w = out = 0;
					}
			
				free (startsVectorRec);
				free (endsVectorRec);
				a = b = aa = bb = aaa = bbb = 0;

				/* intra codon breakpoints readjust MRCA oct2009 */
				if (doBreakpBroken == YES) /* The codon positions that recombinaed are increased a unit */
					{
					for (w = 1; w <= numNuc; w++)
						{
						if (w >= LeftLess2 && w <= RightHigh2)
							{
							S_MRCA[w]++;
							/*fprintf (fpmpi, "\n Increasing MRCA to %d: now is: %d \n", w, S_MRCA[w]);*/
							}
						}

					}
				/* oct2009 */


				if (noisy == 4)
					{
					fprintf (fpmpi, "\n>> Recombination Results:");
					fprintf (fpmpi, "\nNew left node with %d fragment(s)", q->numSegNode);
					}
				for (w = 0; w < q->numSegNode;w++)
					{
					n = segments + post(w,q->index,distance);
					if (noisy == 4)
						{
						fprintf (fpmpi, "\nq->seg->sIndex = %d", n->sIndex);
						fprintf (fpmpi, "\nq->seg->sStart = %d", n->sStart);
						fprintf (fpmpi, "\nq->seg->sEnd = %d\n", n->sEnd);
						} 
					}
				
				if (noisy == 4)
					fprintf (fpmpi, "\nNew right node with %d fragment(s)", r->numSegNode);
					
				for (w = 0; w < r->numSegNode;w++)
					{
					m = segments + post(w,r->index,distance);
					if (noisy == 4)
						{
						fprintf (fpmpi, "\nr->seg->sIndex = %d", m->sIndex);
						fprintf (fpmpi, "\nr->seg->sStart = %d", m->sStart);
						fprintf (fpmpi, "\nr->seg->sEnd = %d\n", m->sEnd);
						} 
					}
				if (noisy > 3)
					{
					fprintf (fpmpi,"\n");
					/*fprintf (fpmpi, "the node is whichInd = %d, and the site is whichSite = %d", whichInd+1, whichSite+1);*/
					}
				if (noisy > 1)
					{
					fprintf (fpmpi, "Recombination involving %d (copied to %d and %d) in deme %d", p->index, q->index, r->index, p->indexCurrentMigPop);
					fprintf (fpmpi, "\n Breakpoint was at site %d", whichSite);
					}
				if (noisy > 3)
					fprintf (fpmpi,"\n");
				
				if (doBranchNetfiles == YES)
					{
					if (q->NetLabelPrint < numSequences)
						fprintf(fpBranchNet,"%d_seq%05d ", q->NetLabelPrint, q->NetLabelPrint+1);
					else
						fprintf(fpBranchNet,"%d ", q->NetLabelPrint);

					if (p->NetLabelPrint < numSequences)
						fprintf(fpBranchNet,"%d_seq%05d\n", p->NetLabelPrint, p->NetLabelPrint+1);
					else
						fprintf(fpBranchNet,"%d\n", p->NetLabelPrint);

					/*fprintf(fpBranchNet,"%d %d\n", q->NetLabelPrint, p->NetLabelPrint);*/


					/*fprintf(fpBranchNet,"%d %d\n", r->NetLabelPrint, p->NetLabelPrint);*/
					if (noisy > 2)
						fprintf (fpmpi, "\nNET INFORMATION Recombination involving %d (copied to %d and %d) in deme %d", p->NetLabelPrint, q->NetLabelPrint, r->NetLabelPrint, p->indexCurrentMigPop);
					}
					
					
				breakpoint[numRE-1] = whichSite;  /* the breakpoint site is call breakpoint. breakpoint[0] = 7, breakpoint[1] = 96, breakpoint[2] = 187.. */
				
				/* readjust active sites */
				activeGametes[whichInd] = firstHalf;	/* new active nodes firstHalf and secondHalf */
				activeGametes[numActiveGametes++] = secondHalf;		/* there are 1 active node more (in recombination) */
			
				w = 0;	
				for (k = 1; k <= numPopulations+currentBigDeme; k++)
					{
					if (k == p->indexCurrentMigPop)
						numParcialActiveGametes[k] = numParcialActiveGametes[k] +1;
					w = w + numParcialActiveGametes[k];
					}
				if (w != numActiveGametes)
					{
					fprintf (fpmpi, "\n 4The sum of partial active gametes is different than total gametes number, w %d != numActiveGametes %d. In choose the deme", w, numActiveGametes);
					exit (-1);
					}
				}
		
		
			/*** MIGRATION ***/
			if (isMigration == YES) 
				{
				if (noisy == 4)
					fprintf (fpmpi, "\n* Migration *");			
					
				/* Which node has the migration? */
				cumPopulPart = (double *) calloc((numParcialActiveGametes[whichDeme]+1),(long) sizeof(double));
				if (!cumPopulPart)
					{
					fprintf (fpmpi, "Could not allocate cumPopulPart (%lu bytes)\n", (numParcialActiveGametes[whichDeme]+1) *(long) sizeof(double));
					exit (-1);
					}
			
				for (k = 1; k <= numParcialActiveGametes[whichDeme]; k++)
					cumPopulPart[k] = 0;
				cumPopulPart[0] = 0;
				w = 0;
			
				for (k = 1; k <= numParcialActiveGametes[whichDeme]; k++)
					cumPopulPart[k] = cumPopulPart[k-1] + 1.0/numParcialActiveGametes[whichDeme];
				/*fprintf(fpmpi, "\n cumPopulPart[numParcialActiveGametes[whichDeme]] = %lf", cumPopulPart[numParcialActiveGametes[whichDeme]]);*/
				for (k = 1; k <= numPopulations+currentBigDeme; k++)
					w = w + numParcialActiveGametes[k];				
					
				if (w != numActiveGametes)
					{
					fprintf (fpmpi, "\n 5The sum of partial active gametes is different than total gametes number, w %d != numActiveGametes %d. In choose the deme", w, numActiveGametes);
					exit (-1);
					}
				
				ran = RandomUniform(seed);
				whichInd = bbinDemes(ran, cumPopulPart, numParcialActiveGametes[whichDeme]);
				w = 0;
				for (i = 0; i < numActiveGametes; i++)
					{
					p = nodes + activeGametes[i];
			
					if (p->indexCurrentMigPop == whichDeme)
						w++;
						
					if (w == whichInd)
						{
						whichInd = i;
						break;
						}
					}
				free (cumPopulPart);
			

				/* Which arrived Deme? */ /* New migration models: doMigrationIsland, doMigrationSTST, doMigrationIslCont */			
				for (k = 1; k <= numPopulations+currentBigDeme; k++)
					cumPopulTase[k] = 0;
				cumPopulTase[0] = 0;
				w = c = e = 0;
				/*fprintf(fpmpi, "\n whichDeme = %d \n", whichDeme);*/

				if (doConvergDemes == YES)
					{
					ArrivedDemesOptions = (int *)calloc((currentDemesNumber+1),(long) sizeof(int));
					if (!ArrivedDemesOptions)
						{
						fprintf (fpmpi, "Could not allocate ArrivedDemesOptions (%lu bytes)\n", (currentDemesNumber+1)  * (long) sizeof(int));
						exit (1);
						}
					for (k = 1; k <= currentDemesNumber; k++)
						ArrivedDemesOptions[k] = 0;
					ArrivedDemesOptions[0] = 0;

					e = 1;
					w = 1;
					for (k = 1; k <= 2*numPopulations-1; k++)
						{
						if (CurrentDemesState[k] != 0)
							{
							ArrivedDemesOptions[w] = CurrentDemesState[k];
							w++;
							}
						}
					if (w != currentDemesNumber+1) /* Checking */
						{
						fprintf (fpmpi, "\n Warning in currentDemesNumber: w = %d, currentDemesNumber+1 = %d\n", w, currentDemesNumber+1);
						fprintf (fpmpi, "\n Check if you have fixed the convergence of two demes which do not exist at that convergence time\n");
						exit (1);
						}
					
					/*for (k = 0; k < numActiveGametes; k++)
						{
						p = nodes + activeGametes[k];
						if (k == 0)
							{
							ArrivedDemesOptions[e] = p->indexCurrentMigPop;
							e++;
							}
						else
							{
							c = 0;
							for (w = 1; w <= currentDemesNumber; w++)
								if (p->indexCurrentMigPop != ArrivedDemesOptions[w])
									c++;
							if (c == currentDemesNumber)
								{
								ArrivedDemesOptions[e] = p->indexCurrentMigPop;
								e++;
								}
							}
							
						fprintf (fpmpi, " \nNode %d of deme %d", p->index, p->indexCurrentMigPop);
						}*/		
					

					/*for (k = 1; k <= currentDemesNumber; k++)
						fprintf (fpmpi, " \n ArrivedDemesOptions[%d] = %d", k, ArrivedDemesOptions[k]);*/ /* To see the array of current active demes*/
				
					/*if (e != currentDemesNumber+1)
						{
						fprintf (fpmpi, "\n Warning in currentDemesNumber: e = %d, currentDemesNumber+1 = %d\n", e, currentDemesNumber+1);
						fprintf (fpmpi, "\n Check if you have fixed the convergence of two demes which do not exit at that time\n");
						exit (1);
						}*/ /* This is not an error */
					w = e = c = 0;

					if (doMigrationIsland == YES) /* migrations go to any other deme */
						{
						for (k = 1; k <= numPopulations+currentBigDeme; k++)
							{
							if (k == whichDeme)
								cumPopulTase[k] = cumPopulTase[k-1];
							else
								{
								c = 0;
								for (w = 1; w <= currentDemesNumber; w++)
									if (k == ArrivedDemesOptions[w])
										c++;
								if (c > 0)
									cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(currentDemesNumber-1);
								else
									cumPopulTase[k] = cumPopulTase[k-1];
								}
							}
						}
					else if (doMigrationSTST == YES) /* migrations go only to close neighboring demes */ /* MIGUEL */
						{
						controlConvSTST1 = summConvSTST1 = controlConvSTST2 = summConvSTST2 = 0;

						for (k = 1; k <= numPopulations+currentBigDeme; k++)
							{
	
							if (k == whichDeme)
								cumPopulTase[k] = cumPopulTase[k-1];
							else
								{
								c = 0;
								for (w = 1; w <= currentDemesNumber; w++)
									if (k == ArrivedDemesOptions[w])
										c++;

								if (c > 0)
									{

									/**/
									if (whichDeme == ArrivedDemesOptions[1]) 
										{
										
										OkValue = ArrivedDemesOptions[2];

										for (tt = 1; tt <= currentDemesNumber; tt++)
											if (ArrivedDemesOptions[tt] < OkValue && ArrivedDemesOptions[tt] != whichDeme)
												OkValue = ArrivedDemesOptions[tt];
										
										if (k == OkValue)
											cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(1);
										else
											cumPopulTase[k] = cumPopulTase[k-1];

										/*if (controlConvSTST1 == 0)
											{
											if (k == whichDeme + summConvSTST1 + 1)
												{
												cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(1);
												controlConvSTST1++;
												}
											else
												cumPopulTase[k] = cumPopulTase[k-1];

											summConvSTST1++;
											}*/

										}
									else if (whichDeme == ArrivedDemesOptions[currentDemesNumber]) 
										{

										OkValue = ArrivedDemesOptions[currentDemesNumber-1];
										
										for (tt = 1; tt <= currentDemesNumber; tt++)
											if (ArrivedDemesOptions[tt] > OkValue && ArrivedDemesOptions[tt] != whichDeme)
												OkValue = ArrivedDemesOptions[tt];
										
										if (k == OkValue)
											cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(1);
										else
											cumPopulTase[k] = cumPopulTase[k-1];


									/*	if (controlConvSTST2 == 0)
											{
											if (k == whichDeme - summConvSTST2 - 1)
												{
												cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(1);
												controlConvSTST2++;
												}
											else
												cumPopulTase[k] = cumPopulTase[k-1];

											summConvSTST2++;

											}*/
										}									
									else
										{
										
										/* lower */
										OkValue1 = ArrivedDemesOptions[1];

										for (tt = 1; tt <= currentDemesNumber; tt++)
											if (ArrivedDemesOptions[tt] < whichDeme && ArrivedDemesOptions[tt] > OkValue1)
												OkValue1 = ArrivedDemesOptions[tt];
										
										/* higher */
										OkValue2 = ArrivedDemesOptions[currentDemesNumber];

										for (tt = 1; tt <= currentDemesNumber; tt++)
											if (ArrivedDemesOptions[tt] > whichDeme && ArrivedDemesOptions[tt] < OkValue2)
												OkValue2 = ArrivedDemesOptions[tt];


										if (k == OkValue1)
											cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(2);
										else if (k == OkValue2)
											cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(2);
										else
											cumPopulTase[k] = cumPopulTase[k-1];	

										}



									}	
								else
									cumPopulTase[k] = cumPopulTase[k-1];
		
								}


							} /* end for */
						} /* end doMigrationSTST in conv demes */
					else if (doMigrationIslCont == YES) /* migrations go only by continent <-> islands demes */ /* MIGUEL */ 
						{
						/*fprintf (fpmpi, "\n In doMigrationIslCont with conv demes \n");*/

						for (k = 1; k <= numPopulations+currentBigDeme; k++)
							{
	
							if (k == whichDeme)
								cumPopulTase[k] = cumPopulTase[k-1];
							else
								{
								c = 0;
								for (w = 1; w <= currentDemesNumber; w++)
									if (k == ArrivedDemesOptions[w])
										c++;

								if (c > 0)
									{
									/**/
									if (newOkValueCI == 0) /* convergence of demes still did not occur */
										{
										OkValueCI = ArrivedDemesOptions[1];
										for (tt = 1; tt <= currentDemesNumber; tt++)
												if (ArrivedDemesOptions[tt] < OkValueCI)
													OkValueCI = ArrivedDemesOptions[tt]; /* lowest value (OkValueCI) = continent */
										}

									/*fprintf (fpmpi, "\n whichDeme = %d; goes to deme k = %d; continent deme (OkValueCI) = %d \n", whichDeme, k, OkValueCI);*/


									if (whichDeme == OkValueCI) /* whichDeme is continent and can go to any island */
										{
										/*fprintf (fpmpi, "  CASE1: whichDeme = %d; k = %d; OkValueCI = %d \n", whichDeme, k, OkValueCI);*/

										if (k == whichDeme)
											cumPopulTase[k] = cumPopulTase[k-1];
							 			else
											cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(currentDemesNumber-1);
										}
									else  /* whichDeme is island and can go only to the continent */
										{
										/*fprintf (fpmpi, "  CASE2: whichDeme = %d; k = %d; OkValueCI = %d \n", whichDeme, k, OkValueCI);*/

										if (k == OkValueCI)
											cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(1);
										else
											cumPopulTase[k] = cumPopulTase[k-1];
										}									
									}	
								else
									cumPopulTase[k] = cumPopulTase[k-1];
		
								}


							} /* end for */
						} /* end doMigrationIslCont in conv demes */
					else
						{
						fprintf(fpmpi, "\nError in migration model (MakeCoalescenceTree function)1. \n\n");
						exit(-1);
						}


					} /* end conv demes */
				else	
					{
					if (doMigrationIsland == YES) /* migrations go to any other deme */
						{
						for (k = 1; k <= numPopulations+currentBigDeme; k++)
							{
							if (k == whichDeme)
								cumPopulTase[k] = cumPopulTase[k-1];
							 else
								cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(numPopulations+currentBigDeme-1);
							}
						}
					else if (doMigrationSTST == YES) /* migrations go only to close neighboring demes */
						{

						for (k = 1; k <= numPopulations+currentBigDeme; k++)
							{
							if (whichDeme == 1) /* node in deme 1, goes only to deme 2 */
								{
								if (k == whichDeme + 1)
									cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(1);
								else
									cumPopulTase[k] = cumPopulTase[k-1];
								}
							else if (whichDeme == numPopulations+currentBigDeme) /* node in deme max, goes only to deme max-1 */
								{
								if (k == whichDeme - 1)
									cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(1);
								else
									cumPopulTase[k] = cumPopulTase[k-1];
								}
							else /* node in other deme, goes to deme + or -1 */
								{
								if (k == whichDeme - 1)
									cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(2);
								else if (k == whichDeme + 1)
									cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(2);
								else
									cumPopulTase[k] = cumPopulTase[k-1];
								}
							}

						}
					else if (doMigrationIslCont == YES) /* migrations go only by continent <-> islands demes */
						{

						for (k = 1; k <= numPopulations+currentBigDeme; k++)
							{
							if (whichDeme == 1) /* node in deme 1 (continent) can go to any other deme (islands) */
								{
								if (k == whichDeme)
									cumPopulTase[k] = cumPopulTase[k-1];
								 else
									cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(numPopulations+currentBigDeme-1);
								}
							else /* node in other deme (island) can go only to deme 1 (continent) */
								{
								if (k == 1)
									cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(1);
								else
									cumPopulTase[k] = cumPopulTase[k-1];
								}
							}

						}
					else
						{
						fprintf(fpmpi, "\nError in migration model (MakeCoalescenceTree function)2. \n\n");
						exit(-1);
						}


					}
				

				/*for (k = 1; k <= numPopulations+currentBigDeme; k++)
					fprintf(fpmpi, "\n cumPopulTase[%d] = %lf", k, cumPopulTase[k]);
				fprintf(fpmpi, "\n numPopulations+currentBigDeme = %d \n", numPopulations+currentBigDeme);*/



				ran = RandomUniform(seed);
				arrivedDeme = bbinDemes(ran, cumPopulTase, numPopulations+currentBigDeme); 		/* Check: this fails if cumPopulTase at the end is != 1 */
				/*fprintf(fpmpi,"\n To deme %d  \n", arrivedDeme);*/
				w = 0;
				
				if (whichDeme == arrivedDeme) /* Cheking */
					{
					fprintf (fpmpi, "\n\nERROR in migration, whichDeme == arrivedDeme");
					exit (-1);
					}
				if (doConvergDemes == YES)
					free (ArrivedDemesOptions);
				/* evolution migration node*/
				p = nodes + activeGametes[whichInd];
				if (p->indexCurrentMigPop != whichDeme)
					{
					fprintf (fpmpi, "\n\nERROR in migration, p->indexCurrentMigPop != whichDeme");
					exit (-1);
					}
			
				p->indexCurrentMigPop = arrivedDeme; /* Changing the deme */
			
				if (noisy == 4)
					{
					fprintf (fpmpi, "\nNode %d migrates from deme %d to deme %d", p->index, whichDeme, arrivedDeme);
					fprintf (fpmpi, "\nThis node contains %d fragment(s):", p->numSegNode);	
					}
				for (w = 0; w < p->numSegNode; w++)
					{
					s = segments + post(w,p->index,distance);
					if (noisy == 4)
						{
						fprintf (fpmpi, "\ns->sIndex = %d", s->sIndex);
						fprintf (fpmpi, "\ns->sStart = %d", s->sStart);
						fprintf (fpmpi, "\ns->sEnd = %d",s->sEnd);
						}
					}
				/*numParcialActiveGametes[k] ++ y --*/
				numParcialActiveGametes[whichDeme] = numParcialActiveGametes[whichDeme]-1;
				numParcialActiveGametes[arrivedDeme] = numParcialActiveGametes[arrivedDeme]+1;								
				k = 0;
				
					
				if (noisy == 4)
					fprintf (fpmpi, "\n");
				if (noisy > 1)
					fprintf (fpmpi, "Migration involving node %d from deme %d to deme %d", p->index, whichDeme, arrivedDeme);
				if (noisy == 4)
					fprintf (fpmpi, "\n");
				}
		
		
			/*** COALESCENCE ***/
			if (isCoalescence == YES)
				{
				if (noisy == 4)
					fprintf (fpmpi, "\n* Coalescence *\n");
					
				/* figure out which two nodes are involved */ 			
				/* intial nodes: firstInd and secondInd (they are the descendants). newInd is the ancestral node, is the new node to make */
				cumPopulPart = (double *) calloc((numParcialActiveGametes[whichDeme]+1),(long) sizeof(double));
				if (!cumPopulPart)
					{
					fprintf (fpmpi, "Could not allocate cumPopulPart (%lu bytes)\n", (numParcialActiveGametes[whichDeme]+1) *(long) sizeof(double));
					exit (-1);
					}
				
				for (k = 1; k <= numParcialActiveGametes[whichDeme]; k++)
					cumPopulPart[k] = 0;
				cumPopulPart[0] = 0;
				w = 0;
			
				for (k = 1; k <= numParcialActiveGametes[whichDeme]; k++)
					cumPopulPart[k] = cumPopulPart[k-1] + 1.0/numParcialActiveGametes[whichDeme];
					
				for (k = 1; k <= numPopulations+currentBigDeme; k++)
					w = w + numParcialActiveGametes[k];
					
				if (w != numActiveGametes)
					{
					fprintf (fpmpi, "\n 6The sum of partial active gametes is different than total gametes number, w %d != numActiveGametes %d. In choose the deme", w, numActiveGametes);
					exit (-1);
					}
				
				ran = RandomUniform(seed);
				firstInd = bbinDemes(ran, cumPopulPart, numParcialActiveGametes[whichDeme]);
				w = 0;
				for (i = 0; i < numActiveGametes; i++)
					{
					p = nodes + activeGametes[i];
			
					if (p->indexCurrentMigPop == whichDeme)
						w++;
						
					if (w == firstInd)
						{
						firstInd = i;
						break;
						}
					}
				if (firstInd >= numActiveGametes) /* checking */
					{
					fprintf (fpmpi, "\n\nERROR: firstInd out of range!\n");
					exit (-1);
					}
					
				do
					{
					for (k = 1; k <= numParcialActiveGametes[whichDeme]; k++)
						cumPopulPart[k] = 0;
					cumPopulPart[0] = 0;
					w = 0;
			
					for (k = 1; k <= numParcialActiveGametes[whichDeme]; k++)
						cumPopulPart[k] = cumPopulPart[k-1] + 1.0/numParcialActiveGametes[whichDeme];
						
					for (k = 1; k <= numPopulations+currentBigDeme; k++)
						w = w + numParcialActiveGametes[k];				
						
					if (w != numActiveGametes)
						{
						fprintf (fpmpi, "\n 7The sum of partial active gametes is different than total gametes number, w %d != numActiveGametes %d. In choose the deme", w, numActiveGametes);
						exit (-1);
						}
				
					ran = RandomUniform(seed);
					secondInd = bbinDemes(ran, cumPopulPart, numParcialActiveGametes[whichDeme]);
					w = 0;
					for (i = 0; i < numActiveGametes; i++)
						{
						p = nodes + activeGametes[i];
			
						if (p->indexCurrentMigPop == whichDeme)
							w++;
							
						if (w == secondInd)
							{
							secondInd = i;
							break;
							}
						}
					} while (firstInd == secondInd);
				free (cumPopulPart);			
			
				newInd = nextAvailable;
				if (noisy > 1)
					fprintf (fpmpi, "Coalescence involving %d and %d to create node %d in deme %d", activeGametes[firstInd], activeGametes[secondInd], newInd, whichDeme);
					
				p = nodes + activeGametes[firstInd];
				q = nodes + activeGametes[secondInd];
				
				if (p->numSegNode > maxSegNode) 
					{
					fprintf (fpmpi, "\n\nWarning, too many segments in this node. max = %d", maxSegNode);
					fprintf (fpmpi, "\n p->numSegNode = %d",p->numSegNode);
					exit(9);
					}
				if (q->numSegNode > maxSegNode)
					{
					fprintf (fpmpi, "\n\nWarning, too many segments in this node. max = %d", maxSegNode);
					fprintf (fpmpi, "\n q->numSegNode = %d",q->numSegNode);
					exit(9);
					}

				r = nodes + newInd;		/* new ancester */
				r->index = nextAvailable;
				r->label = labelNodes++;
				r->indexOldMigPop = r->indexCurrentMigPop = whichDeme;
				
				r->breakp = NO;
				r->breakCodon = NO;
				r->class = 4;
				r->GMRCA_ancestral = NO;
				/*fprintf (fpmpi, "\nobtained r->index = %d: r->breakp = %d, r->breakCodon = %d, r->class = %d \n", r->index, r->breakp, r->breakCodon, r->class);*/
				
				for (mmm = 1; mmm <= numNuc; mmm++)	 /* for each segment of p node going to r node*/
					{
					sigue = 0;
					stateHere_P = -2; /* -2, non ancestral; 0 ancestral */
					stateHere_Q = -2; /* -2, non ancestral; 0 ancestral */

					for (i = 0; i < p->numSegNode; i++)	 /* for each segment of p node going to r node*/
						{
						s = segments + post(i,p->index,distance);
						if (mmm >= s->sStart && mmm <= s->sEnd) /* is ancestral material */
							{
							stateHere_P = 0;
							}
						}
					for (i = 0; i < q->numSegNode; i++)	/* for each segment of q node going to r node */
						{
						n = segments + post(i,q->index,distance);
						if (mmm >= n->sStart && mmm <= n->sEnd) /* is ancestral material */
							{
							stateHere_Q = 0;
							}
						}
					
					
					/*fprintf (fpmpi, "\n Here(%d) stateHere_P = %d and stateHere_Q = %d ", mmm, stateHere_P, stateHere_Q);
					fprintf (fpmpi, "\n  Here(%d), node %d: p->SitesNonAncHere[mmm] = %d && node %d: q->SitesNonAncHere[mmm] = %d \n", mmm, p->index, p->SitesNonAncHere[mmm], q->index, q->SitesNonAncHere[mmm]);*/

					if (stateHere_P < 0 && stateHere_Q < 0) /* non ancestral material */
						{
						r->SitesNonAncHere[mmm] = -1;
						sigue++;
						/*fprintf (fpmpi, "1Position %d is NON anc mat \n", mmm);*/
						}
					if (stateHere_P >= 0 || stateHere_Q >= 0) /* ancestral material (inc pseudo) */
						{
						if (p->SitesNonAncHere[mmm] == 1 && q->SitesNonAncHere[mmm] == 1 && sigue == 0) /* pseudo anc mat */
							{
							r->SitesNonAncHere[mmm] = 1;
							sigue++;
							/*fprintf (fpmpi, "2Position %d is PSEUDO anc mat \n", mmm);*/
							}
						if (p->SitesNonAncHere[mmm] == 1 && stateHere_Q < 0 && sigue == 0) /* pseudo anc mat */
							{
							r->SitesNonAncHere[mmm] = 1;
							sigue++;
							/*fprintf (fpmpi, "3Position %d is PSEUDO anc mat \n", mmm);*/
							}
						if (q->SitesNonAncHere[mmm] == 1 && stateHere_P < 0 && sigue == 0) /* pseudo anc mat */
							{
							r->SitesNonAncHere[mmm] = 1;
							sigue++;
							/*fprintf (fpmpi, "4Position %d is PSEUDO anc mat \n", mmm);*/
							}
						if (sigue == 0)
							{
							if (p->SitesNonAncHere[mmm] == 0 || q->SitesNonAncHere[mmm] == 0)  /* anc mat */
								{
								r->SitesNonAncHere[mmm] = 0;
								sigue++;
								/*fprintf (fpmpi, "5Position %d is ANC mat \n", mmm);*/
								}
							}
						}
					}

				/*fprintf (fpmpi, "\nobtained r->index = %d: r->breakp = %d, r->breakCodon = %d, r->class = %d \n", r->index, r->breakp, r->breakCodon, r->class);*/



				if (doBranchNetfiles == YES)
					{
					r->NetLabelPrint = numNetLabelPrint;
					numNetLabelPrint++;

					if (p->NetLabelPrint == q->NetLabelPrint)
						{

						if (r->NetLabelPrint < numSequences)
							fprintf(fpBranchNet,"%d_seq%05d ", r->NetLabelPrint, r->NetLabelPrint+1);
						else
							fprintf(fpBranchNet,"%d ", r->NetLabelPrint);

						if (p->NetLabelPrint < numSequences)
							fprintf(fpBranchNet,"%d_seq%05d\n", p->NetLabelPrint, p->NetLabelPrint+1);
						else
							fprintf(fpBranchNet,"%d\n", p->NetLabelPrint);

						/*fprintf(fpBranchNet,"%d %d\n", r->NetLabelPrint, p->NetLabelPrint);*/
						}
					else
						{


						if (r->NetLabelPrint < numSequences)
							fprintf(fpBranchNet,"%d_seq%05d ", r->NetLabelPrint, r->NetLabelPrint+1);
						else
							fprintf(fpBranchNet,"%d ", r->NetLabelPrint);

						if (p->NetLabelPrint < numSequences)
							fprintf(fpBranchNet,"%d_seq%05d\n", p->NetLabelPrint, p->NetLabelPrint+1);
						else
							fprintf(fpBranchNet,"%d\n", p->NetLabelPrint);


						if (r->NetLabelPrint < numSequences)
							fprintf(fpBranchNet,"%d_seq%05d ", r->NetLabelPrint, r->NetLabelPrint+1);
						else
							fprintf(fpBranchNet,"%d ", r->NetLabelPrint);

						if (q->NetLabelPrint < numSequences)
							fprintf(fpBranchNet,"%d_seq%05d\n", q->NetLabelPrint, q->NetLabelPrint+1);
						else
							fprintf(fpBranchNet,"%d\n", q->NetLabelPrint);

						/*fprintf(fpBranchNet,"%d %d\n", r->NetLabelPrint, p->NetLabelPrint);
						fprintf(fpBranchNet,"%d %d\n", r->NetLabelPrint, q->NetLabelPrint);*/
						}
					if (noisy > 2)
						fprintf (fpmpi, "\nNET INFORMATION Coalescence involving %d and %d to create node %d in deme %d", p->NetLabelPrint, q->NetLabelPrint, r->NetLabelPrint, whichDeme);
					}
				

				coalVectorCountStarts = (int *) calloc((p->numSegNode+q->numSegNode),(long) sizeof(int));
				if (!coalVectorCountStarts)
					{
					fprintf (fpmpi, "Could not allocate coalVectorCountStarts (%lu bytes)\n", (p->numSegNode+q->numSegNode) *(long) sizeof(int));
					exit (-1);
					}
				coalVectorCountEnds = (int *) calloc((p->numSegNode+q->numSegNode),(long) sizeof(int));
				if (!coalVectorCountEnds)
					{
					fprintf (fpmpi, "Could not allocate coalVectorCountEnds (%lu bytes)\n", (p->numSegNode+q->numSegNode) *(long) sizeof(int));
					exit (-1);
					}
				
				for (i = 0; i < p->numSegNode; i++)	 /* for each segment of p node going to r node */
					{
					s = segments + post(i,p->index,distance);
					if (post(i,r->index,distance) > numTotalSegments) /* control */
						{
						fprintf (fpmpi, "\n post = %d > numTotalSegments = %d", post(w,r->index,distance), numTotalSegments);
						exit (-7);
						}
					
					m = segments + post(i,r->index,distance);					/* new ancester */
					m->sIndexNode = newInd;
					
					s->before1 = m;
					m->before1 = NULL;
					m->before2 = NULL;
					m->after1 = s;
					m->after2 = NULL;
					m->sIndex = actSegIndex;
					m->sStart = s->sStart;
					m->sEnd = s->sEnd;				

					actSegIndex++;
					actNumSegments++;
					/*r->numSegNode++;*/
						
					if (m->sStart == 0 && m->sEnd == 0) /* unreal segments */
						{
						fprintf (fpmpi, "\nNot to be here. COAL1, segment start and end = 0");
						
						m->before1 = m->before2 = m->after1 = m->after2 = NULL;
						actNumSegments--;
						exit(-1);
						}
					coalVectorCountStarts[i] = s->sStart;
					coalVectorCountEnds[i] = s->sEnd;
					}
				
				j = p->numSegNode;
				r->numSegNode = j;
				a = b = 0;
				
				for (i = 0; i < q->numSegNode; i++)	/* for each segment of q node going to r node */
					{
					if (post(i,q->index,distance) > numTotalSegments) /* Cheking */
						{
						fprintf (fpmpi, "\n post = %d > numTotalSegments = %d", post(w,q->index,distance), numTotalSegments);
						exit (-7);
						}
					n = segments + post(i,q->index,distance);
				
					for (w = 0; w < j; w++)
						if (n->sStart == coalVectorCountStarts[w] && n->sEnd == coalVectorCountEnds[w]) /* Segmento repetido */
							a++; 
					
					if (a == 0)
						{
						m = segments + post(b+j,r->index,distance);					/* new ancester */						
						
						r->numSegNode++;
						n->before1 = m;
						m->before1 = NULL;
						m->before2 = NULL;
						m->after1 = n;
						m->after2 = NULL;
						m->sIndexNode = newInd;
						m->sIndex = actSegIndex;
						m->sStart = n->sStart;
						m->sEnd = n->sEnd;				
					
						actSegIndex++;
						b++;
						actNumSegments++;
						/*r->numSegNode++;*/
						if (m->sStart == 0 && m->sEnd == 0) /* unreal segments */
							{
							fprintf (fpmpi, "\nNot to be here. COAL2, segment start and end = 0");
							
							m->before1 = m->before2 = m->after1 = m->after2 = NULL;
							actNumSegments--;
							}
						}
					a = 0;
					}
				
				a = b = 0;
				free (coalVectorCountStarts);
				free (coalVectorCountEnds);
				

					/* Segment Bonds when this segment goes to 2 descendants segments */
				coalEqualSegInit_p = (int *) calloc((p->numSegNode+q->numSegNode),(long) sizeof(int));
				if (!coalEqualSegInit_p)
					{
					fprintf (fpmpi, "Could not allocate coalEqualSegInit_p (%lu bytes)\n", (p->numSegNode+q->numSegNode) *(long) sizeof(int));
					exit (-1);
					}
				coalEqualSegEnd_p = (int *) calloc((p->numSegNode+q->numSegNode),(long) sizeof(int));
				if (!coalEqualSegEnd_p)
					{
					fprintf (fpmpi, "Could not allocate coalEqualSegEnd_p (%lu bytes)\n", (p->numSegNode+q->numSegNode) *(long) sizeof(int));
					exit (-1);
					}
				coalEqualSegInit_q = (int *) calloc((p->numSegNode+q->numSegNode),(long) sizeof(int));
				if (!coalEqualSegInit_q)
					{
					fprintf (fpmpi, "Could not allocate coalEqualSegInit_q (%lu bytes)\n", (p->numSegNode+q->numSegNode) *(long) sizeof(int));
					exit (-1);
					}
				coalEqualSegEnd_q = (int *) calloc((p->numSegNode+q->numSegNode),(long) sizeof(int));
				if (!coalEqualSegEnd_q)
					{
					fprintf (fpmpi, "Could not allocate coalEqualSegEnd_q (%lu bytes)\n", (p->numSegNode+q->numSegNode) *(long) sizeof(int));
					exit (-1);
					}
				
				for (w = 0; w < p->numSegNode; w++)	
					{
					s = segments + post(w,p->index,distance);
					coalEqualSegInit_p[w] = s->sStart;
					coalEqualSegEnd_p[w] = s->sEnd;
					}
				for (w = 0; w < q->numSegNode; w++)	
					{
					n = segments + post(w,q->index,distance);
					coalEqualSegInit_q[w] = n->sStart;
					coalEqualSegEnd_q[w] = n->sEnd;
					}
				for (w = 0; w < p->numSegNode; w++)
					{
					for (i = 0; i < q->numSegNode; i++)
						{
						if (coalEqualSegInit_p[w] != 0 && coalEqualSegEnd_p[w] != 0 && coalEqualSegInit_p[w] == coalEqualSegInit_q[i] && coalEqualSegEnd_p[w] == coalEqualSegEnd_q[i])
							{
							for (a = 0; a < r->numSegNode; a++)	
								{
								m = segments + post(a,r->index,distance);
									
								if (m->sStart == coalEqualSegInit_p[w] && m->sEnd == coalEqualSegEnd_p[w])
									{
									if (noisy == 4)
										fprintf (fpmpi, "\nFragment %d links to 2 descendants, ", m->sIndex);
										
									for (b = 0; b < p->numSegNode; b++)
										{
										s = segments + post(b,p->index,distance);
												
										if (coalEqualSegInit_p[w] == s->sStart && coalEqualSegEnd_p[w] == s->sEnd)
											{
											m->after1 = s;
											if (noisy == 4)
												fprintf (fpmpi, "fragment %d", s->sIndex);
											}
										}
									for (b = 0; b < q->numSegNode; b++)
										{
										n = segments + post(b,q->index,distance);
										
										if (coalEqualSegInit_p[w] == n->sStart && coalEqualSegEnd_p[w] == n->sEnd)
											{
											m->after2 = n;
											if (noisy == 4)
												fprintf (fpmpi, " and fragment %d", n->sIndex);
											}
										}
									}
								}
							}
						}
					}
						
				
				for (i = 0; i < r->numSegNode; i++)			/* cheking, if there are 2 similar segments, it keeps only 1 */		
					{
					m = segments + post(i,r->index,distance);
				
					for (w = 0; w < r->numSegNode; w++)
						{
						z = segments + post(w,r->index,distance);
					
						if (w != i && m->sStart == z->sStart && m->sEnd == z->sEnd && m->after1 != NULL) /* Cheking */
							{
							fprintf (fpmpi, "\n1COAL. Not to be here. it does not to be 2 equal segments in this node %d. index %d y %d", m->sIndex, z->sIndex, r->index);
							fprintf (fpmpi, "\n m->sStart = %d, m->sEnd = %d, m->sIndexNode = %d", m->sStart, m->sEnd, m->sIndexNode);
							fprintf (fpmpi, "\n z->sStart = %d, z->sEnd = %d, z->sIndexNode = %d", z->sStart, z->sEnd, z->sIndexNode);
							
							fprintf (fpmpi, "\n post(i,r->index,distance) = %d", post(i,r->index,distance));
							fprintf (fpmpi, "\n post(w,r->index,distance) = %d", post(w,r->index,distance));
							fprintf (fpmpi, "\n r->index = %d", r->index);
								
							z->after1 = z->after2 = z->before1 = z->before2 = NULL; /* continue only the z segment */
							r->numSegNode--;
							exit(-1);
							}
						}
					}
				j = w = a = b = 0;
				free (coalEqualSegInit_p);
				free (coalEqualSegEnd_p);
				free (coalEqualSegInit_q);
				free (coalEqualSegEnd_q);
				
				
				if (noisy == 4)
					{
					fprintf (fpmpi, "\n\nCoalescence Result is the new node %d with %d fragment(s)", r->index, r->numSegNode);
					for (i = 0; i < r->numSegNode; i++)	
						{
						m = segments + post(i,r->index,distance);
						/*fprintf (fpmpi, "\npost(i,r->index,distance) = %d",post(i,r->index,distance));*/
						/*fprintf (fpmpi, "\nNode r->index = %d", r->index);*/
						fprintf (fpmpi, "\nFragment %d, ", m->sIndex);	
						fprintf (fpmpi, "m->sStart = %d", m->sStart);
						fprintf (fpmpi, " and m->sEnd = %d", m->sEnd);
						}
					fprintf (fpmpi, "\n");
					}
					
			
				/* MRCA */
				/* Array with the information about ancestral stuff */
				/* S_MRCA. overFirst is the biggest site by left & overEnd is the smallest site by right. The difference is the overLapSites */
				sizeNode_p = p->numSegNode;
				sizeNode_q = q->numSegNode;
				out = 0;
			
				if (r->numSegNode == 1) /* 1.- fast. Only 1 segment */
					{
					for (i = 0; i < r->numSegNode; i++)	
						m = segments + post(i,r->index,distance);
						
					overFirst = m->sStart;
					overEnd = m->sEnd;
				
					for (j = 1; j <= numNuc; j++)
						if (j >= overFirst && j <= overEnd)
							{
							S_MRCA[j]--;
							}
					out = 1;
					}
				a = b = k = 0;
			
				if (r->numSegNode > 1)	
					{
					initialVector_pp = (int *) calloc((p->numSegNode),(long) sizeof(int));
					if (!initialVector_pp)
						{
						fprintf (fpmpi, "Could not allocate initialVector_pp (%lu bytes)\n", (p->numSegNode) *(long) sizeof(int));
						exit (-1);
						}
					endVector_pp = (int *) calloc((p->numSegNode),(long) sizeof(int));
					if (!endVector_pp)
						{
						fprintf (fpmpi, "Could not allocate endVector_pp (%lu bytes)\n", (p->numSegNode) *(long) sizeof(int));
						exit (-1);
						}
					initialVector_qq = (int *) calloc((q->numSegNode),(long) sizeof(int));
					if (!initialVector_qq)
						{
						fprintf (fpmpi, "Could not allocate initialVector_qq (%lu bytes)\n", (q->numSegNode) *(long) sizeof(int));
						exit (-1);
						}
					endVector_qq = (int *) calloc((q->numSegNode),(long) sizeof(int));
					if (!endVector_qq)
						{
						fprintf (fpmpi, "Could not allocate endVector_qq (%lu bytes)\n", (q->numSegNode) *(long) sizeof(int));
						exit (-1);
						}
				
					/* 2.- Fast. There is a segment more big than the other segments */
					for (position = 0; position < p->numSegNode; position++)
						{
						s = segments + post(position,p->index,distance);
						initialVector_pp[position] = s->sStart;
						endVector_pp[position] = s->sEnd;
						}
					for (position = 0; position < q->numSegNode; position++)
						{
						n = segments + post(position,q->index,distance);
						initialVector_qq[position] = n->sStart;
						endVector_qq[position] = n->sEnd;
						}
					
					/* smaller value for the initial */
					for (position = 0; position < p->numSegNode; position++)
						{
						if (position == 0)
							minInit_pp = initialVector_pp[position];
						if (initialVector_pp[position] < minInit_pp && initialVector_pp[position] != 0)
							minInit_pp = initialVector_pp[position];
						}

					/* older value for the end */
					for (position = 0; position < p->numSegNode; position++)
						{
						if (position == 0)
							maxEnd_pp = endVector_pp[position];
						if (endVector_pp[position] > maxEnd_pp && endVector_pp[position] != 0)
							maxEnd_pp = endVector_pp[position];
						}
		
					/* smaller value for the initial */
					for (position = 0; position < q->numSegNode; position++)
						{
						if (position == 0)
							minInit_qq = initialVector_qq[position];
				
						if (initialVector_qq[position] < minInit_qq && initialVector_qq[position] != 0)
							minInit_qq = initialVector_qq[position];
						}

					/* older value for the end */
					for (position = 0; position < q->numSegNode; position++)
						{
						if (position == 0)
							maxEnd_qq = endVector_qq[position];
	
						if (endVector_qq[position] > maxEnd_qq && endVector_qq[position] != 0)
							maxEnd_qq = endVector_qq[position];
						}
			
					/* fast, there are in 1 big segment that contains all the segments */					
					for (position = 0; position < p->numSegNode; position++) 
						{
						if (endVector_pp[position] == maxEnd_pp && initialVector_pp[position] == minInit_pp)	
							a = 1;
						}
					for (position = 0; position < q->numSegNode; position++) 
						{
						if (endVector_qq[position] == maxEnd_qq && initialVector_qq[position] == minInit_qq)	
							b = 1;
						}
				
					free (initialVector_pp);
					free (endVector_pp);
					free (initialVector_qq);
					free (endVector_qq);
				
				
					/* 2.- Fast with a big segment */
					if (minInit_pp <= minInit_qq && maxEnd_pp >= maxEnd_qq && a == 1 && b == 1)
						{
						for (j = 1; j <= numNuc; j++)
							{
							if (j >= minInit_qq && j <= maxEnd_qq)
								{
								S_MRCA[j]--;
								}
							}
						a = out = 1;	
						}
					if (minInit_qq <= minInit_pp && maxEnd_qq >= maxEnd_pp && a == 1 && b == 1 && out == 0)
						{
						for (j = 1; j <= numNuc; j++)
							{
							if (j >= minInit_pp && j <= maxEnd_pp)
								{
								S_MRCA[j]--;
								}
							}
						a = out = 1;	
						}
					
					/* 3.- Fast, noncoincident nodes. Ex: Coalescence from 2 nodes which come from of the same recombination. MRCA variation = 0 */
					if (maxEnd_pp < minInit_qq && out == 0)
						{
						/*fprintf (fpmpi, "happened for MRCA, MRCA does not change");*/;
						
						a = out = 1;
						}
					if (maxEnd_qq < minInit_pp && out == 0)
						{
						/*fprintf (fpmpi, "happened for MRCA, MRCA does not change");*/;
						
						a = out = 1;
						}
					
					if (minInit_pp < minInit_qq && maxEnd_pp < maxEnd_qq && a == 1 && b == 1 && out == 0)
						{
						for (j = 1; j <= numNuc; j++)
							{
							if (j >= minInit_qq && j <= maxEnd_pp)
								{
								S_MRCA[j]--;
								}
							}
						a = out = 1;
						}
						
					if (minInit_qq < minInit_pp && maxEnd_qq < maxEnd_pp && a == 1 && b == 1 && out == 0)
						{
						for (j = 1; j <= numNuc; j++)
							{
							if (j >= minInit_pp && j <= maxEnd_qq)
								{
								S_MRCA[j]--;
								}
							}
						a = out = 1;
						}
					
					a = b = k = w = i = 0;
				
					/* 3.- complex case */
					if (out == 0)
						{
						for (j = 1; j <= numNuc; j++)
							{
							if (overLapSegmentsCoalMRCA(p, q, sizeNode_p, sizeNode_q, j) == YES)
								{
								S_MRCA[j]--;
								}
							}
						}
					}
				j = 0;
		


				/* Folllowing only ancestral material */
				for (mmm = 1; mmm <= numNuc; mmm++)	 /* Only anc material*/
					{
					if (p->SitesNonAncHere[mmm] == 0 && q->SitesNonAncHere[mmm] == 0)
						{
						/*fprintf (fpmpi, "\n This Position %d is ANC mat: p->index = %d, p->SitesNonAncHere = %d, q->index = %d, q->SitesNonAncHere = %d \n", mmm, p->index, p->SitesNonAncHere[mmm], q->index, q->SitesNonAncHere[mmm]);*/
						OnlyAncS_MRCA[mmm]--;
						}				
					}
				/* Is this the GMRCA of the anc material? */
				Ok_SMRCA_Codon = 0;
				for (mmm = 1; mmm <= numNuc; mmm++)	 /* Only anc material*/
					{
					if (OnlyAncS_MRCA[mmm] == 1)
						{
						/*fprintf (fpmpi, "\n-- Yes anc GMRCA position %d -- \n", mmm);*/
						Ok_SMRCA_Codon++;
						}
					}			
				if (Ok_SMRCA_Codon == numNuc && AncGMRCA_obtained == NO)
					{
					r->GMRCA_ancestral = YES;
					AncGMRCA_obtained = YES;
					if (noisy == 4)
						fprintf (fpmpi, "\n--GMRCA of the ancestral material in node %d-- \n", r->index);
					}




				/* in coalescence is possible link the nodes */
				r->left = p;
				r->right = q;
				p->anc1 = r;
				q->anc1 = r;
				r->time = currentTime;
				/*fprintf (fpmpi, " r->index = %d, r->time = %lf\n", r->index, r->time);*/
													
				/* readjust active nodes */
				activeGametes[firstInd] = newInd;
				activeGametes[secondInd] = activeGametes[numActiveGametes-1];
				numActiveGametes--; /* it lose 1 active node */
				nextAvailable++; /* 1 node more to available */
				numParcialActiveGametes[whichDeme] = numParcialActiveGametes[whichDeme]-1;
			
			
				if (nextAvailable >= numNodes)	/* if there aren't enough nodes it go into and it addition more */
					{
					/* ReallocNodes(&numNodes, activeGametes); */
					numNodes += INCREMENT_NODES;
					numTotalSegments += (INCREMENT_NODES*maxSegNode)+numNuc;
					
					/* REALLOC */
					segments = (TreeSegment *) realloc (segments, numTotalSegments  * (long) sizeof(TreeSegment));
					if (!segments)
						{
						fprintf (fpmpi, "Could not reallocate segments (%lu bytes)\n", ((numNodes*distance)+numNuc)  * (long) sizeof(TreeSegment));
						exit (1);
						}
					nodes = (TreeNode *) realloc (nodes, numNodes  * (long) sizeof(TreeNode));
					if (!nodes)
						{
						fprintf (fpmpi, "Could not reallocate nodes (%lu bytes)\n", numNodes  * (long) sizeof(TreeNode));
						exit (-1);
						}
					activeGametes = (int *) realloc (activeGametes, numNodes *(long) sizeof(int));
					if (!activeGametes)
						{
						fprintf (fpmpi, "Could not reallocate activeGametes (%lu bytes)\n", numNodes *(long) sizeof(int));
						exit (-1);
						}
					if (noisy == 4)
						fprintf (fpmpi, "\n\n...Doing reallocation of nodes (1)\n");
					}
				}	/* end of coalescence */
				

			/*** Special event of CONVERGENCIE OF DEMES ***/
			if (doConvNext == YES)
				{
				j = 0;
				doConvNext = NO;		

				currentBigDeme++;
				currentDemesNumber--;

				if (noisy > 1)
					{
					fprintf (fpmpi, "Convergence of demes %d and %d", deme_a[nextConvNumber], deme_b[nextConvNumber]);
					fprintf (fpmpi, " to deme %d", currentBigDeme+numPopulations);
					}
				
				if (doMigrationIslCont == YES) /* this is just for the migration model of continent-island */
					{
					if (deme_a[nextConvNumber] == OkValueCI || deme_b[nextConvNumber] == OkValueCI)
						{
						OkValueCI = currentBigDeme+numPopulations;
						newOkValueCI++;
						}
					}


				CurrentDemesState[deme_a[nextConvNumber]] = CurrentDemesState[deme_b[nextConvNumber]] = 0;
				CurrentDemesState[currentBigDeme+numPopulations] = currentBigDeme+numPopulations;
									
				for (d = 0; d < numActiveGametes; d++)
					{
					p = nodes + activeGametes[d];
					
					if (p->indexCurrentMigPop == deme_a[nextConvNumber])
						{
						p->indexCurrentMigPop = currentBigDeme+numPopulations;
						numParcialActiveGametes[currentBigDeme+numPopulations]++;
						numParcialActiveGametes[deme_a[nextConvNumber]]--;
						}
						
					if (p->indexCurrentMigPop == deme_b[nextConvNumber])
						{
						p->indexCurrentMigPop = currentBigDeme+numPopulations;
						numParcialActiveGametes[currentBigDeme+numPopulations]++;
						numParcialActiveGametes[deme_b[nextConvNumber]]--;
						}
					}

				/* when the tip node has a time higher than convergence demes, its initial deme must be the deme of the convergence demes */
				/*if (doDatedTips == YES) 
					{
					for (ss = 0; ss < numSequences; ss++)		
						{
						p = nodes + ss;
						if (p->time >= currentTime)
							{
							if (p->indexOldMigPop == deme_a[nextConvNumber] || p->indexOldMigPop == deme_b[nextConvNumber])
								{
								if (noisy > 2)
									fprintf (fpmpi, "\nInitial node %d that belongs to the deme %d, is belonging now to the deme ", p->index, p->indexOldMigPop);
								p->indexOldMigPop = currentBigDeme+numPopulations;
								p->indexCurrentMigPop = currentBigDeme+numPopulations;
								if (noisy > 2)
									fprintf (fpmpi, "%d by a convergence of demes", p->indexOldMigPop);
								}
							}
						}
					if (noisy > 2)
						fprintf (fpmpi, "\n");
					}*/


				if (noisy > 3)
					fprintf (fpmpi,"\n");
				}	


			/* print out ancestral (active) status for each site and MRCA vector - only mat anc */
			if (noisy > 2)
				{
				fprintf (fpmpi,"\n - Ancestral MRCA in the nodes: -\n");
				for (i=0; i<numActiveGametes; i++)
					{
					for (j=1; j<=numNuc; j++)
						{
						p = nodes + activeGametes[i];
						if (j == 1)
							fprintf (fpmpi, "%4d -- (MRCA:)", p->index);
						fprintf (fpmpi, "%d", OnlyAncS_MRCA[j]);
						}
					fprintf (fpmpi, "\n");
					}
				/*fprintf (fpmpi, "MRCA   ");*/
				for (j=1; j<=numNuc; j++)
					{
					if (OnlyAncS_MRCA[j] <= 1)
						fprintf (fpmpi, "*");
					else
						fprintf (fpmpi, " ");
					}
				/*fprintf (fpmpi, "\n");*/
				fprintf (fpmpi,"\n\n");
				}



			/* print out ancestral (active) status for each site and MRCA vector */
			if (noisy > 2)
				{
				fprintf (fpmpi,"\nMRCA in the nodes:\n");
				for (i=0; i<numActiveGametes; i++)
					{
					for (j=1; j<=numNuc; j++)
						{
						p = nodes + activeGametes[i];
						/*p = nodes + pos(activeGametes[i],j,numNuc);*/
						if (j == 1)
							fprintf (fpmpi, "%4d -- (MRCA:)", p->index);
						fprintf (fpmpi, "%d", S_MRCA[j]);
						}
					fprintf (fpmpi, "\n");
					}
				/*fprintf (fpmpi, "MRCA   ");*/
				for (j=1; j<=numNuc; j++)
					{
					if (S_MRCA[j] /* MRCA[j]*/ <= 1)
						fprintf (fpmpi, "*");
					else
						fprintf (fpmpi, " ");
					}
				/*fprintf (fpmpi, "\n");*/
				}
				
			sizeNode = sizeNode_p = sizeNode_q = 0;
			free (gi);



			/* If doing dated tips, sometimes the number of actives nodes can be already 1 before all have been activated samples. 
			If this happens we need to move towards the next sample, activate it, and start again */
			if (doDatedTips == YES)
			 if (numActiveGametes == 1 && currentSample > 0)
				{
				if (noisy > 2)
					fprintf (stderr, "\n\nOnly 1 lineage active before activating all samples"/*, currentSample*/);
				currentSample--;

				/* activate nodes from this sample*/
				if (noisy > 2)
					fprintf (stderr, "\n Activating sample %d (time = %6.4f). Tips to activate:", currentSample, datedSample[currentSample].time);
				for (i=0; i<datedSample[currentSample].size; i++)
					{
					if (noisy > 2)
						fprintf (stderr, " %d", datedSample[currentSample].member[i]-1);
					
					p = nodes + datedSample[currentSample].member[i]-1;
					p->index = datedSample[currentSample].member[i]-1;
					activeGametes[numActiveGametes] = datedSample[currentSample].member[i]-1; 

					for (ss = 1; ss <= numPopulations /*+ numCONV*/; ss++) 
						{
						if (p->indexOldMigPop == ss)
							{
							numParcialActiveGametes[ss]++;
							/*fprintf (stderr, "\n AQUI numParcialActiveGametes[%d] = %d \n", ss, numParcialActiveGametes[ss]); */
							}
						} 
						
					numActiveGametes++;
					}
				currentTime = datedSample[currentSample].time;
	
				if (noisy > 2)
					{
					fprintf (stderr, "\nActive nodes (%d):", numActiveGametes); 
					for (i=0; i<numActiveGametes; i++)
						fprintf (stderr," %d",activeGametes[i]);
					fprintf (stderr,"   Next node available = %d ", nextAvailable);
					fprintf (stderr, "\nSetting currentTime = %6.4f", currentTime);
					}
				}
			} /***** coalescent tree finished *****/


		for (w = 1; w <= numNuc; w++)
			{
			if (S_MRCA[w] > 1 || S_MRCA[w] < 1)
				{
				fprintf (fpmpi, "\n Warning S_MRCA in the last node is < > 1, S_MRCA[%d] = %d", w, S_MRCA[w]);
				exit (-1);
				}
			}

		if (noisy > 1)
			fprintf (fpmpi, "\n\n\n>> Coalescent tree/s finished\n");
			
			
		counterTimeInit = counterTimeInit + currentTime;
		actualTGMRCA = currentTime;
		
			/* free memory of migrations */			
		free (rateREpartial);
		free (rateCApartial);
		free (rateMIGpartial);
		free (ratePartial);
		free (cumPopulTase);
		free (cumInitPopul);
		free (numParcialActiveGametes);
		free (GiPartial);
		if (doConvergDemes == YES)
			{
			free (currentConvDem);
			free (convDemTimes);
			free (deme_a);
			free (deme_b);
			free (CurrentDemesState);
			}
		/* Use to see the evolution nodes-segments */
		/*#ifdef MPI
			{
			fprintf (fpmpi, "\n\n\nnextAvailable = %d",nextAvailable);
			for (j = 0; j < numNodes; j++)*/	/* looking for parent Node of segments */	
			/*	{
				p = nodes + j;
				fprintf (fpmpi, "\n\n\n\n**The node %d**",p->index);

				for (i=0; i < p->numSegNode; i++)
					{
					s = segments + post(i,j,numNuc);	
					p->seg = s;
			
					fprintf (fpmpi, "\n\ns->sIndex %d con s->parentNode->index = %d", s->sIndex, s->parentNode->index);
					if (s->after1 != NULL)
						fprintf (fpmpi, "\ns->after1->sIndex %d con s->after1->parentNode->index = %d", s->after1->sIndex, s->after1->parentNode->index);
					if (s->after2 != NULL)
						fprintf (fpmpi, "\ns->after2->sIndex %d con s->after2->parentNode->index = %d", s->after2->sIndex, s->after2->parentNode->index);
					}
				}
			}
		*/
		}
	
	if (doMigration == NO) /* Coalescence without migration */
		{		
		eventNum = 0;		
		currentTime = 0.0;
		period = 1;

		while (numActiveGametes > 1)
			{
			/*fprintf (fpmpi,"\nMMM >>>>> NEW EVENT. numActiveGametes = %d", numActiveGametes);*/

			Gi = 0;
			/* allocate memory for each node gi */
			gi = (int *) calloc(numActiveGametes,(long) sizeof(int));
			if (!gi)
				{
				fprintf (fpmpi, "Could not allocate gi (%lu bytes)\n", numActiveGametes *(long) sizeof(int));
				exit (-1);
				}
			/* calculate gi for each node and total Gi */	
			/* Gi is the total number of ancestral sites, gi is a vector with ancestral and not found MRCA sites */
			for (i = 0; i < numActiveGametes; i++)
				{
				p = nodes + activeGametes[i];
				sizeNode = p->numSegNode;
				gi[i] = CalcIndividualGi (i, nodes, activeGametes, numNuc, S_MRCA, sizeNode);
				Gi += gi[i];
				if (noisy == 4)
					fprintf (fpmpi,"\n%d \n", gi[i]);
				}	
			 if (noisy == 4) 
				fprintf (fpmpi," Gi = %lu ", Gi);
			

			/*fprintf (fpmpi,"\nMMM Gi = %lu, Nscaling = %d, N = %d, recombinationRate = %lf ", Gi, Nscaling, N, recombinationRate);*/	
			
	
			/* get rates for events */  
			rateRE = 1.0 * Gi * Nscaling * N * recombinationRate;        /* recombinationRate is constant */
			rateCA = numActiveGametes * (numActiveGametes - 1) / 2.0;
			rate = rateCA + rateRE;
			
			/*fprintf (fpmpi,"\nMMM numActiveGametes = %d", numActiveGametes);
			fprintf (fpmpi,"\nMMM rateRE = %3.2f, rateCA = %3.2f, rate = %3.2f \n", rateRE, rateCA, rate);*/


			/* find out time for coalescence */
			if (doDemographics == YES)
				{
				periodGrowth[period] = -log (Nend[period] / (double) Nbegin[period]) / (double) (cumDuration[period] - cumDuration[period-1]);

				/*fprintf (fpmpi, "\n\n>>>>1 Period %d \n", period);
				fprintf (fpmpi, "Nend[period] = %d, Nbegin[period] = %d, cumDuration[period] = %d, cumDuration[period-1] = %d\n", Nend[period], Nbegin[period], cumDuration[period], cumDuration[period-1]);
				fprintf (fpmpi, "periodGrowth[period] = %lf \n\n", periodGrowth[period]);*/

				if (isnan(periodGrowth[period]) == YES)
					{
					fprintf (fpmpi, "\nERROR: period growth (%f) is NaN", periodGrowth[period]);
					fprintf (fpmpi, "\n      This might suggest that the growth rate is too negative");
					fprintf (fpmpi, "\n      and the coalescent time is therefore infinite.");
					fprintf (fpmpi, "\n      Try a smaller value");
					exit (1);
					}

				if (Nend[period] == Nbegin[period])
					{
					timeCA = RandomExponential (rateCA, seed) * Nscaling * (double) Nbegin[period];
					}
				else
					{
					timeCA = log (1 + RandomExponential (rateCA, seed) * periodGrowth[period] * Nscaling * Nbegin[period] * 
							exp (-periodGrowth[period] * (currentTime - cumDuration[period-1]))) / periodGrowth[period];
					}

				/*	When growth rate is very negative, coalescent time may be infinite
					this results in log (-x) => timCA = NaN. If this not the last period
					just jump to the next. If this is the last period, we have to exit
					the program */
				if (isnan(timeCA) == YES)
					{
					if (period < numPeriods) 
						{
						currentTime = cumDuration[period];
						period++;
						periodGrowth[period] = -log (Nend[period] / (double) Nbegin[period]) / (double) (cumDuration[period] - cumDuration[period-1]);
						continue;
						}	
					else
						{				
						fprintf (fpmpi, "\nERROR: Coalescent time (%f) is infinite ", timeCA);
						fprintf (fpmpi, "\n      This might suggest that the growth rate is too negative");
						fprintf (fpmpi, "\n      and the coalescent time is therefore infinite.");
						fprintf (fpmpi, "\n      Try a smaller value");
						exit (1);
						}
					}
				}
			else
				{
				timeCA = RandomExponential (rateCA, seed) * Nscaling * N;
				if (doExponential == YES)
					{
					timeCA = log (exp(growthRate*currentTime) + growthRate * timeCA) / growthRate - currentTime;
		
					/*	When growth rate is very negative, coalescent time may be infinite
						this results in log (-x) => timeCA = NaN. We have to exit
						the program */
					if (isnan(timeCA) == YES)
						{
						fprintf (fpmpi, "\nERROR: Coalescent time (%f) is infinite ", timeCA);
						fprintf (fpmpi, "\n      This might suggest that the growth rate is too negative");
						fprintf (fpmpi, "\n      and the coalescent time is therefore infinite.");
						fprintf (fpmpi, "\n      Try a smaller value");			
						exit (1);
						}
					}
				}

			/* find out time for recombination */
			timeRE = RandomExponential (rateRE, seed) * Nscaling * N;


			if (doDatedTips == YES)
				{
				if (timeCA < timeRE)
					{
					eventTime = timeCA;
					isCoalescence = YES;	
					}
				else
					{
					eventTime = timeRE;
					isCoalescence = NO;	
					}


				/* if doing dated tips, check whether we need to activate a new sample, update sampling period and start again */
				if ((currentTime + eventTime) > datedSample[currentSample-1].time && currentSample > 0)
					{
					currentSample--;
					/* activate nodes from this sample */
					if (noisy > 2)
						fprintf (stderr, "\nCumulative time = %6.4f  > sample %d time = %6.4f. Activating tips:", currentTime + eventTime, currentSample, datedSample[currentSample].time);
					
					for (i=0; i<datedSample[currentSample].size; i++)
						{
						if (noisy > 2)
							fprintf (stderr, " %d", datedSample[currentSample].member[i]-1);

						p = nodes + datedSample[currentSample].member[i]-1;
						p->index = datedSample[currentSample].member[i]-1;
						activeGametes[numActiveGametes] = datedSample[currentSample].member[i]-1;  

						numActiveGametes++;
						}
					currentTime = datedSample[currentSample].time;

					if (noisy > 2)
						{
						fprintf (stderr, "\nActive nodes (%d):", numActiveGametes); 
						for (i=0; i<numActiveGametes; i++)
							fprintf (stderr," %d",activeGametes[i]);
						fprintf (stderr,"\nNext node available = %d", nextAvailable);
						fprintf (stderr, "\nSample %d activated and going back to currentTime = %6.4f", currentSample, currentTime);
						}
					continue; /* start again*/
					}	


				/* event is a coalescence or a recombination? */
				if (isCoalescence == YES)
					{
					/*	if this period is not the last one and if the event time is outside the current interval,
						update period and start again */
					if (doDemographics == YES && period < numPeriods && (currentTime + eventTime) > cumDuration[period])
						{
						currentTime = cumDuration[period];
						period++;
						periodGrowth[period] = -log (Nend[period] / (double) Nbegin[period]) / (double) (cumDuration[period] - cumDuration[period-1]);
						continue;
						}	
			
					numCA++;
					}
				else
					{
					/*	if this period is not the last one and if the event time is outside the current interval,
						update period and start again */
					if (doDemographics == YES && period < numPeriods && (currentTime + eventTime) > cumDuration[period])
						{
						currentTime = cumDuration[period];
						period++;
						periodGrowth[period] = -log (Nend[period] / (double) Nbegin[period]) / (double) (cumDuration[period] - cumDuration[period-1]);
						continue;
						}	
					numRE++;
					/* reallocate for recombination breakpoints */
					if (numRE >= (memoryBreakp-1))
						{
						memoryBreakp += 50;
					 
						breakpoint = (int *) realloc(breakpoint, memoryBreakp *(long) sizeof(int));
						if (!breakpoint)
							{
							fprintf (fpmpi, "Could not reallocate breakpoint \n");
							exit (-1);
							}
						if (noisy == 4)
							fprintf (fpmpi, "\n...Doing reallocation of breakponts (1)\n");
						}
					if (numRE > (numNuc+1) && many == 0)
						{
						if (noisy > 2)
							fprintf (fpmpi, "\n\n Cheking information: Many recombinations %d (more recombinations that sites)\n", numRE);
						
						many++;
						}
					}
				}
			else /* not tip dates */
				{
				/* event is a coalescence or a recombination? */
				if (timeCA < timeRE)
					{
					isCoalescence = YES;
					eventTime = timeCA;
					/*	if this period is not the last one and if the event time is outside the current interval,
						update period and start again */
					if (doDemographics == YES && period < numPeriods && (currentTime + eventTime) > cumDuration[period])
						{
						currentTime = cumDuration[period];
						period++;
						periodGrowth[period] = -log (Nend[period] / (double) Nbegin[period]) / (double) (cumDuration[period] - cumDuration[period-1]);
						continue;
						}	
			
					numCA++;


					}
				else
					{
					isCoalescence = NO;
					eventTime = timeRE;	
					/*	if this period is not the last one and if the event time is outside the current interval,
						update period and start again */
					if (doDemographics == YES && period < numPeriods && (currentTime + eventTime) > cumDuration[period])
						{
						currentTime = cumDuration[period];
						period++;
						periodGrowth[period] = -log (Nend[period] / (double) Nbegin[period]) / (double) (cumDuration[period] - cumDuration[period-1]);
						continue;
						}	
					numRE++;


					/* reallocate for recombination breakpoints */
					if (numRE >= (memoryBreakp-1))
						{
						memoryBreakp += 50;
					 
						breakpoint = (int *) realloc(breakpoint, memoryBreakp *(long) sizeof(int));
						if (!breakpoint)
							{
							fprintf (fpmpi, "Could not reallocate breakpoint \n");
							exit (-1);
							}
						if (noisy == 4)
							fprintf (fpmpi, "\n...Doing reallocation of breakponts (1)\n");
						}
					if (numRE > (numNuc+1) && many == 0)
						{
						if (noisy > 2)
							fprintf (fpmpi, "\n\n Cheking information: Many recombinations %d (more recombinations that sites)\n", numRE);
						
						many++;
						}
					}

				}





				
			/* set time */
			currentTime += eventTime; /* the time is accumulated */

				
			if (noisy > 3)
				fprintf(fpmpi, "\n\n");
				
			eventNum++;
			if (noisy > 1)
				fprintf (fpmpi, "\n\n*** Event %3d *** rate = %lf, currentTime = %lf\n", eventNum, rate, currentTime);
				
				
		
			/*** if RECOMBINATION, readjust active nodes ***/
			if (isCoalescence == NO)
				{
				if (noisy == 4)
					fprintf (fpmpi, "\n* Recombination *");
					
				/* Which node has the recombination? */
					/* assign probability to each node based on their gi's values */
				cum_gi = 0;
				probRecIndividual = Gi * RandomUniform(seed); /* it calculate the individual probability for the breakpoint */
				for (whichInd=0; whichInd<numActiveGametes; whichInd++)
					{
					cum_gi += gi[whichInd];				/* accumulate gi into cum_gi. whichInd is the choose node. */
					if (probRecIndividual < cum_gi)    /* break whether the node is chosen */
						break;
					}

				if (whichInd >= numActiveGametes)
					{
					fprintf (fpmpi, "\n\nERROR: whichInd out of range3!: whichInd = %d\n", whichInd);
					exit (-1);
					}
			
				/* select a valid breakpoint among potential recombining locations */
				/* to be a potential recombining site, a site has to have ancestral material non-MRCA before and after it */
				legalBreakpoint = NO;
				while (legalBreakpoint == NO)
					{
					do /* oct2009 */
						{
						whichSite = (/*numSites*/numNuc) * RandomUniform(seed); /* it choose a site */
						if (whichSite == 1)
							whichSite = numNuc;
						} while (whichSite == 0);
					/* oct2009 */

					if (whichSite > numNuc)
						{
						fprintf (fpmpi, "\n\nERROR: whichSite out of range! : whichSite = %d\n", whichSite);
						exit (-1);
						}
					p = nodes + activeGametes[whichInd];
					sizeNode = p->numSegNode;
					if	(IsValidBreakSite (activeGametes, nodes, whichInd, whichSite, S_MRCA) == YES)
						legalBreakpoint = YES;
					}
				
				/* should this recombination event be counted in the expected number of recombinations E(R)? */
				/* for E(R) count only events with breakpoints as 1|1, 1|0 or 0|1  (i.e., not 0|0)         */
				/* if 1 represent a site that did found already its MRCA count it as a 0 */
				ThisBreakpIsTrapped = NO;
				if (doCountsForExpNumRec == YES)
					{
					p = nodes + activeGametes[whichInd];
					sizeNode = p->numSegNode;	
					if (CountsForExpNumRec (activeGametes, whichInd, whichSite, nodes, S_MRCA, sizeNode) == NO)
						{
						recNotToCount++;
						ThisBreakpIsTrapped = YES;
						/*fprintf(stderr,"\n ..not to count.. \n");*/
						}
					}
				/* copy whichIndividual to a new space in memory */
				hasPassedBreakPoint = NO;
			
				firstHalf = nextAvailable++; /* firstHalf is the first node that was created by the recombination */
				if (nextAvailable >= numNodes) /* if there aren't enough nodes it go into and it addition more */
					{
					/* ReallocNodes(&numNodes, activeGametes); */
					numNodes += INCREMENT_NODES;
					numTotalSegments += (INCREMENT_NODES*maxSegNode)+numNuc;
					
					/* REALLOC */
					segments = (TreeSegment *) realloc (segments, numTotalSegments  * (long) sizeof(TreeSegment)); 
					if (!segments)
						{
						fprintf (fpmpi, "Could not reallocate segments (%lu bytes)\n", ((numNodes*distance)+numNuc)  * (long) sizeof(TreeSegment));
						exit (1);
						}
					nodes = (TreeNode *) realloc (nodes, numNodes  * (long) sizeof(TreeNode));
					if (!nodes)
						{
						fprintf (fpmpi, "Could not reallocate nodes (%lu bytes)\n", numNodes  * (long) sizeof(TreeNode));
						exit (-1);
						}
					activeGametes = (int *) realloc (activeGametes, numNodes *(long) sizeof(int));
					if (!activeGametes)
						{
						fprintf (fpmpi, "Could not reallocate activeGametes (%lu bytes)\n",numNodes *(long) sizeof(int));
						exit (-1);
						}
					if (noisy == 4)
						fprintf (fpmpi, "\n\n...Doing reallocation of nodes (1)\n");
					}
									
				secondHalf = nextAvailable++; /* secondhalf is the second node that was created by the recombination */
				if (nextAvailable >= numNodes) /* if there aren't enough nodes it go into and it addition more */
					{
					/* ReallocNodes(&numNodes, activeGametes); */
					numNodes += INCREMENT_NODES;
					numTotalSegments += (INCREMENT_NODES*maxSegNode)+numNuc;
					
					/* REALLOC */
					segments = (TreeSegment *) realloc (segments, numTotalSegments  * (long) sizeof(TreeSegment)); 
					if (!segments)
						{
						fprintf (fpmpi, "Could not reallocate segments (%lu bytes)\n", ((numNodes*distance)+numNuc)  * (long) sizeof(TreeSegment));
						exit (1);
						}
					nodes = (TreeNode *) realloc (nodes, numNodes  * (long) sizeof(TreeNode));
					if (!nodes)
						{
						fprintf (fpmpi, "Could not reallocate nodes (%lu bytes)\n", numNodes  * (long) sizeof(TreeNode));
						exit (-1);
						}
					activeGametes = (int *) realloc (activeGametes, numNodes *(long) sizeof(int));
					if (!activeGametes)
						{
						fprintf (fpmpi, "Could not reallocate activeGametes (%lu bytes)\n", numNodes *(long) sizeof(int));
						exit (-1);
						}
					if (noisy == 4)
						fprintf (fpmpi, "\n\n...Doing reallocation of nodes (1)\n");
					}
				p = nodes + activeGametes[whichInd];
				q = nodes + firstHalf;	/* parent1 (new) */
				r = nodes + secondHalf; /* parent2 (new) */
			
				q->index = firstHalf;
				r->index = secondHalf;
				q->numSegNode = r->numSegNode = p->numSegNode;		/* Good if there are not nill segments.. then, in its case, it will be modify */
			


				q->class = 3;
				r->class = 3;
				q->GMRCA_ancestral = NO;
				r->GMRCA_ancestral = NO;
				q->breakp = whichSite;		
				r->breakp = whichSite;			
				q->time = currentTime;
				r->time = currentTime;
				q->sib = r;
				r->sib = q;
				q->left = p;
				r->left = p;
				p->anc1 = q;
				p->anc2 = r;
				
				if (doBranchNetfiles == YES)
					{
					q->NetLabelPrint = numNetLabelPrint;
					/*numNetLabelPrint++;*/
					r->NetLabelPrint = numNetLabelPrint;
					numNetLabelPrint++;
					}


				k = 0;
				for (w = 1; w < numSites; w++)
					{
					//fprintf (fpmpi, "\nstud[%d] = %d", w-1, stud[w-1]);
					if (whichSite == stud[w-1]) /* The breakpoints BETWEEN codons. "stud" is an array with the possible breakpoints beetween codons*/
						k++;

					/* exception for trapped material, any breakpoint here does not break material codons */
					if (ThisBreakpIsTrapped == YES)
						{
						k++;
						/*fprintf (fpmpi, "\n ThisBreakpIsTrapped, whichSite = %d, p->index = %d \n", whichSite, p->index);*/
						}
					}

				doBreakpBroken = NO;
				if (k == 0)
					{
					if (noisy == 4)
						{
						fprintf (fpmpi, "\n Broken codon, breakpoint at %d \n", whichSite);
						}
					//q->breakCodon = YES;
					//r->breakCodon = YES;
					variable1 = whichSite/3.00 + 0.4;
					//fprintf (fpmpi, "\n variable1 = %lf", variable1);
					q->breakCodon = fabs(variable1);
					r->breakCodon = fabs(variable1);
					numREbreakCod++;
					variable2 = fmod(whichSite,3.00);
					if (variable2 == 0)
						q->whereBreakCodon = 2;
					else
						q->whereBreakCodon = 1;
					r->whereBreakCodon = 3;
					
					

					/* oct2009 */
					/* int			doBreakpBroken, LeftLess, LeftHigh, RightLess, RightHigh; */
					if (doCodonModel == YES)
						doBreakpBroken = YES;
					LeftLess = LeftHigh = RightLess = RightHigh = LeftLess2 = RightHigh2 = -1;

					if (q->whereBreakCodon == 1) /* first codon position breakp */
						{
						RightHigh = q->breakCodon * 3;
						RightLess = RightHigh - 1;
						LeftLess = RightLess - 1; 
						LeftHigh = RightLess - 1;
						
						
						q->SitesNonAncHere[LeftLess+1] = 1;
						q->SitesNonAncHere[LeftLess+2] = 1;
						r->SitesNonAncHere[RightLess-1] = 1;

						/*fprintf (fpmpi, "\n LeftLess+2 = %d; RightLess-1 = %d \n", LeftLess+2, RightLess-1);*/
						for (mmm=1; mmm<=numNuc; mmm++)
							{
							if (mmm <= RightLess-1)
								q->SitesNonAncHere[mmm] = p->SitesNonAncHere[mmm]; 
							if (mmm > RightLess-1 && mmm <= LeftLess+2)
								q->SitesNonAncHere[mmm] = 1;
							if (mmm > LeftLess+2)
								q->SitesNonAncHere[mmm] = -1;

							if (mmm < RightLess-1)
								r->SitesNonAncHere[mmm] = -1; 
							if (mmm == RightLess-1)
								r->SitesNonAncHere[mmm] = 1;
							if (mmm > RightLess-1)
								r->SitesNonAncHere[mmm] =  p->SitesNonAncHere[mmm];
							}	
						}
					else if (q->whereBreakCodon == 2) /* second codon position breakp */
						{
						RightHigh = q->breakCodon * 3;
						RightLess = q->breakCodon * 3;
						LeftHigh = RightLess - 1;
						LeftLess = LeftHigh - 1;


						q->SitesNonAncHere[LeftHigh+1] = 1;
						r->SitesNonAncHere[RightLess-1] = 1;	
						r->SitesNonAncHere[RightLess-2] = 1;
						
						/*fprintf (fpmpi, "\n LeftHigh+1 = %d; RightLess-2 = %d \n", LeftHigh+1, RightLess-2);*/
						for (mmm=1; mmm<=numNuc; mmm++)
							{
							if (mmm < LeftHigh+1)
								q->SitesNonAncHere[mmm] = p->SitesNonAncHere[mmm]; 
							if (mmm == LeftHigh+1)
								q->SitesNonAncHere[mmm] = 1;
							if (mmm > LeftHigh+1)
								q->SitesNonAncHere[mmm] = -1;

							if (mmm >= LeftHigh+1)
								r->SitesNonAncHere[mmm] = p->SitesNonAncHere[mmm]; 
							if (mmm >= RightLess-2 && mmm < LeftHigh+1)
								r->SitesNonAncHere[mmm] = 1;
							if (mmm < RightLess-2)
								r->SitesNonAncHere[mmm] = -1;

							}	
						}
					else
						{
						fprintf (fpmpi, "error at q->whereBreakCodon intra codon Rec _ Main (%d != 1 or 2)\n", q->whereBreakCodon);
						exit (-1);
						}
					/* fprintf (fpmpi, "\n Left (Less-High) %d-%d; Right (Less-High) %d-%d \n", LeftLess, LeftHigh, RightLess, RightHigh);	*/				
					if (LeftLess == -1 || LeftHigh == -1 || RightLess == -1 || RightHigh == -1)
						{
						fprintf (fpmpi, "\n Error (value = -1): Left (Less-High) %d-%d; Right (Less-High) %d-%d \n", LeftLess, LeftHigh, RightLess, RightHigh);					
						exit (-1);
						}

					}
				if (k > 0 || doCodonModel == NO) /* inter codon rec */
					{
					doBreakpBroken = NO;

					for (mmm=1; mmm<=numNuc; mmm++)
						{
						if (mmm >= whichSite)
							{
							q->SitesNonAncHere[mmm] = -1; /* non anc mat */
							}
						if (mmm < whichSite)
							{
							q->SitesNonAncHere[mmm] = p->SitesNonAncHere[mmm]; /* non anc mat */
							}

						if (mmm < whichSite)
							{
							r->SitesNonAncHere[mmm] = -1; /* non anc mat */
							}
						if (mmm >= whichSite)
							{
							r->SitesNonAncHere[mmm] = p->SitesNonAncHere[mmm]; /* non anc mat */
							}
						}	


					}
				/* oct2009 */

				/*for (mmm=1; mmm<=numNuc; mmm++)
					{
					fprintf (fpmpi, "\n Initial. Site %d. Node: %d, p->SitesNonAncHere = %d \n", mmm, p->index, p->SitesNonAncHere[mmm]);
					}
				for (mmm=1; mmm<=numNuc; mmm++)
					{
					fprintf (fpmpi, "\n Site %d. Node: %d, q->SitesNonAncHere = %d;  Node %d, r->SitesNonAncHere = %d \n", mmm, q->index, q->SitesNonAncHere[mmm], r->index, r->SitesNonAncHere[mmm]);
					}*/
				

				/*fprintf (fpmpi, "\n r->index = %d, r->time = %lf, r->class = %d, r->breakp = %d, r->breakCodon = %d, r->whereBreakCodon = %d", r->index, r->time, r->class, r->breakp, r->breakCodon, r->whereBreakCodon);
				fprintf (fpmpi, "\n q->index = %d, q->time = %lf, q->class = %d, q->breakp = %d, q->breakCodon = %d, q->whereBreakCodon = %d\n", q->index, q->time, q->class, q->breakp, q->breakCodon, q->whereBreakCodon);*/
				k = 0;				



				if (noisy == 4)
					{		
					fprintf (fpmpi, "\nNode index %d with breakpoint on %d site", p->index, whichSite);
					fprintf (fpmpi, "\nThis node contains %d fragment(s):", p->numSegNode);
					}
				for (w = 0; w < p->numSegNode; w++)
					{
					s = segments + post(w,p->index,distance);
					/*p->seg = s;*/
					if (noisy == 4)
						{
						fprintf (fpmpi, "\ns->sIndex = %d", s->sIndex);
						fprintf (fpmpi, "\ns->sStart = %d", s->sStart);
						fprintf (fpmpi, "\ns->sEnd = %d",s->sEnd);
						}
					}
				if (noisy == 4)
					fprintf (fpmpi, "\n\n>> Process evolution..");
					
				

				
				a = b = aa = bb = aaa = bbb = out = 0;
				startsVectorRec = (int *) calloc((p->numSegNode),(long) sizeof(int));
				if (!startsVectorRec)
					{
					fprintf (fpmpi, "Could not allocate startsVectorRec (%lu bytes)\n", (p->numSegNode) *(long) sizeof(int));
					exit (-1);
					}
				endsVectorRec = (int *) calloc((p->numSegNode),(long) sizeof(int));
				if (!endsVectorRec)
					{
					fprintf (fpmpi, "Could not allocate endsVectorRec (%lu bytes)\n", (p->numSegNode) *(long) sizeof(int));
					exit (-1);
					}
				

				for (i = 0; i < p->numSegNode; i++)					/* for each segment */
					{
					s = segments + post(i,p->index,distance);
					startsVectorRec[i] = s->sStart;
					endsVectorRec[i] = s->sEnd;
				


					/* first half */
					if (s->sStart >= whichSite)
						{
						if (noisy == 4)
							fprintf (fpmpi, "\nNil segment in Left, don't make it");
							
						q->numSegNode--;
						a++;
						out = 1;
						} 
				
					if (s->sStart == 1 && s->sEnd >= (whichSite-1) && out == 0)
						{
						if (aa > 0)
							{
							if (noisy == 4)
								fprintf (fpmpi, "\nRepit segment in Left, don't make it");
								
							q->numSegNode--;
							out = 1;
							}
						aa++;
						}
					
					for (w = 0; w < i+1; w++)
						{
						if (out == 0 && s->sStart != 1 && s->sStart == startsVectorRec[w] && s->sStart < whichSite && w != i && s->sEnd >= (whichSite-1) && endsVectorRec[w] >= (whichSite-1) && startsVectorRec[w] != 0)
							{
							if (noisy == 4)
								fprintf (fpmpi, "\nRepit segment in Left, don't make it");
								
							q->numSegNode--;
							aaa++;
							out = 1;
							}
						}				
					
					
					if (out == 0 && s->sStart < whichSite)
						{
						if (aa == 0 && aaa == 0)
							{
							n = segments + post(i-a-aa-aaa,q->index,distance);
							n->sIndexNode = firstHalf;
							}
						if (aa > 0 && aaa == 0)
							{
							n = segments + post(i+1-a-aa-aaa,q->index,distance);
							n->sIndexNode = firstHalf;
							}
						if (aaa > 0 && aa > 0)
							{
							n = segments + post(i+1-a-aa-aaa,q->index,distance);
							n->sIndexNode = firstHalf;
							}
						if (aaa > 0 && aa == 0)
							{
							n = segments + post(i+0-a-aa-aaa,q->index,distance);
							n->sIndexNode = firstHalf;
							}
						nodeValue = firstHalf;


						if (doBreakpBroken == YES && s->sStart < whichSite && s->sEnd >= whichSite)
							{
							w = recSegmentsGeneratesLeftBrokenCodon(nodeValue, s, n, numNuc, whichSite, LeftLess, RightHigh, &actSegIndex); /* it makes the segments of the left node */
							LeftLess2 = LeftLess;
							RightHigh2 = RightHigh;							
							}
						else
							{
							w = recSegmentsGeneratesLeft(nodeValue, s, n, numNuc, whichSite, &actSegIndex); /* it makes the segments of the left node */
							}
						

						if (w != 1) /* Cheking */
							{
							fprintf (fpmpi, "Warning in recSegmentsGeneratesLeft");
							exit (-1);
							}
						actNumSegments++;
						if (n->sStart == 0 && n->sEnd == 0) /* Cheking, unreal segments */
							{
							fprintf (fpmpi, "\nNot to be here. Segment Left start and end = 0");
							
							n->before1 = n->before2 = n->after1 = n->after2 = NULL;
							actNumSegments--;
							exit(-1);
							}
						if (noisy == 4)
							{
							fprintf (fpmpi, "\nAfter rec. left");
							fprintf (fpmpi, "\nq->seg->sIndex = %d", n->sIndex);
							fprintf (fpmpi, "\nq->seg->sStart = %d", n->sStart);
							fprintf (fpmpi, "\nq->seg->sEnd = %d\n", n->sEnd);		
							}		

						}
					w = out = 0;
				


					/* second half */

					if (s->sEnd < whichSite)
						{
						if (noisy == 4)							
							fprintf (fpmpi, "\nNil segment in Right, don't make it");
							
						r->numSegNode--;
						b++;
						out = 1;
						}
					if (s->sStart <= whichSite && s->sEnd == numNuc && out == 0)
						{
						if (bb > 0)
							{
							if (noisy == 4)
								fprintf (fpmpi, "\nRepit segment in Right, don't make it");
								
							r->numSegNode--;
							out = 1;
							}
						bb++;
						}
					for (w = 0; w < i+1; w++)
						{
						if (out == 0 && s->sEnd != numNuc && s->sEnd == endsVectorRec[w] && s->sEnd > whichSite && w != i && s->sStart <= whichSite && startsVectorRec[w] <= whichSite && endsVectorRec[w] != 0)
							{
							if (noisy == 4)
								fprintf (fpmpi, "\nRepit segment in Right, don't make it");								
								
							r->numSegNode--;
								
							bbb++;
							out = 1;
							}
						}
					for (w = 0; w < i+1; w++)
						{
						if (out == 0 && s->sEnd == endsVectorRec[w] && s->sEnd >= whichSite && w != i && s->sStart <= whichSite && startsVectorRec[w] <= whichSite && endsVectorRec[w] != 0)
							{
							if (noisy == 4)								
								fprintf (fpmpi, "\nRepit segment in Right, don't make it");
								
							r->numSegNode--;
								
							bbb++;
							out = 1;
							}
						}
					

					if (out == 0 && s->sEnd >= whichSite)
						{
						if (bb == 0 && bbb == 0)
							{
							m = segments + post(i-b-bb-bbb,r->index,distance);
							m->sIndexNode = secondHalf;
							}
						if (bb > 0 && bbb == 0)
							{
							m = segments + post(i+1-b-bb-bbb,r->index,distance);
							m->sIndexNode = secondHalf;
							}
						if (bb > 0 && bbb > 0)
							{
							m = segments + post(i+1-b-bb-bbb,r->index,distance);
							m->sIndexNode = secondHalf;
							}
						if (bb == 0 && bbb > 0)
							{
							m = segments + post(i+0-b-bb-bbb,r->index,distance);
							m->sIndexNode = secondHalf;
							}
						/* m = s; initial, the new segments are similar at the old segments */
						nodeValue = secondHalf;


						if (doBreakpBroken == YES && s->sStart < whichSite && s->sEnd >= whichSite)
							{
							w = recSegmentsGeneratesRightBrokenCodon(nodeValue, s, m, numNuc, whichSite, LeftLess, RightHigh, &actSegIndex);
							LeftLess2 = LeftLess;
							RightHigh2 = RightHigh;
							}
						else
							{
							w = recSegmentsGeneratesRight(nodeValue, s, m, numNuc, whichSite, &actSegIndex);
							}
						
						if (w != 1)
							{
							fprintf (fpmpi, "Warning in recSegmentsGeneratesRight");
							exit (-1);
							}
						actNumSegments++;
						if (m->sStart == 0 && m->sEnd == 0) /* unreal segments */
							{
							fprintf (fpmpi, "\nNot to be here. segment Right start and end = 0");
							
							m->before1 = m->before2 = m->after1 = m->after2 = NULL;
							actNumSegments--;
							exit(-1);
							}
						if (noisy == 4)
							{
							fprintf (fpmpi, "\nAfter rec. right");
							fprintf (fpmpi, "\nr->seg->sIndex = %d", m->sIndex);
							fprintf (fpmpi, "\nr->seg->sStart = %d", m->sStart);
							fprintf (fpmpi, "\nr->seg->sEnd = %d\n", m->sEnd);	
							}
						
						}
					w = out = 0;


					}
			

				free (startsVectorRec);
				free (endsVectorRec);
				a = b = aa = bb = aaa = bbb = 0;


				/* intra codon breakpoints readjust MRCA oct2009 */
				if (doBreakpBroken == YES) /* The codon positions that recombinaed are increased a unit */
					{
					
					for (w = 1; w <= numNuc; w++)
						{
						if (w >= LeftLess2 && w <= RightHigh2)
							{
							S_MRCA[w]++;
							/*fprintf (fpmpi, "\n Increasing MRCA to %d: now is: %d \n", w, S_MRCA[w]);*/
							}
						}

					}
				/* oct2009 */



				if (noisy == 4)
					{
					fprintf (fpmpi, "\n>> Recombination Results:");
					fprintf (fpmpi, "\nNew left node with %d fragment(s)", q->numSegNode);				
					}
				for (w = 0; w < q->numSegNode;w++)
					{
					n = segments + post(w,q->index,distance);
					if (noisy == 4)
						{
						fprintf (fpmpi, "\nq->seg->sIndex = %d", n->sIndex);
						fprintf (fpmpi, "\nq->seg->sStart = %d", n->sStart);
						fprintf (fpmpi, "\nq->seg->sEnd = %d\n", n->sEnd);				
						}
					}
				
				if (noisy == 4)
					fprintf (fpmpi, "\nNew right node with %d fragment(s)", r->numSegNode);
					
					
				for (w = 0; w < r->numSegNode;w++)
					{
					m = segments + post(w,r->index,distance);
					if (noisy == 4)
						{
						fprintf (fpmpi, "\nr->seg->sIndex = %d", m->sIndex);
						fprintf (fpmpi, "\nr->seg->sStart = %d", m->sStart);
						fprintf (fpmpi, "\nr->seg->sEnd = %d\n", m->sEnd);						
						}
					}
				if (noisy > 3)
					fprintf (fpmpi, "\n");
					
				
				/*fprintf (stderr, "the node is whichInd = %d, and the site is whichSite = %d", whichInd+1, whichSite+1);*/
				if (noisy > 1)
					{
					fprintf (fpmpi, "Recombination involving %d (copied to %d and %d)", p->index, q->index, r->index );
					fprintf (fpmpi, "\n Breakpoint was at site %d", whichSite);
					}
				if (noisy > 3)
					fprintf (fpmpi, "\n");
				
				if (doBranchNetfiles == YES)
					{

					if (q->NetLabelPrint < numSequences)
						fprintf(fpBranchNet,"%d_seq%05d ", q->NetLabelPrint, q->NetLabelPrint+1);
					else
						fprintf(fpBranchNet,"%d ", q->NetLabelPrint);

					if (p->NetLabelPrint < numSequences)
						fprintf(fpBranchNet,"%d_seq%05d\n", p->NetLabelPrint, p->NetLabelPrint+1);
					else
						fprintf(fpBranchNet,"%d\n", p->NetLabelPrint);


					/*fprintf(fpBranchNet,"%d %d\n", q->NetLabelPrint, p->NetLabelPrint);*/


					/*fprintf(fpBranchNet,"%d %d\n", r->NetLabelPrint, p->NetLabelPrint);*/
					if (noisy > 2)
						fprintf (fpmpi, "\nNET INFORMATION Recombination involving %d (copied to %d and %d)", p->NetLabelPrint, q->NetLabelPrint, r->NetLabelPrint);
					}
				breakpoint[numRE-1] = whichSite;  /* the breakpoint site is call breakpoint. breakpoint[0] = 7, breakpoint[1] = 96, breakpoint[2] = 187.. */
				
				/* readjust active sites */
				activeGametes[whichInd] = firstHalf;	/* new active nodes firstHalf and secondHalf */
				activeGametes[numActiveGametes++] = secondHalf;		/* there are 1 active node more (in recombination) */
				}
		
		
			/*** if COALESCENCE, readjust nodes and pointers ***/
			if (isCoalescence == YES)
				{
				if (noisy == 4)
					fprintf (fpmpi, "\n* Coalescence *\n");
					
				/* figure out which two nodes are involved */ 
			
				/* intial nodes: firstInd and secondInd (they are the descendants). newInd is the ancestral node, is the new node to make */
				firstInd = numActiveGametes * RandomUniform(seed);
				if (firstInd >= numActiveGametes)
					{
					fprintf (fpmpi, "\n\nERROR: firstInd out of range!\n");
					exit (-1);
					}
				do
					{
					secondInd = numActiveGametes * RandomUniform(seed);
					} while (firstInd == secondInd);	/* the new nodes must to be diferents */
				
				/*debug*/
				/*if (doDatedTips == YES)
					fprintf (stderr, "\nsecondInd =%d, numActiveGametes=%d\n", secondInd, numActiveGametes);*/

				newInd = nextAvailable;
				if (noisy > 1)					
					fprintf (fpmpi, "Coalescence involving %d and %d to create node %d", activeGametes[firstInd], activeGametes[secondInd], newInd);
					
					
				p = nodes + activeGametes[firstInd];
				q = nodes + activeGametes[secondInd];
				r = nodes + newInd;		/* new ancester */
				r->index = nextAvailable;
				r->label = labelNodes++;
				
				/*fprintf (fpmpi, "\n\nCoalescence node label %d, y index %d\n\n", r->label, r->index);*/
				
				r->breakp = NO;
				r->breakCodon = NO;
				r->class = 4;
				r->GMRCA_ancestral = NO;
				

				for (mmm = 1; mmm <= numNuc; mmm++)	 /* for each segment of p node going to r node*/
					{
					sigue = 0;
					stateHere_P = -2; /* -2, non ancestral; 0 ancestral */
					stateHere_Q = -2; /* -2, non ancestral; 0 ancestral */

					for (i = 0; i < p->numSegNode; i++)	 /* for each segment of p node going to r node*/
						{
						s = segments + post(i,p->index,distance);
						if (mmm >= s->sStart && mmm <= s->sEnd) /* is ancestral material */
							{
							stateHere_P = 0;
							}
						}
					for (i = 0; i < q->numSegNode; i++)	/* for each segment of q node going to r node */
						{
						n = segments + post(i,q->index,distance);
						if (mmm >= n->sStart && mmm <= n->sEnd) /* is ancestral material */
							{
							stateHere_Q = 0;
							}
						}
					
					
					/*fprintf (fpmpi, "\n Here(%d) stateHere_P = %d and stateHere_Q = %d ", mmm, stateHere_P, stateHere_Q);
					fprintf (fpmpi, "\n  Here(%d), node %d: p->SitesNonAncHere[mmm] = %d && node %d: q->SitesNonAncHere[mmm] = %d \n", mmm, p->index, p->SitesNonAncHere[mmm], q->index, q->SitesNonAncHere[mmm]);*/

					if (stateHere_P < 0 && stateHere_Q < 0) /* non ancestral material */
						{
						r->SitesNonAncHere[mmm] = -1;
						sigue++;
						/*fprintf (fpmpi, "1Position %d is NON anc mat \n", mmm);*/
						}
					if (stateHere_P >= 0 || stateHere_Q >= 0) /* ancestral material (inc pseudo) */
						{
						if (p->SitesNonAncHere[mmm] == 1 && q->SitesNonAncHere[mmm] == 1 && sigue == 0) /* pseudo anc mat */
							{
							r->SitesNonAncHere[mmm] = 1;
							sigue++;
							/*fprintf (fpmpi, "2Position %d is PSEUDO anc mat \n", mmm);*/
							}
						if (p->SitesNonAncHere[mmm] == 1 && stateHere_Q < 0 && sigue == 0) /* pseudo anc mat */
							{
							r->SitesNonAncHere[mmm] = 1;
							sigue++;
							/*fprintf (fpmpi, "3Position %d is PSEUDO anc mat \n", mmm);*/
							}
						if (q->SitesNonAncHere[mmm] == 1 && stateHere_P < 0 && sigue == 0) /* pseudo anc mat */
							{
							r->SitesNonAncHere[mmm] = 1;
							sigue++;
							/*fprintf (fpmpi, "4Position %d is PSEUDO anc mat \n", mmm);*/
							}
						if (sigue == 0)
							{
							if (p->SitesNonAncHere[mmm] == 0 || q->SitesNonAncHere[mmm] == 0)  /* anc mat */
								{
								r->SitesNonAncHere[mmm] = 0;
								sigue++;
								/*fprintf (fpmpi, "5Position %d is ANC mat \n", mmm);*/
								}
							}
						}
					}




				/*fprintf (fpmpi, "\nobtained r->index = %d: r->breakp = %d, r->breakCodon = %d, r->class = %d \n", r->index, r->breakp, r->breakCodon, r->class);*/
				
				if (doBranchNetfiles == YES)
					{
					r->NetLabelPrint = numNetLabelPrint;
					numNetLabelPrint++;

					if (p->NetLabelPrint == q->NetLabelPrint)
						{

						if (r->NetLabelPrint < numSequences)
							fprintf(fpBranchNet,"%d_seq%05d ", r->NetLabelPrint, r->NetLabelPrint+1);
						else
							fprintf(fpBranchNet,"%d ", r->NetLabelPrint);

						if (p->NetLabelPrint < numSequences)
							fprintf(fpBranchNet,"%d_seq%05d\n", p->NetLabelPrint, p->NetLabelPrint+1);
						else
							fprintf(fpBranchNet,"%d\n", p->NetLabelPrint);


						/*fprintf(fpBranchNet,"%d %d\n", r->NetLabelPrint, p->NetLabelPrint);*/
						}
					else
						{

						if (r->NetLabelPrint < numSequences)
							fprintf(fpBranchNet,"%d_seq%05d ", r->NetLabelPrint, r->NetLabelPrint+1);
						else
							fprintf(fpBranchNet,"%d ", r->NetLabelPrint);

						if (p->NetLabelPrint < numSequences)
							fprintf(fpBranchNet,"%d_seq%05d\n", p->NetLabelPrint, p->NetLabelPrint+1);
						else
							fprintf(fpBranchNet,"%d\n", p->NetLabelPrint);


						if (r->NetLabelPrint < numSequences)
							fprintf(fpBranchNet,"%d_seq%05d ", r->NetLabelPrint, r->NetLabelPrint+1);
						else
							fprintf(fpBranchNet,"%d ", r->NetLabelPrint);

						if (q->NetLabelPrint < numSequences)
							fprintf(fpBranchNet,"%d_seq%05d\n", q->NetLabelPrint, q->NetLabelPrint+1);
						else
							fprintf(fpBranchNet,"%d\n", q->NetLabelPrint);

						/*fprintf(fpBranchNet,"%d %d\n", r->NetLabelPrint, p->NetLabelPrint);
						fprintf(fpBranchNet,"%d %d\n", r->NetLabelPrint, q->NetLabelPrint);*/
						}
					if (noisy > 2)
						fprintf (fpmpi, "\nNET INFORMATION Coalescence involving %d and %d to create node %d", p->NetLabelPrint, q->NetLabelPrint, r->NetLabelPrint);
					}


				coalVectorCountStarts = (int *) calloc(((p->numSegNode)+(q->numSegNode)),(long) sizeof(int));
				if (!coalVectorCountStarts)
					{
					fprintf (fpmpi, "Could not allocate coalVectorCountStarts (%lu bytes)\n", ((p->numSegNode)+(q->numSegNode)) *(long) sizeof(int));
					exit (-1);
					}
				coalVectorCountEnds = (int *) calloc(((p->numSegNode)+(q->numSegNode)),(long) sizeof(int));
				if (!coalVectorCountEnds)
					{
					fprintf (fpmpi, "Could not allocate coalVectorCountEnds (%lu bytes)\n", ((p->numSegNode)+(q->numSegNode)) *(long) sizeof(int));
					exit (-1);
					}
				
				
				for (i = 0; i < p->numSegNode; i++)	 /* for each segment of p node going to r node*/
					{
					s = segments + post(i,p->index,distance);
					m = segments + post(i,r->index,distance);					/* new ancester */
					m->sIndexNode = newInd;
					
					s->before1 = m;
					m->before1 = NULL;
					m->before2 = NULL;
					m->after1 = s;
					m->after2 = NULL;
					m->sIndex = actSegIndex;
					m->sStart = s->sStart;
					m->sEnd = s->sEnd;				

					actSegIndex++;
					actNumSegments++;
						
					if (m->sStart == 0 && m->sEnd == 0) /* unreal segments */
						{
						fprintf (fpmpi, "\nNot to be here. COAL1, segment start and end = 0");
						
						m->before1 = m->before2 = m->after1 = m->after2 = NULL;
						actNumSegments--;
						exit(-1);
						}
						
					coalVectorCountStarts[i] = s->sStart;
					coalVectorCountEnds[i] = s->sEnd;
					}
					
				j = p->numSegNode;
				r->numSegNode = j;
				a = b = 0;
				
				for (i = 0; i < q->numSegNode; i++)	/* for each segment of q node going to r node */
					{
					n = segments + post(i,q->index,distance);
					
					for (w = 0; w < j; w++)
						if (n->sStart == coalVectorCountStarts[w] && n->sEnd == coalVectorCountEnds[w]) /* Repeated segment */
							a++;
						
					if (a == 0)
						{
						m = segments + post(j+b,r->index,distance);					/* new ancester */
						r->numSegNode = r->numSegNode+1;
						
						n->before1 = m;
						m->before1 = NULL;
						m->before2 = NULL;
						m->after1 = n;
						m->after2 = NULL;
						m->sIndex = actSegIndex;
						m->sStart = n->sStart;
						m->sEnd = n->sEnd;				
						m->sIndexNode = newInd;
						
						actSegIndex++;
						b++;
						actNumSegments++;
					
						if (m->sStart == 0 && m->sEnd == 0) /* Cheking */ /* unreal segments */
							{
							fprintf (fpmpi, "\nNot to be here. COAL2, segment start and end = 0");
							
							m->before1 = m->before2 = m->after1 = m->after2 = NULL;
							actNumSegments--;
							}
						}
					a = 0;
					}
				a = b = 0;
				free (coalVectorCountStarts);
				free (coalVectorCountEnds);
								

					/* Segment Bonds when this segment goes to 2 descendants segments */
				coalEqualSegInit_p = (int *) calloc((p->numSegNode+q->numSegNode),(long) sizeof(int));
				if (!coalEqualSegInit_p)
					{
					fprintf (fpmpi, "Could not allocate coalEqualSegInit_p (%lu bytes)\n", (p->numSegNode+q->numSegNode) *(long) sizeof(int));
					exit (-1);
					}
				coalEqualSegEnd_p = (int *) calloc((p->numSegNode+q->numSegNode),(long) sizeof(int));
				if (!coalEqualSegEnd_p)
					{
					fprintf (fpmpi, "Could not allocate coalEqualSegEnd_p (%lu bytes)\n", (p->numSegNode+q->numSegNode) *(long) sizeof(int));
					exit (-1);
					}
				coalEqualSegInit_q = (int *) calloc((p->numSegNode+q->numSegNode),(long) sizeof(int));
				if (!coalEqualSegInit_q)
					{
					fprintf (fpmpi, "Could not allocate coalEqualSegInit_q (%lu bytes)\n", (p->numSegNode+q->numSegNode) *(long) sizeof(int));
					exit (-1);
					}
				coalEqualSegEnd_q = (int *) calloc((p->numSegNode+q->numSegNode),(long) sizeof(int));
				if (!coalEqualSegEnd_q)
					{
					fprintf (fpmpi, "Could not allocate coalEqualSegEnd_q (%lu bytes)\n", (p->numSegNode+q->numSegNode) *(long) sizeof(int));
					exit (-1);
					}
				
				for (w = 0; w < p->numSegNode; w++)	
					{
					s = segments + post(w,p->index,distance);
						
					coalEqualSegInit_p[w] = s->sStart;
					coalEqualSegEnd_p[w] = s->sEnd;
					}
				for (w = 0; w < q->numSegNode; w++)	
					{
					n = segments + post(w,q->index,distance);
						
					coalEqualSegInit_q[w] = n->sStart;
					coalEqualSegEnd_q[w] = n->sEnd;
					}
					
				for (w = 0; w < p->numSegNode; w++)
					{
					for (i = 0; i < q->numSegNode; i++)
						{
						if (coalEqualSegInit_p[w] != 0 && coalEqualSegEnd_p[w] != 0 && coalEqualSegInit_p[w] == coalEqualSegInit_q[i] && coalEqualSegEnd_p[w] == coalEqualSegEnd_q[i])
							{
							for (a = 0; a < r->numSegNode; a++)	
								{
								m = segments + post(a,r->index,distance);									
								if (m->sStart == coalEqualSegInit_p[w] && m->sEnd == coalEqualSegEnd_p[w])
									{
									if (noisy == 4)
										fprintf (fpmpi, "\nFragment %d links to 2 descendants, ", m->sIndex);
										
									for (b = 0; b < p->numSegNode; b++)
										{
										s = segments + post(b,p->index,distance);												
										if (coalEqualSegInit_p[w] == s->sStart && coalEqualSegEnd_p[w] == s->sEnd)
											{
											m->after1 = s;
											if (noisy == 4)
												fprintf (fpmpi, "fragment %d", s->sIndex);
											}
										}
									for (b = 0; b < q->numSegNode; b++)
										{
										n = segments + post(b,q->index,distance);											
										if (coalEqualSegInit_p[w] == n->sStart && coalEqualSegEnd_p[w] == n->sEnd)
											{
											m->after2 = n;
											if (noisy == 4)
												fprintf (fpmpi, " and fragment %d", n->sIndex);
												
											}
										}
									}
								}
							}
						}
					}
						
				
				for (i = 0; i < r->numSegNode; i++)			/* cheking, if there are 2 similar segments, it keeps only 1 */		
					{
					m = segments + post(i,r->index,distance);					
					for (w = 0; w < r->numSegNode; w++)
						{
						z = segments + post(w,r->index,distance);						
						if (w != i && m->sStart == z->sStart && m->sEnd == z->sEnd && m->after1 != NULL)
							{
							fprintf (fpmpi, "\n2COAL. Not to be here. It cannot have 2 equal segments en this node.");
							fprintf (fpmpi, "\n m->sIndex = %d, z->sIndex = %d \n", m->sIndex, z->sIndex);
							fprintf (fpmpi, "\n m->sIndex = %d, z->sIndex = %d \n", m->sIndex, z->sIndex);
							
							z->after1 = z->after2 = z->before1 = z->before2 = NULL; /* continue only the z segment */
							r->numSegNode--;
							exit(-1);
							}
						}
					}
				j = w = a = b = 0;
				free (coalEqualSegInit_p);
				free (coalEqualSegEnd_p);
				free (coalEqualSegInit_q);
				free (coalEqualSegEnd_q);
				
					
				
				if (noisy == 4)
					{
					fprintf (fpmpi, "\n\nCoalescence Result is the new node %d with %d fragment(s)", r->index, r->numSegNode);
					for (i = 0; i < r->numSegNode; i++)	
						{
						m = segments + post(i,r->index,distance);
					
						fprintf (fpmpi, "\nFragment %d, ", m->sIndex);
						fprintf (fpmpi, "m->sStart = %d", m->sStart);
						fprintf (fpmpi, " and m->sEnd = %d", m->sEnd);
						}
					fprintf (fpmpi, "\n");
					}
				
				
		
				/** MRCA **/
				/* Array with the information about ancestral stuff */
				/* S_MRCA. overFirst is the biggest site by left & overEnd is the smallest site by right. The difference is the overLapSites */
				sizeNode_p = p->numSegNode;
				sizeNode_q = q->numSegNode;
				out = 0;
			
				if (r->numSegNode == 1) /* 1.- fast. Only 1 segment */
					{
					for (i = 0; i < r->numSegNode; i++)	
						m = segments + post(i,r->index,distance);
				
					overFirst = m->sStart;
					overEnd = m->sEnd;
				
					for (j = 1; j <= numNuc; j++)
						{
						if (j >= overFirst && j <= overEnd)
							{
							S_MRCA[j]--;
							}
						}
					out = 1;
					}
				a = b = k = 0;
			
				if (r->numSegNode > 1)	
					{
					initialVector_pp = (int *) calloc((p->numSegNode),(long) sizeof(int));
					if (!initialVector_pp)
						{
						fprintf (fpmpi, "Could not allocate initialVector_pp (%lu bytes)\n", (p->numSegNode) *(long) sizeof(int));
						exit (-1);
						}
					endVector_pp = (int *) calloc((p->numSegNode),(long) sizeof(int));
					if (!endVector_pp)
						{
						fprintf (fpmpi, "Could not allocate endVector_pp (%lu bytes)\n", (p->numSegNode) *(long) sizeof(int));
						exit (-1);
						}
					initialVector_qq = (int *) calloc((q->numSegNode),(long) sizeof(int));
					if (!initialVector_qq)
						{
						fprintf (fpmpi, "Could not allocate initialVector_qq (%lu bytes)\n", (q->numSegNode) *(long) sizeof(int));
						exit (-1);
						}
					endVector_qq = (int *) calloc((q->numSegNode),(long) sizeof(int));
					if (!endVector_qq)
						{
						fprintf (fpmpi, "Could not allocate endVector_qq (%lu bytes)\n", (q->numSegNode) *(long) sizeof(int));						
						exit (-1);
						}
				
				
					/* 2.- Fast. There is a segment more big than the other segments */
					for (position = 0; position < p->numSegNode; position++)
						{
						s = segments + post(position,p->index,distance);
						initialVector_pp[position] = s->sStart;
						endVector_pp[position] = s->sEnd;
						}
					for (position = 0; position < q->numSegNode; position++)
						{
						n = segments + post(position,q->index,distance);		
						initialVector_qq[position] = n->sStart;
						endVector_qq[position] = n->sEnd;
						}
					
					/* smaller value for the initial */
					for (position = 0; position < p->numSegNode; position++)
						{
						if (position == 0)
							minInit_pp = initialVector_pp[position];
		
						if (initialVector_pp[position] < minInit_pp && initialVector_pp[position] != 0)
							minInit_pp = initialVector_pp[position];
						}

					/* older value for the end */
					for (position = 0; position < p->numSegNode; position++)
						{
						if (position == 0)
							maxEnd_pp = endVector_pp[position];
	
						if (endVector_pp[position] > maxEnd_pp && endVector_pp[position] != 0)
							maxEnd_pp = endVector_pp[position];
						}
		
						/* smaller value for the initial */
					for (position = 0; position < q->numSegNode; position++)
						{
						if (position == 0)
							minInit_qq = initialVector_qq[position];
				
						if (initialVector_qq[position] < minInit_qq && initialVector_qq[position] != 0)
							minInit_qq = initialVector_qq[position];
						}

					/* older value for the end */
					for (position=0; position < q->numSegNode; position++)
						{
						if (position == 0)
							maxEnd_qq = endVector_qq[position];
	
						if (endVector_qq[position] > maxEnd_qq && endVector_qq[position] != 0)
							maxEnd_qq = endVector_qq[position];
						}
			
	
					/* fast, there are in 1 big segment that contains all the segments */					
					for (position = 0; position < p->numSegNode; position++) 
						{
						if (endVector_pp[position] == maxEnd_pp && initialVector_pp[position] == minInit_pp)	
							a = 1;
						}
					for (position = 0; position < q->numSegNode; position++) 
						{
						if (endVector_qq[position] == maxEnd_qq && initialVector_qq[position] == minInit_qq)	
							b = 1;
						}
				
					free (initialVector_pp);
					free (endVector_pp);
					free (initialVector_qq);
					free (endVector_qq);
				
				
					/* 2.- Fast with a big segment */
					if (minInit_pp <= minInit_qq && maxEnd_pp >= maxEnd_qq && a == 1 && b == 1)
						{
						for (j = 1; j <= numNuc; j++)
							{
							if (j >= minInit_qq && j <= maxEnd_qq)
								{
								S_MRCA[j]--;
								}
							}
						a = out = 1;	
						}
					if (minInit_qq <= minInit_pp && maxEnd_qq >= maxEnd_pp && a == 1 && b == 1 && out == 0)
						{
						for (j = 1; j <= numNuc; j++)
							{
							if (j >= minInit_pp && j <= maxEnd_pp)
								{
								S_MRCA[j]--;
								}
							}
						a = out = 1;	
						}
					
					if (maxEnd_pp < minInit_qq && out == 0)
						a = out = 1;
						
					if (maxEnd_qq < minInit_pp && out == 0)
						a = out = 1;
						
					
					if (minInit_pp < minInit_qq && maxEnd_pp < maxEnd_qq && a == 1 && b == 1 && out == 0)
						{
						for (j = 1; j <= numNuc; j++)
							{
							if (j >= minInit_qq && j <= maxEnd_pp)
								{
								S_MRCA[j]--;
								}
							}
						a = out = 1;
						}
						
					if (minInit_qq < minInit_pp && maxEnd_qq < maxEnd_pp && a == 1 && b == 1 && out == 0)
						{
						for (j = 1; j <= numNuc; j++)
							{
							if (j >= minInit_pp && j <= maxEnd_qq)
								{
								S_MRCA[j]--;
								}
							}
						a = out = 1;
						}
					
					a = b = k = w = i = 0;
				
					/* 3.- complex case */
					if (out == 0)
						{
						for (j = 1; j <= numNuc; j++)
							{
							if (overLapSegmentsCoalMRCA(p, q, sizeNode_p, sizeNode_q, j) == YES)
								{
								S_MRCA[j]--;
								}
							}
						}
					}
				j = 0;




				/* Folllowing only ancestral material */
				for (mmm = 1; mmm <= numNuc; mmm++)	 /* Only anc material*/
					{
					if (p->SitesNonAncHere[mmm] == 0 && q->SitesNonAncHere[mmm] == 0)
						{
						/*fprintf (fpmpi, "\n This Position %d is ANC mat: p->index = %d, p->SitesNonAncHere = %d, q->index = %d, q->SitesNonAncHere = %d \n", mmm, p->index, p->SitesNonAncHere[mmm], q->index, q->SitesNonAncHere[mmm]);*/
						OnlyAncS_MRCA[mmm]--;
						}				
					}
				/* Is this the GMRCA of the anc material? */
				Ok_SMRCA_Codon = 0;
				for (mmm = 1; mmm <= numNuc; mmm++)	 /* Only anc material*/
					{
					if (OnlyAncS_MRCA[mmm] == 1)
						{
						/*fprintf (fpmpi, "\n-- Yes anc GMRCA position %d -- \n", mmm);*/
						Ok_SMRCA_Codon++;
						}
					}			
				if (Ok_SMRCA_Codon == numNuc && AncGMRCA_obtained == NO)
					{
					r->GMRCA_ancestral = YES;
					AncGMRCA_obtained = YES;
					if (noisy == 4)
						fprintf (fpmpi, "\n--GMRCA of the ancestral material in node %d-- \n", r->index);
					}



				/* in coalescence is possible link the nodes */
				r->left = p;
				r->right = q;
				p->anc1 = r;
				q->anc1 = r;
				r->time = currentTime;
				/*fprintf (fpmpi, " r->index = %d, r->time = %lf\n", r->index, r->time);*/

				/* readjust active nodes */
				activeGametes[firstInd] = newInd;
				activeGametes[secondInd] = activeGametes[numActiveGametes-1];
				numActiveGametes--; /* it lose 1 active node */
				nextAvailable++; /* 1 node more to available */
			
				if (nextAvailable >= numNodes)	/* if there aren't enough nodes it go into and it addition more */
					{
					/* ReallocNodes(&numNodes, activeGametes); */
					numNodes += INCREMENT_NODES;
					numTotalSegments += (INCREMENT_NODES*maxSegNode)+numNuc;
					
					/* REALLOC */
					segments = (TreeSegment *) realloc (segments, numTotalSegments  * (long) sizeof(TreeSegment)); 
					if (!segments)
						{
						fprintf (fpmpi, "Could not reallocate segments (%lu bytes)\n", ((numNodes*distance)+numNuc)  * (long) sizeof(TreeSegment));
						exit (1);
						}
					nodes = (TreeNode *) realloc (nodes, numNodes  * (long) sizeof(TreeNode));
					if (!nodes)
						{
						fprintf (fpmpi, "Could not reallocate nodes (%lu bytes)\n", numNodes  * (long) sizeof(TreeNode));
						exit (-1);
						}
					activeGametes = (int *) realloc (activeGametes, numNodes *(long) sizeof(int));
					if (!activeGametes)
						{
						fprintf (fpmpi, "Could not reallocate activeGametes (%lu bytes)\n", numNodes *(long) sizeof(int));
						exit (-1);
						}
					if (noisy == 4)
						fprintf (fpmpi, "\n\n...Doing reallocation of nodes (1)\n");
						
					}
				}	/* end of coalescence */
		
						
			/* print out ancestral (active) status for each site and MRCA vector - only mat anc */
			if (noisy > 2)
				{
				fprintf (fpmpi,"\n - Ancestral MRCA in the nodes: -\n");
				for (i=0; i<numActiveGametes; i++)
					{
					for (j=1; j<=numNuc; j++)
						{
						p = nodes + activeGametes[i];
						if (j == 1)
							fprintf (fpmpi, "%4d -- (MRCA:)", p->index);
						fprintf (fpmpi, "%d", OnlyAncS_MRCA[j]);
						}
					fprintf (fpmpi, "\n");
					}
				/*fprintf (fpmpi, "MRCA   ");*/
				for (j=1; j<=numNuc; j++)
					{
					if (OnlyAncS_MRCA[j] <= 1)
						fprintf (fpmpi, "*");
					else
						fprintf (fpmpi, " ");
					}
				/*fprintf (fpmpi, "\n");*/
				fprintf (fpmpi,"\n\n");
				}

			/* print out ancestral (active) status for each site and MRCA vector */
			if (noisy > 2)
				{
				fprintf (fpmpi,"\nMRCA in the nodes:\n");
				for (i=0; i<numActiveGametes; i++)
					{
					for (j=1; j<=numNuc; j++)
						{
						p = nodes + activeGametes[i];
						if (j == 1)
							fprintf (fpmpi, "%4d -- (MRCA:)", p->index);
						fprintf (fpmpi, "%d", S_MRCA[j]);
						}
					fprintf (fpmpi, "\n");
					}
				/*fprintf (fpmpi, "MRCA   ");*/
				for (j=1; j<=numNuc; j++)
					{
					if (S_MRCA[j] <= 1)
						fprintf (fpmpi, "*");
					else
						fprintf (fpmpi, " ");
					}
				/*fprintf (fpmpi, "\n");*/
				}
			
			
			sizeNode = sizeNode_p = sizeNode_q = 0;
			free (gi);

			

			/* If doing dated tips, sometimes the number of actives nodes can be already 1 before all have been activated samples. 
			If this happens we need to move towards the next sample, activate it, and start again */
			if (doDatedTips == YES)
			 if (numActiveGametes == 1 && currentSample > 0)
				{
				if (noisy > 2)
					fprintf (stderr, "\n\nOnly 1 lineage active before activating all samples"/*, currentSample*/);
				currentSample--;

				/* activate nodes from this sample*/
				if (noisy > 2)
					fprintf (stderr, "\n Activating sample %d (time = %6.4f). Tips to activate:", currentSample, datedSample[currentSample].time);
				for (i=0; i<datedSample[currentSample].size; i++)
					{
					if (noisy > 2)
						fprintf (stderr, " %d", datedSample[currentSample].member[i]-1);
					
					p = nodes + datedSample[currentSample].member[i]-1;
					p->index = datedSample[currentSample].member[i]-1;
					activeGametes[numActiveGametes] = datedSample[currentSample].member[i]-1;  
						
					numActiveGametes++;
					}
				currentTime = datedSample[currentSample].time;
	
				if (noisy > 2)
					{
					fprintf (stderr, "\nActive nodes (%d):", numActiveGametes); 
					for (i=0; i<numActiveGametes; i++)
						fprintf (stderr," %d",activeGametes[i]);
					fprintf (stderr,"   Next node available = %d ", nextAvailable);
					fprintf (stderr, "\nSetting currentTime = %6.4f", currentTime);
					}
				}




			} /* coalescent tree finished */

		
		 /* Cheking */
		/*for (w = 1; w <= numNuc; w++)
			{
			if (S_MRCA[w] > 1 || S_MRCA[w] < 1)
				{*/
				/*
				fprintf (fpmpi, "\n Warning S_MRCA in the last node is > 1, S_MRCA[%d] = %d", w, S_MRCA[w]);
				exit (-1);
				}
			}*/


		/*if (noisy > 1)			
			fprintf (fpmpi, "\n\n\n>> Coalescent tree/s finished\n");*/
		if (noisy > 1)			
			fprintf (fpmpi, "\n\n\n>> Coalescent finished\n");
			
				
		counterTimeInit = counterTimeInit + currentTime;
		actualTGMRCA = currentTime;


		/* Use it to see the evolution nodes-segments */
		
		/*
		fprintf (fpmpi, "\n\n\nnextAvailable = %d",nextAvailable);
		for (j = 0; j < numNodes; j++)*/	/* Looking for parent Node of segments */	
		/*	{
			p = nodes + j;
			fprintf (fpmpi, "\n\n\n\n**The node %d**",p->index);

			for (i=0; i < p->numSegNode; i++)
				{
				s = segments + post(i,j,numNuc);	
				p->seg = s;
			
				fprintf (fpmpi, "\n\ns->sIndex %d con s->parentNode->index = %d", s->sIndex, s->parentNode->index);
				if (s->after1 != NULL)
					fprintf (fpmpi, "\ns->after1->sIndex %d con s->after1->parentNode->index = %d", s->after1->sIndex, s->after1->parentNode->index);
				if (s->after2 != NULL)
					fprintf (fpmpi, "\ns->after2->sIndex %d con s->after2->parentNode->index = %d", s->after2->sIndex, s->after2->parentNode->index);
				}
			}*/
			
		}
	
		



	
	/********** BUILDING TREES ***********/
	/* first, we build an array with order breakpoints from - to + */
	free (activeGametes);
	
	if (doFixNumRecEvents == NO || numRE == fixedNumRecEvents) /* Good replicate */
		{
		if (noisy > 1)
			{
			fprintf (fpmpi, "\n\n>> Network finished\n");
			fprintf (fpmpi, "\n\n>> Building trees ..");
			}
		if (noisy == 4 && numRE > 0)
			fprintf (fpmpi, "\n\n");
		
		
		arrayIndBreakpoints = (int *) calloc((numRE+1),(long) sizeof(int));
		if (!arrayIndBreakpoints)
			{
			fprintf (fpmpi, "Could not allocate arrayIndBreakpoints (%lu bytes)\n", (numRE+1) *(long) sizeof(int));
			exit (-1);
			}
		arrayIndBreakpointsOrd = (int *) calloc((numRE+1),(long) sizeof(int));
		if (!arrayIndBreakpointsOrd)
			{
			fprintf (fpmpi, "Could not allocate arrayIndBreakpointsOrd (%lu bytes)\n", (numRE+1) *(long) sizeof(int));	
			exit (-1);
			}
		for (w = 0; w < numRE; w++)
			{
			arrayIndBreakpoints[w] = breakpoint[w];
			arrayIndBreakpointsOrd[w] = 0;
			/*
			fprintf (fpmpi, "arrayIndBreakpoints[%d] = %d\n", w, arrayIndBreakpoints[w]);
			*/
			}
		
		/*fprintf (fpmpi, "arrayIndBreakpoints[%d+1] = %d\n", w+1, arrayIndBreakpoints[w+1]);	*/
		
	
		j = arrayIndBreakpoints[0];
		for (k = 0; k < numRE; k++)
			{
			for (w = 0; w < numRE; w++)		/* order breakpoints, from - to + */
				if (arrayIndBreakpoints[w] < j)
					j = arrayIndBreakpoints[w];
				
			if (j > numNuc) /* end */
				{
				arrayIndBreakpointsOrd[k] = 0;
				break;
				}
					
			for (w = 0; w < numRE; w++)
				if (arrayIndBreakpoints[w] == j)
					arrayIndBreakpoints[w] = numNuc+1;
		
			arrayIndBreakpointsOrd[k] = j;
			j = numNuc+1;
			}
		free (arrayIndBreakpoints);
	
		indNumRE = 0;
		if (noisy == 4 && numRE > 0)
			fprintf (fpmpi, "Breakpoints list (from the smallest to the biggest value):\n");
			
		for (k = 0; k < numRE; k++)
			{
			if (arrayIndBreakpointsOrd[k] != 0)
				indNumRE++;
			if (noisy == 4 && numRE > 0 && arrayIndBreakpointsOrd[k] != 0)
				fprintf (fpmpi, "%d\n", arrayIndBreakpointsOrd[k]);
			}
		
		for (k = 0; k < indNumRE; k++)
			{
			if (k != 0)
				if (arrayIndBreakpointsOrd[k] < arrayIndBreakpointsOrd[k-1])
					{
					fprintf (fpmpi, " \n\n Warning in arrayIndBreakpointsOrd[k], 2 similar breakpoints in this array. See the indepBrekp vector");
					/*exit (-1);*/ /* but no problem */
					}
			}

		/* about the GMRCA */
		p = nodes + newInd; /* because the last one process is the last one coalescence */
		p->class = 5;
		treeRootInit[0] = p;

		/* The trees */
		if (noisy > 3)
			fprintf (fpmpi, "\nIt generates %d tree(s):", indNumRE+1);
			
		j = k = w = countNumTrees = 0;
	
		numSegTrees = (int *) calloc((indNumRE+2),(long) sizeof(int));
		if (!numSegTrees)
			{
			fprintf (fpmpi, "Could not allocate numSegTrees (%lu bytes)\n", (indNumRE+2) *(long) sizeof(int));
			exit (-1);
			}

		/* determination of number of segments for each tree, from the GMRCA node */
		for (i = 0; i < p->numSegNode; i++)
			{
			s = segments + post(i,p->index,distance);			
			j = 0;

			if (s->sStart == 1 && s->sEnd >= (arrayIndBreakpointsOrd[j]-1) && s->after1 != NULL) /* first tree */
				numSegTrees[j]++;
			
			if (indNumRE-1 >= 0) /*only with rec event*/
				if (s->sStart <= arrayIndBreakpointsOrd[indNumRE-1] && s->sEnd == numNuc && s->after1 != NULL) /* last tree */
					numSegTrees[indNumRE]++;

			if (s->after1 == NULL && s->after2 == NULL) /* no conect segments, it must to be 0 */
				numSegTrees[indNumRE+1]++;

			if (indNumRE > 1)
				{
				for (j = 0; j < (indNumRE-1); j++)
					if (s->sStart <= (arrayIndBreakpointsOrd[j]) && s->sEnd >= (arrayIndBreakpointsOrd[j+1]-1) && s->after1 != NULL) /* internal trees */
						numSegTrees[j+1]++;
				}
			}
	
		if (noisy == 4)
			for (i = 0; i < (indNumRE+1); i++)
				fprintf (fpmpi, "\nTree %d starts by %d fragment(s)", i+1, numSegTrees[i]);
		
		
			/*** building trees ***/
		j = k = w = a = b = 0;
		/* default */
		numNodex = (indNumRE+1)*numNodes;
		if (indNumRE > 1000)
			numNodex = numNodex/5;
		if (indNumRE > 10000)
			numNodex = numNodex/50;
		if (indNumRE > 100000)
			numNodex = numNodex/50000;		
		/*fprintf (stderr, "\nindNumRE = %d, numNodex= %d", indNumRE, numNodex);*/
		
		nodex = (TreeNodex *) calloc (numNodex, sizeof(TreeNodex)); /* nodes */
		if (!nodex)
			{
			fprintf (fpmpi, "\nCould not allocate nodex1 (%lu bytes)\n", numNodex  * (long) sizeof(TreeNodex));
			
			fprintf (fpmpi, "\nSecond try \n");
			free (nodex);
			numNodex = (indNumRE+1)*numNodes/2;
			if (indNumRE > 1000)
				numNodex = numNodex/15;
			if (indNumRE > 10000)
				numNodex = numNodex/100;
			if (indNumRE > 100000)
				numNodex = numNodex/500000;	

			nodex = (TreeNodex *) calloc (numNodex, sizeof(TreeNodex)); /* nodes */
			if (!nodex)
				{
				fprintf (fpmpi, "\nCould not allocate nodex2 (%lu bytes)\n", numNodex  * (long) sizeof(TreeNodex));

				fprintf (fpmpi, "\nThird try \n");
				free (nodex);
				numNodex = (indNumRE+1)*numNodes/5;
				if (indNumRE > 1000)
					numNodex = numNodex/30;
				if (indNumRE > 10000)
					numNodex = numNodex/200;
				if (indNumRE > 100000)
					numNodex = numNodex/700000;	

				nodex = (TreeNodex *) calloc (numNodex, sizeof(TreeNodex)); /* nodes */
				if (!nodex)
					{
					fprintf (fpmpi, "\nCould not allocate nodex3 (%lu bytes)\n", numNodex  * (long) sizeof(TreeNodex));

					fprintf (fpmpi, "\nFourth try \n");
					free (nodex);
					numNodex = (indNumRE+1)*numNodes/50;
					if (indNumRE > 1000)
						numNodex = numNodex/100;
					if (indNumRE > 10000)
						numNodex = numNodex/400;
					if (indNumRE > 100000)
						numNodex = numNodex/900000;	

					nodex = (TreeNodex *) calloc (numNodex, sizeof(TreeNodex)); /* nodes */
					if (!nodex)
						{
						fprintf (fpmpi, "\nCould not allocate nodex4 (%lu bytes)\n", numNodex  * (long) sizeof(TreeNodex));
						exit (1);
						}
					}
				}
			}

		treeRootNodex = (TreeNodex **) calloc(indNumRE+1, sizeof(TreeNodex *)); /* node pointers */
		if (!treeRootNodex)
			{
			fprintf (fpmpi, "Could not allocate treeRootNodex (%lu bytes)\n", indNumRE+1  * (long) sizeof(TreeNodex));			
			exit (1);
			}

		for (i = 0; i < numNodex; i++)
			{
			nodex[i].left = NULL;
			nodex[i].right = NULL;
			nodex[i].anc1 = NULL;
			nodex[i].outgroup = NULL;
			nodex[i].index = 0;
			nodex[i].NetIndex = -1;
			nodex[i].indexOldMigPop = 0;
			nodex[i].label = 0;
			nodex[i].isOutgroup = NO;
			nodex[i].length = 0.0;
			nodex[i].time = 0.0;
			nodex[i].MRCAfrom = -1;
			nodex[i].MRCAto = -1;
			}

		/* making trees */
		/*fprintf (stderr, "\n\n\n *********** MAKING TREES **********\n\n");*/
		f = nodex + a;
		f->index = 0;
		f->NetIndex = p->index;
		f->length = p->length;
		f->time = p->time;
		f->indexOldMigPop = p->indexOldMigPop;
		i = 0;
	
		if (indNumRE == 0) /* there aren't recombinations */
			{
			/*f = p;*/
			f->MRCAfrom = 1;
			f->MRCAto = numNuc;
			treeRootNodex[a] = f;
			/*treeRootNodex[a].MRCAfrom = 1;
			treeRootNodex[a].MRCAto = numNuc; */

			/*if (noisy >= 3)
				fprintf (fpmpi, "\nThere aren't recombinations. treeRootNodex[%d] = %d", a, treeRootNodex[a]->index);*/
			if (noisy > 2)
				fprintf (fpmpi,"\n\n>> Making the tree..");
				
			countNumTrees++;
			buildTreeCoal(p, f, numSequences, &numActNodex);
			numActNodex++;
			i = 0;
			}
	
		/* Several trees */
		if (indNumRE > 0) /* first tree */
			{
			/*f->MRCAfrom = 1;
			f->MRCAto = arrayIndBreakpointsOrd[j]-1;
			fprintf (fpmpi,"\n a = %d, arrayIndBreakpointsOrd[j]-1 = %d, f->index = %d, f->NetIndex = %d, f->time = %lf", a, arrayIndBreakpointsOrd[j]-1, f->index, f->NetIndex, f->time);
			fprintf (fpmpi,"\n in first tree numActNodex = %d, p->index = %d", numActNodex, p->index);*/

			treeRootNodex[a] = f;
			/*fprintf (fpmpi,"\n in first tree treeRootNodex[a]->index = %d", treeRootNodex[a]->index);*/
			treeRootNodex[a]->MRCAfrom = 1;
			treeRootNodex[a]->MRCAto = arrayIndBreakpointsOrd[j]-1; 
			i = a;
			if (noisy > 2)
				fprintf (fpmpi,"\n\n\n>> Making the first tree..");
				
		
			for (step = 0; step < p->numSegNode; step++)				
				{
				s = segments + post(step,p->index,distance);				
				if (s->sStart == 1 && s->sEnd >= (arrayIndBreakpointsOrd[j]-1) && s->after1 != NULL)
					{
					k++;
					if (k == numSegTrees[0])
						{
						countNumTrees++;
						buildTreeInit(p, f, numNuc, arrayIndBreakpointsOrd, j, numSequences, &numActNodex);
						}
					}
				}
			k = 0;
			numActNodex++;
		
			if (indNumRE > 1)		/* Internal trees */
				{
				for (j = 0; j < (indNumRE-1); j++)
					{
					/*fprintf (fpmpi,"\n Desde internal primero trees numActNodex = %d", numActNodex);*/
					f = nodex + numActNodex;
					f->index = numActNodex;
					f->NetIndex = p->index;
					f->length = p->length;
					f->time = p->time;
					f->indexOldMigPop = p->indexOldMigPop;
					numActNodex++;
					
					f->MRCAfrom = arrayIndBreakpointsOrd[j];
					f->MRCAto = arrayIndBreakpointsOrd[j+1]-1;
					treeRootNodex[j+1] = f;
					/*fprintf (fpmpi,"\n in intern tree treeRootNodex[j+1]->index = %d", treeRootNodex[j+1]->index);*/
					/*treeRootNodex[j+1].MRCAfrom = arrayIndBreakpointsOrd[j];
					treeRootNodex[j+1].MRCAto = arrayIndBreakpointsOrd[j+1]-1;*/
					
					if (noisy > 2)
						fprintf (fpmpi,"\n>> Making internal tree %d..", j+1);
						
						
					for (step = 0; step < p->numSegNode; step++)		
						{
						s = segments + post(step,p->index,distance);			 
						if (s->sStart <= (arrayIndBreakpointsOrd[j]) && s->sEnd >= (arrayIndBreakpointsOrd[j+1]-1) && s->after1 != NULL) /* internal trees, it can to be several trees */
							{
							k++;
							if (k == numSegTrees[j+1])	/* the last segment of internal tree */
								{
								countNumTrees++;
								buildTreeIntern(p, f, numNuc, arrayIndBreakpointsOrd, j, numSequences, &numActNodex);
								}
							}
						}
					k = 0;
					numActNodex++;
					}
				j = 0;
				}

		
				/* last tree */
			/*fprintf (fpmpi,"\n in Last tree primero numActNodex = %d", numActNodex);*/
			f = nodex + numActNodex;
			f->index = numActNodex;
			f->NetIndex = p->index;
			f->length = p->length;
			f->time = p->time;
			f->indexOldMigPop = p->indexOldMigPop;
		
			numActNodex++;

			f->MRCAfrom = arrayIndBreakpointsOrd[indNumRE-1];
			f->MRCAto = numNuc;			

			treeRootNodex[indNumRE] = f;
			/*fprintf (fpmpi,"\n in last tree treeRootNodex[indNumRE]->index = %d", treeRootNodex[indNumRE]->index);*/
			/*treeRootNodex[indNumRE].MRCAfrom = arrayIndBreakpointsOrd[indNumRE-1];
			treeRootNodex[indNumRE].MRCAto = numNuc;*/

		
			if (noisy > 2)
				fprintf (fpmpi,"\n>> Making the last tree..");
				
			for (step = 0; step < p->numSegNode; step++)		
				{
				s = segments + post(step,p->index,distance);
				if (s->sStart <= arrayIndBreakpointsOrd[indNumRE-1] && s->sEnd == numNuc && s->after1 != NULL)
					{
					k++;
					if (k == numSegTrees[indNumRE])	/* the last segment of internal tree */
						{
						countNumTrees++;
						j = indNumRE-1;
					
						buildTreeEnd(p, f, numNuc, arrayIndBreakpointsOrd, j, numSequences, &numActNodex);
						}
					}
				}
			free (numSegTrees);
			k = j = 0;
			numActNodex++;
			

			/* get rid of superflous nodes */
			a = 0;
			
			if (noisy > 3)
				fprintf (fpmpi, "\n\n");
			if (noisy > 3)
				fprintf (fpmpi, "\n>> Removing superfluos nodes .."); /* nodex */
				
			
			foundSuperflousNode = YES;
			while (foundSuperflousNode == YES)
				{
				foundSuperflousNode = NO;
		
				for (i = 0; i < numActNodex; i++) /* available all nodes */
					{
					f = nodex + i;
			
					if (f->left == NULL && f->right == NULL && f->anc1 == NULL)
						{
						/* nothing to do with this node because it is not connected to anything */
						}
					else if (f->left == NULL && f->right == NULL && f->anc1 != NULL)
						{
						/* do not do anything with this node because it is a tip */
						}
					else if (f->left != NULL && f->right == NULL && f->anc1 != NULL)
						{
						/* this is a superflous node and can be removed */
						foundSuperflousNode = YES;
					
						g = f->left;
						h = f->anc1;
						if (f->anc1->left == f) /* p->anc up, p->left down, total: up and down for left */
							{
							h->left = g;
							g->anc1 = h;
							f->left = NULL;
							f->anc1 = NULL;
							}
						else
							{
							h->right = g;
							g->anc1 = h;
							f->left = NULL;
							f->anc1 = NULL;
							}
						}
					else if (f->left == NULL && f->right != NULL && f->anc1 != NULL)
						{
						/* this is a superflous node and can be removed */
						foundSuperflousNode = YES;
			
						g = f->right;
						h = f->anc1;
					
						if (f->anc1->left == f)
							{
							h->left = g;
							g->anc1 = h;
							f->right = NULL;
							f->anc1 = NULL;
							}
						else
							{
							h->right = g;
							g->anc1 = h;
							f->right = NULL;
							f->anc1 = NULL;
							}
						}
					else if (f->left != NULL && f->right != NULL && f->anc1 != NULL)
						{
						/* this is an internal node formed by a coalescence event, do not touch */
						}
					else if (f->left != NULL && f->right != NULL && f->anc1 == NULL)
						{
						/*fprintf (fpmpi, "\nEn superfluos. f->index = %d\n",  f->index);*/
						/*fprintf (stderr, "\nGMRCA node %d", f->index);*/
						if (a <= indNumRE)					/* THIS IS VERY IMPORTANT, "HERE" WE GIVE ALL THE MRCAs OF NODEX */
							treeRootNodex[a] = f;
						a++;
					
						/* this is the last (coalescence event) in the tree, GMRCA */
						}
					else if (f->left != NULL && f->right == NULL && f->anc1 == NULL)
						{
						/* Seems to be the last coalescent event among sequences with non-ancestral material */	
						/* it is not superfluous, we just remove it */
						f->left->anc1 = NULL;
						}
					else if (f->left == NULL && f->right != NULL && f->anc1 == NULL)
						{
						/* not clear what this node could be doing, but we will remove it anyway */
						fprintf (fpmpi, "strange\n");
						
						f->left = NULL;
						f->right->anc1 = NULL;
						}
					else
						{
						fprintf (fpmpi, "You should not be here, I think\n");
						fprintf (fpmpi, "%d %d-- %d %d %d\n", IndexSeg(f), a, IndexSeg(f->left), IndexSeg(f->right), IndexSeg(f->anc1));
						exit (-1);
						}
					}
				}
			}
		
		if (noisy == 4)
			{
			fprintf (fpmpi, "\n\nProgram Information. List about the root nodes index: ");
			for (j = 0; j <= indNumRE; j++)		
				fprintf (fpmpi, "\ntreeRootNodex[%d]->index = %d", j, treeRootNodex[j]->index); /* careful with the superfluos nodes*/
			}
		
		/*fprintf (fpmpi, "\n\nProgram Information. List about the root nodes index: ");
		for (j = 0; j <= indNumRE; j++)		
			fprintf (fpmpi, "\ntreeRootNodex[%d]->index = %d, treeRootNodex[%d]->time = %lf, NetIndex = %d, from %d to %d", j, treeRootNodex[j]->index, j, treeRootNodex[j]->time, treeRootNodex[j]->NetIndex, treeRootNodex[j]->MRCAfrom, treeRootNodex[j]->MRCAto); */
		



		/* MRCAconcatenate part */
		NodesMRCAposit[0]= -1; /* en este vector se guardara: posicion 1 es el label (=index) del nodo MRCA del nuc 1, posicion 2... */
		/*fprintf (fpmpi, "\n\n");*/
		for (sss = 1; sss <= numNuc; sss++)
			{

			for (j = 0; j <= indNumRE; j++)
				{
				if (sss >= treeRootNodex[j]->MRCAfrom && sss <= treeRootNodex[j]->MRCAto)
					{
					saveThis = 0;
					saveThis = treeRootNodex[j]->NetIndex;
					NodesMRCAposit[sss] = saveThis;
					break;

					}
				}
			/*fprintf (fpmpi, "\n Site %d for node label %d ", sss, NodesMRCAposit[sss]);*/
			}




		
		
		if (thereisOutgroup == YES)   /* special node -Outgroup- */
			{
			if (noisy > 1)
				fprintf (fpmpi, "\n\n\n>> Attaching outgroup (everytree) .. \n");
				
			if (indNumRE == 0)
				{
				/* f is the outgroup node */
				numActNodex++;
				f = nodex + numActNodex;
		
				f->left = NULL;
				f->right = NULL;
				f->anc1 = treeRootNodex[0];
				f->time = 0;
				f->length = outgroupBranchLength/mutationRate;
				f->indexOldMigPop = 0;
				f->isOutgroup = YES;
				f->index = numActNodex;
				f->NetIndex = nextAvailable++/* -1 */;	
				/* p->label = p->index;*/
				f->label = numSequences;
				f->outgroup = NULL;		/* the outgroup can't has outgroup.. */
				treeRootNodex[0]->outgroup = f;
				}
			if (indNumRE > 0)
				{
				for (step = 0; step <= indNumRE; step++)
					{
					/* p is the outgroup node */
					numActNodex++;
					f = nodex + numActNodex;
			
					f->left = NULL;
					f->right = NULL;
					f->anc1 = treeRootNodex[step];
					f->time = 0;
					f->length = outgroupBranchLength/mutationRate;
					f->indexOldMigPop = 0;
					f->isOutgroup = YES;
					f->index = numActNodex;	
					f->NetIndex = nextAvailable++/* -1 */;
					/* p->label = p->index; */
					f->label = numSequences;
					f->outgroup = NULL;	/* the outgroup can't has outgroup.. */
					treeRootNodex[step]->outgroup = f;
					}
				}
			}
		else
			{
			if (noisy > 1)
				fprintf (fpmpi, "\n");
			}

		/* relabel nodes on tree */
		if (noisy > 1)
			fprintf (fpmpi, "\n\n>> Relabeling nodes (everytree) .. \n\n");

		/* tipLabel = 0; */
		if (indNumRE == 0)
			{
			/*tipLabel = 0;*/
			if (thereisOutgroup == YES)
				intLabel = numSequences+1;
			else
				intLabel = numSequences;
			RelabelNodesSeg(treeRootNodex[0]);
			}
		if (indNumRE != 0)
			{
			for (step = 0; step <= indNumRE; step++)
				{
				/*tipLabel = 0;*/
				if (thereisOutgroup == YES)
					intLabel = numSequences+1;
				else
					intLabel = numSequences;

				RelabelNodesSeg(treeRootNodex[step]);		
				}
			}
		/** NET RECODON **/
		if (thereisOutgroup == YES)   /* NET RECODON - OUTGROUP *//* special "node" -Outgroup- */
			{
			/* r is the outgroup node */
			r = nodes + nextAvailable;
		
			r->left = NULL;
			r->right = NULL;
			r->sib = NULL;
			r->class = 2;
			r->GMRCA_ancestral = NO;
			r->breakp = NO;
			r->breakCodon = NO;
			r->anc1 = treeRootInit[0];
			r->time = 0;
			r->length = outgroupBranchLength/mutationRate;
			r->indexOldMigPop = 0;
			r->isOutgroup = YES;
			r->index = nextAvailable++;
			//r->NetIndex = nextAvailable++/* -1 */;	
			/* p->label = p->index;*/
			//r->label = numSequences;
			r->outgroup = NULL;		/* the outgroup can't has outgroup.. */
			treeRootInit[0]->outgroup = r;				
			/*nextAvailable++;*/
			}
		/*fprintf (fpmpi, "\n\n nextAvailable = %d \n\n", nextAvailable);*/
		for (i=0; i<nextAvailable; i++) /* NET RECODON - labels*/
			{
			nodes[i].label = nodes[i].index;
			/*fprintf (fpmpi, "\n\n Node index = %d, Node label = %d, class = %d, deme = %d \n\n", nodes[i].index, nodes[i].label, nodes[i].class, nodes[i].indexOldMigPop);*/
			}


		/* Cheking */
		/*for (i = 0; i < p->numSegNode; i++)	
			{
			s = segments + post(i,p->index,distance);
			if (s->after1 == NULL && s->after2 == NULL)
				{*/
				/*
				fprintf (fpmpi, "\n\nThe fragments %d isn't in the trees\n\n", s->sIndex);
				exit (-1);
				}
			}*/
		
		/*if (indNumRE+1 != countNumTrees)
			{
			fprintf (fpmpi, "\n\nWarning, indNumRE+1 %d != countNumTrees %d \n\n", indNumRE+1, countNumTrees);
			exit (-1);
			}*/
		/*for (i=0; i<nextAvailable; i++)
			{
			r = nodes+i;
			
			fprintf(fpmpi, "\n r->index = %d, r->label = %d, r->time = %lf", r->index, r->label, r->time);
			}*/
			
			
			
			
		}

	free (stud);
	/*free (treeRootInit);*/

	free (S_MRCA);
	free (OnlyAncS_MRCA);
	
	/*free (activeGametes);	*/
	/*free (segments);
	free (nodes);*/
	
	}









/************************* MakeCoalescenceTreeHotspotRec ************************/
/* Builds a genealogy for each site under the coalescent with hotspots of
 recombination and migration */ /* this function go by events */ 
 
void MakeCoalescenceTreeHotspotRec (int numSequences, int numSites, int numNuc, int N, double recombinationRate, int numPopulations, long int *seed)
	{
	int			tt, e, c, d, i, j, w, k, a, b, aa, bb, aaa, bbb, ss, step, position, overFirst, overEnd, sss, *activeGametes, isCoalescence, whichInd, 
				whichSite, hasPassedBreakPoint,
				firstInd, secondInd, newInd, firstHalf, secondHalf, foundSuperflousNode, eventNum, numActiveGametes, 
				period, isRecombination, isMigration, whichDeme, arrivedDeme, currentBigDeme, currentDemesNumber; /*legalBreakpoint,*/ 
	int			minInit_qq, minInit_pp, maxEnd_pp, maxEnd_qq;
	int			actNumSegments, numTotalSegments, labelNodes;
	double		rateCA, rateRE, rate, rateMIG, timeRE, timeCA, timeMIG, currentTime, eventTime, probRecIndividual, timeCONV, variable1, variable2;
	TreeNode	*p, *q, *r;
	TreeSegment *s, *n, *m, *z;
	TreeNodex	*f, *g, *h;
	double 		Gi;
	double		*gi; 
	int			*arrayIndBreakpoints, *numSegTrees, *coalVectorCountStarts, *coalVectorCountEnds;
	int			*coalEqualSegInit_p, *coalEqualSegInit_q, *coalEqualSegEnd_p, *coalEqualSegEnd_q;
	int			*initialVector_pp, *initialVector_qq, *endVector_pp, *endVector_qq;
	int			*endsVectorRec, *startsVectorRec;
	int			sizeNode, sizeNode_p, sizeNode_q, out;
	int			numActNodex, countNumTrees;
	double		ran;
	double		*cumPopulPart;
	int			many, memoryBreakp, maxSegNode;
	int			nodeValue;
	int			*cumInitPopul, *numParcialActiveGametes, *ArrivedDemesOptions, *CurrentDemesState, *stud;
	double		*GiPartial;
	double		*rateREpartial, *rateCApartial, *rateMIGpartial, *ratePartial, *cumPopulTase;
	int			currentSample, saveThis;	
	int			doBreakpBroken, LeftLess, LeftHigh, RightLess, RightHigh, LeftLess2, RightHigh2, mmm, stateHere_P, stateHere_Q, sigue, Ok_SMRCA_Codon, AncGMRCA_obtained;
	int			controlConvSTST1, summConvSTST1, controlConvSTST2, summConvSTST2, OkValue, OkValue1, OkValue2, OkValueCI, newOkValueCI;	
	double		currentMigrationRate;
	int 		cuantos;
	double		RdValue;

	int			lowerTail, upperTail, printRecPDF;
	double		probRecSite;
	double 		cum_gi, cum_gammaRec;
	double		*gammaRec, *counts;
	FILE		*fpCounts;
	
	/* defaults */
	isCoalescence = NO;
	isRecombination = NO;
	isMigration = NO;
	minInit_qq = minInit_pp = maxEnd_pp = maxEnd_qq = newInd = whichDeme = labelNodes = ss = saveThis = 0;
	numNodex = 0;
	maxSegNode = 1;
	currentSample = -1;
	m = NULL;
	n = NULL;
	ratePartial = NULL;
	rateREpartial = NULL;
	rateCApartial = NULL;
	rateMIGpartial = NULL;
	cumPopulTase = NULL;
	GiPartial = NULL;
	numParcialActiveGametes = NULL;
	cumInitPopul = NULL;
	ArrivedDemesOptions = NULL;
	CurrentDemesState = NULL;
	numNodes = 5000;
	memoryBreakp = /*numSites*/ numNuc;
	timeCONV = 0;
	currentBigDeme = 0;
	eventTime = 0.0;
	variable1 = 0.0;
	variable2 = 0.0;
	numREbreakCod = 0;
	numStopCodonREC = 0;
	numNetLabelPrint = 0;
	doBreakpBroken = NO;
	LeftLess = LeftHigh = RightLess = RightHigh = LeftLess2 = RightHigh2 = -1;
	stateHere_P = stateHere_Q = -2;
	mmm = sigue = Ok_SMRCA_Codon = 0;
	AncGMRCA_obtained = NO;
	overFirst = overEnd = sizeNode_p = sizeNode_q = sizeNode = out = numActNodex = many = c = 0;
	controlConvSTST1 = summConvSTST1 = controlConvSTST2 = summConvSTST2 = newOkValueCI = 0;
	OkValueCI = 1;
	printRecPDF = NO;
	giBegin = giEnd = 0;
	whichSite = -1;

	currentDemesNumber = numPopulations;


	/** Initial memories **/
	/*distance = numSites*2+2; is the max segments number in a node */
	/* initial number of nodes according to the recombination rate */
	if (recombinationRate == 0.00)
		distance = 1;
	else /* recombinationRate > 0 */
		{
		if (/*numSites*/numNuc < 400)
			distance = /*numSites*/numNuc*4;
		if (/*numSites*/numNuc >= 400 && /*numSites*/numNuc <= 1000)
			distance = /*numSites*/numNuc*3;
		if (/*numSites*/numNuc > 1000)
			distance = /*numSites*/numNuc*1.5;
		if (/*numSites*/numNuc > 10000)
			distance = /*numSites*/numNuc*0.5;
		if (/*numSites*/numNuc > 100000)
			distance = /*numSites*/numNuc*0.005;
		}

	/* initial segments from numSites and rec rate */
	if (recombinationRate == 0.00) 
		maxSegNode = 1;
	else /* recombinationRate > 0 */
		{
		if (/*numSites*/numNuc < 400)
			{
			if (recombinationRate <= 0.00001)
				maxSegNode = /*numSites*/numNuc*2;
			if (recombinationRate <= 0.0001 && recombinationRate > 0.00001)
				maxSegNode = /*numSites*/numNuc*4;
			if (recombinationRate > 0.0001)
				maxSegNode = /*numSites*/numNuc*5;
			}
		else if (/*numSites*/numNuc >= 400 && /*numSites*/numNuc <= 1000)
			{
			maxSegNode = /*numSites*/numNuc*3;
			if (recombinationRate <= 0.00001)
				maxSegNode = /*numSites*/numNuc*2;			
			if (/*numSites*/numNuc > 800)
				{
				if (recombinationRate <= 0.00001)
					{
					maxSegNode = /*numSites*/numNuc;
					}
				else
					{
					maxSegNode = /*numSites*/numNuc*3;
					if (recombinationRate > 0.0001)
						fprintf(fpmpi, "\nrecombination rate is very high");	
					}
				}
			}
		else if (/*numSites*/numNuc > 1000 && /*numSites*/numNuc <= 10000)  /* NEW */
			{			

			if (recombinationRate <= 0.000001)
				{
				maxSegNode = /*numSites*/numNuc*1.5; /* NEW */
				numNodes = 5000;
				}
			if (recombinationRate <= 0.00001 && recombinationRate > 0.000001)
				{
				maxSegNode = /*numSites*/numNuc*2.3; /* NEW */
				numNodes = 5000;
				}
			if (recombinationRate <= 0.0001 && recombinationRate > 0.00001)
				maxSegNode = /*numSites*/numNuc*2.5;
			if (recombinationRate > 0.0001)
				{
				maxSegNode = /*numSites*/numNuc*3;	
				fprintf(fpmpi, "\nrecombination rate is very high");
				}
			}
		else if (/*numSites*/numNuc > 10000 && /*numSites*/numNuc <= 100000) /* large seqs.1 NEW */
			{
			
			if (recombinationRate <= 0.000001)
				{
				maxSegNode = /*numSites*/numNuc*0.5; /* NEW */
				numNodes = 1000;
				}
			if (recombinationRate <= 0.00001 && recombinationRate > 0.000001)
				{
				maxSegNode = /*numSites*/numNuc*0.5; /* NEW */
				numNodes = 6500;
				}
			if (recombinationRate > 0.0001)
				{
				maxSegNode = /*numSites*/numNuc*1.0;	
				fprintf(fpmpi, "\nrecombination rate is very high");
				}
			}
		else if (/*numSites*/numNuc > 100000 && /*numSites*/numNuc <= 1000000) /* large seqs.2 NEW */
			{
			
			if (recombinationRate <= 0.000001)
				{
				maxSegNode = /*numSites*/numNuc*0.005; /* NEW */
				numNodes = 350;
				}
			if (recombinationRate <= 0.00001 && recombinationRate > 0.000001)
				{
				maxSegNode = /*numSites*/numNuc*0.5; /* NEW */
				numNodes = 5000;
				}
			if (recombinationRate > 0.0001)
				{
				maxSegNode = /*numSites*/numNuc*1.0;	
				fprintf(fpmpi, "\nrecombination rate is very high");
				}
			}
		else
			{
			if (recombinationRate <= 0.00001)
				maxSegNode = /*numSites*/numNuc;
			if (recombinationRate <= 0.0001 && recombinationRate > 0.00001)
				maxSegNode = /*numSites*/numNuc*2;
			if (recombinationRate > 0.0001)
				{
				maxSegNode = /*numSites*/numNuc*3;	
				fprintf(fpmpi, "\nrecombination rate is very high");
				}
			}
		if (N > 1000)
			{
			maxSegNode = maxSegNode*1.5;
			if (N > 10000)
				maxSegNode = maxSegNode*1.5;
			if (N > 50000)
				maxSegNode = maxSegNode*1.1;
			}
		}

	if (doMigration == YES) /* migration implies more rec events because lineages can be isolated for long times */
		{
		if (doMigrationIsland == YES)
			numNodes = numNodes * 1.5;
		if (doMigrationSTST == YES)
			numNodes = numNodes * 1.6;
		if (doMigrationIslCont == YES)
			numNodes = numNodes * 1.7;
		}


	if (numNodes <= numSequences) /* if there are more sequences than nodes in the initial step */
		numNodes = numSequences + 5000;

	numTotalSegments = (numNodes*maxSegNode)+/*numSites*/numNuc;
	/*fprintf(stderr, "\n numTotalSegments = %d \n", numTotalSegments);*/
	
	if (doMigration == YES) /* memory for migrations */
		{
		cumInitPopul = (int *)calloc((numPopulations+numConvergDemes+1),(long) sizeof(int));
		if (!cumInitPopul)
			{
			fprintf (fpmpi, "Could not allocate cumInitPopul (%lu bytes)\n", (numPopulations+numConvergDemes+1)  * (long) sizeof(int));
			exit (1);
			}
		numParcialActiveGametes = (int *) calloc((numPopulations+numConvergDemes+1),(long) sizeof(int));
		if (!numParcialActiveGametes)
			{
			fprintf (fpmpi, "Could not allocate numParcialActiveGametes (%lu bytes)\n", (numPopulations+numConvergDemes+1)  * (long) sizeof(int));
			exit (1);
			}
			
		GiPartial = (double*)calloc((numPopulations+numConvergDemes+1), sizeof (double));
		if (!GiPartial)
			{
			fprintf (fpmpi, "Could not allocate GiPartial (%lu bytes)\n", (numPopulations+numConvergDemes+1)  * (long) sizeof(double));
			exit (1);
			}
		
		cumPopulTase =  (double*) calloc ((numPopulations+numConvergDemes+1), sizeof (double));  
		if (cumPopulTase == NULL)
			{
			fprintf (fpmpi, "Could not allocate cumPopulTase (%lu bytes)", (numPopulations+numConvergDemes+1)  * (long) sizeof(int));
			exit(1);
			}
		rateREpartial =  (double*) calloc ((numPopulations+numConvergDemes+1), sizeof (double));  
		if (rateREpartial == NULL)
			{
			fprintf (fpmpi, "Could not allocate rateREpartial (%lu bytes)", (numPopulations+numConvergDemes+1) * (long) sizeof (double));
			exit(1);
			}
		rateCApartial =  (double*) calloc ((numPopulations+numConvergDemes+1), sizeof (double));  
		if (rateCApartial == NULL)
			{
			fprintf (fpmpi, "Could not allocate rateCApartial (%lu bytes)", (numPopulations+numConvergDemes+1) * (long) sizeof (double));
			exit(1);
			}
		rateMIGpartial =  (double*) calloc ((numPopulations+numConvergDemes+1), sizeof (double));  
		if (rateMIGpartial == NULL)
			{
			fprintf (fpmpi, "Could not allocate rateMIGpartial (%lu bytes)", (numPopulations+numConvergDemes+1) * (long) sizeof (double));
			exit(1);
			}
		ratePartial =  (double*) calloc ((numPopulations+numConvergDemes+1), sizeof (double));  
		if (ratePartial == NULL)
			{
			fprintf (fpmpi, "Could not allocate ratePartial (%lu bytes)", (numPopulations+numConvergDemes+1) * (long) sizeof (double));
			exit(1);
			}
	
		for (i = 0; i < numPopulations+numConvergDemes+1; i++)
			{
			rateREpartial[i] = 0.00;
			rateCApartial[i] = 0.00;
			rateMIGpartial[i] = 0.00;
			ratePartial[i] = 0.00;
			cumPopulTase[i] = 0.00;
			cumInitPopul[i] = 0.00;
			numParcialActiveGametes[i] = 0.00;
			GiPartial[i] = 0.00;
			}
		}
		
	/* allocate space for tree */


	segments = (TreeSegment *) calloc (numTotalSegments, sizeof(TreeSegment)); /* segments */
	if (!segments)
		{
		fprintf (fpmpi, "Could not allocate segments (%lu bytes)\n", numTotalSegments  * (long) sizeof(TreeSegment));
		fprintf (fpmpi, "\n Too much memory is required, try again by less recombinationRate or less numSites or less numSequences.\n");			
		exit (1);
		}
		
	nodes = (TreeNode *) calloc (numNodes, sizeof(TreeNode)); /* nodes */
	if (!nodes)
		{
		fprintf (fpmpi, "Could not allocate nodes (%lu bytes)\n", numNodes  * (long) sizeof(TreeNode));
		exit (1);
		}
	
	
	
	for (mmm=0; mmm<numNodes; mmm++)
		{
		/*printf("\n   Allocating node %d", mmm+1);*/
		nodes[mmm].SitesNonAncHere = (int *) calloc (numNuc+1, sizeof(int));
		if (!nodes[mmm].SitesNonAncHere)
			{
			fprintf (fpmpi, "Could not allocate nodes[mmm].SitesNonAncHere (%lu)\n", (numNuc+1) * (long) sizeof(int));
			exit (1);
			}
		/*printf("\n      allocated %d units for node %d", (numNuc+1), mmm+1);*/
		}
	/*printf("\nFinished allocating nodes...\n");*/



	activeGametes = (int *) calloc (numNodes,(long) sizeof(int)); /* active nodes */
	if (!activeGametes)
		{
		fprintf (fpmpi, "Could not allocate activeGametes (%lu bytes)\n", numNodes *(long) sizeof(int));
		exit (1);
		}
		
	treeRootInit = (TreeNode **) calloc(1, sizeof(TreeNode *)); /* nodes pointers */
	if (!treeRootInit)
		{
		fprintf (fpmpi, "Could not allocate treeRootInit (%lu bytes)\n", 1  * (long) sizeof(TreeNode));
		exit (1);
		}
	stud = (int *)calloc(numSites,(long) sizeof(int));
	if (!stud)
		{			
		fprintf (fpmpi, "Could not allocate stud (%lu bytes)\n", numSites * (long) sizeof(int));
		exit (1);
		}
	for (w = 1; w < numSites; w++) 
		stud[w-1] = w*3+1; 	/* The breakpoints between codons. "stud" is an array with the possible breakpoints beetween codons*/

	
	hotspot = (int *) calloc(numNuc + 2*numSitesOutside, sizeof(int));
	if (!hotspot)
		{
		/*fprintf (stderr, "Could not allocate hotspots (%lu)\n", numNuc + 2*numSitesOutside * sizeof(int));*/
		fprintf (stderr, "Could not allocate hotspots \n");
		exit (1);
		}
	counts = (double *) calloc(numNuc + 2*numSitesOutside + 1, sizeof(double)); /* MA mod: +1 */
	if (!counts)
		{
		/*fprintf (stderr, "Could not allocate counts (%lu)\n", numNuc + 1 + 2*numSitesOutside * sizeof(int));*/
		fprintf (stderr, "Could not allocate counts \n");
		exit (1);
		}
	gammaRec = (double *) calloc(numNuc + 1 + 2*numSitesOutside, sizeof(double)); /* MA mod: +1 */
	if (!gammaRec)
		{
		/*fprintf (stderr, "Could not allocate gamma (%lu)\n", numNuc + 1 + 2*numSitesOutside * sizeof(double));*/
		fprintf (stderr, "Could not allocate gamma \n");
		exit (1);
		}

	
	/* allocate space for S_MRCA vector = [n1, n2, ..., ni,...nk] 
   	where n is the number of sequences and k is the number of sites
   	When an element of MRCS reaches 1, means that the site i found its MRCA */
	/* The MRCA vector has got the number of coalescences n, when 1 coalescence happen n=n-1. In the last coalescent n<=1, we are in the MRCA */
	S_MRCA = (int *) calloc((numNuc+1),(long) sizeof(int));
	if (!S_MRCA)
		{
		fprintf (fpmpi, "Could not allocate S_MRCA (%lu bytes)\n", (numNuc+1) *(long) sizeof(int));
		exit (-1);
		}
	OnlyAncS_MRCA = (int *) calloc((numNuc+1),(long) sizeof(int));
	if (!OnlyAncS_MRCA)
		{
		fprintf (fpmpi, "Could not allocate OnlyAncS_MRCA (%lu bytes)\n", (numNuc+1) *(long) sizeof(int));
		exit (-1);
		}


	/* allocate space for recombination breakpoints */
	breakpoint = (int *) calloc(memoryBreakp,(long) sizeof(int));
	if (!breakpoint)
		{
		fprintf (fpmpi, "Could not allocate breakpoint (%lu bytes)\n", memoryBreakp*(long) sizeof(int));
		exit (-1);
		}

	/* set everything to null */
	for (i=0; i<numNodes; i++)
		{
		nodes[i].left = NULL;
		nodes[i].right = NULL;
		nodes[i].anc1 = NULL;
		nodes[i].anc2 = NULL;
		nodes[i].outgroup = NULL;
		nodes[i].sib = NULL;
		nodes[i].time = 0;
		nodes[i].length = 0;
		nodes[i].BBM0omg = 1.0;
		nodes[i].index = 0;
		nodes[i].indexOldMigPop = 0;
		nodes[i].indexCurrentMigPop = 0;
		nodes[i].numSegNode = 0;
		nodes[i].label = 0;
		nodes[i].isOutgroup = NO;
		nodes[i].class = 0;
		nodes[i].breakp = NO;
		nodes[i].passNumber = 0;
		nodes[i].breakCodon = NO;
		nodes[i].breakCodon = 0;
		nodes[i].NetLabelPrint = 0;
		nodes[i].MRCAfrom = -1;
		nodes[i].MRCAto = -1;
		nodes[i].GMRCA_ancestral = NO;
		for (mmm=0; mmm<=numNuc; mmm++)
			nodes[i].SitesNonAncHere[mmm] = 0;
		}


	/* set times in generation for dated tips; the latest sample will be generation 0 */		
	if (doDatedTips == YES)
		{
		/* NEW */
		numActiveGametes = 0;
		actNumSegments = 0;

		if (doMigration == YES)
			{
			if (noisy > 1)
				fprintf (fpmpi,"\n Initial relation nodes-demes:");

			for (i = 1; i <= numPopulations; i++)
				{
				cumInitPopul[i] = cumInitPopul[i-1] + numNodesInitPopul[i];
				/*numParcialActiveGametes[i] = numNodesInitPopul[i];*/ /* do not active here */
				numParcialActiveGametes[i] = 0;
				/*fprintf (fpmpi,"\n cumInitPopul[i]: %d", cumInitPopul[i]);*/
				/*fprintf (fpmpi,"\n numParcialActiveGametes[i]: %d", numParcialActiveGametes[i]);*/
				}
			}

		for (j = 0; j < numSequences; j++)		
			{
			p = nodes + j;
			/*fprintf (stderr, "\n >> nodes + %d", j);*/
			/*activeGametes[numActiveGametes] = j;*/ /* do not active here */
			p->index = j;
			p->label = j;
			p->NetLabelPrint = numNetLabelPrint;
			/*fprintf (fpmpi,"\n numNetLabelPrint = %d", numNetLabelPrint);*/
			numNetLabelPrint++;		
			labelNodes = j;
			p->class = 1;
			p->GMRCA_ancestral = NO;
			p->numSegNode = 1;				/* initial, each node contain 1 segment */
			/*fprintf (fpmpi,"\n TIP, The node %d with class %d", p->index, p->class);*/
			
			if (doMigration == YES) /* initial nodes - populations */
				{
				if ((j+1) <= cumInitPopul[1])
					{
					p->indexOldMigPop = 1;
					p->indexCurrentMigPop = 1;
					}
				else
					{
					for (k = 1; k <= numPopulations; k++)
						{
						if ((j+1) > cumInitPopul[k] && (j+1) <= cumInitPopul[k+1])
							{
							p->indexOldMigPop = k+1;
							p->indexCurrentMigPop = k+1;
							break;
							}
						}
					k = 0;
					}
				if (noisy > 1)
					fprintf (fpmpi,"\n > The node %d belongs to deme %d", p->index, p->indexOldMigPop);
				}
			
			for (mmm=1; mmm<=numNuc; mmm++)
				p->SitesNonAncHere[mmm] = 0;

			for (i = 0; i < p->numSegNode; i++) /* segments of the tip */
				{
				s = segments + post(i,j,distance);	
				s->before1 = NULL;
				s->before2 = NULL;
				s->after1 = NULL;
				s->after2 = NULL;			
				s->sIndexNode = j;
				s->sIndex = actSegIndex;
				s->sStart = 1;
				s->sEnd = numNuc;
				
				actSegIndex++;
				}
			/*numActiveGametes++;*/ /* do not active here */
			}
		labelNodes++;
		/*nextAvailable = numActiveGametes;*/ /* do not active here */
		actNumSegments = numSequences;
		/* end NEW */

		for (i=0; i<numTipDates; i++)
			{
			for (j=0; j<datedSample[i].size; j++)
				{
				p = nodes + datedSample[i].member[j]-1;
				p->time =  datedSample[i].time;

				/*fprintf (stderr, "\n > nodes + %d", datedSample[i].member[j]-1);*/
				/*for (k=0; k<numSites; k++)
					{
					p = nodes + pos(datedSample[i].member[j]-1,k,numSites);
					p->time =  datedSample[i].time; 
					}*/ 	/* to get generations back (assumes generation time and sampling times are in the same unit, e.g., years) */
				}
			}
		/*debug */
		if (noisy > 1)
			fprintf (stderr, "\nTime Tips:");
		for (j=0; j<numSequences; j++)
			{
			p = nodes + j;
			if (noisy > 1)
				fprintf (stderr, "\n => node %d, sampling time %f", j, p->time);
			/*for (k=0; k<3; k++)
				{
				p = nodes + pos(j,k,numSites);
				fprintf (stderr, "\n%d =>seq %d, site %d, sampling time %f", p, j+1, k+1, p->time);
				}*/
			
			/* check - Fix only converge demes respect to tip dates (with less time than the time of the convergence of deme) s*/
			if (doConvergDemes == YES) 
				{
				ss=0;
				for (ss=1; ss<=numConvergDemes; ss++)
					{
					if (convDemTimes_old[ss] <= p->time)
						{
						fprintf (fpmpi,"\n\n Warning. Tip dates AND Convergence of demes.\n The time of any tip date (%f) cannot be higher than the time of the convergence of demes (%f)", p->time, convDemTimes_old[ss]);
						PrintUsage();
						}
					
					}
				ss=0;
				}
			}				
		}

			


	/* set up MRCA vector */
	for (i = 0; i <= numNuc; i++)
		{
		S_MRCA[i] = numSequences; /* MRCA[i] = numSequences; example initial values: MRCA[0] = 10, MRCA[1] = 10, MRCA[2] = 10 .. */
		OnlyAncS_MRCA[i] = numSequences; /* MRCA[i] = numSequences; example initial values: MRCA[0] = 10, MRCA[1] = 10, MRCA[2] = 10 .. */
		}
		



	/* tip of the trees */ /* set up initial nodes */
	if (doDatedTips == YES) /** active oldest sample for dated tips **/
		{
		currentSample = numTipDates - 1;
		if (noisy > 2)
			fprintf (stderr, "\nActivating initial sample %d (with time = %6.4f):", currentSample,datedSample[currentSample].time);

		numActiveGametes = 0;

		for (j=0; j<datedSample[currentSample].size; j++)
			{
			if (noisy > 2)
				fprintf (stderr, " %d", datedSample[currentSample].member[j]-1);

			/*fprintf (stderr, "\n > Activated nodes + %d \n", datedSample[currentSample].member[j]-1);*/
			p = nodes + datedSample[currentSample].member[j]-1;
			p->index = datedSample[currentSample].member[j]-1;
			activeGametes[numActiveGametes] = datedSample[currentSample].member[j]-1; 
			numActiveGametes++;
			
			if (doMigration == YES)
				{			
				for (i = 1; i <= numPopulations; i++) 
					{
					if (p->indexOldMigPop == i)
						{
						numParcialActiveGametes[i]++;
						}
					}
				}
			}
		nextAvailable = numSequences;  /* to keep the indexes 1 to numSequences for tips */
		if (doMigration == YES && noisy > 2)
			{
			fprintf (fpmpi,"\nInitial demes (with time = %6.4f): \n", datedSample[currentSample].time);			
			for (i = 1; i <= numPopulations; i++) 
				fprintf (fpmpi," Deme %d with %d nodes\n", i, numParcialActiveGametes[i]);
			}
		/*labelNodes++;
		actNumSegments = numActiveGametes-1;*/
		}	
	else /** Here, not tip dates **/
		{
		numActiveGametes = 0;
		actNumSegments = 0;
		
		if (doMigration == YES)
			{
			for (i = 1; i <= numPopulations; i++)
				{
				cumInitPopul[i] = cumInitPopul[i-1] + numNodesInitPopul[i];
				numParcialActiveGametes[i] = numNodesInitPopul[i];
				/*fprintf (fpmpi,"\n numParcialActiveGametes[i]: %d \n", numParcialActiveGametes[i]);*/
				}
			if (noisy > 1)
				fprintf (fpmpi,"\n Initial relation nodes-demes:");
			}
	
		for (j = 0; j < numSequences; j++)		
			{
			p = nodes + j;
			activeGametes[numActiveGametes] = j;
			p->index = j;
			p->label = j;
		
			p->NetLabelPrint = numNetLabelPrint;
			/*fprintf (fpmpi,"\n numNetLabelPrint = %d", numNetLabelPrint);*/
			numNetLabelPrint++;		

			labelNodes = j;
			p->class = 1;
			p->GMRCA_ancestral = NO;
		
			p->numSegNode = 1;				/* initial, each node contain 1 segment */
			if (doMigration == YES) /* initial nodes - populations */
				{
				if ((j+1) <= cumInitPopul[1])
					{
					p->indexOldMigPop = 1;
					p->indexCurrentMigPop = 1;
					}
				else
					{
					for (k = 1; k <= numPopulations; k++)
						{
						if ((j+1) > cumInitPopul[k] && (j+1) <= cumInitPopul[k+1])
							{
							p->indexOldMigPop = k+1;
							p->indexCurrentMigPop = k+1;
							break;
							}
						}
					k = 0;
					}
				if (noisy > 1)
					fprintf (fpmpi,"\n > The node %d belongs to deme %d", p->index, p->indexOldMigPop);
				
				for (mmm=1; mmm<=numNuc; mmm++)
					p->SitesNonAncHere[mmm] = 0;
				}

			/*fprintf (fpmpi,"\n TIP, The node %d with class %d", p->index, p->class);*/

			for (i = 0; i < p->numSegNode; i++) /* segments of the tip */
				{
				s = segments + post(i,j,distance);	
				s->before1 = NULL;
				s->before2 = NULL;
				s->after1 = NULL;
				s->after2 = NULL;			
				s->sIndexNode = j;
				s->sIndex = actSegIndex;
				s->sStart = 1;
				s->sEnd = numNuc;
				
				actSegIndex++;
				}
			numActiveGametes++;
			}
	
		labelNodes++;
		nextAvailable = numActiveGametes;
		actNumSegments = numSequences;
		}
	

	if (doDatedTips == YES)
		{
		if (noisy > 2)
			{
			fprintf (stderr, "\nActive nodes (%d):", numActiveGametes); 
			for (i=0; i<numActiveGametes; i++)
				fprintf (stderr," %d",activeGametes[i]);
			fprintf (stderr,"   Next node available = %d ", nextAvailable);
			}
		if (noisy > 2)
			{			
			fprintf (fpmpi, "\n\n Initial MRCA in the nodes:\n");
			for (i=0; i<numActiveGametes; i++)
				{
				for (j=1; j<=numNuc; j++)
					{
					p = nodes + activeGametes[i];
					/*p = nodes + pos(activeGametes[i],j,numNuc);*/
					if (j == 1)
						fprintf (fpmpi, "%4d -- (MRCA:)", p->index);
					fprintf (fpmpi, "%d", S_MRCA[j]);
					}
				fprintf (fpmpi, "\n");
				}
			}	
		}
	else
		{
		/* print out ancestral (active) status for each site */
		if (noisy > 2)
			{			
			fprintf (fpmpi, "\n\n Initial MRCA in the nodes:\n");
			for (i=0; i<numActiveGametes; i++)
				{
				for (j=1; j<=numNuc; j++)
					{
					p = nodes + activeGametes[i];
					/*p = nodes + pos(activeGametes[i],j,numNuc);*/
					if (j == 1)
						fprintf (fpmpi, "%4d -- (MRCA:)", p->index);
					fprintf (fpmpi, "%d", S_MRCA[j]);
					}
				fprintf (fpmpi, "\n");
				}
			}	
		}




	/** recombination hotspots **/
	/*	(1) If the user has fixed the number of hotspots locate them uniformly
			otherwise get number of hotspots from Poisson anf their positions from
			an Exponential (no interference) or Gamm (interference)  */
	if (fixedNumHotspots == 0)	
		numHotspots = GammaHotspots (expNumPoissonHotspots * (numNuc + 2*numSitesOutside) / (double) numNuc, interferenceInterval, seed);
	else 
		{
		numHotspots = fixedNumHotspots;
		UniformHotspots (numHotspots, seed);
		}
	
	/* (2) Simulate the recombination PDF along the gene and extra tails */
	SimRecombinationPDF (counts, seed);
	
/*
	fprintf (stderr,"\n%d hotspots BEFORE = ", numHotspots);
	for (i=0; i<numHotspots; i++)
		fprintf (stderr, "%d ", hotspot[i]+1);
*/

	/* (3) If recombinations were simulated, was used get rid of tails E outside gene: correct counts and hotspots 
		We are taking into account offshots from hotspots situated some 
		numSitesOutside (E) the gene (L) 

	      E          L            E
		-----0000000000000000000-----  */

	
	if (printRecPDF == YES)
		{
		 fpCounts = fopen ("RecPDF1", "w+");
		if (fpCounts == NULL)
			{
			fprintf (stderr, "Could not open the \"RecPDF1\" file");
			exit (1);
			}
		fprintf (fpCounts, "\n\n\n\nBEFORE relabelling of counts and hotspots");
		for (i=1; i<=numNuc+2*numSitesOutside; i++) /* MA mod: for (i=0; i<numNuc+2*numSitesOutside; i++) */
			fprintf (fpCounts, "\n%04d %6.4f", i, counts[i]); /* MA mod: fprintf (fpCounts, "\n%04d %6.4f", i+1, counts[i]); */
		fclose (fpCounts);
		}
	
	if (fixedNumHotspots == 0)	
		{
		/* correct counts */
		for (i=1; i<=numNuc; i++)	/* MA mod: for (i=0; i<numNuc; i++) */
			counts[i] = counts[i+numSitesOutside];

		/* in case there are hotspots outside, relabel them */
		lowerTail = upperTail = 0;
		for (i=0; i<numHotspots; i++)
			{
			if (hotspot[i] < numSitesOutside)
				lowerTail++;
			else if (hotspot[i] >= numNuc + numSitesOutside)
				upperTail++;
			}
		numHotspots -= (lowerTail + upperTail);
		for (i=0; i<numHotspots; i++)
			hotspot[i] = hotspot[i+lowerTail] - numSitesOutside;
		}

/*	fprintf (stderr,"\n%d hotspots AFTER (lowerTail = %d  upperTail = %d) = ", numHotspots, lowerTail, upperTail);
		for (i=0; i<numHotspots; i++) 
			fprintf (stderr, "%d ", hotspot[i]+1);
*/

	if (printRecPDF == YES)
		{
		 fpCounts = fopen ("RecPDF2", "w+");
		if (fpCounts == NULL)
			{
			fprintf (stderr, "Could not open the \"RecPDF2\" file");
			exit (1);
			}
		fprintf (fpCounts, "\n\n\n\nAFTER relabelling of counts and hotspots");
		for (i=1; i<=numNuc; i++) /* MA mod: for (i=0; i<numSites; i++) */
			fprintf (fpCounts, "\n%04d %6.4f", i, counts[i]); /* MA mod: fprintf (fpCounts, "\n%04d %6.4f", i+1, counts[i]); */
		fclose (fpCounts);
		}
		

	/* set global recombination rate per site (gamma) */
	for (i=1; i<=numNuc; i++) /* MA mod: for (i=0; i<numSites; i++) */
		{
		gammaRec[i] = recombinationRate + blockRecombinationRate * ((double) counts[i] / (double) numPointsRecPDF);	
		/*fprintf (stderr, "gammaRec[i]= %10.8f\n", gammaRec[i]);*/
		}

	/* calculate overall recombination rate = integrate over gamma PDF */
	C01 = 0;
	for (i=1; i<=numNuc; i++) /* MA mod: for (i=0; i<numSites; i++) */
		C01 += gammaRec[i];
	C01 *= 2.0 * Nscaling * N; /* MA mod: C01 *= 4.0 * N; */








	/**** make coalescence tree ****/	
	if (doMigration == YES) /* Coalescence with migration */
		{		
		eventNum = 0;		
		currentTime = 0.0;
		period = 1;
		
		if (doConvergDemes == YES) /* these arrays are for the convergence demes events */
			{
			deme_a = (int *) calloc(numConvergDemes+1,(long) sizeof(int));
			if (!deme_a)
				{
				fprintf (stderr, "PARAMETER ERROR: Could not allocate deme_a of convergencies demes events (%lu bytes)\n", (numConvergDemes+1) *(long) sizeof(int));
				exit (1);
				}
			deme_b = (int *) calloc(numConvergDemes+1,(long) sizeof(int));
			if (!deme_b)
				{
				fprintf (stderr, "PARAMETER ERROR: Could not allocate deme_b of convergencies demes events (%lu bytes)\n", (numConvergDemes+1) *(long) sizeof(int));
				exit (1);
				}
			convDemTimes = (double*) calloc ((numConvergDemes+1), sizeof (double)); 
			if (convDemTimes == NULL)
				{
				fprintf (stderr, "PARAMETER ERROR: Could not allocate convDemTimes of convergencies demes events (%lu bytes)\n", (numConvergDemes+1) *(long) sizeof(double));
				exit (1);
				}
			currentConvDem = (int *) calloc(numConvergDemes+1,(long) sizeof(int));
			if (!currentConvDem)
				{
				fprintf (stderr, "PARAMETER ERROR: Could not allocate currentConvDem of convergencies demes events (%lu bytes)\n", (numConvergDemes+1) *(long) sizeof(int));
				exit (1);
				}
			CurrentDemesState = (int *)calloc((2*numPopulations),(long) sizeof(int));
			if (!CurrentDemesState)
				{
				fprintf (fpmpi, "Could not allocate CurrentDemesState (%lu bytes)\n", (2*numPopulations)  * (long) sizeof(int));
				exit (1);
				}
			for (k = 1; k <= 2*numPopulations-1; k++)
				CurrentDemesState[k] = 0;
			CurrentDemesState[0] = 0;
			for (k = 1; k <= numPopulations; k++)
				CurrentDemesState[k] = k;
			for (k=1; k<=numConvergDemes; k++)
				{
				deme_a[k] = deme_a_old[k];
				deme_b[k] = deme_b_old[k];
				convDemTimes[k] = convDemTimes_old[k];
				/*fprintf(stderr, "\n\n deme_a[%d] = %d \n", k, deme_a[k]);
				fprintf(stderr, "\n\n deme_b[%d] = %d \n", k, deme_b[k]);
				fprintf(stderr, "\n\n convDemTimes[%d] = %lf \n", k, convDemTimes[k]);*/
				}
			k = 0;
			}

		while (numActiveGametes > 1)
			{
			/* print out MRCA vector */
			/*if (noisy == 8)
				{	
				fprintf(stderr,"S_MRCA [] = ");
				for (j=1; j<=numNuc; j++)
					fprintf (stderr,"%d ", S_MRCA[j]);
				fprintf(stderr,"\n");
				}*/

			/*for (i = 1; i <= 2*numPopulations-1; i++)
				fprintf (fpmpi,"\n CurrentDemesState[%d] = %d\n", i, CurrentDemesState[i]);*/  /* to see the active demes */

			/* NEW MIGUEL Feb 2012 */
			Gi = 0.00;
			/* allocate memory for each node gi */
			gi = (double *) calloc(numActiveGametes, sizeof(double));
				if (!gi)
				{
				/*fprintf (stderr, "Could not allocate gi (%lu)\n", numActiveGametes * sizeof(double));*/
				fprintf (stderr, "Could not allocate gi \n");
				exit (-1);
				}


			/* calculate gi for each node and total Gi */	
			/* Gi is the total number of ancestral sites, gi is a vector with ancestral and not found MRCA sites */
			/* NEW MIGUEL Feb 2011 */
			Gi = 0.0;
			for (i = 0; i < numActiveGametes; i++)
				{
				p = nodes + activeGametes[i];
				sizeNode = p->numSegNode;

				gi[i] = 0.0;
				cuantos = 0;

				for (j=1; j<=numNuc; j++)
					{

					if	(IsValidBreakSite (activeGametes, nodes, i, j, S_MRCA) == YES) /*if	(IsValidBreakSite (activeGametes, nodes, whichInd, whichSite, S_MRCA) == YES) */
						{
						cuantos++;
						gi[i] += gammaRec[j];
						/* fprintf (fpmpi,"\n Site %d, gammaRec[j] = %3.10f, gi[i] = %3.10f", j, gammaRec[j], gi[i]); */
						}
					}
				Gi += gi[i]; 

				/* fprintf (fpmpi,"\nA. Gamete %d (%d), GameteGi = %d, gi = %3.10f, cuantos = %d", i, p->index, GameteGi, gi[i], cuantos); */
				}	

			if (noisy == 4)
				fprintf (fpmpi," Gi = %lf ", Gi); /* This Gi is small because the gamma distribution.. But then for the rates we do not multiply by recRate.. */
			/*fprintf (fpmpi,"\nMMM Gi = %lf, Nscaling = %d, N = %d, recombinationRate = %lf ", Gi, Nscaling, N, recombinationRate);*/	
			
	

			for (k = 1; k <= numPopulations+currentBigDeme; k++)
				GiPartial[k] = 0.0;
			
			if (noisy == 4)
				fprintf (fpmpi, "\n");
			for (i = 0; i < numActiveGametes; i++)
				{
				p = nodes + activeGametes[i];
				for (j = 1; j <= numPopulations+currentBigDeme; j++)
					{
					if (p->indexCurrentMigPop == j)
						GiPartial[j] = GiPartial[j] + gi[i];
					}
				if (noisy > 2)
					fprintf (fpmpi, " \nNode %d of deme %d", p->index, p->indexCurrentMigPop);
				}

			

			if (doMigRatePeriods == YES) /* variable migration rate with time */ 
				{
				currentMigrationRate = -1.0;				

				for (i = 1; i <= numMigRatePeriods-1; i++) /* [t1 0.001] [t2 100 0.001 0.005] [t3 100 1000 0.001 0.005 0.001] */
					{
					if (currentTime < MigTbegin[i])
						{
						currentMigrationRate = periodMigrationRate[i];
						break;
						}
					}

				if (currentMigrationRate == -1.0)
					currentMigrationRate = periodMigrationRate[numMigRatePeriods];
				
				if (noisy == 3)
					fprintf (fpmpi, "\nCurrent migration rate = %lf", currentMigrationRate);
				}
			else /* migration rate is constant with time */
				currentMigrationRate = migrationRate; 
			
			/*fprintf (fpmpi, " \n\n PROOF variable Mig rate: currentTime = %lf, currentMigrationRate = %lf", currentTime, currentMigrationRate);*/






			if (noisy == 3)
				fprintf (fpmpi, "\n");			

			/* get rates for events */  
			rateRE = rateCA = rateMIG = rate = 0;
			for (i = 1; i <= numPopulations+currentBigDeme; i++)
				{
				rateREpartial[i] = (double) GiPartial[i] * (double) Nscaling * (double) N;
				rateRE = rateRE + rateREpartial[i];
				/*fprintf (fpmpi, " \nrateREpartial[%d] = %lf", i, rateREpartial[i]);*/

				rateCApartial[i] = (double) numParcialActiveGametes[i] * ((double) numParcialActiveGametes[i] - 1) / 2.0;
				rateCA = rateCA + rateCApartial[i];
				/*fprintf (fpmpi, " \nrateCApartial[%d] = %lf", i, rateCApartial[i]);*/
				
				rateMIGpartial[i] = 0.00;
				rateMIGpartial[i] = (double) numParcialActiveGametes[i] * (double) Nscaling * (double) N * currentMigrationRate;
				/*fprintf (fpmpi, " \n numParcialActiveGametes[i] = %d, Nscaling = %d, N = %d, currentMigrationRate = %lf", numParcialActiveGametes[i], Nscaling, N, currentMigrationRate);*/
				if (doConvergDemes == YES && currentDemesNumber <= 1)  /* No more migrations because there is only one deme */
					rateMIGpartial[i] = 0.00;
				rateMIG = rateMIG + rateMIGpartial[i];
				/*fprintf (fpmpi, " \nnumParcialActiveGametes[%d] = %d", i, numParcialActiveGametes[i]);
				fprintf (fpmpi, " \nrateMIGpartial [%d] = %lf", i, rateMIGpartial[i]);*/

				ratePartial[i] = rateREpartial[i] + rateCApartial[i] + rateMIGpartial[i];
				rate = rate + ratePartial[i];
				}
			rate = rateRE + rateCA + rateMIG;
			/* find out time for coalescence */
			if (doDemographics == YES)
				{
				periodGrowth[period] = -log (Nend[period] / (double) Nbegin[period]) / (double) (cumDuration[period] - cumDuration[period-1]);
				/*fprintf (fpmpi, "\n>>>>1 period growth  = %f (period = %d)", periodGrowth[period], period);*/
				if (isnan(periodGrowth[period]) == YES)
					{						
					fprintf (fpmpi, "\nERROR: period growth (%f) is NaN", periodGrowth[period]);
					fprintf (fpmpi, "\n      This might suggest that the growth rate is too negative");
					fprintf (fpmpi, "\n      and the coalescent time is therefore infinite.");
					fprintf (fpmpi, "\n      Try a smaller value");				
					exit (1);
					}

				if (Nend[period] == Nbegin[period])
					{
					timeCA = RandomExponential (rateCA, seed) * Nscaling * (double) Nbegin[period];
					}
				else
					{
					timeCA = log (1 + RandomExponential (rateCA, seed) * periodGrowth[period] * Nscaling * Nbegin[period] * 
			               exp (-periodGrowth[period] * (currentTime - cumDuration[period-1]))) / periodGrowth[period];
					}

				/*	When growth rate is very negative, coalescent time may be infinite
					this results in log (-x) => timCA = NaN. If this not the last period
					just jump to the next. If this is the last period, we have to exit
					the program */
				if (isnan(timeCA) == YES)
					{
					if (period < numPeriods) 
						{
						currentTime = cumDuration[period];
						period++;
						periodGrowth[period] = -log (Nend[period] / (double) Nbegin[period]) / (double) (cumDuration[period] - cumDuration[period-1]);
						continue;
						}
					else
						{
						fprintf (fpmpi, "\nERROR: Coalescent time (%f) is infinite ", timeCA);
						fprintf (fpmpi, "\n      This might suggest that the growth rate is too negative");
						fprintf (fpmpi, "\n      and the coalescent time is therefore infinite.");
						fprintf (fpmpi, "\n      Try a smaller value");
						exit (1);
						}
					}
				}
			else
				{
				timeCA = RandomExponential (rateCA, seed) * Nscaling * N;
				if (doExponential == YES)
					{
					timeCA = log (exp(growthRate*currentTime) + growthRate * timeCA) / growthRate - currentTime;
		
					/*	When growth rate is very negative, coalescent time may be infinite
						this results in log (-x) => timeCA = NaN. We have to exit
						the program */
					if (isnan(timeCA) == YES)
						{				
						fprintf (fpmpi, "\nERROR: Coalescent time (%f) is infinite ", timeCA);
						fprintf (fpmpi, "\n      This might suggest that the growth rate is too negative");
						fprintf (fpmpi, "\n      and the coalescent time is therefore infinite.");
						fprintf (fpmpi, "\n      Try a smaller value");
						exit (1);
						}
					}
				}

			/* find out time for recombination */
			timeRE = RandomExponential (rateRE, seed) * Nscaling * N; /* It doesn't depend of demographics because the node doesnt depend of another node to make this event */
			/* find out time for migration */
			timeMIG = RandomExponential (rateMIG, seed) * Nscaling * N; /* It doesn't depend of demographics because the node doesnt depend of another node to make this event */
			/*fprintf (fpmpi, " \ntimeMIG = %lf, rateMIG = %lf, Nscaling = %d, N = %d, RandExp = %lf", timeMIG, rateMIG, Nscaling, N, RandomExponential (rateMIG, seed));*/
			/* find out time for convergence of demes */	/* It doesn't depend of demographics because the node doesnt depend of another node to make this event */		
			w = j = d = totCurrentConv = 0;
			if (doConvergDemes == YES)
				{
				for (k=1; k<=numConvergDemes; k++)
					currentConvDem[k] = 0;
			
				for (k=1; k<=numConvergDemes; k++) /* looking for the event nearer (with less time and future) */
					{ 
					if (convDemTimes[k] >= currentTime && convDemTimes[k] >= 0)
						{
						if (d == 0)
							j = k;
						d++;
						if (convDemTimes[k] >= currentTime && convDemTimes[k] < j)
							j = k;
						}
					}
				if (d > 0) /* there are convergences */
					{
					//fprintf(fpmpi,"\n proximo de menor tiempo = %d, con tiempo %lf", j, convDemTimes[j]);
					nextConvNumber = j;
					timeCONV = convDemTimes[nextConvNumber] - currentTime;
					/*fprintf(fpmpi,"\n timeCONV = %lf", timeCONV);*/
					}
				else
					timeCONV = 0; /* there is no more convergences */
				}
			/*fprintf(fpmpi,"\n timeCA = %lf, timeRE = %lf, timeMIG = %lf \n", timeCA,timeRE,timeMIG);*/





			if (doDatedTips == YES)
				{
				if (doConvergDemes == YES && timeCONV > 0)
					{
					if (timeCA < timeRE && timeCA < timeMIG && timeCA < timeCONV) /* coalescence event */
						{
						isCoalescence = YES;
						isRecombination = NO;
						isMigration = NO;
						doConvNext = NO;
						eventTime = timeCA;
						}
					else if (timeRE < timeCA && timeRE < timeMIG && timeRE < timeCONV) /* recombination event */
						{
						isCoalescence = NO;
						isRecombination = YES;
						isMigration = NO;
						doConvNext = NO;
						eventTime = timeRE;
						}
					else if (timeMIG < timeCA && timeMIG < timeRE && timeMIG < timeCONV) /* migration event */
						{
						isCoalescence = NO;
						isRecombination = NO;
						isMigration = YES;
						doConvNext = NO;

						eventTime = timeMIG;
						}
					else if (timeCONV < timeCA && timeCONV < timeRE && timeCONV < timeMIG) /* convergence between demes event */
						{
						isCoalescence = NO;
						isRecombination = NO;
						isMigration = NO;
						doConvNext = YES;
						eventTime = timeCONV;
						}
					else
						{
						fprintf(fpmpi, "\n\n Warning choosing the type of event");
						fprintf(fpmpi, "\n Check:: \n 1. Do you have a migration rate = 0 starting by more than one demes and without convergence events for the demes? \n 2. Do you have a migration rate = 0 without convergence events for ALL demes IN TIME BEFORE? \n When two demes converg the result deme has a new number that (if there are more demes) it should be converged or migrated. So, e.g. -%%2 1 2 200 3 4 500, in 200 1 more 2 make 5, then in 500 3 and 4 make 6, so finally you have deme 5 and deme 6 as independent demes, it is a problem with migration rate = 0 \n So, if you are working with migration rate = 0 it is recomending convergence all demes, including the new demes (e.g. - %%3 1 2 200 3 4 500 5 6 2000) ");
						fprintf(fpmpi, "\n 3. If migration rate is different than 0: Check if you are using tip dates and convergence of demes, the sample could belongs to a time older than the existence of its user-given deme. To solve this problem try to erase this tip date (this sample time = 0.00) or to modify the time of the tip node to a value younger than the convergence of demes \n");
						exit (-1);
						}

					}
				if (doConvergDemes == NO || timeCONV == 0)
					{
					if (timeCA < timeRE && timeCA < timeMIG) /* coalescence event */
						{
						isCoalescence = YES;
						isRecombination = NO;
						isMigration = NO;
						eventTime = timeCA;
						}
					else if (timeRE < timeCA && timeRE < timeMIG) /* recombination event */
						{
						isCoalescence = NO;
						isRecombination = YES;
						isMigration = NO;
						eventTime = timeRE;
						}
					else if (timeMIG < timeCA && timeMIG < timeRE) /* migration event */
						{
						isCoalescence = NO;
						isRecombination = NO;
						isMigration = YES;
			
						eventTime = timeMIG;
						}
					else
						{
						fprintf(fpmpi, "\n\n Warning choosing the type of event");
						fprintf(fpmpi, "\n Check::: \n 1. Do you have a migration rate = 0 starting by more than one demes and without convergence events for the demes? \n 2. Do you have a migration rate = 0 without convergence events for ALL demes IN TIME BEFORE? \n When two demes converg the result deme has a new number that (if there are more demes) it should be converged or migrated. So, e.g. -%%2 1 2 200 3 4 500, in 200 1 more 2 make 5, then in 500 3 and 4 make 6, so finally you have deme 5 and deme 6 as independent demes, it is a problem with migration rate = 0 \n So, if you are working with migration rate = 0 it is recomending convergence all demes, including the new demes (e.g. - %%3 1 2 200 3 4 500 5 6 2000) ");
						fprintf(fpmpi, "\n 3. If migration rate is different than 0: Check if you are using tip dates and convergence of demes, the sample could belongs to a time older than the existence of its user-given deme. To solve this problem try to erase this tip date (this sample time = 0.00) or to modify the time of the tip node to a value younger than the convergence of demes \n");
						exit (-1);
						}

					}
				}
			
			if (doDatedTips == YES)
				{
				/* if doing dated tips, check whether we need to activate a new sample, update sampling period and start again */
				if ((currentTime + eventTime) > datedSample[currentSample-1].time && currentSample > 0)
					{
					currentSample--;
					/* activate nodes from this sample */
					if (noisy > 2)
						fprintf (stderr, "\nCumulative time = %6.4f  > sample %d time = %6.4f. Activating tips:", currentTime + eventTime, currentSample, datedSample[currentSample].time);
					
					for (i=0; i<datedSample[currentSample].size; i++)
						{
						if (noisy > 2)
							fprintf (stderr, " %d", datedSample[currentSample].member[i]-1);

						p = nodes + datedSample[currentSample].member[i]-1;
						p->index = datedSample[currentSample].member[i]-1;
						activeGametes[numActiveGametes] = datedSample[currentSample].member[i]-1;  

						numActiveGametes++;
											
						for (ss = 1; ss <= numPopulations /*+ numCONV*/; ss++) 
							{
							if (p->indexOldMigPop == ss)
								{
								numParcialActiveGametes[ss]++;
								/*fprintf (stderr, "\n AQUI numParcialActiveGametes[%d] = %d \n", ss, numParcialActiveGametes[ss]);*/ 
								}
							}
						}
					currentTime = datedSample[currentSample].time;

					if (noisy > 2)
						{
						fprintf (stderr, "\nActive nodes (%d):", numActiveGametes); 
						for (i=0; i<numActiveGametes; i++)
							fprintf (stderr," %d",activeGametes[i]);
						fprintf (stderr,"\nNext node available = %d", nextAvailable);
						fprintf (stderr, "\nSample %d activated and going back to currentTime = %6.4f", currentSample, currentTime);
						}
					continue; /* start again*/
					}
				}

			

			if (doConvergDemes == YES && timeCONV > 0)
				{
				/* event is a coalescence, a recombination or a migration? */
				if (timeCA < timeRE && timeCA < timeMIG && timeCA < timeCONV) /* coalescence event */
					{
					isCoalescence = YES;
					isRecombination = NO;
					isMigration = NO;
					doConvNext = NO; /* new */
					eventTime = timeCA;

					/*	if this period is not the last one and if the event time is outside the current interval,
						update period and start again */
					if (doDemographics == YES && period < numPeriods && (currentTime + eventTime) > cumDuration[period])
						{
						currentTime = cumDuration[period];
						period++;
						periodGrowth[period] = -log (Nend[period] / (double) Nbegin[period]) / (double) (cumDuration[period] - cumDuration[period-1]);
						continue;
						}	
			
					numCA++;
					}
				else if (timeRE < timeCA && timeRE < timeMIG && timeRE < timeCONV) /* recombination event */
					{
					isCoalescence = NO;
					isRecombination = YES;
					isMigration = NO;
					doConvNext = NO; /* new */
					eventTime = timeRE;	

					/*	if this period is not the last one and if the event time is outside the current interval,
						update period and start again */
					if (doDemographics == YES && period < numPeriods && (currentTime + eventTime) > cumDuration[period])
						{
						currentTime = cumDuration[period];
						period++;
						periodGrowth[period] = -log (Nend[period] / (double) Nbegin[period]) / (double) (cumDuration[period] - cumDuration[period-1]);
						continue;
						}	
					numRE++;
				
					/* reallocate space for recombination breakpoints */
					if (numRE >= (memoryBreakp-1))
						{
						memoryBreakp += 50;
					 
						breakpoint = (int *) realloc(breakpoint, memoryBreakp *(long) sizeof(int));
						if (!breakpoint)
							{	
							fprintf (fpmpi, "Could not reallocate breakpoint \n");
							exit (-1);
							}
						if (noisy == 4)
							fprintf (fpmpi, "\n...Doing reallocation of breakponts (1)\n");
						}
				
					if (numRE > (numNuc+1) && many == 0)
						{
						if (noisy > 1)
							fprintf (fpmpi, "\n\n Many recombinations %d (more recombinations that sites)!\n", numRE);
						
						many++;
						}
					}
				else if (timeMIG < timeCA && timeMIG < timeRE && timeMIG < timeCONV) /* migration event */
					{
					isCoalescence = NO;
					isRecombination = NO;
					isMigration = YES;
					doConvNext = NO;

					eventTime = timeMIG;	

					/*	if this period is not the last one and if the event time is outside the current interval,
						update period and start again */
					if (doDemographics == YES && period < numPeriods && (currentTime + eventTime) > cumDuration[period])
						{
						currentTime = cumDuration[period];
						period++;
						periodGrowth[period] = -log (Nend[period] / (double) Nbegin[period]) / (double) (cumDuration[period] - cumDuration[period-1]);
						continue;
						}	
					numMIG++;
					}
				else if (timeCONV < timeCA && timeCONV < timeRE && timeCONV < timeMIG) /* convergence between demes event */
					{
					isCoalescence = NO;
					isRecombination = NO;
					isMigration = NO;
					doConvNext = YES;
					eventTime = timeCONV;

					convDemTimes[nextConvNumber] = -1; /* erasing the event */	
					/*	if this period is not the last one and if the event time is outside the current interval,
						update period and start again */
					if (doDemographics == YES && period < numPeriods && (currentTime + eventTime) > cumDuration[period])
						{
						currentTime = cumDuration[period];
						period++;
						periodGrowth[period] = -log (Nend[period] / (double) Nbegin[period]) / (double) (cumDuration[period] - cumDuration[period-1]);
						continue;
						}	
					numCONV++;
					}
				else
					{
					fprintf(fpmpi, "\n\n Warning choosing the type of event");
					fprintf(fpmpi, "\n Check: \n 1. Do you have a migration rate = 0 starting by more than one demes and without convergence events for the demes? \n 2. Do you have a migration rate = 0 without convergence events for ALL demes IN TIME BEFORE? \n When two demes converg the result deme has a new number that (if there are more demes) it should be converged or migrated. So, e.g. -%%2 1 2 200 3 4 500, in 200 1 more 2 make 5, then in 500 3 and 4 make 6, so finally you have deme 5 and deme 6 as independent demes, it is a problem with migration rate = 0 \n So, if you are working with migration rate = 0 it is recomending convergence all demes, including the new demes (e.g. - %%3 1 2 200 3 4 500 5 6 2000) ");
					fprintf(fpmpi, "\n 3. If migration rate is different than 0: Check if you are using tip dates and convergence of demes, the sample could belongs to a time older than the existence of its user-given deme. To solve this problem try to erase this tip date (this sample time = 0.00) or to modify the time of the tip node to a value younger than the convergence of demes \n");
					exit (-1);
					}
				}
			if (doConvergDemes == NO || timeCONV == 0)
				{
				doConvNext = NO;
				/* event is a coalescence, a recombination or a migration? */
				if (timeCA < timeRE && timeCA < timeMIG) /* coalescence event */
					{
					isCoalescence = YES;
					isRecombination = NO;
					isMigration = NO;
					eventTime = timeCA;
					
					/*	if this period is not the last one and if the event time is outside the current interval,
						update period and start again */
					if (doDemographics == YES && period < numPeriods && (currentTime + eventTime) > cumDuration[period])
						{
						currentTime = cumDuration[period];
						period++;
						periodGrowth[period] = -log (Nend[period] / (double) Nbegin[period]) / (double) (cumDuration[period] - cumDuration[period-1]);
						continue;
						}	
			
					numCA++;
					}
				else if (timeRE < timeCA && timeRE < timeMIG) /* recombination event */
					{
					isCoalescence = NO;
					isRecombination = YES;
					isMigration = NO;
					eventTime = timeRE;
										
					/*	if this period is not the last one and if the event time is outside the current interval,
						update period and start again */
					if (doDemographics == YES && period < numPeriods && (currentTime + eventTime) > cumDuration[period])
						{
						currentTime = cumDuration[period];
						period++;
						periodGrowth[period] = -log (Nend[period] / (double) Nbegin[period]) / (double) (cumDuration[period] - cumDuration[period-1]);
						continue;
						}	
					numRE++;
				
					/* reallocate space for recombination breakpoints */
					if (numRE >= (memoryBreakp-1))
						{
						memoryBreakp += 50;
					 
						breakpoint = (int *) realloc(breakpoint, memoryBreakp *(long) sizeof(int));
						if (!breakpoint)
							{	
							fprintf (fpmpi, "Could not reallocate breakpoint \n");
							exit (-1);
							}
						if (noisy == 4)
							fprintf (fpmpi, "\n...Doing reallocation of breakponts (1)\n");
						}
				
					if (numRE > (numNuc+1) && many == 0)
						{
						if (noisy > 1)
							fprintf (fpmpi, "\n\n Many recombinations %d (more recombinations than sites)!\n", numRE);
						
						many++;
						}
					}
				else if (timeMIG < timeCA && timeMIG < timeRE) /* migration event */
					{
					isCoalescence = NO;
					isRecombination = NO;
					isMigration = YES;
			
					eventTime = timeMIG;	

					/*	if this period is not the last one and if the event time is outside the current interval,
						update period and start again */
					if (doDemographics == YES && period < numPeriods && (currentTime + eventTime) > cumDuration[period])
						{
						currentTime = cumDuration[period];
						period++;
						periodGrowth[period] = -log (Nend[period] / (double) Nbegin[period]) / (double) (cumDuration[period] - cumDuration[period-1]);
						continue;
						}	
					numMIG++;
					}
				else
					{
					fprintf(fpmpi, "\n\n Warning choosing the type of event");
					fprintf(fpmpi, "\n Check: \n 1. Do you have a migration rate = 0 starting by more than one demes and without convergence events for the demes? \n 2. Do you have a migration rate = 0 without convergence events for ALL demes IN TIME BEFORE? \n When two demes converg the result deme has a new number that (if there are more demes) it should be converged or migrated. So, e.g. -%%2 1 2 200 3 4 500, in 200 1 more 2 make 5, then in 500 3 and 4 make 6, so finally you have deme 5 and deme 6 as independent demes, it is a problem with migration rate = 0 \n So, if you are working with migration rate = 0 it is recomending convergence all demes, including the new demes (e.g. - %%3 1 2 200 3 4 500 5 6 2000) ");
					fprintf(fpmpi, "\n 3. If migration rate is different than 0: Check if you are using tip dates and convergence of demes, the sample could belongs to a time older than the existence of its user-given deme. To solve this problem try to erase this tip date (this sample time = 0.00) or to modify the time of the tip node to a value younger than the convergence of demes \n");
					exit (-1);
					}
				}




			/** it chooses the deme for this event **/
			if (isCoalescence == YES)
				{
				for (k = 1; k <= numPopulations+currentBigDeme; k++)
					cumPopulTase[k] = 0;
				cumPopulTase[0] = 0;
				w = 0;
						
				for (k = 1; k <= numPopulations+currentBigDeme; k++)
					{
					cumPopulTase[k] = cumPopulTase[k-1] + rateCApartial[k];
					w = w + numParcialActiveGametes[k];
					}
				/* (cumPopulTase[numPopulations+currentBigDeme] must to be similar to rateCA) */
				if (w != numActiveGametes)
					{
					fprintf(fpmpi, "\n 1 The sum of partial active gametes is different than total gametes number, w %d != numActiveGametes %d. In choose the deme", w, numActiveGametes);
					exit (-1);
					}
				for (k = 1; k <= numPopulations+currentBigDeme; k++)
					cumPopulTase[k] = cumPopulTase[k]/cumPopulTase[numPopulations+currentBigDeme];
					
				ran = RandomUniform(seed);
				whichDeme = bbinDemes(ran, cumPopulTase, numPopulations+currentBigDeme);
				w = 0;
				}
		
			if (isMigration == YES) /* the choice of the deme which send migrants should not depend on the migration model. Model affects to the choice of the deme who receive the migrants.. */
				{
				for (k = 1; k <= numPopulations+currentBigDeme; k++)
					cumPopulTase[k] = 0;
				cumPopulTase[0] = 0;
				w = 0;
			
				for (k = 1; k <= numPopulations+currentBigDeme; k++)
					{
					cumPopulTase[k] = cumPopulTase[k-1] + rateMIGpartial[k];
					w = w + numParcialActiveGametes[k];
					}
				/* (cumPopulTase[numPopulations+currentBigDeme] must to be similar to rateMIG) */
				if (w != numActiveGametes)
					{
					fprintf(fpmpi, "\n 2The sum of partial active gametes is different than total gametes number, w %d != numActiveGametes %d. In choose the deme", w, numActiveGametes);
					exit (-1);
					}

				for (k = 1; k <= numPopulations+currentBigDeme; k++)
					cumPopulTase[k] = cumPopulTase[k]/cumPopulTase[numPopulations+currentBigDeme];
				/*fprintf(fpmpi, "\n cumPopulTase[numPopulations+currentBigDeme] = %lf", cumPopulTase[numPopulations+currentBigDeme]);*/
				ran = RandomUniform(seed);
				whichDeme = bbinDemes(ran, cumPopulTase, numPopulations+currentBigDeme);
				w = 0;
				}
			/* for event of convergent demes we do not have to choose the deme to converge.. */
			




			/** set time **/
			currentTime += eventTime; /* the time is accumulated */
			if (noisy > 3)
				fprintf(fpmpi, "\n\n");
			eventNum++;
			if (noisy > 1 && doConvNext == NO)
				fprintf (fpmpi, "\n\n*** Event %3d *** rate = %lf, currentTime = %lf\n", eventNum, rate, currentTime);
			if (noisy > 1 && doConvNext == YES)
				fprintf (fpmpi, "\n\n*** Event %3d *** currentTime = %lf\n", eventNum, currentTime);

				
			/*** if RECOMBINATION ***/
			if (isRecombination == YES) 
				{
				if (noisy == 4)
					fprintf(fpmpi, "\n* Recombination *");
					
				w = 0;
				for (k = 1; k <= numPopulations+currentBigDeme; k++)
					w = w + numParcialActiveGametes[k];
				if (w != numActiveGametes)
					{
					fprintf(fpmpi, "\n 3The sum of partial active gametes is different than total gametes number, w %d != numActiveGametes %d. In choose the deme", w, numActiveGametes);
					exit (-1);
					}	
				w = 0;
				
				/* Which node has the recombination? */
					/* assign probability to each node based on their gi's values */
				cum_gi = 0;
				probRecIndividual = Gi * RandomUniform(seed); /* it calculate the individual probability for the breakpoint */
				for (whichInd=0; whichInd<numActiveGametes; whichInd++)
					{
					cum_gi += gi[whichInd];				/* accumulate gi into cum_gi. whichInd is the choose node. */
					if (probRecIndividual < cum_gi)    /* ok whether the node is choosen */
						break;
					}
			
				if (whichInd >= numActiveGametes)
					{
					fprintf (fpmpi, "\n\nERROR: whichInd out of range1!: whichInd = %d\n", whichInd);
					exit (-1);
					}
			

				/* (7) Choose whichSite based on gammma[j] */
				/* select a valid breakpoint among potential recombining locations */
				/* to be a potential recombining site, a site has to have ancestral material non-MRCA before and after it */
				cum_gammaRec = 0.0;
				RdValue = RandomUniform(seed);
				probRecSite = gi[whichInd] * RdValue;
				/*fprintf (fpmpi, "\n\n-> whichInd = %d, gi[%d] = %3.10f, RdValue = %3.10f, probRecSite = %3.10f \n", whichInd, whichInd, gi[whichInd], RdValue, probRecSite);*/

				cuantos = 0;
				for (j=1; j<=numNuc; j++)
					{
					whichSite = j;

					if	(IsValidBreakSite (activeGametes, nodes, whichInd, whichSite, S_MRCA) == YES)
						{
						cuantos++;
						cum_gammaRec += gammaRec[whichSite];
						/* fprintf (fpmpi, "\n Sum %d -> cum_gammaRec=%3.10f, gammaRec[whichSite]=%3.10f", whichSite, cum_gammaRec, gammaRec[whichSite]); */

						if (cum_gammaRec >= probRecSite)
							{
							/*fprintf (fpmpi, "\n OK %d", whichSite);*/
							break;
							}
						}
					
					}
				/*fprintf (fpmpi, "\n site = %d, probRecSite = %lf, cum_gammaRec = %lf, cuantos = %d \n\n", whichSite, probRecSite, cum_gammaRec, cuantos);*/



				if (whichSite > numNuc || whichSite <= 0)
					{
					fprintf (stderr, "\n\nERROR: whichSite (%d) out of range!\n", whichSite);
					exit (-1);
					}

				/*legalBreakpoint = NO;
				while (legalBreakpoint == NO)
					{
					do 
						{
						whichSite = (numNuc) * RandomUniform(seed); 
						if (whichSite == 1) 
							whichSite = numNuc;
						
						} while (whichSite == 0);


					if (whichSite > numNuc)
						{
						fprintf (fpmpi, "\n\nERROR: whichSite out of range! : whichSite = %d\n", whichSite);
						exit (-1);
						}
					p = nodes + activeGametes[whichInd];
					sizeNode = p->numSegNode;
					if	(IsValidBreakSite (activeGametes, nodes, whichInd, whichSite, S_MRCA) == YES)
						legalBreakpoint = YES;
					}*/
				
				/* should this recombination event be counted in the expected number of recombinations E(R)? */
				/* for E(R) count only events with breakpoints as 1|1, 1|0 or 0|1  (i.e., not 0|0)         */
				/* if 1 represent a site that did found already its MRCA count it as a 0 */
				ThisBreakpIsTrapped = NO;
				if (doCountsForExpNumRec == YES)
					{
					p = nodes + activeGametes[whichInd];
					sizeNode = p->numSegNode;	
					if (CountsForExpNumRec (activeGametes, whichInd, whichSite, nodes, S_MRCA, sizeNode) == NO)
						{
						recNotToCount++;
						ThisBreakpIsTrapped = YES;
						/*fprintf(fpmpi,"..not to count.."); */
						}
					}
			
				/* copy whichIndividual to a new space in memory */
				hasPassedBreakPoint = NO;
			
			
				firstHalf = nextAvailable++; /* firstHalf is the first node that was created by the recombination */
				if (nextAvailable >= numNodes) /* if there aren't enough nodes it go into and it addition more */
					{
					/* ReallocNodes(&numNodes, activeGametes); */
					numNodes += INCREMENT_NODES;
					numTotalSegments += (INCREMENT_NODES*maxSegNode)+numNuc;
					
					segments = (TreeSegment *) realloc (segments, numTotalSegments  * (long) sizeof(TreeSegment)); 
					if (!segments)
						{
						fprintf (fpmpi, "Could not reallocate segments (%lu bytes)\n", ((numNodes*distance)+numNuc)  * (long) sizeof(TreeSegment));
						exit (1);
						}
					nodes = (TreeNode *) realloc (nodes, numNodes  * (long) sizeof(TreeNode));
					if (!nodes)
						{
						fprintf (fpmpi, "Could not reallocate nodes (%lu bytes)\n", numNodes  * (long) sizeof(TreeNode));
						exit (-1);
						}
					activeGametes = (int *) realloc (activeGametes, numNodes *(long) sizeof(int));
					if (!activeGametes)
						{
						fprintf (fpmpi, "Could not reallocate activeGametes (%lu bytes)\n", numNodes *(long) sizeof(int));
						exit (-1);
						}
					if (noisy == 4)
						fprintf (fpmpi, "\n\n...Doing reallocation of nodes (1)\n");
					}
									
				secondHalf = nextAvailable++; /* secondhalf is the second node that was created by the recombination */
				if (nextAvailable >= numNodes) /* if there aren't enough nodes it go into and it addition more */
					{
					/* ReallocNodes(&numNodes, activeGametes); */
					numNodes += INCREMENT_NODES;
					numTotalSegments += (INCREMENT_NODES*maxSegNode)+numNuc;
					
					segments = (TreeSegment *) realloc (segments, numTotalSegments  * (long) sizeof(TreeSegment));
					if (!segments)
						{
						fprintf (fpmpi, "Could not reallocate segments (%lu bytes)\n", ((numNodes*distance)+numNuc)  * (long) sizeof(TreeSegment));
						exit (1);
						}
					nodes = (TreeNode *) realloc (nodes, numNodes  * (long) sizeof(TreeNode));
					if (!nodes)
						{
						fprintf (fpmpi, "Could not reallocate nodes (%lu bytes)\n", numNodes  * (long) sizeof(TreeNode));
						exit (-1);
						}
					activeGametes = (int *) realloc (activeGametes, numNodes *(long) sizeof(int));
					if (!activeGametes)
						{
						fprintf (fpmpi, "Could not reallocate activeGametes (%lu bytes)\n", numNodes *(long) sizeof(int));
						exit (-1);
						}
					if (noisy == 4)
						fprintf (fpmpi, "\n\n...Doing reallocation of nodes (1)\n");
					}
								
				
				p = nodes + activeGametes[whichInd];
				q = nodes + firstHalf;	/* parent1 (new) */
				r = nodes + secondHalf; /* parent2 (new) */
				if (p->numSegNode > maxSegNode) /* checking */
					{
					fprintf (fpmpi, "\n\nWarning, too many segments in this node. max = %d", maxSegNode);
					fprintf (fpmpi, "\n p->numSegNode = %d",p->numSegNode);	
					exit(9);
					}
				q->index = firstHalf;
				r->index = secondHalf;

				if (doBranchNetfiles == YES)
					{
					q->NetLabelPrint = numNetLabelPrint;
					/*numNetLabelPrint++;*/
					r->NetLabelPrint = numNetLabelPrint;
					numNetLabelPrint++;
					}

				q->numSegNode = r->numSegNode = p->numSegNode;		/* Good if there are not nill segments.. then, in its case, it will be modify */
				q->indexOldMigPop = q->indexCurrentMigPop = p->indexCurrentMigPop; /* demes evolution */
				r->indexOldMigPop = r->indexCurrentMigPop = p->indexCurrentMigPop;


				q->class = 3;
				r->class = 3;
				q->GMRCA_ancestral = NO;
				r->GMRCA_ancestral = NO;
				q->breakp = whichSite;		
				r->breakp = whichSite;			
				q->time = currentTime;
				r->time = currentTime;
				q->sib = r;
				r->sib = q;
				q->left = p;
				r->left = p;
				p->anc1 = q;
				p->anc2 = r;				

				k = 0;
				for (w = 1; w < numSites; w++)
					{
					//fprintf (fpmpi, "\nstud[%d] = %d", w-1, stud[w-1]);
					if (whichSite == stud[w-1]) /* The breakpoints BETWEEN codons. "stud" is an array with the possible breakpoints beetween codons*/
						k++;

					/* exception for trapped material, any breakpoint here does not break material codons */
					if (ThisBreakpIsTrapped == YES)
						{
						k++;
						/*fprintf (fpmpi, "\n ThisBreakpIsTrapped \n");*/
						}
					}
				if (k == 0) /* broken codon, this indicates the position of rupture of the codon.. */
					{
					//q->breakCodon = YES;
					//r->breakCodon = YES;
					variable1 = whichSite/3.00 + 0.4;
					//fprintf (fpmpi, "\n variable1 = %lf", variable1);
					q->breakCodon = fabs(variable1);
					r->breakCodon = fabs(variable1);
					numREbreakCod++;
					variable2 = fmod(whichSite,3.00);
					if (variable2 == 0)
						q->whereBreakCodon = 2;
					else
						q->whereBreakCodon = 1;
					r->whereBreakCodon = 3;



					

					/* oct2009 */
					/* int			doBreakpBroken, LeftLess, LeftHigh, RightLess, RightHigh; */
					if (doCodonModel == YES)
						doBreakpBroken = YES;
					LeftLess = LeftHigh = RightLess = RightHigh = LeftLess2 = RightHigh2 = -1;

					if (q->whereBreakCodon == 1) /* first codon position breakp */
						{
						RightHigh = q->breakCodon * 3;
						RightLess = RightHigh - 1;
						LeftLess = RightLess - 1; 
						LeftHigh = RightLess - 1;
						
						
						q->SitesNonAncHere[LeftLess+1] = 1;
						q->SitesNonAncHere[LeftLess+2] = 1;
						r->SitesNonAncHere[RightLess-1] = 1;

						/*fprintf (fpmpi, "\n LeftLess+2 = %d; RightLess-1 = %d \n", LeftLess+2, RightLess-1);*/
						for (mmm=1; mmm<=numNuc; mmm++)
							{
							if (mmm <= RightLess-1)
								q->SitesNonAncHere[mmm] = p->SitesNonAncHere[mmm]; 
							if (mmm > RightLess-1 && mmm <= LeftLess+2)
								q->SitesNonAncHere[mmm] = 1;
							if (mmm > LeftLess+2)
								q->SitesNonAncHere[mmm] = -1;

							if (mmm < RightLess-1)
								r->SitesNonAncHere[mmm] = -1; 
							if (mmm == RightLess-1)
								r->SitesNonAncHere[mmm] = 1;
							if (mmm > RightLess-1)
								r->SitesNonAncHere[mmm] =  p->SitesNonAncHere[mmm];
							}	
						}
					else if (q->whereBreakCodon == 2) /* second codon position breakp */
						{
						RightHigh = q->breakCodon * 3;
						RightLess = q->breakCodon * 3;
						LeftHigh = RightLess - 1;
						LeftLess = LeftHigh - 1;


						q->SitesNonAncHere[LeftHigh+1] = 1;
						r->SitesNonAncHere[RightLess-1] = 1;	
						r->SitesNonAncHere[RightLess-2] = 1;
						
						/*fprintf (fpmpi, "\n LeftHigh+1 = %d; RightLess-2 = %d \n", LeftHigh+1, RightLess-2);*/
						for (mmm=1; mmm<=numNuc; mmm++)
							{
							if (mmm < LeftHigh+1)
								q->SitesNonAncHere[mmm] = p->SitesNonAncHere[mmm]; 
							if (mmm == LeftHigh+1)
								q->SitesNonAncHere[mmm] = 1;
							if (mmm > LeftHigh+1)
								q->SitesNonAncHere[mmm] = -1;

							if (mmm >= LeftHigh+1)
								r->SitesNonAncHere[mmm] = p->SitesNonAncHere[mmm]; 
							if (mmm >= RightLess-2 && mmm < LeftHigh+1)
								r->SitesNonAncHere[mmm] = 1;
							if (mmm < RightLess-2)
								r->SitesNonAncHere[mmm] = -1;

							}	
						}
					else
						{
						fprintf (fpmpi, "error at q->whereBreakCodon intra codon Rec _ Main (%d != 1 or 2)\n", q->whereBreakCodon);
						exit (-1);
						}
					/* fprintf (fpmpi, "\n Left (Less-High) %d-%d; Right (Less-High) %d-%d \n", LeftLess, LeftHigh, RightLess, RightHigh);	*/				
					if (LeftLess == -1 || LeftHigh == -1 || RightLess == -1 || RightHigh == -1)
						{
						fprintf (fpmpi, "\n Error (value = -1): Left (Less-High) %d-%d; Right (Less-High) %d-%d \n", LeftLess, LeftHigh, RightLess, RightHigh);					
						exit (-1);
						}


					}
				if (k > 0 || doCodonModel == NO) /* inter codon rec */
					{
					doBreakpBroken = NO;

					for (mmm=1; mmm<=numNuc; mmm++)
						{
						if (mmm >= whichSite)
							{
							q->SitesNonAncHere[mmm] = -1; /* non anc mat */
							}
						if (mmm < whichSite)
							{
							q->SitesNonAncHere[mmm] = p->SitesNonAncHere[mmm]; /* non anc mat */
							}

						if (mmm < whichSite)
							{
							r->SitesNonAncHere[mmm] = -1; /* non anc mat */
							}
						if (mmm >= whichSite)
							{
							r->SitesNonAncHere[mmm] = p->SitesNonAncHere[mmm]; /* non anc mat */
							}
						}	
					}
				/* oct2009 */

				/*for (mmm=1; mmm<=numNuc; mmm++)
					{
					fprintf (fpmpi, "\n Initial. Site %d. Node: %d, p->SitesNonAncHere = %d \n", mmm, p->index, p->SitesNonAncHere[mmm]);
					}
				for (mmm=1; mmm<=numNuc; mmm++)
					{
					fprintf (fpmpi, "\n Site %d. Node: %d, q->SitesNonAncHere = %d;  Node %d, r->SitesNonAncHere = %d \n", mmm, q->index, q->SitesNonAncHere[mmm], r->index, r->SitesNonAncHere[mmm]);
					}*/
				

				/*fprintf (fpmpi, "\n r->index = %d, r->time = %lf, r->class = %d, r->breakp = %d, r->breakCodon = %d, r->whereBreakCodon = %d", r->index, r->time, r->class, r->breakp, r->breakCodon, r->whereBreakCodon);
				fprintf (fpmpi, "\n q->index = %d, q->time = %lf, q->class = %d, q->breakp = %d, q->breakCodon = %d, q->whereBreakCodon = %d\n", q->index, q->time, q->class, q->breakp, q->breakCodon, q->whereBreakCodon);*/
				k = 0;	

			


				if (noisy == 4)
					{
					fprintf (fpmpi, "\nNode index %d with breakpoint on %d site", p->index, whichSite);
					fprintf (fpmpi, "\nThis node contains %d fragment(s):", p->numSegNode);
					}
				
				for (w = 0; w < p->numSegNode; w++)
					{
					s = segments + post(w,p->index,distance);
					if (post(w,p->index,distance) > numTotalSegments) /* checking */
						{
						fprintf (fpmpi, "\n post = %d > numTotalSegments = %d", post(w,p->index,distance), numTotalSegments);
						exit (-7);
						}
					if (noisy == 4)
						{
						fprintf (fpmpi, "\ns->sIndex = %d", s->sIndex);
						fprintf (fpmpi, "\ns->sStart = %d", s->sStart);
						fprintf (fpmpi, "\ns->sEnd = %d",s->sEnd);
						}
					}
				if (noisy == 4)
					fprintf (fpmpi, "\n\n>> Process evolution..");
					
					
				a = b = aa = bb = aaa = bbb = out = 0;
				startsVectorRec = (int *) calloc((p->numSegNode),(long) sizeof(int));
				if (!startsVectorRec)
					{
					fprintf (fpmpi, "Could not allocate startsVectorRec (%lu bytes)\n", (p->numSegNode) *(long) sizeof(int));	
					exit (-1);
					}
				endsVectorRec = (int *) calloc((p->numSegNode),(long) sizeof(int));
				if (!endsVectorRec)
					{
					fprintf (fpmpi, "Could not allocate endsVectorRec (%lu bytes)\n", (p->numSegNode) *(long) sizeof(int));
					exit (-1);
					}
			
				for (i = 0; i < p->numSegNode; i++)					/* for each segment */
					{
					s = segments + post(i,p->index,distance);										
					startsVectorRec[i] = s->sStart;
					endsVectorRec[i] = s->sEnd;
				
					/* first half */
					if (s->sStart >= whichSite)
						{
						if (noisy == 4)
							fprintf (fpmpi, "\nNil segment in Left, don't make it");
							
						q->numSegNode--;
						a++;
						out = 1;
						} 
				
					if (s->sStart == 1 && s->sEnd >= (whichSite-1) && out == 0)
						{
						if (aa > 0)
							{
							if (noisy == 4)
								fprintf (fpmpi, "\nRepit segment in Left, don't make it");
								
							q->numSegNode--;
							out = 1;
							}
						aa++;
						}
					
					for (w = 0; w < i+1; w++)
						{
						if (out == 0 && s->sStart != 1 && s->sStart == startsVectorRec[w] && s->sStart < whichSite && w != i && s->sEnd >= (whichSite-1) && endsVectorRec[w] >= (whichSite-1) && startsVectorRec[w] != 0)
							{
							if (noisy == 4)
								fprintf (fpmpi, "\nRepit segment in Left, don't make it");
								
							q->numSegNode--;
							aaa++;
							out = 1;
							}
						}
					
					if (out == 0 && s->sStart < whichSite)
						{
						if (aa == 0 && aaa == 0)
							{							
							if (post(i-a-aa-aaa,q->index,distance) > numTotalSegments) /* checking */
								{
								fprintf (fpmpi, "\n post = %d > numTotalSegments = %d", post(i-a-aa-aaa,q->index,distance), numTotalSegments);
								exit (-7);
								}
							
							n = segments + post(i-a-aa-aaa,q->index,distance);
							n->sIndexNode = firstHalf;
							}
						if (aa > 0 && aaa == 0)
							{
							if (post(i+1-a-aa-aaa,q->index,distance) > numTotalSegments) /* checking */
								{
								fprintf (fpmpi, "\n post = %d > numTotalSegments = %d", post(i+1-a-aa-aaa,q->index,distance), numTotalSegments);
								exit (-7);
								}
							
							n = segments + post(i+1-a-aa-aaa,q->index,distance);
							n->sIndexNode = firstHalf;
							}
						if (aaa > 0 && aa > 0)
							{
							if (post(i+1-a-aa-aaa,q->index,distance) > numTotalSegments) /* checking */
								{
								fprintf (fpmpi, "\n post = %d > numTotalSegments = %d", post(i+1-a-aa-aaa,q->index,distance), numTotalSegments);
								exit (-7);
								}
							
							n = segments + post(i+1-a-aa-aaa,q->index,distance);
							n->sIndexNode = firstHalf;
							}
						if (aaa > 0 && aa == 0)
							{
							if (post(i+0-a-aa-aaa,q->index,distance) > numTotalSegments) /* checking */
								{
								fprintf (fpmpi, "\n post = %d > numTotalSegments = %d", post(i+0-a-aa-aaa,q->index,distance), numTotalSegments);
								exit (-7);
								}
							
							n = segments + post(i+0-a-aa-aaa,q->index,distance);
							n->sIndexNode = firstHalf;
							}
						/* n = s; initial, the new segments are similar to the old segments */
						nodeValue = firstHalf;


						if (doBreakpBroken == YES && s->sStart < whichSite && s->sEnd >= whichSite)
							{
							w = recSegmentsGeneratesLeftBrokenCodon(nodeValue, s, n, numNuc, whichSite, LeftLess, RightHigh, &actSegIndex); /* it makes the segments of the left node */
							LeftLess2 = LeftLess;
							RightHigh2 = RightHigh;
							}
						else
							{
							w = recSegmentsGeneratesLeft(nodeValue, s, n, numNuc, whichSite, &actSegIndex); /* it makes the segments of the left node */
							}


						if (w != 1)
							{
							fprintf (fpmpi, "Warning in recSegmentsGeneratesLeft");
							exit (-1);
							}
						actNumSegments++;
						if (n->sStart == 0 && n->sEnd == 0) /* unreal segments */
							{
							fprintf (fpmpi, "\nNot to be here. Segment Left start and end = 0");
							
							n->before1 = n->before2 = n->after1 = n->after2 = NULL;
							actNumSegments--;
							exit(-1);
							}
						if (noisy == 4)			
							{
							fprintf (fpmpi, "\nAfter rec. left");
							fprintf (fpmpi, "\nq->seg->sIndex = %d", n->sIndex);
							fprintf (fpmpi, "\nq->seg->sStart = %d", n->sStart);
							fprintf (fpmpi, "\nq->seg->sEnd = %d\n", n->sEnd);
							}
						}
					w = out = 0;
				
					/* second half */
					if (s->sEnd < whichSite)
						{
						if (noisy == 4)
							fprintf (fpmpi, "\nNil segment in Right, don't make it");
							
						r->numSegNode--;
						b++;
						out = 1;
						}
					if (s->sStart <= whichSite && s->sEnd == numNuc && out == 0)
						{
						if (bb > 0)
							{
							if (noisy == 4)
								fprintf (fpmpi, "\nRepit segment in Right, don't make it");
								
							r->numSegNode--;
							out = 1;
							}
						bb++;
						}
					for (w = 0; w < i+1; w++)
						{
						if (out == 0 && s->sEnd != numNuc && s->sEnd == endsVectorRec[w] && s->sEnd > whichSite && w != i && s->sStart <= whichSite && startsVectorRec[w] <= whichSite && endsVectorRec[w] != 0)
							{
							if (noisy == 4)
								fprintf (fpmpi, "\nRepit segment in Right, don't make it");
								
							r->numSegNode--;
								
							bbb++;
							out = 1;
							}
						}
					for (w = 0; w < i+1; w++)
						{
						if (out == 0 && s->sEnd == endsVectorRec[w] && s->sEnd >= whichSite && w != i && s->sStart <= whichSite && startsVectorRec[w] <= whichSite && endsVectorRec[w] != 0)
							{
							if (noisy == 4)
								fprintf (fpmpi, "\nRepit segment in Right, don't make it");
								
							r->numSegNode--;
								
							bbb++;
							out = 1;
							}
						}
					if (out == 0 && s->sEnd >= whichSite)
						{
						if (bb == 0 && bbb == 0)
							{
							if (post(i-b-bb-bbb,r->index,distance) > numTotalSegments) /* checking */
								{
								fprintf (fpmpi, "\n post = %d > numTotalSegments = %d", post(i-b-bb-bbb,r->index,distance), numTotalSegments);
								exit (-7);
								}
							
							m = segments + post(i-b-bb-bbb,r->index,distance);
							m->sIndexNode = secondHalf;
							}
						if (bb > 0 && bbb == 0)
							{
							if (post(i+1-b-bb-bbb,r->index,distance) > numTotalSegments) /* checking */
								{
								fprintf (fpmpi, "\n post = %d > numTotalSegments = %d", post(i+1-b-bb-bbb,r->index,distance), numTotalSegments);
								exit (-7);
								}
							
							m = segments + post(i+1-b-bb-bbb,r->index,distance);
							m->sIndexNode = secondHalf;
							}
						if (bb > 0 && bbb > 0)
							{
							if (post(i+1-b-bb-bbb,r->index,distance) > numTotalSegments) /* checking */
								{
								fprintf (fpmpi, "\n post = %d > numTotalSegments = %d", post(i+1-b-bb-bbb,r->index,distance), numTotalSegments);
								exit (-7);
								}
							
							m = segments + post(i+1-b-bb-bbb,r->index,distance);
							m->sIndexNode = secondHalf;
							}
						if (bb == 0 && bbb > 0)
							{
							if (post(i+0-b-bb-bbb,r->index,distance) > numTotalSegments) /* checking */
								{
								fprintf (fpmpi, "\n post = %d > numTotalSegments = %d", post(i+0-b-bb-bbb,r->index,distance), numTotalSegments);
								exit (-7);
								}
							
							m = segments + post(i+0-b-bb-bbb,r->index,distance);
							m->sIndexNode = secondHalf;
							}
						/* m = s; initial, the new segments are similar to the old segments */
						nodeValue = secondHalf;


						if (doBreakpBroken == YES && s->sStart < whichSite && s->sEnd >= whichSite)
							{
							w = recSegmentsGeneratesRightBrokenCodon(nodeValue, s, m, numNuc, whichSite, LeftLess, RightHigh, &actSegIndex);
							LeftLess2 = LeftLess;
							RightHigh2 = RightHigh;
							}
						else
							{
							w = recSegmentsGeneratesRight(nodeValue, s, m, numNuc, whichSite, &actSegIndex);
							}


						if (w != 1)
							{
							fprintf (fpmpi, "Warning in recSegmentsGeneratesRight");
							exit (-1);
							}
					
						actNumSegments++;
						if (m->sStart == 0 && m->sEnd == 0) /* unreal segments */
							{
							fprintf (fpmpi, "\nNot to be here. Segment Right start and end = 0");
							
							m->before1 = m->before2 = m->after1 = m->after2 = NULL;
							actNumSegments--;
							exit(-1);
							}
						if (noisy == 4)
							{
							fprintf (fpmpi, "\nAfter rec. right");
							fprintf (fpmpi, "\nr->seg->sIndex = %d", m->sIndex);
							fprintf (fpmpi, "\nr->seg->sStart = %d", m->sStart);
							fprintf (fpmpi, "\nr->seg->sEnd = %d\n", m->sEnd);
							} 
						}
					w = out = 0;
					}
			
				free (startsVectorRec);
				free (endsVectorRec);
				a = b = aa = bb = aaa = bbb = 0;

				/* intra codon breakpoints readjust MRCA oct2009 */
				if (doBreakpBroken == YES) /* The codon positions that have recombined are increased a unit */
					{
					for (w = 1; w <= numNuc; w++)
						{
						if (w >= LeftLess2 && w <= RightHigh2)
							{
							S_MRCA[w]++;
							/*fprintf (fpmpi, "\n Increasing MRCA to %d: now is: %d \n", w, S_MRCA[w]);*/
							}
						}

					}
				/* oct2009 */


				if (noisy == 4)
					{
					fprintf (fpmpi, "\n>> Recombination Results:");
					fprintf (fpmpi, "\nNew left node with %d fragment(s)", q->numSegNode);
					}
				for (w = 0; w < q->numSegNode;w++)
					{
					n = segments + post(w,q->index,distance);
					if (noisy == 4)
						{
						fprintf (fpmpi, "\nq->seg->sIndex = %d", n->sIndex);
						fprintf (fpmpi, "\nq->seg->sStart = %d", n->sStart);
						fprintf (fpmpi, "\nq->seg->sEnd = %d\n", n->sEnd);
						} 
					}
				
				if (noisy == 4)
					fprintf (fpmpi, "\nNew right node with %d fragment(s)", r->numSegNode);
					
				for (w = 0; w < r->numSegNode;w++)
					{
					m = segments + post(w,r->index,distance);
					if (noisy == 4)
						{
						fprintf (fpmpi, "\nr->seg->sIndex = %d", m->sIndex);
						fprintf (fpmpi, "\nr->seg->sStart = %d", m->sStart);
						fprintf (fpmpi, "\nr->seg->sEnd = %d\n", m->sEnd);
						} 
					}
				if (noisy > 3)
					{
					fprintf (fpmpi,"\n");
					/*fprintf (fpmpi, "the node is whichInd = %d, and the site is whichSite = %d", whichInd+1, whichSite+1);*/
					}
				if (noisy > 1)
					{
					fprintf (fpmpi, "Recombination involving %d (copied to %d and %d) in deme %d", p->index, q->index, r->index, p->indexCurrentMigPop);
					fprintf (fpmpi, "\n Breakpoint was at site %d", whichSite);
					}
				if (noisy > 3)
					fprintf (fpmpi,"\n");
				
				if (doBranchNetfiles == YES)
					{
					if (q->NetLabelPrint < numSequences)
						fprintf(fpBranchNet,"%d_seq%05d ", q->NetLabelPrint, q->NetLabelPrint+1);
					else
						fprintf(fpBranchNet,"%d ", q->NetLabelPrint);

					if (p->NetLabelPrint < numSequences)
						fprintf(fpBranchNet,"%d_seq%05d\n", p->NetLabelPrint, p->NetLabelPrint+1);
					else
						fprintf(fpBranchNet,"%d\n", p->NetLabelPrint);

					/*fprintf(fpBranchNet,"%d %d\n", q->NetLabelPrint, p->NetLabelPrint);*/


					/*fprintf(fpBranchNet,"%d %d\n", r->NetLabelPrint, p->NetLabelPrint);*/
					if (noisy > 2)
						fprintf (fpmpi, "\nNET INFORMATION Recombination involving %d (copied to %d and %d) in deme %d", p->NetLabelPrint, q->NetLabelPrint, r->NetLabelPrint, p->indexCurrentMigPop);
					}
					
					
				breakpoint[numRE-1] = whichSite;  /* the breakpoint site is call breakpoint. breakpoint[0] = 7, breakpoint[1] = 96, breakpoint[2] = 187.. */
				
				/* readjust active sites */
				activeGametes[whichInd] = firstHalf;	/* new active nodes firstHalf and secondHalf */
				activeGametes[numActiveGametes++] = secondHalf;		/* there are 1 active node more (in recombination) */
			
				w = 0;	
				for (k = 1; k <= numPopulations+currentBigDeme; k++)
					{
					if (k == p->indexCurrentMigPop)
						numParcialActiveGametes[k] = numParcialActiveGametes[k] +1;
					w = w + numParcialActiveGametes[k];
					}
				if (w != numActiveGametes)
					{
					fprintf (fpmpi, "\n 4The sum of partial active gametes is different than total gametes number, w %d != numActiveGametes %d. In choose the deme", w, numActiveGametes);
					exit (-1);
					}
				}
		
		
			/*** MIGRATION ***/
			if (isMigration == YES) 
				{
				if (noisy == 4)
					fprintf (fpmpi, "\n* Migration *");			
					
				/* Which node has the migration? */
				cumPopulPart = (double *) calloc((numParcialActiveGametes[whichDeme]+1),(long) sizeof(double));
				if (!cumPopulPart)
					{
					fprintf (fpmpi, "Could not allocate cumPopulPart (%lu bytes)\n", (numParcialActiveGametes[whichDeme]+1) *(long) sizeof(double));
					exit (-1);
					}
			
				for (k = 1; k <= numParcialActiveGametes[whichDeme]; k++)
					cumPopulPart[k] = 0;
				cumPopulPart[0] = 0;
				w = 0;
			
				for (k = 1; k <= numParcialActiveGametes[whichDeme]; k++)
					cumPopulPart[k] = cumPopulPart[k-1] + 1.0/numParcialActiveGametes[whichDeme];
				/*fprintf(fpmpi, "\n cumPopulPart[numParcialActiveGametes[whichDeme]] = %lf", cumPopulPart[numParcialActiveGametes[whichDeme]]);*/
				for (k = 1; k <= numPopulations+currentBigDeme; k++)
					w = w + numParcialActiveGametes[k];				
					
				if (w != numActiveGametes)
					{
					fprintf (fpmpi, "\n 5The sum of partial active gametes is different than total gametes number, w %d != numActiveGametes %d. In choose the deme", w, numActiveGametes);
					exit (-1);
					}
				
				ran = RandomUniform(seed);
				whichInd = bbinDemes(ran, cumPopulPart, numParcialActiveGametes[whichDeme]);
				w = 0;
				for (i = 0; i < numActiveGametes; i++)
					{
					p = nodes + activeGametes[i];
			
					if (p->indexCurrentMigPop == whichDeme)
						w++;
						
					if (w == whichInd)
						{
						whichInd = i;
						break;
						}
					}
				free (cumPopulPart);
			

				/* Which arrived Deme? */ /* New migration models: doMigrationIsland, doMigrationSTST, doMigrationIslCont */			
				for (k = 1; k <= numPopulations+currentBigDeme; k++)
					cumPopulTase[k] = 0;
				cumPopulTase[0] = 0;
				w = c = e = 0;
				/*fprintf(fpmpi, "\n whichDeme = %d \n", whichDeme);*/

				if (doConvergDemes == YES)
					{
					ArrivedDemesOptions = (int *)calloc((currentDemesNumber+1),(long) sizeof(int));
					if (!ArrivedDemesOptions)
						{
						fprintf (fpmpi, "Could not allocate ArrivedDemesOptions (%lu bytes)\n", (currentDemesNumber+1)  * (long) sizeof(int));
						exit (1);
						}
					for (k = 1; k <= currentDemesNumber; k++)
						ArrivedDemesOptions[k] = 0;
					ArrivedDemesOptions[0] = 0;

					e = 1;
					w = 1;
					for (k = 1; k <= 2*numPopulations-1; k++)
						{
						if (CurrentDemesState[k] != 0)
							{
							ArrivedDemesOptions[w] = CurrentDemesState[k];
							w++;
							}
						}
					if (w != currentDemesNumber+1) /* Checking */
						{
						fprintf (fpmpi, "\n Warning in currentDemesNumber: w = %d, currentDemesNumber+1 = %d\n", w, currentDemesNumber+1);
						fprintf (fpmpi, "\n Check if you have fixed the convergence of two demes which do not exist at that convergence time\n");
						exit (1);
						}
					
					/*for (k = 0; k < numActiveGametes; k++)
						{
						p = nodes + activeGametes[k];
						if (k == 0)
							{
							ArrivedDemesOptions[e] = p->indexCurrentMigPop;
							e++;
							}
						else
							{
							c = 0;
							for (w = 1; w <= currentDemesNumber; w++)
								if (p->indexCurrentMigPop != ArrivedDemesOptions[w])
									c++;
							if (c == currentDemesNumber)
								{
								ArrivedDemesOptions[e] = p->indexCurrentMigPop;
								e++;
								}
							}
							
						fprintf (fpmpi, " \nNode %d of deme %d", p->index, p->indexCurrentMigPop);
						}*/		
					

					/*for (k = 1; k <= currentDemesNumber; k++)
						fprintf (fpmpi, " \n ArrivedDemesOptions[%d] = %d", k, ArrivedDemesOptions[k]);*/ /* To see the array of current active demes*/
				
					/*if (e != currentDemesNumber+1)
						{
						fprintf (fpmpi, "\n Warning in currentDemesNumber: e = %d, currentDemesNumber+1 = %d\n", e, currentDemesNumber+1);
						fprintf (fpmpi, "\n Check if you have fixed the convergence of two demes which do not exit at that time\n");
						exit (1);
						}*/ /* This is not an error */
					w = e = c = 0;

					if (doMigrationIsland == YES) /* migrations go to any other deme */
						{
						for (k = 1; k <= numPopulations+currentBigDeme; k++)
							{
							if (k == whichDeme)
								cumPopulTase[k] = cumPopulTase[k-1];
							else
								{
								c = 0;
								for (w = 1; w <= currentDemesNumber; w++)
									if (k == ArrivedDemesOptions[w])
										c++;
								if (c > 0)
									cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(currentDemesNumber-1);
								else
									cumPopulTase[k] = cumPopulTase[k-1];
								}
							}
						}
					else if (doMigrationSTST == YES) /* migrations go only to close neighboring demes */ /* MIGUEL */
						{
						controlConvSTST1 = summConvSTST1 = controlConvSTST2 = summConvSTST2 = 0;

						for (k = 1; k <= numPopulations+currentBigDeme; k++)
							{
	
							if (k == whichDeme)
								cumPopulTase[k] = cumPopulTase[k-1];
							else
								{
								c = 0;
								for (w = 1; w <= currentDemesNumber; w++)
									if (k == ArrivedDemesOptions[w])
										c++;

								if (c > 0)
									{

									/**/
									if (whichDeme == ArrivedDemesOptions[1]) 
										{
										
										OkValue = ArrivedDemesOptions[2];

										for (tt = 1; tt <= currentDemesNumber; tt++)
											if (ArrivedDemesOptions[tt] < OkValue && ArrivedDemesOptions[tt] != whichDeme)
												OkValue = ArrivedDemesOptions[tt];
										
										if (k == OkValue)
											cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(1);
										else
											cumPopulTase[k] = cumPopulTase[k-1];

										/*if (controlConvSTST1 == 0)
											{
											if (k == whichDeme + summConvSTST1 + 1)
												{
												cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(1);
												controlConvSTST1++;
												}
											else
												cumPopulTase[k] = cumPopulTase[k-1];

											summConvSTST1++;
											}*/

										}
									else if (whichDeme == ArrivedDemesOptions[currentDemesNumber]) 
										{

										OkValue = ArrivedDemesOptions[currentDemesNumber-1];
										
										for (tt = 1; tt <= currentDemesNumber; tt++)
											if (ArrivedDemesOptions[tt] > OkValue && ArrivedDemesOptions[tt] != whichDeme)
												OkValue = ArrivedDemesOptions[tt];
										
										if (k == OkValue)
											cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(1);
										else
											cumPopulTase[k] = cumPopulTase[k-1];


									/*	if (controlConvSTST2 == 0)
											{
											if (k == whichDeme - summConvSTST2 - 1)
												{
												cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(1);
												controlConvSTST2++;
												}
											else
												cumPopulTase[k] = cumPopulTase[k-1];

											summConvSTST2++;

											}*/
										}									
									else
										{
										
										/* lower */
										OkValue1 = ArrivedDemesOptions[1];

										for (tt = 1; tt <= currentDemesNumber; tt++)
											if (ArrivedDemesOptions[tt] < whichDeme && ArrivedDemesOptions[tt] > OkValue1)
												OkValue1 = ArrivedDemesOptions[tt];
										
										/* higher */
										OkValue2 = ArrivedDemesOptions[currentDemesNumber];

										for (tt = 1; tt <= currentDemesNumber; tt++)
											if (ArrivedDemesOptions[tt] > whichDeme && ArrivedDemesOptions[tt] < OkValue2)
												OkValue2 = ArrivedDemesOptions[tt];


										if (k == OkValue1)
											cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(2);
										else if (k == OkValue2)
											cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(2);
										else
											cumPopulTase[k] = cumPopulTase[k-1];	

										}



									}	
								else
									cumPopulTase[k] = cumPopulTase[k-1];
		
								}


							} /* end for */
						} /* end doMigrationSTST in conv demes */
					else if (doMigrationIslCont == YES) /* migrations go only by continent <-> islands demes */ /* MIGUEL */ 
						{
						/*fprintf (fpmpi, "\n In doMigrationIslCont with conv demes \n");*/

						for (k = 1; k <= numPopulations+currentBigDeme; k++)
							{
	
							if (k == whichDeme)
								cumPopulTase[k] = cumPopulTase[k-1];
							else
								{
								c = 0;
								for (w = 1; w <= currentDemesNumber; w++)
									if (k == ArrivedDemesOptions[w])
										c++;

								if (c > 0)
									{
									/**/
									if (newOkValueCI == 0) /* convergence of demes still did not occur */
										{
										OkValueCI = ArrivedDemesOptions[1];
										for (tt = 1; tt <= currentDemesNumber; tt++)
												if (ArrivedDemesOptions[tt] < OkValueCI)
													OkValueCI = ArrivedDemesOptions[tt]; /* lowest value (OkValueCI) = continent */
										}

									/*fprintf (fpmpi, "\n whichDeme = %d; goes to deme k = %d; continent deme (OkValueCI) = %d \n", whichDeme, k, OkValueCI);*/


									if (whichDeme == OkValueCI) /* whichDeme is continent and can go to any island */
										{
										/*fprintf (fpmpi, "  CASE1: whichDeme = %d; k = %d; OkValueCI = %d \n", whichDeme, k, OkValueCI);*/

										if (k == whichDeme)
											cumPopulTase[k] = cumPopulTase[k-1];
							 			else
											cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(currentDemesNumber-1);
										}
									else  /* whichDeme is island and can go only to the continent */
										{
										/*fprintf (fpmpi, "  CASE2: whichDeme = %d; k = %d; OkValueCI = %d \n", whichDeme, k, OkValueCI);*/

										if (k == OkValueCI)
											cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(1);
										else
											cumPopulTase[k] = cumPopulTase[k-1];
										}									
									}	
								else
									cumPopulTase[k] = cumPopulTase[k-1];
		
								}


							} /* end for */
						} /* end doMigrationIslCont in conv demes */
					else
						{
						fprintf(fpmpi, "\nError in migration model (MakeCoalescenceTreeHotspotRec function)1. \n\n");
						exit(-1);
						}


					} /* end conv demes */
				else	
					{
					if (doMigrationIsland == YES) /* migrations go to any other deme */
						{
						for (k = 1; k <= numPopulations+currentBigDeme; k++)
							{
							if (k == whichDeme)
								cumPopulTase[k] = cumPopulTase[k-1];
							 else
								cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(numPopulations+currentBigDeme-1);
							}
						}
					else if (doMigrationSTST == YES) /* migrations go only to close neighboring demes */
						{

						for (k = 1; k <= numPopulations+currentBigDeme; k++)
							{
							if (whichDeme == 1) /* node in deme 1, goes only to deme 2 */
								{
								if (k == whichDeme + 1)
									cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(1);
								else
									cumPopulTase[k] = cumPopulTase[k-1];
								}
							else if (whichDeme == numPopulations+currentBigDeme) /* node in deme max, goes only to deme max-1 */
								{
								if (k == whichDeme - 1)
									cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(1);
								else
									cumPopulTase[k] = cumPopulTase[k-1];
								}
							else /* node in other deme, goes to deme + or -1 */
								{
								if (k == whichDeme - 1)
									cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(2);
								else if (k == whichDeme + 1)
									cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(2);
								else
									cumPopulTase[k] = cumPopulTase[k-1];
								}
							}

						}
					else if (doMigrationIslCont == YES) /* migrations go only by continent <-> islands demes */
						{

						for (k = 1; k <= numPopulations+currentBigDeme; k++)
							{
							if (whichDeme == 1) /* node in deme 1 (continent) can go to any other deme (islands) */
								{
								if (k == whichDeme)
									cumPopulTase[k] = cumPopulTase[k-1];
								 else
									cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(numPopulations+currentBigDeme-1);
								}
							else /* node in other deme (island) can go only to deme 1 (continent) */
								{
								if (k == 1)
									cumPopulTase[k] = cumPopulTase[k-1] + 1.0/(1);
								else
									cumPopulTase[k] = cumPopulTase[k-1];
								}
							}

						}
					else
						{
						fprintf(fpmpi, "\nError in migration model (MakeCoalescenceTreeHotspotRec function)2. \n\n");
						exit(-1);
						}


					}
				

				/*for (k = 1; k <= numPopulations+currentBigDeme; k++)
					fprintf(fpmpi, "\n cumPopulTase[%d] = %lf", k, cumPopulTase[k]);
				fprintf(fpmpi, "\n numPopulations+currentBigDeme = %d \n", numPopulations+currentBigDeme);*/



				ran = RandomUniform(seed);
				arrivedDeme = bbinDemes(ran, cumPopulTase, numPopulations+currentBigDeme); 		/* Check: this fails if cumPopulTase at the end is != 1 */
				/*fprintf(fpmpi,"\n To deme %d  \n", arrivedDeme);*/
				w = 0;
				
				if (whichDeme == arrivedDeme) /* Cheking */
					{
					fprintf (fpmpi, "\n\nERROR in migration, whichDeme == arrivedDeme");
					exit (-1);
					}
				if (doConvergDemes == YES)
					free (ArrivedDemesOptions);
				/* evolution migration node*/
				p = nodes + activeGametes[whichInd];
				if (p->indexCurrentMigPop != whichDeme)
					{
					fprintf (fpmpi, "\n\nERROR in migration, p->indexCurrentMigPop != whichDeme");
					exit (-1);
					}
			
				p->indexCurrentMigPop = arrivedDeme; /* Changing the deme */
			
				if (noisy == 4)
					{
					fprintf (fpmpi, "\nNode %d migrates from deme %d to deme %d", p->index, whichDeme, arrivedDeme);
					fprintf (fpmpi, "\nThis node contains %d fragment(s):", p->numSegNode);	
					}
				for (w = 0; w < p->numSegNode; w++)
					{
					s = segments + post(w,p->index,distance);
					if (noisy == 4)
						{
						fprintf (fpmpi, "\ns->sIndex = %d", s->sIndex);
						fprintf (fpmpi, "\ns->sStart = %d", s->sStart);
						fprintf (fpmpi, "\ns->sEnd = %d",s->sEnd);
						}
					}
				/*numParcialActiveGametes[k] ++ y --*/
				numParcialActiveGametes[whichDeme] = numParcialActiveGametes[whichDeme]-1;
				numParcialActiveGametes[arrivedDeme] = numParcialActiveGametes[arrivedDeme]+1;								
				k = 0;
				
					
				if (noisy == 4)
					fprintf (fpmpi, "\n");
				if (noisy > 1)
					fprintf (fpmpi, "Migration involving node %d from deme %d to deme %d", p->index, whichDeme, arrivedDeme);
				if (noisy == 4)
					fprintf (fpmpi, "\n");
				}
		
		
			/*** COALESCENCE ***/
			if (isCoalescence == YES)
				{
				if (noisy == 4)
					fprintf (fpmpi, "\n* Coalescence *\n");
					
				/* figure out which two nodes are involved */ 			
				/* intial nodes: firstInd and secondInd (they are the descendants). newInd is the ancestral node, is the new node to make */
				cumPopulPart = (double *) calloc((numParcialActiveGametes[whichDeme]+1),(long) sizeof(double));
				if (!cumPopulPart)
					{
					fprintf (fpmpi, "Could not allocate cumPopulPart (%lu bytes)\n", (numParcialActiveGametes[whichDeme]+1) *(long) sizeof(double));
					exit (-1);
					}
				
				for (k = 1; k <= numParcialActiveGametes[whichDeme]; k++)
					cumPopulPart[k] = 0;
				cumPopulPart[0] = 0;
				w = 0;
			
				for (k = 1; k <= numParcialActiveGametes[whichDeme]; k++)
					cumPopulPart[k] = cumPopulPart[k-1] + 1.0/numParcialActiveGametes[whichDeme];
					
				for (k = 1; k <= numPopulations+currentBigDeme; k++)
					w = w + numParcialActiveGametes[k];
					
				if (w != numActiveGametes)
					{
					fprintf (fpmpi, "\n 6The sum of partial active gametes is different than total gametes number, w %d != numActiveGametes %d. In choose the deme", w, numActiveGametes);
					exit (-1);
					}
				
				ran = RandomUniform(seed);
				firstInd = bbinDemes(ran, cumPopulPart, numParcialActiveGametes[whichDeme]);
				w = 0;
				for (i = 0; i < numActiveGametes; i++)
					{
					p = nodes + activeGametes[i];
			
					if (p->indexCurrentMigPop == whichDeme)
						w++;
						
					if (w == firstInd)
						{
						firstInd = i;
						break;
						}
					}
				if (firstInd >= numActiveGametes) /* checking */
					{
					fprintf (fpmpi, "\n\nERROR: firstInd out of range!\n");
					exit (-1);
					}
					
				do
					{
					for (k = 1; k <= numParcialActiveGametes[whichDeme]; k++)
						cumPopulPart[k] = 0;
					cumPopulPart[0] = 0;
					w = 0;
			
					for (k = 1; k <= numParcialActiveGametes[whichDeme]; k++)
						cumPopulPart[k] = cumPopulPart[k-1] + 1.0/numParcialActiveGametes[whichDeme];
						
					for (k = 1; k <= numPopulations+currentBigDeme; k++)
						w = w + numParcialActiveGametes[k];				
						
					if (w != numActiveGametes)
						{
						fprintf (fpmpi, "\n 7The sum of partial active gametes is different than total gametes number, w %d != numActiveGametes %d. In choose the deme", w, numActiveGametes);
						exit (-1);
						}
				
					ran = RandomUniform(seed);
					secondInd = bbinDemes(ran, cumPopulPart, numParcialActiveGametes[whichDeme]);
					w = 0;
					for (i = 0; i < numActiveGametes; i++)
						{
						p = nodes + activeGametes[i];
			
						if (p->indexCurrentMigPop == whichDeme)
							w++;
							
						if (w == secondInd)
							{
							secondInd = i;
							break;
							}
						}
					} while (firstInd == secondInd);
				free (cumPopulPart);			
			
				newInd = nextAvailable;
				if (noisy > 1)
					fprintf (fpmpi, "Coalescence involving %d and %d to create node %d in deme %d", activeGametes[firstInd], activeGametes[secondInd], newInd, whichDeme);
					
				p = nodes + activeGametes[firstInd];
				q = nodes + activeGametes[secondInd];
				
				if (p->numSegNode > maxSegNode) 
					{
					fprintf (fpmpi, "\n\nWarning, too many segments in this node. max = %d", maxSegNode);
					fprintf (fpmpi, "\n p->numSegNode = %d",p->numSegNode);
					exit(9);
					}
				if (q->numSegNode > maxSegNode)
					{
					fprintf (fpmpi, "\n\nWarning, too many segments in this node. max = %d", maxSegNode);
					fprintf (fpmpi, "\n q->numSegNode = %d",q->numSegNode);
					exit(9);
					}

				r = nodes + newInd;		/* new ancester */
				r->index = nextAvailable;
				r->label = labelNodes++;
				r->indexOldMigPop = r->indexCurrentMigPop = whichDeme;
				
				r->breakp = NO;
				r->breakCodon = NO;
				r->class = 4;
				r->GMRCA_ancestral = NO;
				/*fprintf (fpmpi, "\nobtained r->index = %d: r->breakp = %d, r->breakCodon = %d, r->class = %d \n", r->index, r->breakp, r->breakCodon, r->class);*/
				
				for (mmm = 1; mmm <= numNuc; mmm++)	 /* for each segment of p node going to r node*/
					{
					sigue = 0;
					stateHere_P = -2; /* -2, non ancestral; 0 ancestral */
					stateHere_Q = -2; /* -2, non ancestral; 0 ancestral */

					for (i = 0; i < p->numSegNode; i++)	 /* for each segment of p node going to r node*/
						{
						s = segments + post(i,p->index,distance);
						if (mmm >= s->sStart && mmm <= s->sEnd) /* is ancestral material */
							{
							stateHere_P = 0;
							}
						}
					for (i = 0; i < q->numSegNode; i++)	/* for each segment of q node going to r node */
						{
						n = segments + post(i,q->index,distance);
						if (mmm >= n->sStart && mmm <= n->sEnd) /* is ancestral material */
							{
							stateHere_Q = 0;
							}
						}
					
					
					/*fprintf (fpmpi, "\n Here(%d) stateHere_P = %d and stateHere_Q = %d ", mmm, stateHere_P, stateHere_Q);
					fprintf (fpmpi, "\n  Here(%d), node %d: p->SitesNonAncHere[mmm] = %d && node %d: q->SitesNonAncHere[mmm] = %d \n", mmm, p->index, p->SitesNonAncHere[mmm], q->index, q->SitesNonAncHere[mmm]);*/

					if (stateHere_P < 0 && stateHere_Q < 0) /* non ancestral material */
						{
						r->SitesNonAncHere[mmm] = -1;
						sigue++;
						/*fprintf (fpmpi, "1Position %d is NON anc mat \n", mmm);*/
						}
					if (stateHere_P >= 0 || stateHere_Q >= 0) /* ancestral material (inc pseudo) */
						{
						if (p->SitesNonAncHere[mmm] == 1 && q->SitesNonAncHere[mmm] == 1 && sigue == 0) /* pseudo anc mat */
							{
							r->SitesNonAncHere[mmm] = 1;
							sigue++;
							/*fprintf (fpmpi, "2Position %d is PSEUDO anc mat \n", mmm);*/
							}
						if (p->SitesNonAncHere[mmm] == 1 && stateHere_Q < 0 && sigue == 0) /* pseudo anc mat */
							{
							r->SitesNonAncHere[mmm] = 1;
							sigue++;
							/*fprintf (fpmpi, "3Position %d is PSEUDO anc mat \n", mmm);*/
							}
						if (q->SitesNonAncHere[mmm] == 1 && stateHere_P < 0 && sigue == 0) /* pseudo anc mat */
							{
							r->SitesNonAncHere[mmm] = 1;
							sigue++;
							/*fprintf (fpmpi, "4Position %d is PSEUDO anc mat \n", mmm);*/
							}
						if (sigue == 0)
							{
							if (p->SitesNonAncHere[mmm] == 0 || q->SitesNonAncHere[mmm] == 0)  /* anc mat */
								{
								r->SitesNonAncHere[mmm] = 0;
								sigue++;
								/*fprintf (fpmpi, "5Position %d is ANC mat \n", mmm);*/
								}
							}
						}
					}

				/*fprintf (fpmpi, "\nobtained r->index = %d: r->breakp = %d, r->breakCodon = %d, r->class = %d \n", r->index, r->breakp, r->breakCodon, r->class);*/



				if (doBranchNetfiles == YES)
					{
					r->NetLabelPrint = numNetLabelPrint;
					numNetLabelPrint++;

					if (p->NetLabelPrint == q->NetLabelPrint)
						{

						if (r->NetLabelPrint < numSequences)
							fprintf(fpBranchNet,"%d_seq%05d ", r->NetLabelPrint, r->NetLabelPrint+1);
						else
							fprintf(fpBranchNet,"%d ", r->NetLabelPrint);

						if (p->NetLabelPrint < numSequences)
							fprintf(fpBranchNet,"%d_seq%05d\n", p->NetLabelPrint, p->NetLabelPrint+1);
						else
							fprintf(fpBranchNet,"%d\n", p->NetLabelPrint);

						/*fprintf(fpBranchNet,"%d %d\n", r->NetLabelPrint, p->NetLabelPrint);*/
						}
					else
						{


						if (r->NetLabelPrint < numSequences)
							fprintf(fpBranchNet,"%d_seq%05d ", r->NetLabelPrint, r->NetLabelPrint+1);
						else
							fprintf(fpBranchNet,"%d ", r->NetLabelPrint);

						if (p->NetLabelPrint < numSequences)
							fprintf(fpBranchNet,"%d_seq%05d\n", p->NetLabelPrint, p->NetLabelPrint+1);
						else
							fprintf(fpBranchNet,"%d\n", p->NetLabelPrint);


						if (r->NetLabelPrint < numSequences)
							fprintf(fpBranchNet,"%d_seq%05d ", r->NetLabelPrint, r->NetLabelPrint+1);
						else
							fprintf(fpBranchNet,"%d ", r->NetLabelPrint);

						if (q->NetLabelPrint < numSequences)
							fprintf(fpBranchNet,"%d_seq%05d\n", q->NetLabelPrint, q->NetLabelPrint+1);
						else
							fprintf(fpBranchNet,"%d\n", q->NetLabelPrint);

						/*fprintf(fpBranchNet,"%d %d\n", r->NetLabelPrint, p->NetLabelPrint);
						fprintf(fpBranchNet,"%d %d\n", r->NetLabelPrint, q->NetLabelPrint);*/
						}
					if (noisy > 2)
						fprintf (fpmpi, "\nNET INFORMATION Coalescence involving %d and %d to create node %d in deme %d", p->NetLabelPrint, q->NetLabelPrint, r->NetLabelPrint, whichDeme);
					}
				

				coalVectorCountStarts = (int *) calloc((p->numSegNode+q->numSegNode),(long) sizeof(int));
				if (!coalVectorCountStarts)
					{
					fprintf (fpmpi, "Could not allocate coalVectorCountStarts (%lu bytes)\n", (p->numSegNode+q->numSegNode) *(long) sizeof(int));
					exit (-1);
					}
				coalVectorCountEnds = (int *) calloc((p->numSegNode+q->numSegNode),(long) sizeof(int));
				if (!coalVectorCountEnds)
					{
					fprintf (fpmpi, "Could not allocate coalVectorCountEnds (%lu bytes)\n", (p->numSegNode+q->numSegNode) *(long) sizeof(int));
					exit (-1);
					}
				
				for (i = 0; i < p->numSegNode; i++)	 /* for each segment of p node going to r node */
					{
					s = segments + post(i,p->index,distance);
					if (post(i,r->index,distance) > numTotalSegments) /* control */
						{
						fprintf (fpmpi, "\n post = %d > numTotalSegments = %d", post(w,r->index,distance), numTotalSegments);
						exit (-7);
						}
					
					m = segments + post(i,r->index,distance);					/* new ancester */
					m->sIndexNode = newInd;
					
					s->before1 = m;
					m->before1 = NULL;
					m->before2 = NULL;
					m->after1 = s;
					m->after2 = NULL;
					m->sIndex = actSegIndex;
					m->sStart = s->sStart;
					m->sEnd = s->sEnd;				

					actSegIndex++;
					actNumSegments++;
					/*r->numSegNode++;*/
						
					if (m->sStart == 0 && m->sEnd == 0) /* unreal segments */
						{
						fprintf (fpmpi, "\nNot to be here. COAL1, segment start and end = 0");
						
						m->before1 = m->before2 = m->after1 = m->after2 = NULL;
						actNumSegments--;
						exit(-1);
						}
					coalVectorCountStarts[i] = s->sStart;
					coalVectorCountEnds[i] = s->sEnd;
					}
				
				j = p->numSegNode;
				r->numSegNode = j;
				a = b = 0;
				
				for (i = 0; i < q->numSegNode; i++)	/* for each segment of q node going to r node */
					{
					if (post(i,q->index,distance) > numTotalSegments) /* Cheking */
						{
						fprintf (fpmpi, "\n post = %d > numTotalSegments = %d", post(w,q->index,distance), numTotalSegments);
						exit (-7);
						}
					n = segments + post(i,q->index,distance);
				
					for (w = 0; w < j; w++)
						if (n->sStart == coalVectorCountStarts[w] && n->sEnd == coalVectorCountEnds[w]) /* Segmento repetido */
							a++; 
					
					if (a == 0)
						{
						m = segments + post(b+j,r->index,distance);					/* new ancester */						
						
						r->numSegNode++;
						n->before1 = m;
						m->before1 = NULL;
						m->before2 = NULL;
						m->after1 = n;
						m->after2 = NULL;
						m->sIndexNode = newInd;
						m->sIndex = actSegIndex;
						m->sStart = n->sStart;
						m->sEnd = n->sEnd;				
					
						actSegIndex++;
						b++;
						actNumSegments++;
						/*r->numSegNode++;*/
						if (m->sStart == 0 && m->sEnd == 0) /* unreal segments */
							{
							fprintf (fpmpi, "\nNot to be here. COAL2, segment start and end = 0");
							
							m->before1 = m->before2 = m->after1 = m->after2 = NULL;
							actNumSegments--;
							}
						}
					a = 0;
					}
				
				a = b = 0;
				free (coalVectorCountStarts);
				free (coalVectorCountEnds);
				

					/* Segment Bonds when this segment goes to 2 descendants segments */
				coalEqualSegInit_p = (int *) calloc((p->numSegNode+q->numSegNode),(long) sizeof(int));
				if (!coalEqualSegInit_p)
					{
					fprintf (fpmpi, "Could not allocate coalEqualSegInit_p (%lu bytes)\n", (p->numSegNode+q->numSegNode) *(long) sizeof(int));
					exit (-1);
					}
				coalEqualSegEnd_p = (int *) calloc((p->numSegNode+q->numSegNode),(long) sizeof(int));
				if (!coalEqualSegEnd_p)
					{
					fprintf (fpmpi, "Could not allocate coalEqualSegEnd_p (%lu bytes)\n", (p->numSegNode+q->numSegNode) *(long) sizeof(int));
					exit (-1);
					}
				coalEqualSegInit_q = (int *) calloc((p->numSegNode+q->numSegNode),(long) sizeof(int));
				if (!coalEqualSegInit_q)
					{
					fprintf (fpmpi, "Could not allocate coalEqualSegInit_q (%lu bytes)\n", (p->numSegNode+q->numSegNode) *(long) sizeof(int));
					exit (-1);
					}
				coalEqualSegEnd_q = (int *) calloc((p->numSegNode+q->numSegNode),(long) sizeof(int));
				if (!coalEqualSegEnd_q)
					{
					fprintf (fpmpi, "Could not allocate coalEqualSegEnd_q (%lu bytes)\n", (p->numSegNode+q->numSegNode) *(long) sizeof(int));
					exit (-1);
					}
				
				for (w = 0; w < p->numSegNode; w++)	
					{
					s = segments + post(w,p->index,distance);
					coalEqualSegInit_p[w] = s->sStart;
					coalEqualSegEnd_p[w] = s->sEnd;
					}
				for (w = 0; w < q->numSegNode; w++)	
					{
					n = segments + post(w,q->index,distance);
					coalEqualSegInit_q[w] = n->sStart;
					coalEqualSegEnd_q[w] = n->sEnd;
					}
				for (w = 0; w < p->numSegNode; w++)
					{
					for (i = 0; i < q->numSegNode; i++)
						{
						if (coalEqualSegInit_p[w] != 0 && coalEqualSegEnd_p[w] != 0 && coalEqualSegInit_p[w] == coalEqualSegInit_q[i] && coalEqualSegEnd_p[w] == coalEqualSegEnd_q[i])
							{
							for (a = 0; a < r->numSegNode; a++)	
								{
								m = segments + post(a,r->index,distance);
									
								if (m->sStart == coalEqualSegInit_p[w] && m->sEnd == coalEqualSegEnd_p[w])
									{
									if (noisy == 4)
										fprintf (fpmpi, "\nFragment %d links to 2 descendants, ", m->sIndex);
										
									for (b = 0; b < p->numSegNode; b++)
										{
										s = segments + post(b,p->index,distance);
												
										if (coalEqualSegInit_p[w] == s->sStart && coalEqualSegEnd_p[w] == s->sEnd)
											{
											m->after1 = s;
											if (noisy == 4)
												fprintf (fpmpi, "fragment %d", s->sIndex);
											}
										}
									for (b = 0; b < q->numSegNode; b++)
										{
										n = segments + post(b,q->index,distance);
										
										if (coalEqualSegInit_p[w] == n->sStart && coalEqualSegEnd_p[w] == n->sEnd)
											{
											m->after2 = n;
											if (noisy == 4)
												fprintf (fpmpi, " and fragment %d", n->sIndex);
											}
										}
									}
								}
							}
						}
					}
						
				
				for (i = 0; i < r->numSegNode; i++)			/* cheking, if there are 2 similar segments, it keeps only 1 */		
					{
					m = segments + post(i,r->index,distance);
				
					for (w = 0; w < r->numSegNode; w++)
						{
						z = segments + post(w,r->index,distance);
					
						if (w != i && m->sStart == z->sStart && m->sEnd == z->sEnd && m->after1 != NULL) /* Cheking */
							{
							fprintf (fpmpi, "\n1COAL. Not to be here. it does not to be 2 equal segments in this node %d. index %d y %d", m->sIndex, z->sIndex, r->index);
							fprintf (fpmpi, "\n m->sStart = %d, m->sEnd = %d, m->sIndexNode = %d", m->sStart, m->sEnd, m->sIndexNode);
							fprintf (fpmpi, "\n z->sStart = %d, z->sEnd = %d, z->sIndexNode = %d", z->sStart, z->sEnd, z->sIndexNode);
							
							fprintf (fpmpi, "\n post(i,r->index,distance) = %d", post(i,r->index,distance));
							fprintf (fpmpi, "\n post(w,r->index,distance) = %d", post(w,r->index,distance));
							fprintf (fpmpi, "\n r->index = %d", r->index);
								
							z->after1 = z->after2 = z->before1 = z->before2 = NULL; /* continue only the z segment */
							r->numSegNode--;
							exit(-1);
							}
						}
					}
				j = w = a = b = 0;
				free (coalEqualSegInit_p);
				free (coalEqualSegEnd_p);
				free (coalEqualSegInit_q);
				free (coalEqualSegEnd_q);
				
				
				if (noisy == 4)
					{
					fprintf (fpmpi, "\n\nCoalescence Result is the new node %d with %d fragment(s)", r->index, r->numSegNode);
					for (i = 0; i < r->numSegNode; i++)	
						{
						m = segments + post(i,r->index,distance);
						/*fprintf (fpmpi, "\npost(i,r->index,distance) = %d",post(i,r->index,distance));*/
						/*fprintf (fpmpi, "\nNode r->index = %d", r->index);*/
						fprintf (fpmpi, "\nFragment %d, ", m->sIndex);	
						fprintf (fpmpi, "m->sStart = %d", m->sStart);
						fprintf (fpmpi, " and m->sEnd = %d", m->sEnd);
						}
					fprintf (fpmpi, "\n");
					}
					
			
				/* MRCA */
				/* Array with the information about ancestral stuff */
				/* S_MRCA. overFirst is the biggest site by left & overEnd is the smallest site by right. The difference is the overLapSites */
				sizeNode_p = p->numSegNode;
				sizeNode_q = q->numSegNode;
				out = 0;
			
				if (r->numSegNode == 1) /* 1.- fast. Only 1 segment */
					{
					for (i = 0; i < r->numSegNode; i++)	
						m = segments + post(i,r->index,distance);
						
					overFirst = m->sStart;
					overEnd = m->sEnd;
				
					for (j = 1; j <= numNuc; j++)
						if (j >= overFirst && j <= overEnd)
							{
							S_MRCA[j]--;
							}
					out = 1;
					}
				a = b = k = 0;
			
				if (r->numSegNode > 1)	
					{
					initialVector_pp = (int *) calloc((p->numSegNode),(long) sizeof(int));
					if (!initialVector_pp)
						{
						fprintf (fpmpi, "Could not allocate initialVector_pp (%lu bytes)\n", (p->numSegNode) *(long) sizeof(int));
						exit (-1);
						}
					endVector_pp = (int *) calloc((p->numSegNode),(long) sizeof(int));
					if (!endVector_pp)
						{
						fprintf (fpmpi, "Could not allocate endVector_pp (%lu bytes)\n", (p->numSegNode) *(long) sizeof(int));
						exit (-1);
						}
					initialVector_qq = (int *) calloc((q->numSegNode),(long) sizeof(int));
					if (!initialVector_qq)
						{
						fprintf (fpmpi, "Could not allocate initialVector_qq (%lu bytes)\n", (q->numSegNode) *(long) sizeof(int));
						exit (-1);
						}
					endVector_qq = (int *) calloc((q->numSegNode),(long) sizeof(int));
					if (!endVector_qq)
						{
						fprintf (fpmpi, "Could not allocate endVector_qq (%lu bytes)\n", (q->numSegNode) *(long) sizeof(int));
						exit (-1);
						}
				
					/* 2.- Fast. There is a segment more big than the other segments */
					for (position = 0; position < p->numSegNode; position++)
						{
						s = segments + post(position,p->index,distance);
						initialVector_pp[position] = s->sStart;
						endVector_pp[position] = s->sEnd;
						}
					for (position = 0; position < q->numSegNode; position++)
						{
						n = segments + post(position,q->index,distance);
						initialVector_qq[position] = n->sStart;
						endVector_qq[position] = n->sEnd;
						}
					
					/* smaller value for the initial */
					for (position = 0; position < p->numSegNode; position++)
						{
						if (position == 0)
							minInit_pp = initialVector_pp[position];
						if (initialVector_pp[position] < minInit_pp && initialVector_pp[position] != 0)
							minInit_pp = initialVector_pp[position];
						}

					/* older value for the end */
					for (position = 0; position < p->numSegNode; position++)
						{
						if (position == 0)
							maxEnd_pp = endVector_pp[position];
						if (endVector_pp[position] > maxEnd_pp && endVector_pp[position] != 0)
							maxEnd_pp = endVector_pp[position];
						}
		
					/* smaller value for the initial */
					for (position = 0; position < q->numSegNode; position++)
						{
						if (position == 0)
							minInit_qq = initialVector_qq[position];
				
						if (initialVector_qq[position] < minInit_qq && initialVector_qq[position] != 0)
							minInit_qq = initialVector_qq[position];
						}

					/* older value for the end */
					for (position = 0; position < q->numSegNode; position++)
						{
						if (position == 0)
							maxEnd_qq = endVector_qq[position];
	
						if (endVector_qq[position] > maxEnd_qq && endVector_qq[position] != 0)
							maxEnd_qq = endVector_qq[position];
						}
			
					/* fast, there are in 1 big segment that contains all the segments */					
					for (position = 0; position < p->numSegNode; position++) 
						{
						if (endVector_pp[position] == maxEnd_pp && initialVector_pp[position] == minInit_pp)	
							a = 1;
						}
					for (position = 0; position < q->numSegNode; position++) 
						{
						if (endVector_qq[position] == maxEnd_qq && initialVector_qq[position] == minInit_qq)	
							b = 1;
						}
				
					free (initialVector_pp);
					free (endVector_pp);
					free (initialVector_qq);
					free (endVector_qq);
				
				
					/* 2.- Fast with a big segment */
					if (minInit_pp <= minInit_qq && maxEnd_pp >= maxEnd_qq && a == 1 && b == 1)
						{
						for (j = 1; j <= numNuc; j++)
							{
							if (j >= minInit_qq && j <= maxEnd_qq)
								{
								S_MRCA[j]--;
								}
							}
						a = out = 1;	
						}
					if (minInit_qq <= minInit_pp && maxEnd_qq >= maxEnd_pp && a == 1 && b == 1 && out == 0)
						{
						for (j = 1; j <= numNuc; j++)
							{
							if (j >= minInit_pp && j <= maxEnd_pp)
								{
								S_MRCA[j]--;
								}
							}
						a = out = 1;	
						}
					
					/* 3.- Fast, noncoincident nodes. Ex: Coalescence from 2 nodes which come from of the same recombination. MRCA variation = 0 */
					if (maxEnd_pp < minInit_qq && out == 0)
						{
						/*fprintf (fpmpi, "happened for MRCA, MRCA does not change");*/;
						
						a = out = 1;
						}
					if (maxEnd_qq < minInit_pp && out == 0)
						{
						/*fprintf (fpmpi, "happened for MRCA, MRCA does not change");*/;
						
						a = out = 1;
						}
					
					if (minInit_pp < minInit_qq && maxEnd_pp < maxEnd_qq && a == 1 && b == 1 && out == 0)
						{
						for (j = 1; j <= numNuc; j++)
							{
							if (j >= minInit_qq && j <= maxEnd_pp)
								{
								S_MRCA[j]--;
								}
							}
						a = out = 1;
						}
						
					if (minInit_qq < minInit_pp && maxEnd_qq < maxEnd_pp && a == 1 && b == 1 && out == 0)
						{
						for (j = 1; j <= numNuc; j++)
							{
							if (j >= minInit_pp && j <= maxEnd_qq)
								{
								S_MRCA[j]--;
								}
							}
						a = out = 1;
						}
					
					a = b = k = w = i = 0;
				
					/* 3.- complex case */
					if (out == 0)
						{
						for (j = 1; j <= numNuc; j++)
							{
							if (overLapSegmentsCoalMRCA(p, q, sizeNode_p, sizeNode_q, j) == YES)
								{
								S_MRCA[j]--;
								}
							}
						}
					}
				j = 0;
		


				/* Folllowing only ancestral material */
				for (mmm = 1; mmm <= numNuc; mmm++)	 /* Only anc material*/
					{
					if (p->SitesNonAncHere[mmm] == 0 && q->SitesNonAncHere[mmm] == 0)
						{
						/*fprintf (fpmpi, "\n This Position %d is ANC mat: p->index = %d, p->SitesNonAncHere = %d, q->index = %d, q->SitesNonAncHere = %d \n", mmm, p->index, p->SitesNonAncHere[mmm], q->index, q->SitesNonAncHere[mmm]);*/
						OnlyAncS_MRCA[mmm]--;
						}				
					}
				/* Is this the GMRCA of the anc material? */
				Ok_SMRCA_Codon = 0;
				for (mmm = 1; mmm <= numNuc; mmm++)	 /* Only anc material*/
					{
					if (OnlyAncS_MRCA[mmm] == 1)
						{
						/*fprintf (fpmpi, "\n-- Yes anc GMRCA position %d -- \n", mmm);*/
						Ok_SMRCA_Codon++;
						}
					}			
				if (Ok_SMRCA_Codon == numNuc && AncGMRCA_obtained == NO)
					{
					r->GMRCA_ancestral = YES;
					AncGMRCA_obtained = YES;
					if (noisy == 4)
						fprintf (fpmpi, "\n--GMRCA of the ancestral material in node %d-- \n", r->index);
					}




				/* in coalescence is possible link the nodes */
				r->left = p;
				r->right = q;
				p->anc1 = r;
				q->anc1 = r;
				r->time = currentTime;
				/*fprintf (fpmpi, " r->index = %d, r->time = %lf\n", r->index, r->time);*/
													
				/* readjust active nodes */
				activeGametes[firstInd] = newInd;
				activeGametes[secondInd] = activeGametes[numActiveGametes-1];
				numActiveGametes--; /* it lose 1 active node */
				nextAvailable++; /* 1 node more to available */
				numParcialActiveGametes[whichDeme] = numParcialActiveGametes[whichDeme]-1;
			
			
				if (nextAvailable >= numNodes)	/* if there aren't enough nodes it go into and it addition more */
					{
					/* ReallocNodes(&numNodes, activeGametes); */
					numNodes += INCREMENT_NODES;
					numTotalSegments += (INCREMENT_NODES*maxSegNode)+numNuc;
					
					/* REALLOC */
					segments = (TreeSegment *) realloc (segments, numTotalSegments  * (long) sizeof(TreeSegment));
					if (!segments)
						{
						fprintf (fpmpi, "Could not reallocate segments (%lu bytes)\n", ((numNodes*distance)+numNuc)  * (long) sizeof(TreeSegment));
						exit (1);
						}
					nodes = (TreeNode *) realloc (nodes, numNodes  * (long) sizeof(TreeNode));
					if (!nodes)
						{
						fprintf (fpmpi, "Could not reallocate nodes (%lu bytes)\n", numNodes  * (long) sizeof(TreeNode));
						exit (-1);
						}
					activeGametes = (int *) realloc (activeGametes, numNodes *(long) sizeof(int));
					if (!activeGametes)
						{
						fprintf (fpmpi, "Could not reallocate activeGametes (%lu bytes)\n", numNodes *(long) sizeof(int));
						exit (-1);
						}
					if (noisy == 4)
						fprintf (fpmpi, "\n\n...Doing reallocation of nodes (1)\n");
					}
				}	/* end of coalescence */
				

			/*** Special event of CONVERGENCIE OF DEMES ***/
			if (doConvNext == YES)
				{
				j = 0;
				doConvNext = NO;		

				currentBigDeme++;
				currentDemesNumber--;

				if (noisy > 1)
					{
					fprintf (fpmpi, "Convergence of demes %d and %d", deme_a[nextConvNumber], deme_b[nextConvNumber]);
					fprintf (fpmpi, " to deme %d", currentBigDeme+numPopulations);
					}
				
				if (doMigrationIslCont == YES) /* this is just for the migration model of continent-island */
					{
					if (deme_a[nextConvNumber] == OkValueCI || deme_b[nextConvNumber] == OkValueCI)
						{
						OkValueCI = currentBigDeme+numPopulations;
						newOkValueCI++;
						}
					}


				CurrentDemesState[deme_a[nextConvNumber]] = CurrentDemesState[deme_b[nextConvNumber]] = 0;
				CurrentDemesState[currentBigDeme+numPopulations] = currentBigDeme+numPopulations;
									
				for (d = 0; d < numActiveGametes; d++)
					{
					p = nodes + activeGametes[d];
					
					if (p->indexCurrentMigPop == deme_a[nextConvNumber])
						{
						p->indexCurrentMigPop = currentBigDeme+numPopulations;
						numParcialActiveGametes[currentBigDeme+numPopulations]++;
						numParcialActiveGametes[deme_a[nextConvNumber]]--;
						}
						
					if (p->indexCurrentMigPop == deme_b[nextConvNumber])
						{
						p->indexCurrentMigPop = currentBigDeme+numPopulations;
						numParcialActiveGametes[currentBigDeme+numPopulations]++;
						numParcialActiveGametes[deme_b[nextConvNumber]]--;
						}
					}

				/* when the tip node has a time higher than convergence demes, its initial deme must be the deme of the convergence demes */
				/*if (doDatedTips == YES) 
					{
					for (ss = 0; ss < numSequences; ss++)		
						{
						p = nodes + ss;
						if (p->time >= currentTime)
							{
							if (p->indexOldMigPop == deme_a[nextConvNumber] || p->indexOldMigPop == deme_b[nextConvNumber])
								{
								if (noisy > 2)
									fprintf (fpmpi, "\nInitial node %d that belongs to the deme %d, is belonging now to the deme ", p->index, p->indexOldMigPop);
								p->indexOldMigPop = currentBigDeme+numPopulations;
								p->indexCurrentMigPop = currentBigDeme+numPopulations;
								if (noisy > 2)
									fprintf (fpmpi, "%d by a convergence of demes", p->indexOldMigPop);
								}
							}
						}
					if (noisy > 2)
						fprintf (fpmpi, "\n");
					}*/


				if (noisy > 3)
					fprintf (fpmpi,"\n");
				}	


			/* print out ancestral (active) status for each site and MRCA vector - only mat anc */
			if (noisy > 2)
				{
				fprintf (fpmpi,"\n - Ancestral MRCA in the nodes: -\n");
				for (i=0; i<numActiveGametes; i++)
					{
					for (j=1; j<=numNuc; j++)
						{
						p = nodes + activeGametes[i];
						if (j == 1)
							fprintf (fpmpi, "%4d -- (MRCA:)", p->index);
						fprintf (fpmpi, "%d", OnlyAncS_MRCA[j]);
						}
					fprintf (fpmpi, "\n");
					}
				/*fprintf (fpmpi, "MRCA   ");*/
				for (j=1; j<=numNuc; j++)
					{
					if (OnlyAncS_MRCA[j] <= 1)
						fprintf (fpmpi, "*");
					else
						fprintf (fpmpi, " ");
					}
				/*fprintf (fpmpi, "\n");*/
				fprintf (fpmpi,"\n\n");

				}



			/* print out ancestral (active) status for each site and MRCA vector */
			if (noisy > 2)
				{
				fprintf (fpmpi,"\nMRCA in the nodes:\n");
				for (i=0; i<numActiveGametes; i++)
					{
					for (j=1; j<=numNuc; j++)
						{
						p = nodes + activeGametes[i];
						/*p = nodes + pos(activeGametes[i],j,numNuc);*/
						if (j == 1)
							fprintf (fpmpi, "%4d -- (MRCA:)", p->index);
						fprintf (fpmpi, "%d", S_MRCA[j]);
						}
					fprintf (fpmpi, "\n");
					}
				/*fprintf (fpmpi, "MRCA   ");*/
				for (j=1; j<=numNuc; j++)
					{
					if (S_MRCA[j] /* MRCA[j]*/ <= 1)
						fprintf (fpmpi, "*");
					else
						fprintf (fpmpi, " ");
					}
				/*fprintf (fpmpi, "\n");*/
				}
			

			if (noisy > 2) /* hotspots recombination */
				{
				if (doBlockRecombination == YES)
					{
					fprintf (stderr, "Hotspot ");
					i = 0;
					for (j=1; j<=numNuc; j++)
						{
						if (hotspot[i] == j)
							{
							fprintf (stderr, "+");
							i++;
							}
						else
							fprintf (stderr, " ");
						}
					fprintf (stderr, "\n");
					}
				}


			sizeNode = sizeNode_p = sizeNode_q = 0;
			free (gi);



			/* If doing dated tips, sometimes the number of actives nodes can be already 1 before all have been activated samples. 
			If this happens we need to move towards the next sample, activate it, and start again */
			if (doDatedTips == YES)
			 if (numActiveGametes == 1 && currentSample > 0)
				{
				if (noisy > 2)
					fprintf (stderr, "\n\nOnly 1 lineage active before activating all samples"/*, currentSample*/);
				currentSample--;

				/* activate nodes from this sample*/
				if (noisy > 2)
					fprintf (stderr, "\n Activating sample %d (time = %6.4f). Tips to activate:", currentSample, datedSample[currentSample].time);
				for (i=0; i<datedSample[currentSample].size; i++)
					{
					if (noisy > 2)
						fprintf (stderr, " %d", datedSample[currentSample].member[i]-1);
					
					p = nodes + datedSample[currentSample].member[i]-1;
					p->index = datedSample[currentSample].member[i]-1;
					activeGametes[numActiveGametes] = datedSample[currentSample].member[i]-1; 

					for (ss = 1; ss <= numPopulations /*+ numCONV*/; ss++) 
						{
						if (p->indexOldMigPop == ss)
							{
							numParcialActiveGametes[ss]++;
							/*fprintf (stderr, "\n AQUI numParcialActiveGametes[%d] = %d \n", ss, numParcialActiveGametes[ss]); */
							}
						} 
						
					numActiveGametes++;
					}
				currentTime = datedSample[currentSample].time;
	
				if (noisy > 2)
					{
					fprintf (stderr, "\nActive nodes (%d):", numActiveGametes); 
					for (i=0; i<numActiveGametes; i++)
						fprintf (stderr," %d",activeGametes[i]);
					fprintf (stderr,"   Next node available = %d ", nextAvailable);
					fprintf (stderr, "\nSetting currentTime = %6.4f", currentTime);
					}
				}
			} /***** coalescent tree finished *****/


		for (w = 1; w <= numNuc; w++)
			{
			if (S_MRCA[w] > 1 || S_MRCA[w] < 1)
				{
				fprintf (fpmpi, "\n Warning S_MRCA in the last node is < > 1, S_MRCA[%d] = %d", w, S_MRCA[w]);
				exit (-1);
				}
			}

		if (noisy > 1)
			fprintf (fpmpi, "\n\n\n>> Coalescent tree/s finished\n");
			
			
		counterTimeInit = counterTimeInit + currentTime;
		actualTGMRCA = currentTime;
		
			/* free memory of migrations */			
		free (rateREpartial);
		free (rateCApartial);
		free (rateMIGpartial);
		free (ratePartial);
		free (cumPopulTase);
		free (cumInitPopul);
		free (numParcialActiveGametes);
		free (GiPartial);
		if (doConvergDemes == YES)
			{
			free (currentConvDem);
			free (convDemTimes);
			free (deme_a);
			free (deme_b);
			free (CurrentDemesState);
			}
		/* Use to see the evolution nodes-segments */
		/*#ifdef MPI
			{
			fprintf (fpmpi, "\n\n\nnextAvailable = %d",nextAvailable);
			for (j = 0; j < numNodes; j++)*/	/* looking for parent Node of segments */	
			/*	{
				p = nodes + j;
				fprintf (fpmpi, "\n\n\n\n**The node %d**",p->index);

				for (i=0; i < p->numSegNode; i++)
					{
					s = segments + post(i,j,numNuc);	
					p->seg = s;
			
					fprintf (fpmpi, "\n\ns->sIndex %d con s->parentNode->index = %d", s->sIndex, s->parentNode->index);
					if (s->after1 != NULL)
						fprintf (fpmpi, "\ns->after1->sIndex %d con s->after1->parentNode->index = %d", s->after1->sIndex, s->after1->parentNode->index);
					if (s->after2 != NULL)
						fprintf (fpmpi, "\ns->after2->sIndex %d con s->after2->parentNode->index = %d", s->after2->sIndex, s->after2->parentNode->index);
					}
				}
			}
		*/
		}
	
	if (doMigration == NO) /* Coalescence without migration */
		{		
		eventNum = 0;		
		currentTime = 0.0;
		period = 1;

		while (numActiveGametes > 1)
			{
			/*fprintf (fpmpi,"\nMMM >>>>> NEW EVENT. numActiveGametes = %d", numActiveGametes);*/

			/* NEW MIGUEL Feb 2012 */
			Gi = 0.00;
			/* allocate memory for each node gi */
			gi = (double *) calloc(numActiveGametes, sizeof(double));
				if (!gi)
				{
				/*fprintf (stderr, "Could not allocate gi (%lu)\n", numActiveGametes * sizeof(double));*/
				fprintf (stderr, "Could not allocate gi \n");
				exit (-1);
				}


			/* calculate gi for each node and total Gi */	
			/* Gi is the total number of ancestral sites, gi is a vector with ancestral and not found MRCA sites */
			/* NEW MIGUEL Feb 2011 */
			Gi = 0.0;
			for (i = 0; i < numActiveGametes; i++)
				{
				p = nodes + activeGametes[i];
				sizeNode = p->numSegNode;

				gi[i] = 0.0;
				cuantos = 0;

				for (j=1; j<=numNuc; j++)
					{

					if	(IsValidBreakSite (activeGametes, nodes, i, j, S_MRCA) == YES) /*if	(IsValidBreakSite (activeGametes, nodes, whichInd, whichSite, S_MRCA) == YES) */
						{
						cuantos++;
						gi[i] += gammaRec[j];
						/* fprintf (fpmpi,"\n Site %d, gammaRec[j] = %3.10f, gi[i] = %3.10f", j, gammaRec[j], gi[i]); */
						}
					}
				Gi += gi[i]; 

				/* fprintf (fpmpi,"\nA. Gamete %d (%d), GameteGi = %d, gi = %3.10f, cuantos = %d", i, p->index, GameteGi, gi[i], cuantos); */
				}	

			if (noisy == 4)
				fprintf (fpmpi," Gi = %lf ", Gi); /* This Gi is small because the gamma distribution.. But then for the rates we do not multiply by recRate.. */
			/*fprintf (fpmpi,"\nMMM Gi = %lf, Nscaling = %d, N = %d, recombinationRate = %lf ", Gi, Nscaling, N, recombinationRate);*/	

			/* calculate gi for each node and total Gi */	
			/* Gi is the total number of ancestral sites, gi is a vector with ancestral and not found MRCA sites */
			/* This section does not work because breakp with MRCA=1 are incorrectly considered between gBegin and giEnd  */
			/*Gi = 0.0;
			for (i = 0; i < numActiveGametes; i++)
				{
				p = nodes + activeGametes[i];
				sizeNode = p->numSegNode;
				CalcIndividualGi_HotSpots (i, nodes, activeGametes, numNuc, S_MRCA, sizeNode);
				gi[i] = 0.0;

				for (j=1; j<=numNuc; j++) 
					{
					if (j >= giBegin && j <= giEnd)
						{
						gi[i] += gammaRec[j];
						}
					}
				Gi += gi[i]; 

				}	

			if (noisy == 4)
				fprintf (fpmpi," Gi = %lf ", Gi); */ /* This Gi is small because the gamma distribution.. But then for the rates we do not multiply by recRate.. */
			


			/* get rates for events */  
			rateRE = 1.0 * Gi * Nscaling * N;        /* recombinationRate is constant */
			rateCA = numActiveGametes * (numActiveGametes - 1) / 2.0;
			rate = rateCA + rateRE;
			
			/*fprintf (fpmpi,"\nnumActiveGametes = %d", numActiveGametes);
			fprintf (fpmpi,"\nrateRE = %3.2f, rateCA = %3.2f, rate = %3.2f \n", rateRE, rateCA, rate);*/


			/* find out time for coalescence */
			if (doDemographics == YES)
				{
				periodGrowth[period] = -log (Nend[period] / (double) Nbegin[period]) / (double) (cumDuration[period] - cumDuration[period-1]);
				/*fprintf (fpmpi, "\n>>>>1 period growth  = %f (period = %d)", periodGrowth[period], period);*/
				if (isnan(periodGrowth[period]) == YES)
					{
					fprintf (fpmpi, "\nERROR: period growth (%f) is NaN", periodGrowth[period]);
					fprintf (fpmpi, "\n      This might suggest that the growth rate is too negative");
					fprintf (fpmpi, "\n      and the coalescent time is therefore infinite.");
					fprintf (fpmpi, "\n      Try a smaller value");
					exit (1);
					}

				if (Nend[period] == Nbegin[period])
					{
					timeCA = RandomExponential (rateCA, seed) * Nscaling * (double) Nbegin[period];
					}
				else
					{
					timeCA = log (1 + RandomExponential (rateCA, seed) * periodGrowth[period] * Nscaling * Nbegin[period] * 
							exp (-periodGrowth[period] * (currentTime - cumDuration[period-1]))) / periodGrowth[period];
					}

				/*	When growth rate is very negative, coalescent time may be infinite
					this results in log (-x) => timCA = NaN. If this not the last period
					just jump to the next. If this is the last period, we have to exit
					the program */
				if (isnan(timeCA) == YES)
					{
					if (period < numPeriods) 
						{
						currentTime = cumDuration[period];
						period++;
						periodGrowth[period] = -log (Nend[period] / (double) Nbegin[period]) / (double) (cumDuration[period] - cumDuration[period-1]);
						continue;
						}	
					else
						{				
						fprintf (fpmpi, "\nERROR: Coalescent time (%f) is infinite ", timeCA);
						fprintf (fpmpi, "\n      This might suggest that the growth rate is too negative");
						fprintf (fpmpi, "\n      and the coalescent time is therefore infinite.");
						fprintf (fpmpi, "\n      Try a smaller value");
						exit (1);
						}
					}
				}
			else
				{
				timeCA = RandomExponential (rateCA, seed) * Nscaling * N;
				if (doExponential == YES)
					{
					timeCA = log (exp(growthRate*currentTime) + growthRate * timeCA) / growthRate - currentTime;
		
					/*	When growth rate is very negative, coalescent time may be infinite
						this results in log (-x) => timeCA = NaN. We have to exit
						the program */
					if (isnan(timeCA) == YES)
						{
						fprintf (fpmpi, "\nERROR: Coalescent time (%f) is infinite ", timeCA);
						fprintf (fpmpi, "\n      This might suggest that the growth rate is too negative");
						fprintf (fpmpi, "\n      and the coalescent time is therefore infinite.");
						fprintf (fpmpi, "\n      Try a smaller value");			
						exit (1);
						}
					}
				}

			/* find out time for recombination */
			timeRE = RandomExponential (rateRE, seed) * Nscaling * N;


			if (doDatedTips == YES)
				{
				if (timeCA < timeRE)
					{
					eventTime = timeCA;
					isCoalescence = YES;	
					}
				else
					{
					eventTime = timeRE;
					isCoalescence = NO;	
					}


				/* if doing dated tips, check whether we need to activate a new sample, update sampling period and start again */
				if ((currentTime + eventTime) > datedSample[currentSample-1].time && currentSample > 0)
					{
					currentSample--;
					/* activate nodes from this sample */
					if (noisy > 2)
						fprintf (stderr, "\nCumulative time = %6.4f  > sample %d time = %6.4f. Activating tips:", currentTime + eventTime, currentSample, datedSample[currentSample].time);
					
					for (i=0; i<datedSample[currentSample].size; i++)
						{
						if (noisy > 2)
							fprintf (stderr, " %d", datedSample[currentSample].member[i]-1);

						p = nodes + datedSample[currentSample].member[i]-1;
						p->index = datedSample[currentSample].member[i]-1;
						activeGametes[numActiveGametes] = datedSample[currentSample].member[i]-1;  

						numActiveGametes++;
						}
					currentTime = datedSample[currentSample].time;

					if (noisy > 2)
						{
						fprintf (stderr, "\nActive nodes (%d):", numActiveGametes); 
						for (i=0; i<numActiveGametes; i++)
							fprintf (stderr," %d",activeGametes[i]);
						fprintf (stderr,"\nNext node available = %d", nextAvailable);
						fprintf (stderr, "\nSample %d activated and going back to currentTime = %6.4f", currentSample, currentTime);
						}
					continue; /* start again*/
					}

				/* event is a coalescence or a recombination? */
				if (isCoalescence == YES)
					{
					/*	if this period is not the last one and if the event time is outside the current interval,
						update period and start again */
					if (doDemographics == YES && period < numPeriods && (currentTime + eventTime) > cumDuration[period])
						{
						currentTime = cumDuration[period];
						period++;
						periodGrowth[period] = -log (Nend[period] / (double) Nbegin[period]) / (double) (cumDuration[period] - cumDuration[period-1]);
						continue;
						}	
			
					numCA++;
					}
				else
					{
					/*	if this period is not the last one and if the event time is outside the current interval,
						update period and start again */
					if (doDemographics == YES && period < numPeriods && (currentTime + eventTime) > cumDuration[period])
						{
						currentTime = cumDuration[period];
						period++;
						periodGrowth[period] = -log (Nend[period] / (double) Nbegin[period]) / (double) (cumDuration[period] - cumDuration[period-1]);
						continue;
						}	
					numRE++;
					/* reallocate for recombination breakpoints */
					if (numRE >= (memoryBreakp-1))
						{
						memoryBreakp += 50;
					 
						breakpoint = (int *) realloc(breakpoint, memoryBreakp *(long) sizeof(int));
						if (!breakpoint)
							{
							fprintf (fpmpi, "Could not reallocate breakpoint \n");
							exit (-1);
							}
						if (noisy == 4)
							fprintf (fpmpi, "\n...Doing reallocation of breakponts (1)\n");
						}
					if (numRE > (numNuc+1) && many == 0)
						{
						if (noisy > 2)
							fprintf (fpmpi, "\n\n Cheking information: Many recombinations %d (more recombinations that sites)\n", numRE);
						
						many++;
						}
					}
				}
			else /* not tip dates */
				{
				/* event is a coalescence or a recombination? */
				if (timeCA < timeRE)
					{
					isCoalescence = YES;
					eventTime = timeCA;
					/*	if this period is not the last one and if the event time is outside the current interval,
						update period and start again */
					if (doDemographics == YES && period < numPeriods && (currentTime + eventTime) > cumDuration[period])
						{
						currentTime = cumDuration[period];
						period++;
						periodGrowth[period] = -log (Nend[period] / (double) Nbegin[period]) / (double) (cumDuration[period] - cumDuration[period-1]);
						continue;
						}	
			
					numCA++;


					}
				else
					{
					isCoalescence = NO;
					eventTime = timeRE;	
					/*	if this period is not the last one and if the event time is outside the current interval,
						update period and start again */
					if (doDemographics == YES && period < numPeriods && (currentTime + eventTime) > cumDuration[period])
						{
						currentTime = cumDuration[period];
						period++;
						periodGrowth[period] = -log (Nend[period] / (double) Nbegin[period]) / (double) (cumDuration[period] - cumDuration[period-1]);
						continue;
						}	
					numRE++;


					/* reallocate for recombination breakpoints */
					if (numRE >= (memoryBreakp-1))
						{
						memoryBreakp += 50;
					 
						breakpoint = (int *) realloc(breakpoint, memoryBreakp *(long) sizeof(int));
						if (!breakpoint)
							{
							fprintf (fpmpi, "Could not reallocate breakpoint \n");
							exit (-1);
							}
						if (noisy == 4)
							fprintf (fpmpi, "\n...Doing reallocation of breakponts (1)\n");
						}
					if (numRE > (numNuc+1) && many == 0)
						{
						if (noisy > 2)
							fprintf (fpmpi, "\n\n Cheking information: Many recombinations %d (more recombinations that sites)\n", numRE);
						
						many++;
						}
					}

				}
			/*fprintf (fpmpi,"\ntimeCA = %3.2f, timeRE = %3.2f \n", timeCA, timeRE);*/




				
			/* set time */
			currentTime += eventTime; /* the time is accumulated */

			if (noisy > 3)
				fprintf(fpmpi, "\n\n");
				
			eventNum++;
			if (noisy > 1)
				fprintf (fpmpi, "\n\n*** Event %3d *** rate = %lf, currentTime = %lf\n", eventNum, rate, currentTime);
				
				
		
			/*** if RECOMBINATION, readjust active nodes ***/
			if (isCoalescence == NO)
				{
				if (noisy == 4)
					fprintf (fpmpi, "\n* Recombination *");
					
				/* Which node has the recombination? */
					/* assign probability to each node based on their gi's values */
				cum_gi = 0;
				probRecIndividual = Gi * RandomUniform(seed); /* it calculate the individual probability for the breakpoint */
				for (whichInd=0; whichInd<numActiveGametes; whichInd++)
					{
					cum_gi += gi[whichInd];				/* accumulate gi into cum_gi. whichInd is the choose node. */
					if (probRecIndividual < cum_gi)    /* break whether the node is chosen */
						break;
					}
			
				if (whichInd >= numActiveGametes)
					{
					fprintf (fpmpi, "\n\nERROR: whichInd out of range3!: whichInd = %d\n", whichInd);
					exit (-1);
					}
			


				/* (7) Choose whichSite based on gammma[j] */
				/* select a valid breakpoint among potential recombining locations */
				/* to be a potential recombining site, a site has to have ancestral material non-MRCA before and after it */
				cum_gammaRec = 0.0;
				RdValue = RandomUniform(seed);
				probRecSite = gi[whichInd] * RdValue;
				/*fprintf (fpmpi, "\n\n-> whichInd = %d, gi[%d] = %3.10f, RdValue = %3.10f, probRecSite = %3.10f \n", whichInd, whichInd, gi[whichInd], RdValue, probRecSite);*/

				cuantos = 0;
				for (j=1; j<=numNuc; j++)
					{
					whichSite = j;

					if	(IsValidBreakSite (activeGametes, nodes, whichInd, whichSite, S_MRCA) == YES)
						{
						cuantos++;
						cum_gammaRec += gammaRec[whichSite];
						/* fprintf (fpmpi, "\n Sum %d -> cum_gammaRec=%3.10f, gammaRec[whichSite]=%3.10f", whichSite, cum_gammaRec, gammaRec[whichSite]); */

						if (cum_gammaRec >= probRecSite)
							{
							/*fprintf (fpmpi, "\n OK %d", whichSite);*/
							break;
							}
						}
					
					}
				/*fprintf (fpmpi, "\n site = %d, probRecSite = %lf, cum_gammaRec = %lf, cuantos = %d \n\n", whichSite, probRecSite, cum_gammaRec, cuantos);*/

				if (whichSite > numNuc || whichSite <= 0)
					{
					fprintf (stderr, "\n\nERROR: whichSite (%d) out of range!\n", whichSite);
					exit (-1);
					}


				/*legalBreakpoint = NO;
				while (legalBreakpoint == NO)
					{
					do 
						{
						whichSite = (numNuc) * RandomUniform(seed); 
						if (whichSite == 1)
							whichSite = numNuc;
						} while (whichSite == 0);


					if (whichSite > numNuc)
						{
						fprintf (fpmpi, "\n\nERROR: whichSite out of range! : whichSite = %d\n", whichSite);
						exit (-1);
						}
					p = nodes + activeGametes[whichInd];
					sizeNode = p->numSegNode;
					if	(IsValidBreakSite (activeGametes, nodes, whichInd, whichSite, S_MRCA) == YES)
						legalBreakpoint = YES;
					}*/
				
				/* should this recombination event be counted in the expected number of recombinations E(R)? */
				/* for E(R) count only events with breakpoints as 1|1, 1|0 or 0|1  (i.e., not 0|0)         */
				/* if 1 represent a site that did found already its MRCA count it as a 0 */
				ThisBreakpIsTrapped = NO;
				if (doCountsForExpNumRec == YES)
					{
					p = nodes + activeGametes[whichInd];
					sizeNode = p->numSegNode;	
					if (CountsForExpNumRec (activeGametes, whichInd, whichSite, nodes, S_MRCA, sizeNode) == NO)
						{
						recNotToCount++;
						ThisBreakpIsTrapped = YES;
						/*fprintf(stderr,"\n ..not to count.. \n");*/
						}
					}
				/* copy whichIndividual to a new space in memory */
				hasPassedBreakPoint = NO;
			
				firstHalf = nextAvailable++; /* firstHalf is the first node that was created by the recombination */
				if (nextAvailable >= numNodes) /* if there aren't enough nodes it go into and it addition more */
					{
					/* ReallocNodes(&numNodes, activeGametes); */
					numNodes += INCREMENT_NODES;
					numTotalSegments += (INCREMENT_NODES*maxSegNode)+numNuc;
					
					/* REALLOC */
					segments = (TreeSegment *) realloc (segments, numTotalSegments  * (long) sizeof(TreeSegment)); 
					if (!segments)
						{
						fprintf (fpmpi, "Could not reallocate segments (%lu bytes)\n", ((numNodes*distance)+numNuc)  * (long) sizeof(TreeSegment));
						exit (1);
						}
					nodes = (TreeNode *) realloc (nodes, numNodes  * (long) sizeof(TreeNode));
					if (!nodes)
						{
						fprintf (fpmpi, "Could not reallocate nodes (%lu bytes)\n", numNodes  * (long) sizeof(TreeNode));
						exit (-1);
						}
					activeGametes = (int *) realloc (activeGametes, numNodes *(long) sizeof(int));
					if (!activeGametes)
						{
						fprintf (fpmpi, "Could not reallocate activeGametes (%lu bytes)\n",numNodes *(long) sizeof(int));
						exit (-1);
						}
					if (noisy == 4)
						fprintf (fpmpi, "\n\n...Doing reallocation of nodes (1)\n");
					}
									
				secondHalf = nextAvailable++; /* secondhalf is the second node that was created by the recombination */
				if (nextAvailable >= numNodes) /* if there aren't enough nodes it go into and it addition more */
					{
					/* ReallocNodes(&numNodes, activeGametes); */
					numNodes += INCREMENT_NODES;
					numTotalSegments += (INCREMENT_NODES*maxSegNode)+numNuc;
					
					/* REALLOC */
					segments = (TreeSegment *) realloc (segments, numTotalSegments  * (long) sizeof(TreeSegment)); 
					if (!segments)
						{
						fprintf (fpmpi, "Could not reallocate segments (%lu bytes)\n", ((numNodes*distance)+numNuc)  * (long) sizeof(TreeSegment));
						exit (1);
						}
					nodes = (TreeNode *) realloc (nodes, numNodes  * (long) sizeof(TreeNode));
					if (!nodes)
						{
						fprintf (fpmpi, "Could not reallocate nodes (%lu bytes)\n", numNodes  * (long) sizeof(TreeNode));
						exit (-1);
						}
					activeGametes = (int *) realloc (activeGametes, numNodes *(long) sizeof(int));
					if (!activeGametes)
						{
						fprintf (fpmpi, "Could not reallocate activeGametes (%lu bytes)\n", numNodes *(long) sizeof(int));
						exit (-1);
						}
					if (noisy == 4)
						fprintf (fpmpi, "\n\n...Doing reallocation of nodes (1)\n");
					}
				p = nodes + activeGametes[whichInd];
				q = nodes + firstHalf;	/* parent1 (new) */
				r = nodes + secondHalf; /* parent2 (new) */
			
				q->index = firstHalf;
				r->index = secondHalf;
				q->numSegNode = r->numSegNode = p->numSegNode;		/* Good if there are not nill segments.. then, in its case, it will be modify */
			


				q->class = 3;
				r->class = 3;
				q->GMRCA_ancestral = NO;
				r->GMRCA_ancestral = NO;
				q->breakp = whichSite;		
				r->breakp = whichSite;			
				q->time = currentTime;
				r->time = currentTime;
				q->sib = r;
				r->sib = q;
				q->left = p;
				r->left = p;
				p->anc1 = q;
				p->anc2 = r;
				
				if (doBranchNetfiles == YES)
					{
					q->NetLabelPrint = numNetLabelPrint;
					/*numNetLabelPrint++;*/
					r->NetLabelPrint = numNetLabelPrint;
					numNetLabelPrint++;
					}


				k = 0;
				for (w = 1; w < numSites; w++)
					{
					//fprintf (fpmpi, "\nstud[%d] = %d", w-1, stud[w-1]);
					if (whichSite == stud[w-1]) /* The breakpoints BETWEEN codons. "stud" is an array with the possible breakpoints beetween codons*/
						k++;

					/* exception for trapped material, any breakpoint here does not break material codons */
					if (ThisBreakpIsTrapped == YES)
						{
						k++;
						/*fprintf (fpmpi, "\n ThisBreakpIsTrapped, whichSite = %d, p->index = %d \n", whichSite, p->index);*/
						}
					}

				doBreakpBroken = NO;
				if (k == 0)
					{
					if (noisy == 4)
						{
						fprintf (fpmpi, "\n Broken codon, breakpoint at %d \n", whichSite);
						}
					//q->breakCodon = YES;
					//r->breakCodon = YES;
					variable1 = whichSite/3.00 + 0.4;
					//fprintf (fpmpi, "\n variable1 = %lf", variable1);
					q->breakCodon = fabs(variable1);
					r->breakCodon = fabs(variable1);
					numREbreakCod++;
					variable2 = fmod(whichSite,3.00);
					if (variable2 == 0)
						q->whereBreakCodon = 2;
					else
						q->whereBreakCodon = 1;
					r->whereBreakCodon = 3;
					
					

					/* oct2009 */
					/* int			doBreakpBroken, LeftLess, LeftHigh, RightLess, RightHigh; */
					if (doCodonModel == YES)
						doBreakpBroken = YES;
					LeftLess = LeftHigh = RightLess = RightHigh = LeftLess2 = RightHigh2 = -1;

					if (q->whereBreakCodon == 1) /* first codon position breakp */
						{
						RightHigh = q->breakCodon * 3;
						RightLess = RightHigh - 1;
						LeftLess = RightLess - 1; 
						LeftHigh = RightLess - 1;
						
						
						q->SitesNonAncHere[LeftLess+1] = 1;
						q->SitesNonAncHere[LeftLess+2] = 1;
						r->SitesNonAncHere[RightLess-1] = 1;

						/*fprintf (fpmpi, "\n LeftLess+2 = %d; RightLess-1 = %d \n", LeftLess+2, RightLess-1);*/
						for (mmm=1; mmm<=numNuc; mmm++)
							{
							if (mmm <= RightLess-1)
								q->SitesNonAncHere[mmm] = p->SitesNonAncHere[mmm]; 
							if (mmm > RightLess-1 && mmm <= LeftLess+2)
								q->SitesNonAncHere[mmm] = 1;
							if (mmm > LeftLess+2)
								q->SitesNonAncHere[mmm] = -1;

							if (mmm < RightLess-1)
								r->SitesNonAncHere[mmm] = -1; 
							if (mmm == RightLess-1)
								r->SitesNonAncHere[mmm] = 1;
							if (mmm > RightLess-1)
								r->SitesNonAncHere[mmm] =  p->SitesNonAncHere[mmm];
							}	
						}
					else if (q->whereBreakCodon == 2) /* second codon position breakp */
						{
						RightHigh = q->breakCodon * 3;
						RightLess = q->breakCodon * 3;
						LeftHigh = RightLess - 1;
						LeftLess = LeftHigh - 1;


						q->SitesNonAncHere[LeftHigh+1] = 1;
						r->SitesNonAncHere[RightLess-1] = 1;	
						r->SitesNonAncHere[RightLess-2] = 1;
						
						/*fprintf (fpmpi, "\n LeftHigh+1 = %d; RightLess-2 = %d \n", LeftHigh+1, RightLess-2);*/
						for (mmm=1; mmm<=numNuc; mmm++)
							{
							if (mmm < LeftHigh+1)
								q->SitesNonAncHere[mmm] = p->SitesNonAncHere[mmm]; 
							if (mmm == LeftHigh+1)
								q->SitesNonAncHere[mmm] = 1;
							if (mmm > LeftHigh+1)
								q->SitesNonAncHere[mmm] = -1;

							if (mmm >= LeftHigh+1)
								r->SitesNonAncHere[mmm] = p->SitesNonAncHere[mmm]; 
							if (mmm >= RightLess-2 && mmm < LeftHigh+1)
								r->SitesNonAncHere[mmm] = 1;
							if (mmm < RightLess-2)
								r->SitesNonAncHere[mmm] = -1;

							}	
						}
					else
						{
						fprintf (fpmpi, "error at q->whereBreakCodon intra codon Rec _ Main (%d != 1 or 2)\n", q->whereBreakCodon);
						exit (-1);
						}
					/* fprintf (fpmpi, "\n Left (Less-High) %d-%d; Right (Less-High) %d-%d \n", LeftLess, LeftHigh, RightLess, RightHigh);	*/				
					if (LeftLess == -1 || LeftHigh == -1 || RightLess == -1 || RightHigh == -1)
						{
						fprintf (fpmpi, "\n Error (value = -1): Left (Less-High) %d-%d; Right (Less-High) %d-%d \n", LeftLess, LeftHigh, RightLess, RightHigh);					
						exit (-1);
						}

					}
				if (k > 0 || doCodonModel == NO) /* inter codon rec */
					{
					doBreakpBroken = NO;

					for (mmm=1; mmm<=numNuc; mmm++)
						{
						if (mmm >= whichSite)
							{
							q->SitesNonAncHere[mmm] = -1; /* non anc mat */
							}
						if (mmm < whichSite)
							{
							q->SitesNonAncHere[mmm] = p->SitesNonAncHere[mmm]; /* non anc mat */
							}

						if (mmm < whichSite)
							{
							r->SitesNonAncHere[mmm] = -1; /* non anc mat */
							}
						if (mmm >= whichSite)
							{
							r->SitesNonAncHere[mmm] = p->SitesNonAncHere[mmm]; /* non anc mat */
							}
						}	


					}
				/* oct2009 */

				/*for (mmm=1; mmm<=numNuc; mmm++)
					{
					fprintf (fpmpi, "\n Initial. Site %d. Node: %d, p->SitesNonAncHere = %d \n", mmm, p->index, p->SitesNonAncHere[mmm]);
					}
				for (mmm=1; mmm<=numNuc; mmm++)
					{
					fprintf (fpmpi, "\n Site %d. Node: %d, q->SitesNonAncHere = %d;  Node %d, r->SitesNonAncHere = %d \n", mmm, q->index, q->SitesNonAncHere[mmm], r->index, r->SitesNonAncHere[mmm]);
					}*/
				

				/*fprintf (fpmpi, "\n r->index = %d, r->time = %lf, r->class = %d, r->breakp = %d, r->breakCodon = %d, r->whereBreakCodon = %d", r->index, r->time, r->class, r->breakp, r->breakCodon, r->whereBreakCodon);
				fprintf (fpmpi, "\n q->index = %d, q->time = %lf, q->class = %d, q->breakp = %d, q->breakCodon = %d, q->whereBreakCodon = %d\n", q->index, q->time, q->class, q->breakp, q->breakCodon, q->whereBreakCodon);*/
				k = 0;				



				if (noisy == 4)
					{		
					fprintf (fpmpi, "\nNode index %d with breakpoint on %d site", p->index, whichSite);
					fprintf (fpmpi, "\nThis node contains %d fragment(s):", p->numSegNode);
					}
				for (w = 0; w < p->numSegNode; w++)
					{
					s = segments + post(w,p->index,distance);
					/*p->seg = s;*/
					if (noisy == 4)
						{
						fprintf (fpmpi, "\ns->sIndex = %d", s->sIndex);
						fprintf (fpmpi, "\ns->sStart = %d", s->sStart);
						fprintf (fpmpi, "\ns->sEnd = %d",s->sEnd);
						}
					}
				if (noisy == 4)
					fprintf (fpmpi, "\n\n>> Process evolution..");
					
				

				
				a = b = aa = bb = aaa = bbb = out = 0;
				startsVectorRec = (int *) calloc((p->numSegNode),(long) sizeof(int));
				if (!startsVectorRec)
					{
					fprintf (fpmpi, "Could not allocate startsVectorRec (%lu bytes)\n", (p->numSegNode) *(long) sizeof(int));
					exit (-1);
					}
				endsVectorRec = (int *) calloc((p->numSegNode),(long) sizeof(int));
				if (!endsVectorRec)
					{
					fprintf (fpmpi, "Could not allocate endsVectorRec (%lu bytes)\n", (p->numSegNode) *(long) sizeof(int));
					exit (-1);
					}
				

				for (i = 0; i < p->numSegNode; i++)					/* for each segment */
					{
					s = segments + post(i,p->index,distance);
					startsVectorRec[i] = s->sStart;
					endsVectorRec[i] = s->sEnd;
				


					/* first half */
					if (s->sStart >= whichSite)
						{
						if (noisy == 4)
							fprintf (fpmpi, "\nNil segment in Left, don't make it");
							
						q->numSegNode--;
						a++;
						out = 1;
						} 
				
					if (s->sStart == 1 && s->sEnd >= (whichSite-1) && out == 0)
						{
						if (aa > 0)
							{
							if (noisy == 4)
								fprintf (fpmpi, "\nRepit segment in Left, don't make it");
								
							q->numSegNode--;
							out = 1;
							}
						aa++;
						}
					
					for (w = 0; w < i+1; w++)
						{
						if (out == 0 && s->sStart != 1 && s->sStart == startsVectorRec[w] && s->sStart < whichSite && w != i && s->sEnd >= (whichSite-1) && endsVectorRec[w] >= (whichSite-1) && startsVectorRec[w] != 0)
							{
							if (noisy == 4)
								fprintf (fpmpi, "\nRepit segment in Left, don't make it");
								
							q->numSegNode--;
							aaa++;
							out = 1;
							}
						}				
					
					
					if (out == 0 && s->sStart < whichSite)
						{
						if (aa == 0 && aaa == 0)
							{
							n = segments + post(i-a-aa-aaa,q->index,distance);
							n->sIndexNode = firstHalf;
							}
						if (aa > 0 && aaa == 0)
							{
							n = segments + post(i+1-a-aa-aaa,q->index,distance);
							n->sIndexNode = firstHalf;
							}
						if (aaa > 0 && aa > 0)
							{
							n = segments + post(i+1-a-aa-aaa,q->index,distance);
							n->sIndexNode = firstHalf;
							}
						if (aaa > 0 && aa == 0)
							{
							n = segments + post(i+0-a-aa-aaa,q->index,distance);
							n->sIndexNode = firstHalf;
							}
						nodeValue = firstHalf;


						if (doBreakpBroken == YES && s->sStart < whichSite && s->sEnd >= whichSite)
							{
							w = recSegmentsGeneratesLeftBrokenCodon(nodeValue, s, n, numNuc, whichSite, LeftLess, RightHigh, &actSegIndex); /* it makes the segments of the left node */
							LeftLess2 = LeftLess;
							RightHigh2 = RightHigh;							
							}
						else
							{
							w = recSegmentsGeneratesLeft(nodeValue, s, n, numNuc, whichSite, &actSegIndex); /* it makes the segments of the left node */
							}
						

						if (w != 1) /* Cheking */
							{
							fprintf (fpmpi, "Warning in recSegmentsGeneratesLeft");
							exit (-1);
							}
						actNumSegments++;
						if (n->sStart == 0 && n->sEnd == 0) /* Cheking, unreal segments */
							{
							fprintf (fpmpi, "\nNot to be here. Segment Left start and end = 0");
							
							n->before1 = n->before2 = n->after1 = n->after2 = NULL;
							actNumSegments--;
							exit(-1);
							}
						if (noisy == 4)
							{
							fprintf (fpmpi, "\nAfter rec. left");
							fprintf (fpmpi, "\nq->seg->sIndex = %d", n->sIndex);
							fprintf (fpmpi, "\nq->seg->sStart = %d", n->sStart);
							fprintf (fpmpi, "\nq->seg->sEnd = %d\n", n->sEnd);		
							}		

						}
					w = out = 0;
				


					/* second half */

					if (s->sEnd < whichSite)
						{
						if (noisy == 4)							
							fprintf (fpmpi, "\nNil segment in Right, don't make it");
							
						r->numSegNode--;
						b++;
						out = 1;
						}
					if (s->sStart <= whichSite && s->sEnd == numNuc && out == 0)
						{
						if (bb > 0)
							{
							if (noisy == 4)
								fprintf (fpmpi, "\nRepit segment in Right, don't make it");
								
							r->numSegNode--;
							out = 1;
							}
						bb++;
						}
					for (w = 0; w < i+1; w++)
						{
						if (out == 0 && s->sEnd != numNuc && s->sEnd == endsVectorRec[w] && s->sEnd > whichSite && w != i && s->sStart <= whichSite && startsVectorRec[w] <= whichSite && endsVectorRec[w] != 0)
							{
							if (noisy == 4)
								fprintf (fpmpi, "\nRepit segment in Right, don't make it");								
								
							r->numSegNode--;
								
							bbb++;
							out = 1;
							}
						}
					for (w = 0; w < i+1; w++)
						{
						if (out == 0 && s->sEnd == endsVectorRec[w] && s->sEnd >= whichSite && w != i && s->sStart <= whichSite && startsVectorRec[w] <= whichSite && endsVectorRec[w] != 0)
							{
							if (noisy == 4)								
								fprintf (fpmpi, "\nRepit segment in Right, don't make it");
								
							r->numSegNode--;
								
							bbb++;
							out = 1;
							}
						}
					

					if (out == 0 && s->sEnd >= whichSite)
						{
						if (bb == 0 && bbb == 0)
							{
							m = segments + post(i-b-bb-bbb,r->index,distance);
							m->sIndexNode = secondHalf;
							}
						if (bb > 0 && bbb == 0)
							{
							m = segments + post(i+1-b-bb-bbb,r->index,distance);
							m->sIndexNode = secondHalf;
							}
						if (bb > 0 && bbb > 0)
							{
							m = segments + post(i+1-b-bb-bbb,r->index,distance);
							m->sIndexNode = secondHalf;
							}
						if (bb == 0 && bbb > 0)
							{
							m = segments + post(i+0-b-bb-bbb,r->index,distance);
							m->sIndexNode = secondHalf;
							}
						/* m = s; initial, the new segments are similar at the old segments */
						nodeValue = secondHalf;


						if (doBreakpBroken == YES && s->sStart < whichSite && s->sEnd >= whichSite)
							{
							/*fprintf (fpmpi, "\nBefore recSegmentsGeneratesRightBrokenCodon");
							fprintf (fpmpi, "\ns->sStart = %d, s->sEnd = %d, whichSite = %d, LeftLess = %d, RightHigh = %d \n\n", s->sStart, s->sEnd, whichSite, LeftLess, RightHigh);*/
							w = recSegmentsGeneratesRightBrokenCodon(nodeValue, s, m, numNuc, whichSite, LeftLess, RightHigh, &actSegIndex);
							LeftLess2 = LeftLess;
							RightHigh2 = RightHigh;
							}
						else
							{
							w = recSegmentsGeneratesRight(nodeValue, s, m, numNuc, whichSite, &actSegIndex);
							}
						
						if (w != 1)
							{
							fprintf (fpmpi, "Warning in recSegmentsGeneratesRight");
							exit (-1);
							}
						actNumSegments++;
						if (m->sStart == 0 && m->sEnd == 0) /* unreal segments */
							{
							fprintf (fpmpi, "\nNot to be here. segment Right start and end = 0");
							
							m->before1 = m->before2 = m->after1 = m->after2 = NULL;
							actNumSegments--;
							exit(-1);
							}
						if (noisy == 4)
							{
							fprintf (fpmpi, "\nAfter rec. right");
							fprintf (fpmpi, "\nr->seg->sIndex = %d", m->sIndex);
							fprintf (fpmpi, "\nr->seg->sStart = %d", m->sStart);
							fprintf (fpmpi, "\nr->seg->sEnd = %d\n", m->sEnd);	
							}
						
						}
					w = out = 0;


					}
			

				free (startsVectorRec);
				free (endsVectorRec);
				a = b = aa = bb = aaa = bbb = 0;


				/* intra codon breakpoints readjust MRCA oct2009 */
				if (doBreakpBroken == YES) /* The codon positions that recombinaed are increased a unit */
					{
					
					for (w = 1; w <= numNuc; w++)
						{
						if (w >= LeftLess2 && w <= RightHigh2)
							{
							S_MRCA[w]++;
							/*fprintf (fpmpi, "\n Increasing MRCA to %d: now is: %d \n", w, S_MRCA[w]);*/
							}
						}

					}
				/* oct2009 */



				if (noisy == 4)
					{
					fprintf (fpmpi, "\n>> Recombination Results:");
					fprintf (fpmpi, "\nNew left node with %d fragment(s)", q->numSegNode);				
					}
				for (w = 0; w < q->numSegNode;w++)
					{
					n = segments + post(w,q->index,distance);
					if (noisy == 4)
						{
						fprintf (fpmpi, "\nq->seg->sIndex = %d", n->sIndex);
						fprintf (fpmpi, "\nq->seg->sStart = %d", n->sStart);
						fprintf (fpmpi, "\nq->seg->sEnd = %d\n", n->sEnd);				
						}
					}
				
				if (noisy == 4)
					fprintf (fpmpi, "\nNew right node with %d fragment(s)", r->numSegNode);
					
					
				for (w = 0; w < r->numSegNode;w++)
					{
					m = segments + post(w,r->index,distance);
					if (noisy == 4)
						{
						fprintf (fpmpi, "\nr->seg->sIndex = %d", m->sIndex);
						fprintf (fpmpi, "\nr->seg->sStart = %d", m->sStart);
						fprintf (fpmpi, "\nr->seg->sEnd = %d\n", m->sEnd);						
						}
					}
				if (noisy > 3)
					fprintf (fpmpi, "\n");
					
				
				/*fprintf (stderr, "the node is whichInd = %d, and the site is whichSite = %d", whichInd+1, whichSite+1);*/
				if (noisy > 1)
					{
					fprintf (fpmpi, "Recombination involving %d (copied to %d and %d)", p->index, q->index, r->index );
					fprintf (fpmpi, "\n Breakpoint was at site %d", whichSite);
					}
				if (noisy > 3)
					fprintf (fpmpi, "\n");
				
				if (doBranchNetfiles == YES)
					{

					if (q->NetLabelPrint < numSequences)
						fprintf(fpBranchNet,"%d_seq%05d ", q->NetLabelPrint, q->NetLabelPrint+1);
					else
						fprintf(fpBranchNet,"%d ", q->NetLabelPrint);

					if (p->NetLabelPrint < numSequences)
						fprintf(fpBranchNet,"%d_seq%05d\n", p->NetLabelPrint, p->NetLabelPrint+1);
					else
						fprintf(fpBranchNet,"%d\n", p->NetLabelPrint);


					/*fprintf(fpBranchNet,"%d %d\n", q->NetLabelPrint, p->NetLabelPrint);*/


					/*fprintf(fpBranchNet,"%d %d\n", r->NetLabelPrint, p->NetLabelPrint);*/
					if (noisy > 2)
						fprintf (fpmpi, "\nNET INFORMATION Recombination involving %d (copied to %d and %d)", p->NetLabelPrint, q->NetLabelPrint, r->NetLabelPrint);
					}
				breakpoint[numRE-1] = whichSite;  /* the breakpoint site is call breakpoint. breakpoint[0] = 7, breakpoint[1] = 96, breakpoint[2] = 187.. */
				
				/* readjust active sites */
				activeGametes[whichInd] = firstHalf;	/* new active nodes firstHalf and secondHalf */
				activeGametes[numActiveGametes++] = secondHalf;		/* there are 1 active node more (in recombination) */
				}
		
		
			/*** if COALESCENCE, readjust nodes and pointers ***/
			if (isCoalescence == YES)
				{
				if (noisy == 4)
					fprintf (fpmpi, "\n* Coalescence *\n");
					
				/* figure out which two nodes are involved */ 
			
				/* intial nodes: firstInd and secondInd (they are the descendants). newInd is the ancestral node, is the new node to make */
				firstInd = numActiveGametes * RandomUniform(seed);
				if (firstInd >= numActiveGametes)
					{
					fprintf (fpmpi, "\n\nERROR: firstInd out of range!\n");
					exit (-1);
					}
				do
					{
					secondInd = numActiveGametes * RandomUniform(seed);
					} while (firstInd == secondInd);	/* the new nodes must to be diferents */
				
				/*debug*/
				/*if (doDatedTips == YES)
					fprintf (stderr, "\nsecondInd =%d, numActiveGametes=%d\n", secondInd, numActiveGametes);*/

				newInd = nextAvailable;
				if (noisy > 1)					
					fprintf (fpmpi, "Coalescence involving %d and %d to create node %d", activeGametes[firstInd], activeGametes[secondInd], newInd);
					
					
				p = nodes + activeGametes[firstInd];
				q = nodes + activeGametes[secondInd];
				r = nodes + newInd;		/* new ancester */
				r->index = nextAvailable;
				r->label = labelNodes++;
				
				/*fprintf (fpmpi, "\n\nCoalescence node label %d, y index %d\n\n", r->label, r->index);*/
				
				r->breakp = NO;
				r->breakCodon = NO;
				r->class = 4;
				r->GMRCA_ancestral = NO;
				

				for (mmm = 1; mmm <= numNuc; mmm++)	 /* for each segment of p node going to r node*/
					{
					sigue = 0;
					stateHere_P = -2; /* -2, non ancestral; 0 ancestral */
					stateHere_Q = -2; /* -2, non ancestral; 0 ancestral */

					for (i = 0; i < p->numSegNode; i++)	 /* for each segment of p node going to r node*/
						{
						s = segments + post(i,p->index,distance);
						if (mmm >= s->sStart && mmm <= s->sEnd) /* is ancestral material */
							{
							stateHere_P = 0;
							}
						}
					for (i = 0; i < q->numSegNode; i++)	/* for each segment of q node going to r node */
						{
						n = segments + post(i,q->index,distance);
						if (mmm >= n->sStart && mmm <= n->sEnd) /* is ancestral material */
							{
							stateHere_Q = 0;
							}
						}
					
					
					/*fprintf (fpmpi, "\n Here(%d) stateHere_P = %d and stateHere_Q = %d ", mmm, stateHere_P, stateHere_Q);
					fprintf (fpmpi, "\n  Here(%d), node %d: p->SitesNonAncHere[mmm] = %d && node %d: q->SitesNonAncHere[mmm] = %d \n", mmm, p->index, p->SitesNonAncHere[mmm], q->index, q->SitesNonAncHere[mmm]);*/

					if (stateHere_P < 0 && stateHere_Q < 0) /* non ancestral material */
						{
						r->SitesNonAncHere[mmm] = -1;
						sigue++;
						/*fprintf (fpmpi, "1Position %d is NON anc mat \n", mmm);*/
						}
					if (stateHere_P >= 0 || stateHere_Q >= 0) /* ancestral material (inc pseudo) */
						{
						if (p->SitesNonAncHere[mmm] == 1 && q->SitesNonAncHere[mmm] == 1 && sigue == 0) /* pseudo anc mat */
							{
							r->SitesNonAncHere[mmm] = 1;
							sigue++;
							/*fprintf (fpmpi, "2Position %d is PSEUDO anc mat \n", mmm);*/
							}
						if (p->SitesNonAncHere[mmm] == 1 && stateHere_Q < 0 && sigue == 0) /* pseudo anc mat */
							{
							r->SitesNonAncHere[mmm] = 1;
							sigue++;
							/*fprintf (fpmpi, "3Position %d is PSEUDO anc mat \n", mmm);*/
							}
						if (q->SitesNonAncHere[mmm] == 1 && stateHere_P < 0 && sigue == 0) /* pseudo anc mat */
							{
							r->SitesNonAncHere[mmm] = 1;
							sigue++;
							/*fprintf (fpmpi, "4Position %d is PSEUDO anc mat \n", mmm);*/
							}
						if (sigue == 0)
							{
							if (p->SitesNonAncHere[mmm] == 0 || q->SitesNonAncHere[mmm] == 0)  /* anc mat */
								{
								r->SitesNonAncHere[mmm] = 0;
								sigue++;
								/*fprintf (fpmpi, "5Position %d is ANC mat \n", mmm);*/
								}
							}
						}
					}




				/*fprintf (fpmpi, "\nobtained r->index = %d: r->breakp = %d, r->breakCodon = %d, r->class = %d \n", r->index, r->breakp, r->breakCodon, r->class);*/
				
				if (doBranchNetfiles == YES)
					{
					r->NetLabelPrint = numNetLabelPrint;
					numNetLabelPrint++;

					if (p->NetLabelPrint == q->NetLabelPrint)
						{

						if (r->NetLabelPrint < numSequences)
							fprintf(fpBranchNet,"%d_seq%05d ", r->NetLabelPrint, r->NetLabelPrint+1);
						else
							fprintf(fpBranchNet,"%d ", r->NetLabelPrint);

						if (p->NetLabelPrint < numSequences)
							fprintf(fpBranchNet,"%d_seq%05d\n", p->NetLabelPrint, p->NetLabelPrint+1);
						else
							fprintf(fpBranchNet,"%d\n", p->NetLabelPrint);


						/*fprintf(fpBranchNet,"%d %d\n", r->NetLabelPrint, p->NetLabelPrint);*/
						}
					else
						{

						if (r->NetLabelPrint < numSequences)
							fprintf(fpBranchNet,"%d_seq%05d ", r->NetLabelPrint, r->NetLabelPrint+1);
						else
							fprintf(fpBranchNet,"%d ", r->NetLabelPrint);

						if (p->NetLabelPrint < numSequences)
							fprintf(fpBranchNet,"%d_seq%05d\n", p->NetLabelPrint, p->NetLabelPrint+1);
						else
							fprintf(fpBranchNet,"%d\n", p->NetLabelPrint);


						if (r->NetLabelPrint < numSequences)
							fprintf(fpBranchNet,"%d_seq%05d ", r->NetLabelPrint, r->NetLabelPrint+1);
						else
							fprintf(fpBranchNet,"%d ", r->NetLabelPrint);

						if (q->NetLabelPrint < numSequences)
							fprintf(fpBranchNet,"%d_seq%05d\n", q->NetLabelPrint, q->NetLabelPrint+1);
						else
							fprintf(fpBranchNet,"%d\n", q->NetLabelPrint);

						/*fprintf(fpBranchNet,"%d %d\n", r->NetLabelPrint, p->NetLabelPrint);
						fprintf(fpBranchNet,"%d %d\n", r->NetLabelPrint, q->NetLabelPrint);*/
						}
					if (noisy > 2)
						fprintf (fpmpi, "\nNET INFORMATION Coalescence involving %d and %d to create node %d", p->NetLabelPrint, q->NetLabelPrint, r->NetLabelPrint);
					}


				coalVectorCountStarts = (int *) calloc(((p->numSegNode)+(q->numSegNode)),(long) sizeof(int));
				if (!coalVectorCountStarts)
					{
					fprintf (fpmpi, "Could not allocate coalVectorCountStarts (%lu bytes)\n", ((p->numSegNode)+(q->numSegNode)) *(long) sizeof(int));
					exit (-1);
					}
				coalVectorCountEnds = (int *) calloc(((p->numSegNode)+(q->numSegNode)),(long) sizeof(int));
				if (!coalVectorCountEnds)
					{
					fprintf (fpmpi, "Could not allocate coalVectorCountEnds (%lu bytes)\n", ((p->numSegNode)+(q->numSegNode)) *(long) sizeof(int));
					exit (-1);
					}
				
				
				for (i = 0; i < p->numSegNode; i++)	 /* for each segment of p node going to r node*/
					{
					s = segments + post(i,p->index,distance);
					m = segments + post(i,r->index,distance);					/* new ancester */
					m->sIndexNode = newInd;
					
					s->before1 = m;
					m->before1 = NULL;
					m->before2 = NULL;
					m->after1 = s;
					m->after2 = NULL;
					m->sIndex = actSegIndex;
					m->sStart = s->sStart;
					m->sEnd = s->sEnd;				

					actSegIndex++;
					actNumSegments++;
						
					if (m->sStart == 0 && m->sEnd == 0) /* unreal segments */
						{
						fprintf (fpmpi, "\nNot to be here. COAL1, segment start and end = 0");
						
						m->before1 = m->before2 = m->after1 = m->after2 = NULL;
						actNumSegments--;
						exit(-1);
						}
						
					coalVectorCountStarts[i] = s->sStart;
					coalVectorCountEnds[i] = s->sEnd;
					}
					
				j = p->numSegNode;
				r->numSegNode = j;
				a = b = 0;
				
				for (i = 0; i < q->numSegNode; i++)	/* for each segment of q node going to r node */
					{
					n = segments + post(i,q->index,distance);
					
					for (w = 0; w < j; w++)
						if (n->sStart == coalVectorCountStarts[w] && n->sEnd == coalVectorCountEnds[w]) /* Repeated segment */
							a++;
						
					if (a == 0)
						{
						m = segments + post(j+b,r->index,distance);					/* new ancester */
						r->numSegNode = r->numSegNode+1;
						
						n->before1 = m;
						m->before1 = NULL;
						m->before2 = NULL;
						m->after1 = n;
						m->after2 = NULL;
						m->sIndex = actSegIndex;
						m->sStart = n->sStart;
						m->sEnd = n->sEnd;				
						m->sIndexNode = newInd;
						
						actSegIndex++;
						b++;
						actNumSegments++;
					
						if (m->sStart == 0 && m->sEnd == 0) /* Cheking */ /* unreal segments */
							{
							fprintf (fpmpi, "\nNot to be here. COAL2, segment start and end = 0");
							
							m->before1 = m->before2 = m->after1 = m->after2 = NULL;
							actNumSegments--;
							}
						}
					a = 0;
					}
				a = b = 0;
				free (coalVectorCountStarts);
				free (coalVectorCountEnds);
								

					/* Segment Bonds when this segment goes to 2 descendants segments */
				coalEqualSegInit_p = (int *) calloc((p->numSegNode+q->numSegNode),(long) sizeof(int));
				if (!coalEqualSegInit_p)
					{
					fprintf (fpmpi, "Could not allocate coalEqualSegInit_p (%lu bytes)\n", (p->numSegNode+q->numSegNode) *(long) sizeof(int));
					exit (-1);
					}
				coalEqualSegEnd_p = (int *) calloc((p->numSegNode+q->numSegNode),(long) sizeof(int));
				if (!coalEqualSegEnd_p)
					{
					fprintf (fpmpi, "Could not allocate coalEqualSegEnd_p (%lu bytes)\n", (p->numSegNode+q->numSegNode) *(long) sizeof(int));
					exit (-1);
					}
				coalEqualSegInit_q = (int *) calloc((p->numSegNode+q->numSegNode),(long) sizeof(int));
				if (!coalEqualSegInit_q)
					{
					fprintf (fpmpi, "Could not allocate coalEqualSegInit_q (%lu bytes)\n", (p->numSegNode+q->numSegNode) *(long) sizeof(int));
					exit (-1);
					}
				coalEqualSegEnd_q = (int *) calloc((p->numSegNode+q->numSegNode),(long) sizeof(int));
				if (!coalEqualSegEnd_q)
					{
					fprintf (fpmpi, "Could not allocate coalEqualSegEnd_q (%lu bytes)\n", (p->numSegNode+q->numSegNode) *(long) sizeof(int));
					exit (-1);
					}
				
				for (w = 0; w < p->numSegNode; w++)	
					{
					s = segments + post(w,p->index,distance);
						
					coalEqualSegInit_p[w] = s->sStart;
					coalEqualSegEnd_p[w] = s->sEnd;
					}
				for (w = 0; w < q->numSegNode; w++)	
					{
					n = segments + post(w,q->index,distance);
						
					coalEqualSegInit_q[w] = n->sStart;
					coalEqualSegEnd_q[w] = n->sEnd;
					}
					
				for (w = 0; w < p->numSegNode; w++)
					{
					for (i = 0; i < q->numSegNode; i++)
						{
						if (coalEqualSegInit_p[w] != 0 && coalEqualSegEnd_p[w] != 0 && coalEqualSegInit_p[w] == coalEqualSegInit_q[i] && coalEqualSegEnd_p[w] == coalEqualSegEnd_q[i])
							{
							for (a = 0; a < r->numSegNode; a++)	
								{
								m = segments + post(a,r->index,distance);									
								if (m->sStart == coalEqualSegInit_p[w] && m->sEnd == coalEqualSegEnd_p[w])
									{
									if (noisy == 4)
										fprintf (fpmpi, "\nFragment %d links to 2 descendants, ", m->sIndex);
										
									for (b = 0; b < p->numSegNode; b++)
										{
										s = segments + post(b,p->index,distance);												
										if (coalEqualSegInit_p[w] == s->sStart && coalEqualSegEnd_p[w] == s->sEnd)
											{
											m->after1 = s;
											if (noisy == 4)
												fprintf (fpmpi, "fragment %d", s->sIndex);
											}
										}
									for (b = 0; b < q->numSegNode; b++)
										{
										n = segments + post(b,q->index,distance);											
										if (coalEqualSegInit_p[w] == n->sStart && coalEqualSegEnd_p[w] == n->sEnd)
											{
											m->after2 = n;
											if (noisy == 4)
												fprintf (fpmpi, " and fragment %d", n->sIndex);
												
											}
										}
									}
								}
							}
						}
					}
						
				
				for (i = 0; i < r->numSegNode; i++)			/* cheking, if there are 2 similar segments, it keeps only 1 */		
					{
					m = segments + post(i,r->index,distance);					
					for (w = 0; w < r->numSegNode; w++)
						{
						z = segments + post(w,r->index,distance);						
						if (w != i && m->sStart == z->sStart && m->sEnd == z->sEnd && m->after1 != NULL)
							{
							fprintf (fpmpi, "\n2COAL. Not to be here. It cannot have 2 equal segments en this node.");
							fprintf (fpmpi, "\n m->sIndex = %d, z->sIndex = %d \n", m->sIndex, z->sIndex);
							fprintf (fpmpi, "\n m->sIndex = %d, z->sIndex = %d \n", m->sIndex, z->sIndex);
							
							z->after1 = z->after2 = z->before1 = z->before2 = NULL; /* continue only the z segment */
							r->numSegNode--;
							exit(-1);
							}
						}
					}
				j = w = a = b = 0;
				free (coalEqualSegInit_p);
				free (coalEqualSegEnd_p);
				free (coalEqualSegInit_q);
				free (coalEqualSegEnd_q);
				
					
				
				if (noisy == 4)
					{
					fprintf (fpmpi, "\n\nCoalescence Result is the new node %d with %d fragment(s)", r->index, r->numSegNode);
					for (i = 0; i < r->numSegNode; i++)	
						{
						m = segments + post(i,r->index,distance);
					
						fprintf (fpmpi, "\nFragment %d, ", m->sIndex);
						fprintf (fpmpi, "m->sStart = %d", m->sStart);
						fprintf (fpmpi, " and m->sEnd = %d", m->sEnd);
						}
					fprintf (fpmpi, "\n");
					}
				
				
		
				/** MRCA **/
				/* Array with the information about ancestral stuff */
				/* S_MRCA. overFirst is the biggest site by left & overEnd is the smallest site by right. The difference is the overLapSites */
				sizeNode_p = p->numSegNode;
				sizeNode_q = q->numSegNode;
				out = 0;
			
				if (r->numSegNode == 1) /* 1.- fast. Only 1 segment */
					{
					for (i = 0; i < r->numSegNode; i++)	
						m = segments + post(i,r->index,distance);
				
					overFirst = m->sStart;
					overEnd = m->sEnd;
				
					for (j = 1; j <= numNuc; j++)
						{
						if (j >= overFirst && j <= overEnd)
							{
							S_MRCA[j]--;
							}
						}
					out = 1;
					}
				a = b = k = 0;
			
				if (r->numSegNode > 1)	
					{
					initialVector_pp = (int *) calloc((p->numSegNode),(long) sizeof(int));
					if (!initialVector_pp)
						{
						fprintf (fpmpi, "Could not allocate initialVector_pp (%lu bytes)\n", (p->numSegNode) *(long) sizeof(int));
						exit (-1);
						}
					endVector_pp = (int *) calloc((p->numSegNode),(long) sizeof(int));
					if (!endVector_pp)
						{
						fprintf (fpmpi, "Could not allocate endVector_pp (%lu bytes)\n", (p->numSegNode) *(long) sizeof(int));
						exit (-1);
						}
					initialVector_qq = (int *) calloc((q->numSegNode),(long) sizeof(int));
					if (!initialVector_qq)
						{
						fprintf (fpmpi, "Could not allocate initialVector_qq (%lu bytes)\n", (q->numSegNode) *(long) sizeof(int));
						exit (-1);
						}
					endVector_qq = (int *) calloc((q->numSegNode),(long) sizeof(int));
					if (!endVector_qq)
						{
						fprintf (fpmpi, "Could not allocate endVector_qq (%lu bytes)\n", (q->numSegNode) *(long) sizeof(int));						
						exit (-1);
						}
				
				
					/* 2.- Fast. There is a segment more big than the other segments */
					for (position = 0; position < p->numSegNode; position++)
						{
						s = segments + post(position,p->index,distance);
						initialVector_pp[position] = s->sStart;
						endVector_pp[position] = s->sEnd;
						}
					for (position = 0; position < q->numSegNode; position++)
						{
						n = segments + post(position,q->index,distance);		
						initialVector_qq[position] = n->sStart;
						endVector_qq[position] = n->sEnd;
						}
					
					/* smaller value for the initial */
					for (position = 0; position < p->numSegNode; position++)
						{
						if (position == 0)
							minInit_pp = initialVector_pp[position];
		
						if (initialVector_pp[position] < minInit_pp && initialVector_pp[position] != 0)
							minInit_pp = initialVector_pp[position];
						}

					/* older value for the end */
					for (position = 0; position < p->numSegNode; position++)
						{
						if (position == 0)
							maxEnd_pp = endVector_pp[position];
	
						if (endVector_pp[position] > maxEnd_pp && endVector_pp[position] != 0)
							maxEnd_pp = endVector_pp[position];
						}
		
						/* smaller value for the initial */
					for (position = 0; position < q->numSegNode; position++)
						{
						if (position == 0)
							minInit_qq = initialVector_qq[position];
				
						if (initialVector_qq[position] < minInit_qq && initialVector_qq[position] != 0)
							minInit_qq = initialVector_qq[position];
						}

					/* older value for the end */
					for (position=0; position < q->numSegNode; position++)
						{
						if (position == 0)
							maxEnd_qq = endVector_qq[position];
	
						if (endVector_qq[position] > maxEnd_qq && endVector_qq[position] != 0)
							maxEnd_qq = endVector_qq[position];
						}
			
	
					/* fast, there are in 1 big segment that contains all the segments */					
					for (position = 0; position < p->numSegNode; position++) 
						{
						if (endVector_pp[position] == maxEnd_pp && initialVector_pp[position] == minInit_pp)	
							a = 1;
						}
					for (position = 0; position < q->numSegNode; position++) 
						{
						if (endVector_qq[position] == maxEnd_qq && initialVector_qq[position] == minInit_qq)	
							b = 1;
						}
				
					free (initialVector_pp);
					free (endVector_pp);
					free (initialVector_qq);
					free (endVector_qq);
				
				
					/* 2.- Fast with a big segment */
					if (minInit_pp <= minInit_qq && maxEnd_pp >= maxEnd_qq && a == 1 && b == 1)
						{
						for (j = 1; j <= numNuc; j++)
							{
							if (j >= minInit_qq && j <= maxEnd_qq)
								{
								S_MRCA[j]--;
								}
							}
						a = out = 1;	
						}
					if (minInit_qq <= minInit_pp && maxEnd_qq >= maxEnd_pp && a == 1 && b == 1 && out == 0)
						{
						for (j = 1; j <= numNuc; j++)
							{
							if (j >= minInit_pp && j <= maxEnd_pp)
								{
								S_MRCA[j]--;
								}
							}
						a = out = 1;	
						}
					
					if (maxEnd_pp < minInit_qq && out == 0)
						a = out = 1;
						
					if (maxEnd_qq < minInit_pp && out == 0)
						a = out = 1;
						
					
					if (minInit_pp < minInit_qq && maxEnd_pp < maxEnd_qq && a == 1 && b == 1 && out == 0)
						{
						for (j = 1; j <= numNuc; j++)
							{
							if (j >= minInit_qq && j <= maxEnd_pp)
								{
								S_MRCA[j]--;
								}
							}
						a = out = 1;
						}
						
					if (minInit_qq < minInit_pp && maxEnd_qq < maxEnd_pp && a == 1 && b == 1 && out == 0)
						{
						for (j = 1; j <= numNuc; j++)
							{
							if (j >= minInit_pp && j <= maxEnd_qq)
								{
								S_MRCA[j]--;
								}
							}
						a = out = 1;
						}
					
					a = b = k = w = i = 0;
				
					/* 3.- complex case */
					if (out == 0)
						{
						for (j = 1; j <= numNuc; j++)
							{
							if (overLapSegmentsCoalMRCA(p, q, sizeNode_p, sizeNode_q, j) == YES)
								{
								S_MRCA[j]--;
								}
							}
						}
					}
				j = 0;




				/* Folllowing only ancestral material */
				for (mmm = 1; mmm <= numNuc; mmm++)	 /* Only anc material*/
					{
					if (p->SitesNonAncHere[mmm] == 0 && q->SitesNonAncHere[mmm] == 0)
						{
						/*fprintf (fpmpi, "\n This Position %d is ANC mat: p->index = %d, p->SitesNonAncHere = %d, q->index = %d, q->SitesNonAncHere = %d \n", mmm, p->index, p->SitesNonAncHere[mmm], q->index, q->SitesNonAncHere[mmm]);*/
						OnlyAncS_MRCA[mmm]--;
						}				
					}
				/* Is this the GMRCA of the anc material? */
				Ok_SMRCA_Codon = 0;
				for (mmm = 1; mmm <= numNuc; mmm++)	 /* Only anc material*/
					{
					if (OnlyAncS_MRCA[mmm] == 1)
						{
						/*fprintf (fpmpi, "\n-- Yes anc GMRCA position %d -- \n", mmm);*/
						Ok_SMRCA_Codon++;
						}
					}			
				if (Ok_SMRCA_Codon == numNuc && AncGMRCA_obtained == NO)
					{
					r->GMRCA_ancestral = YES;
					AncGMRCA_obtained = YES;
					if (noisy == 4)
						fprintf (fpmpi, "\n--GMRCA of the ancestral material in node %d-- \n", r->index);
					}



				/* in coalescence is possible link the nodes */
				r->left = p;
				r->right = q;
				p->anc1 = r;
				q->anc1 = r;
				r->time = currentTime;
				/*fprintf (fpmpi, " r->index = %d, r->time = %lf\n", r->index, r->time);*/

				/* readjust active nodes */
				activeGametes[firstInd] = newInd;
				activeGametes[secondInd] = activeGametes[numActiveGametes-1];
				numActiveGametes--; /* it lose 1 active node */
				nextAvailable++; /* 1 node more to available */
			
				if (nextAvailable >= numNodes)	/* if there aren't enough nodes it go into and it addition more */
					{
					/* ReallocNodes(&numNodes, activeGametes); */
					numNodes += INCREMENT_NODES;
					numTotalSegments += (INCREMENT_NODES*maxSegNode)+numNuc;
					
					/* REALLOC */
					segments = (TreeSegment *) realloc (segments, numTotalSegments  * (long) sizeof(TreeSegment)); 
					if (!segments)
						{
						fprintf (fpmpi, "Could not reallocate segments (%lu bytes)\n", ((numNodes*distance)+numNuc)  * (long) sizeof(TreeSegment));
						exit (1);
						}
					nodes = (TreeNode *) realloc (nodes, numNodes  * (long) sizeof(TreeNode));
					if (!nodes)
						{
						fprintf (fpmpi, "Could not reallocate nodes (%lu bytes)\n", numNodes  * (long) sizeof(TreeNode));
						exit (-1);
						}
					activeGametes = (int *) realloc (activeGametes, numNodes *(long) sizeof(int));
					if (!activeGametes)
						{
						fprintf (fpmpi, "Could not reallocate activeGametes (%lu bytes)\n", numNodes *(long) sizeof(int));
						exit (-1);
						}
					if (noisy == 4)
						fprintf (fpmpi, "\n\n...Doing reallocation of nodes (1)\n");
						
					}
				}	/* end of coalescence */
		
						
			/* print out ancestral (active) status for each site and MRCA vector - only mat anc */
			if (noisy > 2)
				{
				fprintf (fpmpi,"\n - Ancestral MRCA in the nodes: -\n");
				for (i=0; i<numActiveGametes; i++)
					{
					for (j=1; j<=numNuc; j++)
						{
						p = nodes + activeGametes[i];
						if (j == 1)
							fprintf (fpmpi, "%4d -- (MRCA:)", p->index);
						fprintf (fpmpi, "%d", OnlyAncS_MRCA[j]);
						}
					fprintf (fpmpi, "\n");
					}
				/*fprintf (fpmpi, "MRCA   ");*/
				for (j=1; j<=numNuc; j++)
					{
					if (OnlyAncS_MRCA[j] <= 1)
						fprintf (fpmpi, "*");
					else
						fprintf (fpmpi, " ");
					}
				/*fprintf (fpmpi, "\n");*/
				fprintf (fpmpi,"\n\n");
				}

			/* print out ancestral (active) status for each site and MRCA vector */
			if (noisy > 2)
				{
				fprintf (fpmpi,"\nMRCA in the nodes:\n");
				for (i=0; i<numActiveGametes; i++)
					{
					for (j=1; j<=numNuc; j++)
						{
						p = nodes + activeGametes[i];
						if (j == 1)
							fprintf (fpmpi, "%4d -- (MRCA:)", p->index);
						fprintf (fpmpi, "%d", S_MRCA[j]);
						}
					fprintf (fpmpi, "\n");
					}
				/*fprintf (fpmpi, "MRCA   ");*/
				for (j=1; j<=numNuc; j++)
					{
					if (S_MRCA[j] <= 1)
						fprintf (fpmpi, "*");
					else
						fprintf (fpmpi, " ");
					}
				/*fprintf (fpmpi, "\n");*/
				}
			

			if (noisy > 2) /* hotspots recombination */
				{
				if (doBlockRecombination == YES)
					{
					fprintf (stderr, "\nHotspots:\n ");
					i = 0;
					for (j=1; j<=numNuc; j++)
						{
						if (hotspot[i] == j)
							{
							fprintf (stderr, "+");
							i++;
							}
						else
							fprintf (stderr, " ");
						}
					fprintf (stderr, "\n");
					}
				}			

			
			sizeNode = sizeNode_p = sizeNode_q = 0;
			free (gi);

			

			/* If doing dated tips, sometimes the number of actives nodes can be already 1 before all have been activated samples. 
			If this happens we need to move towards the next sample, activate it, and start again */
			if (doDatedTips == YES)
			 if (numActiveGametes == 1 && currentSample > 0)
				{
				if (noisy > 2)
					fprintf (stderr, "\n\nOnly 1 lineage active before activating all samples"/*, currentSample*/);
				currentSample--;

				/* activate nodes from this sample*/
				if (noisy > 2)
					fprintf (stderr, "\n Activating sample %d (time = %6.4f). Tips to activate:", currentSample, datedSample[currentSample].time);
				for (i=0; i<datedSample[currentSample].size; i++)
					{
					if (noisy > 2)
						fprintf (stderr, " %d", datedSample[currentSample].member[i]-1);
					
					p = nodes + datedSample[currentSample].member[i]-1;
					p->index = datedSample[currentSample].member[i]-1;
					activeGametes[numActiveGametes] = datedSample[currentSample].member[i]-1;  
						
					numActiveGametes++;
					}
				currentTime = datedSample[currentSample].time;
	
				if (noisy > 2)
					{
					fprintf (stderr, "\nActive nodes (%d):", numActiveGametes); 
					for (i=0; i<numActiveGametes; i++)
						fprintf (stderr," %d",activeGametes[i]);
					fprintf (stderr,"   Next node available = %d ", nextAvailable);
					fprintf (stderr, "\nSetting currentTime = %6.4f", currentTime);
					}
				}




			} /* coalescent tree finished */

		
		 /* Cheking */
		/*for (w = 1; w <= numNuc; w++)
			{
			if (S_MRCA[w] > 1 || S_MRCA[w] < 1)
				{*/
				/*
				fprintf (fpmpi, "\n Warning S_MRCA in the last node is > 1, S_MRCA[%d] = %d", w, S_MRCA[w]);
				exit (-1);
				}
			}*/


		/*if (noisy > 1)			
			fprintf (fpmpi, "\n\n\n>> Coalescent tree/s finished\n");*/
		if (noisy > 1)			
			fprintf (fpmpi, "\n\n\n>> Coalescent finished\n");
			
				
		counterTimeInit = counterTimeInit + currentTime;
		actualTGMRCA = currentTime;


		/* Use it to see the evolution nodes-segments */
		
		/*
		fprintf (fpmpi, "\n\n\nnextAvailable = %d",nextAvailable);
		for (j = 0; j < numNodes; j++)*/	/* Looking for parent Node of segments */	
		/*	{
			p = nodes + j;
			fprintf (fpmpi, "\n\n\n\n**The node %d**",p->index);

			for (i=0; i < p->numSegNode; i++)
				{
				s = segments + post(i,j,numNuc);	
				p->seg = s;
			
				fprintf (fpmpi, "\n\ns->sIndex %d con s->parentNode->index = %d", s->sIndex, s->parentNode->index);
				if (s->after1 != NULL)
					fprintf (fpmpi, "\ns->after1->sIndex %d con s->after1->parentNode->index = %d", s->after1->sIndex, s->after1->parentNode->index);
				if (s->after2 != NULL)
					fprintf (fpmpi, "\ns->after2->sIndex %d con s->after2->parentNode->index = %d", s->after2->sIndex, s->after2->parentNode->index);
				}
			}*/
			
		}
	
		



	
	/********** BUILDING TREES ***********/
	/* first, we build an array with order breakpoints from - to + */
	free (activeGametes);
	
	if (doFixNumRecEvents == NO || numRE == fixedNumRecEvents) /* Good replicate */
		{
		if (noisy > 1)
			{
			fprintf (fpmpi, "\n\n>> Network finished\n");
			fprintf (fpmpi, "\n\n>> Building trees ..");
			}
		if (noisy == 4 && numRE > 0)
			fprintf (fpmpi, "\n\n");
		
		
		arrayIndBreakpoints = (int *) calloc((numRE+1),(long) sizeof(int));
		if (!arrayIndBreakpoints)
			{
			fprintf (fpmpi, "Could not allocate arrayIndBreakpoints (%lu bytes)\n", (numRE+1) *(long) sizeof(int));
			exit (-1);
			}
		arrayIndBreakpointsOrd = (int *) calloc((numRE+1),(long) sizeof(int));
		if (!arrayIndBreakpointsOrd)
			{
			fprintf (fpmpi, "Could not allocate arrayIndBreakpointsOrd (%lu bytes)\n", (numRE+1) *(long) sizeof(int));	
			exit (-1);
			}
		for (w = 0; w < numRE; w++)
			{
			arrayIndBreakpoints[w] = breakpoint[w];
			arrayIndBreakpointsOrd[w] = 0;
			
			/*
			fprintf (fpmpi, "arrayIndBreakpoints[%d] = %d\n", w, arrayIndBreakpoints[w]);
			*/
			}
		
		/*
		fprintf (fpmpi, "arrayIndBreakpoints[%d+1] = %d\n", w+1, arrayIndBreakpoints[w+1]);	
		*/	
	
		j = arrayIndBreakpoints[0];
		for (k = 0; k < numRE; k++)
			{
			for (w = 0; w < numRE; w++)		/* order breakpoints, from - to + */
				if (arrayIndBreakpoints[w] < j)
					j = arrayIndBreakpoints[w];
				
			if (j > numNuc) /* end */
				{
				arrayIndBreakpointsOrd[k] = 0;
				break;
				}
					
			for (w = 0; w < numRE; w++)
				if (arrayIndBreakpoints[w] == j)
					arrayIndBreakpoints[w] = numNuc+1;
		
			arrayIndBreakpointsOrd[k] = j;
			j = numNuc+1;
			}
		free (arrayIndBreakpoints);
	
		indNumRE = 0;
		if (noisy == 4 && numRE > 0)
			fprintf (fpmpi, "Breakpoints list (from the smallest to the biggest value):\n");
			
			
		for (k = 0; k < numRE; k++)
			{
			if (arrayIndBreakpointsOrd[k] != 0)
				indNumRE++;
			if (noisy == 4 && numRE > 0 && arrayIndBreakpointsOrd[k] != 0)
				fprintf (fpmpi, "%d\n", arrayIndBreakpointsOrd[k]);
			}
		
		for (k = 0; k < indNumRE; k++)
			{
			if (k != 0)
				if (arrayIndBreakpointsOrd[k] < arrayIndBreakpointsOrd[k-1])
					{
					fprintf (fpmpi, " \n\n Warning in arrayIndBreakpointsOrd[k], 2 similar breakpoints in this array. See the indepBrekp vector");
					/*exit (-1);*/ /* but no problem */
					}
			}
	
		/* about the GMRCA */
		p = nodes + newInd; /* because the last one process is the last one coalescence */
		p->class = 5;
		treeRootInit[0] = p;
		

		/* The trees */
		if (noisy > 3)
			fprintf (fpmpi, "\nIt generates %d tree(s):", indNumRE+1);
			
		j = k = w = countNumTrees = 0;
	
		numSegTrees = (int *) calloc((indNumRE+2),(long) sizeof(int));
		if (!numSegTrees)
			{
			fprintf (fpmpi, "Could not allocate numSegTrees (%lu bytes)\n", (indNumRE+2) *(long) sizeof(int));
			exit (-1);
			}
				/* determination of segments number of each tree, from the GMRCA node */
		for (i = 0; i < p->numSegNode; i++)
			{
			s = segments + post(i,p->index,distance);			
			j = 0;
			
			if (s->sStart == 1 && s->sEnd >= (arrayIndBreakpointsOrd[j]-1) && s->after1 != NULL) /* first tree */
				numSegTrees[j]++;
			if (indNumRE-1 >= 0) /*only with rec event*/
				if (s->sStart <= arrayIndBreakpointsOrd[indNumRE-1] && s->sEnd == numNuc && s->after1 != NULL) /* last tree */
					numSegTrees[indNumRE]++;
			if (s->after1 == NULL && s->after2 == NULL) /* no conect segments, it must to be 0 */
				numSegTrees[indNumRE+1]++;
			if (indNumRE > 1)
				{
				for (j = 0; j < (indNumRE-1); j++)
					if (s->sStart <= (arrayIndBreakpointsOrd[j]) && s->sEnd >= (arrayIndBreakpointsOrd[j+1]-1) && s->after1 != NULL) /* internal trees */
						numSegTrees[j+1]++;
				}
			}
		
	
		if (noisy == 4)
			for (i = 0; i < (indNumRE+1); i++)
				fprintf (fpmpi, "\nTree %d starts by %d fragment(s)", i+1, numSegTrees[i]);
			
		
		
			/*** building trees ***/
		j = k = w = a = b = 0;
		/* default */
		numNodex = (indNumRE+1)*numNodes;
		if (indNumRE > 1000)
			numNodex = numNodex/5;
		if (indNumRE > 10000)
			numNodex = numNodex/50;
		if (indNumRE > 100000)
			numNodex = numNodex/50000;		
		/*fprintf (stderr, "\nindNumRE = %d, numNodex= %d", indNumRE, numNodex);*/
		
		nodex = (TreeNodex *) calloc (numNodex, sizeof(TreeNodex)); /* nodes */
		if (!nodex)
			{
			fprintf (fpmpi, "\nCould not allocate nodex1 (%lu bytes)\n", numNodex  * (long) sizeof(TreeNodex));
			
			fprintf (fpmpi, "\nSecond try \n");
			free (nodex);
			numNodex = (indNumRE+1)*numNodes/2;
			if (indNumRE > 1000)
				numNodex = numNodex/15;
			if (indNumRE > 10000)
				numNodex = numNodex/100;
			if (indNumRE > 100000)
				numNodex = numNodex/500000;	

			nodex = (TreeNodex *) calloc (numNodex, sizeof(TreeNodex)); /* nodes */
			if (!nodex)
				{
				fprintf (fpmpi, "\nCould not allocate nodex2 (%lu bytes)\n", numNodex  * (long) sizeof(TreeNodex));

				fprintf (fpmpi, "\nThird try \n");
				free (nodex);
				numNodex = (indNumRE+1)*numNodes/5;
				if (indNumRE > 1000)
					numNodex = numNodex/30;
				if (indNumRE > 10000)
					numNodex = numNodex/200;
				if (indNumRE > 100000)
					numNodex = numNodex/700000;	

				nodex = (TreeNodex *) calloc (numNodex, sizeof(TreeNodex)); /* nodes */
				if (!nodex)
					{
					fprintf (fpmpi, "\nCould not allocate nodex3 (%lu bytes)\n", numNodex  * (long) sizeof(TreeNodex));

					fprintf (fpmpi, "\nFourth try \n");
					free (nodex);
					numNodex = (indNumRE+1)*numNodes/50;
					if (indNumRE > 1000)
						numNodex = numNodex/100;
					if (indNumRE > 10000)
						numNodex = numNodex/400;
					if (indNumRE > 100000)
						numNodex = numNodex/900000;	

					nodex = (TreeNodex *) calloc (numNodex, sizeof(TreeNodex)); /* nodes */
					if (!nodex)
						{
						fprintf (fpmpi, "\nCould not allocate nodex4 (%lu bytes)\n", numNodex  * (long) sizeof(TreeNodex));
						exit (1);
						}
					}
				}
			}

		treeRootNodex = (TreeNodex **) calloc(indNumRE+1, sizeof(TreeNodex *)); /* node pointers */
		if (!treeRootNodex)
			{
			fprintf (fpmpi, "Could not allocate treeRootNodex (%lu bytes)\n", indNumRE+1  * (long) sizeof(TreeNodex));			
			exit (1);
			}

		for (i = 0; i < numNodex; i++)
			{
			nodex[i].left = NULL;
			nodex[i].right = NULL;
			nodex[i].anc1 = NULL;
			nodex[i].outgroup = NULL;
			nodex[i].index = 0;
			nodex[i].NetIndex = -1;
			nodex[i].indexOldMigPop = 0;
			nodex[i].label = 0;
			nodex[i].isOutgroup = NO;
			nodex[i].length = 0.0;
			nodex[i].time = 0.0;
			nodex[i].MRCAfrom = -1;
			nodex[i].MRCAto = -1;
			}

		/* making trees */
		/*fprintf (stderr, "\n\n\n *********** MAKING TREES **********\n\n");*/
		f = nodex + a;
		f->index = 0;
		f->NetIndex = p->index;
		f->length = p->length;
		f->time = p->time;
		f->indexOldMigPop = p->indexOldMigPop;
		i = 0;
	
		if (indNumRE == 0) /* there aren't recombinations */
			{
			/*f = p;*/
			f->MRCAfrom = 1;
			f->MRCAto = numNuc;
			treeRootNodex[a] = f;
			/*treeRootNodex[a].MRCAfrom = 1;
			treeRootNodex[a].MRCAto = numNuc; */

			/*if (noisy >= 3)
				fprintf (fpmpi, "\nThere aren't recombinations. treeRootNodex[%d] = %d", a, treeRootNodex[a]->index);*/
			if (noisy > 2)
				fprintf (fpmpi,"\n\n>> Making the tree..");
				
			countNumTrees++;
			buildTreeCoal(p, f, numSequences, &numActNodex);
			numActNodex++;
			i = 0;
			}
	
		/* Several trees */
		if (indNumRE > 0) /* first tree */
			{
			/*f->MRCAfrom = 1;
			f->MRCAto = arrayIndBreakpointsOrd[j]-1;
			fprintf (fpmpi,"\n a = %d, arrayIndBreakpointsOrd[j]-1 = %d, f->index = %d, f->NetIndex = %d, f->time = %lf", a, arrayIndBreakpointsOrd[j]-1, f->index, f->NetIndex, f->time);
			fprintf (fpmpi,"\n in first tree numActNodex = %d, p->index = %d", numActNodex, p->index);*/

			treeRootNodex[a] = f;
			/*fprintf (fpmpi,"\n in first tree treeRootNodex[a]->index = %d", treeRootNodex[a]->index);*/
			treeRootNodex[a]->MRCAfrom = 1;
			treeRootNodex[a]->MRCAto = arrayIndBreakpointsOrd[j]-1; 
			i = a;
			if (noisy > 2)
				fprintf (fpmpi,"\n\n\n>> Making the first tree..");
				
		
			for (step = 0; step < p->numSegNode; step++)				
				{
				s = segments + post(step,p->index,distance);				
				if (s->sStart == 1 && s->sEnd >= (arrayIndBreakpointsOrd[j]-1) && s->after1 != NULL)
					{
					k++;
					if (k == numSegTrees[0])
						{
						countNumTrees++;
						buildTreeInit(p, f, numNuc, arrayIndBreakpointsOrd, j, numSequences, &numActNodex);
						}
					}
				}
			k = 0;
			numActNodex++;
		
			if (indNumRE > 1)		/* Internal trees */
				{
				for (j = 0; j < (indNumRE-1); j++)
					{
					/*fprintf (fpmpi,"\n Desde internal primero trees numActNodex = %d", numActNodex);*/
					f = nodex + numActNodex;
					f->index = numActNodex;
					f->NetIndex = p->index;
					f->length = p->length;
					f->time = p->time;
					f->indexOldMigPop = p->indexOldMigPop;
					numActNodex++;
					
					f->MRCAfrom = arrayIndBreakpointsOrd[j];
					f->MRCAto = arrayIndBreakpointsOrd[j+1]-1;
					treeRootNodex[j+1] = f;
					/*fprintf (fpmpi,"\n in intern tree treeRootNodex[j+1]->index = %d", treeRootNodex[j+1]->index);*/
					/*treeRootNodex[j+1].MRCAfrom = arrayIndBreakpointsOrd[j];
					treeRootNodex[j+1].MRCAto = arrayIndBreakpointsOrd[j+1]-1;*/
					
					if (noisy > 2)
						fprintf (fpmpi,"\n>> Making internal tree %d..", j+1);
						
						
					for (step = 0; step < p->numSegNode; step++)		
						{
						s = segments + post(step,p->index,distance);			 
						if (s->sStart <= (arrayIndBreakpointsOrd[j]) && s->sEnd >= (arrayIndBreakpointsOrd[j+1]-1) && s->after1 != NULL) /* internal trees, it can to be several trees */
							{
							k++;
							if (k == numSegTrees[j+1])	/* the last segment of internal tree */
								{
								countNumTrees++;
								buildTreeIntern(p, f, numNuc, arrayIndBreakpointsOrd, j, numSequences, &numActNodex);
								}
							}
						}
					k = 0;
					numActNodex++;
					}
				j = 0;
				}

		
				/* last tree */
			/*fprintf (fpmpi,"\n in Last tree primero numActNodex = %d", numActNodex);*/
			f = nodex + numActNodex;
			f->index = numActNodex;
			f->NetIndex = p->index;
			f->length = p->length;
			f->time = p->time;
			f->indexOldMigPop = p->indexOldMigPop;
		
			numActNodex++;

			f->MRCAfrom = arrayIndBreakpointsOrd[indNumRE-1];
			f->MRCAto = numNuc;			

			treeRootNodex[indNumRE] = f;
			/*fprintf (fpmpi,"\n in last tree treeRootNodex[indNumRE]->index = %d", treeRootNodex[indNumRE]->index);*/
			/*treeRootNodex[indNumRE].MRCAfrom = arrayIndBreakpointsOrd[indNumRE-1];
			treeRootNodex[indNumRE].MRCAto = numNuc;*/

		
			if (noisy > 2)
				fprintf (fpmpi,"\n>> Making the last tree..");
				
			for (step = 0; step < p->numSegNode; step++)		
				{
				s = segments + post(step,p->index,distance);
				if (s->sStart <= arrayIndBreakpointsOrd[indNumRE-1] && s->sEnd == numNuc && s->after1 != NULL)
					{
					k++;
					if (k == numSegTrees[indNumRE])	/* the last segment of internal tree */
						{
						countNumTrees++;
						j = indNumRE-1;
					
						buildTreeEnd(p, f, numNuc, arrayIndBreakpointsOrd, j, numSequences, &numActNodex);
						}
					}
				}
			free (numSegTrees);
			k = j = 0;
			numActNodex++;
			

			/* get rid of superflous nodes */
			a = 0;
			
			if (noisy > 3)
				fprintf (fpmpi, "\n\n");
			if (noisy > 3)
				fprintf (fpmpi, "\n>> Removing superfluos nodes .."); /* nodex */
				
			
			foundSuperflousNode = YES;
			while (foundSuperflousNode == YES)
				{
				foundSuperflousNode = NO;
		
				for (i = 0; i < numActNodex; i++) /* available all nodes */
					{
					f = nodex + i;
			
					if (f->left == NULL && f->right == NULL && f->anc1 == NULL)
						{
						/* nothing to do with this node because it is not connected to anything */
						}
					else if (f->left == NULL && f->right == NULL && f->anc1 != NULL)
						{
						/* do not do anything with this node because it is a tip */
						}
					else if (f->left != NULL && f->right == NULL && f->anc1 != NULL)
						{
						/* this is a superflous node and can be removed */
						foundSuperflousNode = YES;
					
						g = f->left;
						h = f->anc1;
						if (f->anc1->left == f) /* p->anc up, p->left down, total: up and down for left */
							{
							h->left = g;
							g->anc1 = h;
							f->left = NULL;
							f->anc1 = NULL;
							}
						else
							{
							h->right = g;
							g->anc1 = h;
							f->left = NULL;
							f->anc1 = NULL;
							}
						}
					else if (f->left == NULL && f->right != NULL && f->anc1 != NULL)
						{
						/* this is a superflous node and can be removed */
						foundSuperflousNode = YES;
			
						g = f->right;
						h = f->anc1;
					
						if (f->anc1->left == f)
							{
							h->left = g;
							g->anc1 = h;
							f->right = NULL;
							f->anc1 = NULL;
							}
						else
							{
							h->right = g;
							g->anc1 = h;
							f->right = NULL;
							f->anc1 = NULL;
							}
						}
					else if (f->left != NULL && f->right != NULL && f->anc1 != NULL)
						{
						/* this is an internal node formed by a coalescence event, do not touch */
						}
					else if (f->left != NULL && f->right != NULL && f->anc1 == NULL)
						{
						/*fprintf (fpmpi, "\nEn superfluos. f->index = %d\n",  f->index);*/
						/*fprintf (stderr, "\nGMRCA node %d", f->index);*/
						if (a <= indNumRE)					/* THIS IS VERY IMPORTANT, "HERE" WE GIVE ALL THE MRCAs OF NODEX */
							treeRootNodex[a] = f;
						a++;
					
						/* this is the last (coalescence event) in the tree, GMRCA */
						}
					else if (f->left != NULL && f->right == NULL && f->anc1 == NULL)
						{
						/* Seems to be the last coalescent event among sequences with non-ancestral material */	
						/* it is not superfluous, we just remove it */
						f->left->anc1 = NULL;
						}
					else if (f->left == NULL && f->right != NULL && f->anc1 == NULL)
						{
						/* not clear what this node could be doing, but we will remove it anyway */
						fprintf (fpmpi, "strange\n");
						
						f->left = NULL;
						f->right->anc1 = NULL;
						}
					else
						{
						fprintf (fpmpi, "You should not be here, I think\n");
						fprintf (fpmpi, "%d %d-- %d %d %d\n", IndexSeg(f), a, IndexSeg(f->left), IndexSeg(f->right), IndexSeg(f->anc1));
						exit (-1);
						}
					}
				}
			}
		
		if (noisy == 4)
			{
			fprintf (fpmpi, "\n\nProgram Information. List about the root nodes index: ");
			for (j = 0; j <= indNumRE; j++)		
				fprintf (fpmpi, "\ntreeRootNodex[%d]->index = %d", j, treeRootNodex[j]->index); /* careful with the superfluos nodes*/
			}
		
		/*fprintf (fpmpi, "\n\nProgram Information. List about the root nodes index: ");
		for (j = 0; j <= indNumRE; j++)		
			fprintf (fpmpi, "\ntreeRootNodex[%d]->index = %d, treeRootNodex[%d]->time = %lf, NetIndex = %d, from %d to %d", j, treeRootNodex[j]->index, j, treeRootNodex[j]->time, treeRootNodex[j]->NetIndex, treeRootNodex[j]->MRCAfrom, treeRootNodex[j]->MRCAto); */
		



		/* MRCAconcatenate part */
		NodesMRCAposit[0]= -1; /* en este vector se guardara: posicion 1 es el label (=index) del nodo MRCA del nuc 1, posicion 2... */
		/*fprintf (fpmpi, "\n\n");*/
		for (sss = 1; sss <= numNuc; sss++)
			{

			for (j = 0; j <= indNumRE; j++)
				{
				if (sss >= treeRootNodex[j]->MRCAfrom && sss <= treeRootNodex[j]->MRCAto)
					{
					saveThis = 0;
					saveThis = treeRootNodex[j]->NetIndex;
					NodesMRCAposit[sss] = saveThis;
					break;

					}
				}
			/*fprintf (fpmpi, "\n Site %d for node label %d ", sss, NodesMRCAposit[sss]);*/
			}




		
		
		if (thereisOutgroup == YES)   /* special node -Outgroup- */
			{
			if (noisy > 1)
				fprintf (fpmpi, "\n\n\n>> Attaching outgroup (everytree) .. \n");
				
			if (indNumRE == 0)
				{
				/* f is the outgroup node */
				numActNodex++;
				f = nodex + numActNodex;
		
				f->left = NULL;
				f->right = NULL;
				f->anc1 = treeRootNodex[0];
				f->time = 0;
				f->length = outgroupBranchLength/mutationRate;
				f->indexOldMigPop = 0;
				f->isOutgroup = YES;
				f->index = numActNodex;
				f->NetIndex = nextAvailable++/* -1 */;	
				/* p->label = p->index;*/
				f->label = numSequences;
				f->outgroup = NULL;		/* the outgroup can't has outgroup.. */
				treeRootNodex[0]->outgroup = f;
				}
			if (indNumRE > 0)
				{
				for (step = 0; step <= indNumRE; step++)
					{
					/* p is the outgroup node */
					numActNodex++;
					f = nodex + numActNodex;
			
					f->left = NULL;
					f->right = NULL;
					f->anc1 = treeRootNodex[step];
					f->time = 0;
					f->length = outgroupBranchLength/mutationRate;
					f->indexOldMigPop = 0;
					f->isOutgroup = YES;
					f->index = numActNodex;	
					f->NetIndex = nextAvailable++/* -1 */;
					/* p->label = p->index; */
					f->label = numSequences;
					f->outgroup = NULL;	/* the outgroup can't has outgroup.. */
					treeRootNodex[step]->outgroup = f;
					}
				}
			}
		else
			{
			if (noisy > 1)
				fprintf (fpmpi, "\n");
			}

		/* relabel nodes on tree */
		if (noisy > 1)
			fprintf (fpmpi, "\n\n>> Relabeling nodes (everytree) .. \n\n");

		/* tipLabel = 0; */
		if (indNumRE == 0)
			{
			/*tipLabel = 0;*/
			if (thereisOutgroup == YES)
				intLabel = numSequences+1;
			else
				intLabel = numSequences;
			RelabelNodesSeg(treeRootNodex[0]);
			}
		if (indNumRE != 0)
			{
			for (step = 0; step <= indNumRE; step++)
				{
				/*tipLabel = 0;*/
				if (thereisOutgroup == YES)
					intLabel = numSequences+1;
				else
					intLabel = numSequences;

				RelabelNodesSeg(treeRootNodex[step]);		
				}
			}
		/** NET RECODON **/
		if (thereisOutgroup == YES)   /* NET RECODON - OUTGROUP *//* special "node" -Outgroup- */
			{
			/* r is the outgroup node */
			r = nodes + nextAvailable;
		
			r->left = NULL;
			r->right = NULL;
			r->sib = NULL;
			r->class = 2;
			r->GMRCA_ancestral = NO;
			r->breakp = NO;
			r->breakCodon = NO;
			r->anc1 = treeRootInit[0];
			r->time = 0;
			r->length = outgroupBranchLength/mutationRate;
			r->indexOldMigPop = 0;
			r->isOutgroup = YES;
			r->index = nextAvailable++;
			//r->NetIndex = nextAvailable++/* -1 */;	
			/* p->label = p->index;*/
			//r->label = numSequences;
			r->outgroup = NULL;		/* the outgroup can't has outgroup.. */
			treeRootInit[0]->outgroup = r;				
			/*nextAvailable++;*/
			}
		/*fprintf (fpmpi, "\n\n nextAvailable = %d \n\n", nextAvailable);*/
		for (i=0; i<nextAvailable; i++) /* NET RECODON - labels*/
			{
			nodes[i].label = nodes[i].index;
			/*fprintf (fpmpi, "\n\n Node index = %d, Node label = %d, class = %d, deme = %d \n\n", nodes[i].index, nodes[i].label, nodes[i].class, nodes[i].indexOldMigPop);*/
			}


		/* Cheking */
		/*for (i = 0; i < p->numSegNode; i++)	
			{
			s = segments + post(i,p->index,distance);
			if (s->after1 == NULL && s->after2 == NULL)
				{*/
				/*
				fprintf (fpmpi, "\n\nThe fragments %d isn't in the trees\n\n", s->sIndex);
				exit (-1);
				}
			}*/
		
		/*if (indNumRE+1 != countNumTrees)
			{
			fprintf (fpmpi, "\n\nWarning, indNumRE+1 %d != countNumTrees %d \n\n", indNumRE+1, countNumTrees);
			exit (-1);
			}*/
		/*for (i=0; i<nextAvailable; i++)
			{
			r = nodes+i;
			
			fprintf(fpmpi, "\n r->index = %d, r->label = %d, r->time = %lf", r->index, r->label, r->time);
			}*/
			
			
			
			
		}

	free (stud);
	/*free (treeRootInit);*/

	free (S_MRCA);
	free (OnlyAncS_MRCA);
	
	/*free (activeGametes);	*/
	/*free (segments);
	free (nodes);*/
	
	}





/*************************** GammaHotspots **************************/
/*	Distances between hotspots are distributed as 
	gamma[interval, shape]. 
*/

int GammaHotspots (double lambda, double interval, long int *seed)
{

	int	i;
	int index, numberPoissonHotspots;
	int numThinnedHotspots;
	
	numberPoissonHotspots = PoissonHotspots (lambda, seed);
	
	/*
	fprintf (stderr, "\n\nBefore thinning: ");
	for (i=0; i<numberPoissonHotspots; i++)
		fprintf (stderr, "%d ", hotspot[i]);
	*/

	/* 	When there is no interference the model reduces to a Poisson 
		so we are done */
	if (interval<= 1)
		return numberPoissonHotspots;
	

	/*	If there is interference simulate
	   	gamma by thinning current hotspots */
	/*
		   origin
	- - - ----*-----------*----*--------* - - -

	*/
	
	/* Find ordinal for first hostpot (0->interval-1) */
	index = RandomUniformTo (interval, seed);
/*	fprintf (stderr, "\nIndex1 = %d\n\nAfter thinning: ", index);*/
	
	/* Keep only hotspots numbered as "0" */
	numThinnedHotspots = 0;
	for (i=0; i<numberPoissonHotspots; i++)
		{
		if (index == interval)
			index = 0;
		if (index == 0)
			{
			hotspot[numThinnedHotspots] = hotspot[i];
			numThinnedHotspots++;
			}
		index++;	
		}
	
	hotspot = (int*) realloc (hotspot, numThinnedHotspots*sizeof(int)); 

/*	for (i=0; i<numThinnedHotspots; i++)
		fprintf (stderr, "%d ", hotspot[i]);
	fprintf (stderr, "\n\n");
*/	
	
	return numThinnedHotspots;
}



/********************* PoissonHotspots ********************/
/* Generates a random number from a Poisson distibution with
   mean lambda. Uses the fact that the time between Poisson
   occurrences is exponentially distributed
*/

int PoissonHotspots (double lambda, long int *seed)
{
	int		i, poissonNumber, numberHotspots;
	double	sum;
	
	sum = 0;
	poissonNumber = -1;
	
	/* get poisson number and exponential position */
	while (sum <= 1.0)
		{
		sum += -(1.0/lambda) * log (RandomUniform(seed));
		poissonNumber++;
		if (sum < 1.0)
			{
			hotspot[poissonNumber] = (int) floor (sum * (numNuc + 2*numSitesOutside - 1) + 0.5);
			if (poissonNumber > 0  &&  hotspot[poissonNumber] == hotspot[poissonNumber-1])
					hotspot[poissonNumber]++;
			}
		}
	
	numberHotspots = poissonNumber;
	
	/* make invalid ones to be like last valid */
		for (i=0; i<numberHotspots-1; i++)
			if (hotspot[i+1] >= numNuc + 2*numSitesOutside)
				hotspot[i+1] = hotspot[i];
			

	/* Check whether the hotspots are valid */
	for (i=0; i<numberHotspots; i++)
		{
		if (hotspot[i] >= (numNuc + 2*numSitesOutside)   ||  hotspot[i] < 0)
			{
			fprintf (stderr,"\n\nERROR: hotspot %d out of range (= %d)  numHotspots = %d  numSitesOutside = %d\n", 
						i+1, hotspot[i], numberHotspots, numSitesOutside);
			exit (-1);
			}
		}
	
	return numberHotspots;

}



/********************* UniformHotspots ********************/
/* 
	Generates a fixed number of hotspots locations from a 
  	uniform distribution. If a hotspot is overimposed upon another
  	it will be moved to the closest available location
*/

void UniformHotspots (int numberHotspots, long int *seed)
{
	int		i, j, isValid, moveLeft, sorted, pass, temp;	

	for (i=0; i<numberHotspots; i++)
		{
		/* get uniform location */
		hotspot[i] = (numNuc - 1) * RandomUniform(seed);
		
		if (hotspot[i] < 0)
			{
			fprintf (stderr, "\nERROR: hotspot location is %d\n", hotspot[i]);
			exit(-1);
			}
		
		/* in case is needed, decide to move left or move right */
		if (hotspot[i] > ((numNuc+ 2*numSitesOutside - 1)/2.0))
			moveLeft = YES;
		else
			moveLeft = NO;	

		isValid = NO;
		/* while this hotspot is occupied, move it one position at a time */
		while (isValid == NO)
			{
			isValid = YES;
			for (j=0; j<i; j++)
				{
				if (hotspot[i] == hotspot[j])
					{
					isValid = NO;
					if (moveLeft == NO)
						hotspot[i]++;
					else	
						hotspot[i]--;
					break;
					}
				}
			}
		}

	/* order hotspots from left to right */
	sorted = NO; 
	pass = 1; 
	while (sorted == NO)
		{
		sorted = YES;
		for (i=0; i < (numberHotspots-pass); i++)
	 		if (hotspot[i] > hotspot [i+1])
				{
				temp = hotspot[i];
				hotspot[i] = hotspot[i+1];
				hotspot[i+1] = temp;
				sorted = NO; 
				}
		pass++;	
		} 


	/* make invalid ones to be like last valid */
		for (i=0; i<numberHotspots-1; i++)
			if (hotspot[i+1] >= numNuc + 2*numSitesOutside)
				hotspot[i+1] = hotspot[i];

	/* Check whether the hotspots are valid */
	for (i=0; i<numberHotspots; i++)
		{
		if (hotspot[i] >= (numNuc + 2*numSitesOutside)   ||  hotspot[i] < 0)
			{
			fprintf (stderr,"\n\nERROR: hotspot %d out of range (= %d)  numHotspots = %d  numSitesOutside = %d\n", 
						i+1, hotspot[i], numberHotspots, numSitesOutside);
			exit (-1);
			}
		}

}



/************************ SimRecombinationPDF ***********************/
/* 
	Simulates a probability density function for recombination
	along the gene. The number of hotspots will be distributed 
	as a Poisson while their position is exponential. The position
	of the breakpoints follows a Normal (hotpost, imprecision) or  
	a Uniform(hotspotWidth). In the latter case we do not need to simulate.

	Added heterogeneity of hotspot recombination rate 
	(with gamma distribution)

*/

void SimRecombinationPDF (double *counts, long int *seed)
{
	int		i, k;
	int		breakpoint, before, after;
	double	gammaVariable;
	
	for (i=0; i<numHotspots; i++)
		{
		if (hotspotHeterogeneity == YES)
			gammaVariable = RandomGamma (alpha, seed) / alpha;
		else
			gammaVariable = 1;	

		if (hotspotUniform == YES) 
			{
			if (hotspotWidth == 1)
				counts[hotspot[i]] += gammaVariable * numPointsRecPDF;
			else
				{
				before = hotspotWidth/2.0;
				if (hotspotWidth%2 != 0)
					after = hotspotWidth/2.0 + 1;
				else
					after = hotspotWidth/2.0;	
				for (breakpoint = hotspot[i]-before; breakpoint < hotspot[i]+after; breakpoint++)
					 counts[breakpoint] += gammaVariable * numPointsRecPDF/(double)hotspotWidth;
				}
			}
		else
			{
			if (hotspotImprecision == 0)
				counts[hotspot[i]] += gammaVariable * numPointsRecPDF;
			else
				{
				for (k=0; k<numPointsRecPDF; k++)
					{
					breakpoint = (int) floor (RandomNormal (hotspot[i], hotspotImprecision, seed) + 0.5);
					if (breakpoint < 0 || breakpoint >= numSites+2.0*numSitesOutside)
						continue;
					counts[breakpoint] += gammaVariable;
					}
				}
			}
		}
}










/********************* CalcREprobs ********************/
/* 
	Returns an array (k = 2 to numSequences) with the
	probability that the recombination occurs while there
	are k lineages 
*/

/*double *CalcREprobs (int numSequences, int rateType)
{
	int			j, k;
	double		*probs;
	double		probs_sum;
	double		rate, jrate, sum;*/
	
	
	/*probs = (double *) calloc((numSequences-1),(long) sizeof(double));
		if (!probs)
		{
		fprintf (fpmpi, "Could not allocate probs (%lu bytes)\n", (numSequences-1) *(long) sizeof(double));
		exit (-1);
		}
	
	probs_sum = 0;
	for (k=numSequences; k>1; k--)
		{*/
		/* which rate type */
		/*if (rateType == 1)*/	/* short external branches and long internal ones */
			/*rate = k * (k - 1) / 2.0;
		else if (rateType == 2)*/	/* in between */
			/*rate = 1;
		else if (rateType == 3)*/ /* long external branches and short internal ones */
			/*rate = numSequences - k + 2.0;*/

		/* calculate the sum term */
		/*sum = 0;
		for (j=2; j<=numSequences; j++)
			{
			if (rateType == 1)*/	/* short external branches and long internal ones */
				/*jrate = j * (j - 1) / 2.0;
			else if (rateType == 2)*/	/* in between */
				/*jrate = 1;
			else if (rateType == 3)*/ /* long external branches and short internal ones */
				/*jrate = numSequences - j + 2.0;

			sum += j / jrate;
			}*/

		/* probability that the recombination occurs while there are k lineages */
		/*probs[k] = (k / rate) / (sum);
		probs_sum += probs[k];*/
		
		
		/*
		fprintf (fpmpi, "\nprobs with %-2d lineages = %6.4f", k, probs[k]);
		fprintf (fpmpi, " (%6.4f)", probs_sum);
		*/
		/*}

	return probs;
}*/






/*********************************************** Codon Model ********************************************/
/* Functions to codon model. Some of them were taken from code provided by R. Nielsen and Z. Yang. 
  It will be showed */
/********************************************************************************************************/

/********************************** EvolveSequenceOnTree_Codon ***********************************/
/* This function evolves sequences on the coalescent trees by codon model */

void EvolveSequenceOnTree_Codon (long int *seed, double m, 
							double alpha, int numNuc, int indNumRE, int *arrayIndBreakpointsOrd, char *MRCAsequence, int numOmegaCat, int numSites)
	{
	int			i, w, n, a, j, sitePosition, siteCodon, numCo, controlStopCodon, Cbroke, M8option;
	double		varRate, ran, cumFreq[64];
	int			out_C[4], codon[3];
	int			*codonMRCASeq, *arrayIndBreakpointsOrd_C;
	double 		*cumProbCatM1, *cumProbCatM8, *cumProbCat, *hetProb;
	double		betaVar, GammaVarRateOmega, VarOmega1;
	double		cumProbCatM6[3], cumProbCatM910[3];
	double		GammaVarRateOmegaM6, VarOmegaM6, GammaVarRateOmegaM910, VarOmegaM910;
	double		BBM0GammaVarRateOmega, BBM0VarOmega1, BBM0omega, BBM0betaVar, BBM0M7_FinalSite_omega, BBM0partialomega;
	double		*BBM0cumProbCat;
	int			e, BBM0ProbCategory;
	TreeNode	*q;
	/*double		Qij_C[NUMCOD][NUMCOD];*/ /* global variable */

	w = sitePosition = controlStopCodon = a = j = M8option = e = 0;
	n = siteCodon = 1;
	out_C[0] = out_C[1] = out_C[2] = out_C[3] = -1;
	Cbroke = NO;
	doRepitEvol = NO;
	BBM0omega = -1;	


	codonMRCASeq = (int *)calloc((numSites+1),(long) sizeof(int));
	if (!codonMRCASeq)
		{
		fprintf (fpmpi, "Could not allocate codonMRCASeq (%lu bytes)\n", (numSites+1)  * (long) sizeof(int));		
		exit (1);
		}
	arrayIndBreakpointsOrd_C = (int *)calloc((indNumRE+1),(long) sizeof(int));
	if (!arrayIndBreakpointsOrd_C)
		{
		fprintf (fpmpi, "Could not allocate arrayIndBreakpointsOrd_C (%lu bytes)\n", (indNumRE+1)  * (long) sizeof(int));
		exit (1);
		}
	

	/* making codon breakpoints */
	for (i = 0; i < indNumRE+1; i++)
		arrayIndBreakpointsOrd_C[i] = fabs(arrayIndBreakpointsOrd[i]/3);
	
	if (doMRCAFile == YES) /* MRCA from File */
		{
		for (i = 1; i <= numNuc; i++)		/* taking MRCA sequence */
			{
			sitePosition = n;	/* site position */
			n++;
			if (n == 4)
				n = 1;
		
			if (i == arrayIndBreakpointsOrd[w]) /* recombinations, breakpoints. CAMBIA LA RAIZ DEL ARBOL */
				w++;
		

			w = 0; /* NETRECODON Ahora solo hay un nodo raiz, "GMRCA" base de toda la red */
			

			if (sitePosition == 1)
				out_C[1] = EnterCodonMRCA_File (treeRootInit[w], i, numNuc, MRCAsequence, out_C);
			else if (sitePosition == 2)
				out_C[2] = EnterCodonMRCA_File (treeRootInit[w], i, numNuc, MRCAsequence, out_C);
			else
				{
				out_C[3] = EnterCodonMRCA_File (treeRootInit[w], i, numNuc, MRCAsequence, out_C);
			
				if ((out_C[1] == 3 && out_C[2] == 0 && out_C[3] == 0) || (out_C[1] == 3 && out_C[2] == 0 && out_C[3] == 2) || (out_C[1] == 3 && out_C[2] == 2 && out_C[3] == 0)) /* Checking stop codons */
					{
					fprintf (fpmpi, "\nWarning: There are some STOP CODON in your MRCA sequence:");
					if (out_C[1] == 3 && out_C[2] == 0 && out_C[3] == 0)
						fprintf (fpmpi, " TAA");
					if (out_C[1] == 3 && out_C[2] == 0 && out_C[3] == 2)
						fprintf (fpmpi, " TAG");
					if (out_C[1] == 3 && out_C[2] == 2 && out_C[3] == 0)
						fprintf (fpmpi, " TGA");
					exit(-1);
					}
				if (out_C[0] != -1 || out_C[1] != -1 || out_C[2] != -1 || out_C[3] != -1)	
					{
					matrixC[pos(out_C[0] /*p->label*/,siteCodon,numSites)] = makeCodonFromNuc(out_C[1], out_C[2], out_C[3]);
					
					if (matrixC[pos(out_C[0] /*p->label*/,siteCodon,numSites)] > 60)
						{
						fprintf (fpmpi, "\n stop codon20 \n");
						exit(-1);
						}
					siteCodon++;
					out_C[0] = out_C[1] = out_C[2] = out_C[3] = -1;
					}
				else
					{
					fprintf (fpmpi, "\nWarning: Error from EnterCodonMRCA function");
					exit (-1);
					}
				}
			}
		}
	else /* MRCA from nucleotide frequencies */
		{

		cumFreq[0] = codonTable_frequencies_MRCA(0);
		for (i = 1; i <= 63; i++)
			cumFreq[i] = cumFreq[i-1] + codonTable_frequencies_MRCA(i);

		/*fprintf (fpmpi, "\n cumFreq[0] = %lf", cumFreq[0]);*/
		for (i = 1; i <= 63; i++)
			{
			cumFreq[i] = cumFreq[i]/cumFreq[63];
			/*fprintf (fpmpi, "\n cumFreq[%d] = %lf", i, cumFreq[i]);*/
			}
		
		
		for (i=1; i <= numSites; i++)
			{
			ran = RandomUniform(seed);
			codonMRCASeq[i] = bbin_EnterMRCA(ran, cumFreq); /* codon MRCA sequence */
			/*if (i == 1)
				{
				fprintf (fpmpi, "\n ran = %lf", ran);
				fprintf (fpmpi, "\n codonMRCASeq[%d] = %d", i, codonMRCASeq[i]);
				}*/
			
			/*fprintf (fpmpi, "\n codon[%d] = %d", i, codonMRCASeq[i]);*/  /* active to see the GMRCA codon sequence */
			
			if (codonMRCASeq[i] == 48 || codonMRCASeq[i] == 50 || codonMRCASeq[i] == 56) /* Cheking stop codons */
				{
				fprintf (fpmpi, "\n Warning by stop codons in EvolveSequenceOnTree_Codon");
				exit (-2);
				}
			}
		

		numCo = 1;
		for (i = 1; i <= numNuc; i++)
			{
			/*fprintf (fpmpi, "\n nuc %d, numCo %d", i, numCo);*/			
			
			sitePosition = n;	/* site position */
			n++;
			
			if (n == 4)
				n = 1;
				
			if (sitePosition == 1 && i != 1)
				numCo++;
				
			if (i == arrayIndBreakpointsOrd[w]) /* recombinations, breakpoints */
				w++;					
			w = 0; /* NETRECODON Ahora solo hay un nodo raiz, "GMRCA" base de toda la red */


			number_to_codon_MRCA(codonMRCASeq[numCo], codon); /* de un codon salen 3 nucleotidos para el vector "codon" */


			if (sitePosition == 1)
				{
				out_C[1] = EnterCodonMRCA_Freq (treeRootInit[w], i, sitePosition, numNuc, out_C, codon);
				/*fprintf (fpmpi, "\n out_C[%d] = %d", sitePosition, out_C[sitePosition]);*/
				}
			else if (sitePosition == 2)
				{
				out_C[2] = EnterCodonMRCA_Freq (treeRootInit[w], i, sitePosition, numNuc, out_C, codon);
				/*fprintf (fpmpi, "\n out_C[%d] = %d", sitePosition, out_C[sitePosition]);*/
				}
			else
				{
				out_C[3] = EnterCodonMRCA_Freq (treeRootInit[w], i, sitePosition, numNuc, out_C, codon);
				/*fprintf (fpmpi, "\n out_C[%d] = %d", sitePosition, out_C[sitePosition]);*/	

				if ((out_C[1] == 3 && out_C[2] == 0 && out_C[3] == 0) || (out_C[1] == 3 && out_C[2] == 0 && out_C[3] == 2) || (out_C[1] == 3 && out_C[2] == 2 && out_C[3] == 0))
					{
					fprintf (fpmpi, "\nWarning: There are some STOP CODONS in the MRCA sequence:");
					if (out_C[1] == 3 && out_C[2] == 0 && out_C[3] == 0)
						fprintf (fpmpi, " TAA");
					if (out_C[1] == 3 && out_C[2] == 0 && out_C[3] == 2)
						fprintf (fpmpi, " TAG");
					if (out_C[1] == 3 && out_C[2] == 2 && out_C[3] == 0)
						fprintf (fpmpi, " TGA");						
					exit(-1);
					}
				
				if (out_C[0] != -1 || out_C[1] != -1 || out_C[2] != -1 || out_C[3] != -1)	
					{
					matrixC[pos(out_C[0] /*p->label*/,siteCodon,numSites)] = makeCodonFromNuc(out_C[1], out_C[2], out_C[3]);
					/*fprintf (fpmpi, "\n from nuc Freq, GMRCA, out_C_0 = %d\n", out_C[0]);*/
					
					if (matrixC[pos(out_C[0] /*p->label*/,siteCodon,numSites)] > 60)
						{
						fprintf (fpmpi, "\n stop codon21 \n");
						exit(-1);
						}
					siteCodon++;
					out_C[0] = out_C[1] = out_C[2] = out_C[3] = -1;
					}
				else
					{
					fprintf (fpmpi, "\nWarning: Error from EnterCodonMRCA function");
					exit (-1);
					}
				}
			}
		

		}
	

	free (codonMRCASeq);
	


	/*fprintf (fpmpi, "\n Entra en la recursion, EvolveSequenceOnTree_Codon, numRE = %d, numREbreakCod = %d", numRE, numREbreakCod);*/
	w = 0;
	if (doPrintOmegasPerSitefiles == YES && doVariableDnDsBranches == NO) /* print omegas to file */
		fprintf(fpOmegasPerSitePrint,"Site      OmegaValue\n");
	if (doPrintOmegasPerSitefiles == YES && doVariableDnDsBranches == YES) /* print omegas to file */
		fprintf(fpOmegasPerSitePrint,"Site,   Branch   ->   OmegaValue\n");

	if  (doVariableDnDsBranches == YES && doOmegaProb == NO && doOmegaRateHetDisc == NO && doM1 == NO)
		{
		if (noisy >= 2)
			fprintf (stderr, "> Variable omega per branch may take some time \n");
		}

	/**** Special for dN/dS constant (M0) in per dN/dS branch *****/
	if  (doVariableDnDsBranches == YES && doBBM0 == YES) /* BBmodelNumber 1,2,3 */
		{
		/*fprintf (stderr, "\n * Variable omega per branch and M0 *\n");*/

		for (a=0; a<nextAvailable; a++)
			{
			if (BBmodelNumber == 1) /* categories from the user */ /* BBnumOmegaCat, BBomegaVal, BBomegaProb,  */
				{
				BBM0cumProbCat =  (double*) calloc ((BBnumOmegaCat+1), sizeof (double));  
				if (BBM0cumProbCat == NULL)
					{
					fprintf (fpmpi, "Could not allocate BBM0cumProbCat (%lu bytes)", (BBnumOmegaCat+1) * (long) sizeof (double));
					exit(1);
					}
			
				for (e=1; e<=BBnumOmegaCat; e++)
					BBM0cumProbCat[e] = 0;
				BBM0cumProbCat[0] = 0;
	
				for (e=1; e<=BBnumOmegaCat; e++)
					BBM0cumProbCat[e] = BBM0cumProbCat[e-1] + BBomegaProb[e];
				ran = RandomUniform(seed);

				BBM0ProbCategory = bbinInOmegaCat (ran, BBM0cumProbCat, BBnumOmegaCat);
				e = 0;
				free (BBM0cumProbCat);
				/*fprintf (stderr, "\n BBM0ProbCategory = %d \n", BBM0ProbCategory);*/

				BBM0partialomega = BBomegaVal[BBM0ProbCategory];
				BBM0omega = roundit(BBM0partialomega,5);

				/*fprintf (stderr, "\n BBM0omega 1 = %lf", BBM0omega);*/
				}
			else if (BBmodelNumber == 2) /* gamma distribution */ /* BBOmegaRateHet, BBomega, BBOmegaInit */
				{
				BBM0GammaVarRateOmega = RndGamma (BBOmegaRateHet, seed) / BBOmegaRateHet; 
				BBM0VarOmega1 = BBOmegaInit*BBM0GammaVarRateOmega;
				BBM0omega = roundit(BBM0VarOmega1,5);

				/*fprintf (stderr, "\n BBM0omega 2 = %lf", BBM0omega);*/
				}
			else if (BBmodelNumber == 3) /* beta distribution */ /* BBM7_p_beta, BBM7_q_beta */
				{
				BBM0betaVar = RandomBeta (BBM7_p_beta, BBM7_q_beta, seed);
				BBM0M7_FinalSite_omega = BBM0betaVar;
				BBM0omega = roundit(BBM0M7_FinalSite_omega,5);

				/*fprintf (stderr, "\n BBM0omega 3 = %lf", BBM0omega);*/
				}
			else
				{
				fprintf (stderr, "\n ERROR in EvolveSequenceOnTree_Codon function, bad M0 model from dN/dS per branch: BBmodelNumber (%d) \n", BBmodelNumber);
				exit (-1);
				}

			q = nodes + a;
			q->BBM0omg = BBM0omega;

			/*fprintf (stderr, "\n Branch: %d, BBM0omega = %lf, q->BBM0omg = %lf ", a, BBM0omega, q->BBM0omg);*/
			}
		a = 0;

		}
	/********/




	/************ FOR EACH SITE (CODON)**********/	
	for (i = 1; i <= numSites; i++)	/************* Other sequences */ /* Hace esto para cada codon FOR EACH SITE (CODON)**********/
		{
		/*fprintf (fpmpi, "\n\n +++++++ CODON = %d ++++++++ \n\n", i);*/
		Cbroke = NO;
		


		/******* ALL VARIABLE CODON MODELS PER SITE. PROB, GAMMA, M1, M7 and M8 codon models *******/
		if (doVariableDnDsBranches == NO) /* variation only per site, not per branch */
		{
		if (doOmegaProb == YES)
			{
			cumProbCat =  (double*) calloc ((numOmegaCat+1), sizeof (double));  
			if (cumProbCat == NULL)
				{
				fprintf (fpmpi, "Could not allocate cumProbCat (%lu bytes)", (numOmegaCat+1) * (long) sizeof (double));
				exit(1);
				}
			
			for (j=1; j<=numOmegaCat; j++)
				cumProbCat[j] = 0;
			cumProbCat[0] = 0;
			for (j=1; j<=numOmegaCat; j++)
				cumProbCat[j] = cumProbCat[j-1] + omegaProb[j];
			ran = RandomUniform(seed);
			ProbCategory = bbinInOmegaCat (ran, cumProbCat, numOmegaCat);
			j = 0;
			free (cumProbCat);
			/*fprintf (stderr, "\n ProbCategory = %d \n", ProbCategory);*/
			if (doPrintOmegasPerSitefiles == YES) /* print omegas to file */
				{
				fprintf(fpOmegasPerSitePrint,"Site %d - Omega %3.5f\n", i, omegaVal[ProbCategory]);
				}
			}

		if (doOmegaRateHetDisc == YES)
			{
			hetProb =  (double*) calloc ((numOmegaCat+1), sizeof (double));  
			if (hetProb == NULL)
				{
				fprintf (fpmpi, "Could not allocate hetProb (%lu bytes)", (numOmegaCat+1) * (long) sizeof (double));
				exit(1);
				}
			cumProbCat =  (double*) calloc ((numOmegaCat+1), sizeof (double));  
			if (cumProbCat == NULL)
				{
				fprintf (fpmpi, "Could not allocate cumProbCat (%lu bytes)", (numOmegaCat+1) * (long) sizeof (double));
				exit(1);
				}			


			for (j=1; j<=numOmegaCat; j++)
				{
				cumProbCat[j] = 0;
				hetProb[j] = 1.0/numOmegaCat;
				}
			cumProbCat[0] = 0;
			for (j=1; j<=numOmegaCat; j++)
				cumProbCat[j] = cumProbCat[j-1] + hetProb[j];
			ran = RandomUniform(seed);
			GammCategory = bbinInOmegaCat (ran, cumProbCat, numOmegaCat);
			j = 0;
			free (hetProb);
			free (cumProbCat);

			/*fprintf (stderr, "\n GammCategory = %d \n", GammCategory);*/
			if (doPrintOmegasPerSitefiles == YES) /* print omegas to file */
				{
				fprintf(fpOmegasPerSitePrint,"Site %d - Omega %3.5f\n", i, omegaValGammaRate[GammCategory]);
				}
			}



		if (doM1 == YES) /* for each site */ /* Important Note: M1_FinalSite_omega = 1, prop0, omega will be 0; if M1_FinalSite_omega = 2, prop1, omega will be 1  */
			{
			cumProbCatM1 =  (double*) calloc ((numOmegaCat+1), sizeof (double));  
			if (cumProbCatM1 == NULL)
				{
				fprintf (fpmpi, "Could not allocate cumProbCatM1 (%lu bytes)", (numOmegaCat+1) * (long) sizeof (double));
				exit(1);
				}
			
			/*fprintf(fpmpi,"\n Categ number = %d \n", numOmegaCat);*/ 


			for (j=1; j<=numOmegaCat; j++)
				cumProbCatM1[j] = 0;
			cumProbCatM1[0] = 0;
			for (j=1; j<=numOmegaCat; j++)
				{
				cumProbCatM1[j] = cumProbCatM1[j-1] + omegaProb[j];
				/*fprintf (stderr, "\n cumProbCatM1[%d] = %lf \n", j, cumProbCatM1[j]);*/
				}
			ran = RandomUniform(seed);
			M1_FinalSite_omega = bbinInOmegaCat (ran, cumProbCatM1, numOmegaCat);
			j = 0;
			/*fprintf (stderr, "\n M1_FinalSite_omega (or category) = %d, ran = %lf \n", M1_FinalSite_omega, ran);*/
			if (doPrintOmegasPerSitefiles == YES) /* print omegas to file */
				{
				if (M1_FinalSite_omega == 1)
					{
					fprintf(fpOmegasPerSitePrint,"Site %d - Omega %3.5f\n", i, M1_omega0);
					}
				if (M1_FinalSite_omega == 2)
					{
					fprintf(fpOmegasPerSitePrint,"Site %d - Omega 1.00000\n", i);
					}
				}
			
			free (cumProbCatM1);
			}
		

		if (doOmegaRateHetCont == YES) /* M5. for each site */
			{
			GammaVarRateOmega = RndGamma (OmegaRateHet, seed) / OmegaRateHet; 
			VarOmega1 = OmegaInit*GammaVarRateOmega;
			omega = roundit(VarOmega1,5);
			if (doPrintOmegasPerSitefiles == YES) /* print omegas to file */
				{
				fprintf(fpOmegasPerSitePrint,"Site %d - Omega %3.5f\n", i, omega);
				}
			/*fprintf(stderr,"doOmegaRateHetCont - Site %d - Omega %3.5f\n", i, omega);*/

			/*fprintf(stderr, "\nBEFORE Cijk_C[10*NUMCOD*NUMCOD+10*NUMCOD+10] = %d\n", Cijk_C[10*NUMCOD*NUMCOD+10*NUMCOD+10]);
			fprintf(stderr, "\nBEFORE Cijk_C[5*NUMCOD*NUMCOD+5*NUMCOD+5] = %d\n", Cijk_C[5*NUMCOD*NUMCOD+5*NUMCOD+5]);*/

			buildCodonMatrix_Qij_Cijk ();
			/*fprintf(stderr, "\nAFTER Cijk_C[10*NUMCOD*NUMCOD+10*NUMCOD+10] = %d\n", Cijk_C[10*NUMCOD*NUMCOD+10*NUMCOD+10]);
			fprintf(stderr, "\nAFTER Cijk_C[5*NUMCOD*NUMCOD+5*NUMCOD+5] = %d\n", Cijk_C[5*NUMCOD*NUMCOD+5*NUMCOD+5]);*/	
			}

		if (doM6 == YES) /* for each site */
			{		/* M6_P0, M6_P1; OmegaRateHetM6_0 OmegaM6_0 OmegaInitM6_0; OmegaRateHetM6_1 OmegaM6_1 OmegaInitM6_1 */

			for (j=1; j<=2; j++)
				cumProbCatM6[j] = 0;
			cumProbCatM6[0] = 0;
			cumProbCatM6[1] = M6_P0;
			cumProbCatM6[2] = M6_P0 + M6_P1;

			ran = RandomUniform(seed);
			M6_FinalSite_omega = bbinInOmegaCat (ran, cumProbCatM6, 2);
			j = 0;
			/*fprintf (stderr, "\n M6_FinalSite_omega (or category) = %d, ran = %lf \n", M6_FinalSite_omega, ran);*/


			if (M6_FinalSite_omega == 1) /* gamma distribt 1 */
				{
				GammaVarRateOmegaM6 = RndGamma (OmegaRateHetM6_0, seed) / OmegaRateHetM6_0; 
				VarOmegaM6 = OmegaInitM6_0*GammaVarRateOmegaM6;
				omega = roundit(VarOmegaM6,5);
				}
			else if (M6_FinalSite_omega == 2) /* gamma distribt 2 */
				{
				GammaVarRateOmegaM6 = RndGamma (OmegaRateHetM6_1, seed) / OmegaRateHetM6_1; 
				VarOmegaM6 = OmegaInitM6_1*GammaVarRateOmegaM6;
				omega = roundit(VarOmegaM6,5);
				}
			else
				{
				fprintf (stderr, "\n ERROR in EvolveSequenceOnTree_Codon function, M6 codon model. Parameter M6_FinalSite_omega must be 1 or 2 (%d) \n", M6_FinalSite_omega);
				exit (-1);
				}
			/*fprintf(stderr,"Site %d - Omega %3.5f\n", i, omega);*/
			buildCodonMatrix_Qij_Cijk ();


			if (doPrintOmegasPerSitefiles == YES) /* print omegas to file */
				{
				fprintf(fpOmegasPerSitePrint,"Site %d - Omega %3.5f\n", i, omega);
				}			
			}

		if (doM7 == YES) /* for each site */  
			{
			/*fprintf (stderr, "\n M7_p_beta = %lf, M7_q_beta = %lf \n", M7_p_beta, M7_q_beta);*/	
			betaVar = RandomBeta (M7_p_beta, M7_q_beta, seed); /* Thanks to David Posada! */
			M7_FinalSite_omega = betaVar;

			omega = roundit(M7_FinalSite_omega,5);

			/*omega = M7_FinalSite_omega;
			if (omega < 0.001)
				omega = 0.00;*/	
			/*fprintf (stderr, "\n M7: Site %d, omega = %lf, M7_FinalSite_omega = %lf  \n", i, omega, M7_FinalSite_omega);*/	
			buildCodonMatrix_Qij_Cijk ();

			if (doPrintOmegasPerSitefiles == YES) /* print omegas to file */
				{
				fprintf(fpOmegasPerSitePrint,"Site %d - Omega %3.5f\n", i, omega);
				}
			}


		if (doM8 == YES) /* for each site */  
			{
			cumProbCatM8 =  (double*) calloc ((3), sizeof (double));  
			if (cumProbCatM8 == NULL)
				{
				fprintf (fpmpi, "Could not allocate cumProbCatM8 (%lu bytes)", (3) * (long) sizeof (double));
				exit(1);
				}

			for (j=0; j<=2; j++)
				cumProbCatM8[j] = 0;
			/*fprintf (stderr, "\n M8_P0_beta = %lf, M8_P1_omega = %lf \n", M8_P0_beta, M8_P1_omega);*/			
			for (j=1; j<=2; j++)
				{
				if (j == 1)
					{
					cumProbCatM8[j] = cumProbCatM8[j-1] + M8_P0_beta;
					}
				if (j == 2)
					{
					cumProbCatM8[j] = cumProbCatM8[j-1] + M8_P1_omega;
					}
				/*fprintf (stderr, "\n cumProbCatM8[%d] = %lf \n", j, cumProbCatM8[j]);*/
				}
			
			ran = RandomUniform(seed);
			M8option = bbinInOmegaCat (ran, cumProbCatM8, 2);
			j = 0;			
			free (cumProbCatM8);
			M8_FinalSite_omega = -1.0;
			/*fprintf (stderr, "\n M8option (or category) = %d, ran = %lf \n", M8option, ran);*/

			if (M8option == 1) /* beta distribution */ /* M8_p_beta, M8_q_beta -> M8_omegaP0 */
				{
				/* From David Posada. Thanks to David!! */
				/*int		i, numReps;
				long int	seed;
				double	betaVar, p, q, sum, sumsq, variance;
				seed = time(NULL); 			
				p = 0.3;
				q = 0.5;
				sum = 0;
				numReps = 1000;
				fprintf (stderr, "beta variable = ");
				for (i=0; i<numReps; i++)
					{
					betaVar = RandomBeta (p, q, &seed);
					fprintf (stderr, " %6.4f", betaVar);
					sum += betaVar;
					sumsq += pow(betaVar,2);
					}
				variance = (1.0 / (double) (numReps-1)) * (sumsq - pow(sum,2) / (double) numReps);
				fprintf (stderr, "\nmean = %6.4f  var = %6.4f", sum/=numReps, variance);
				return 0;*/

				betaVar = RandomBeta (M8_p_beta, M8_q_beta, seed);
				M8_omegaP0 = betaVar;
				M8_FinalSite_omega = M8_omegaP0;
				/*fprintf (stderr, "\n option 1, omega = %lf   D.beta: p = %lf, q = %lf \n", M8_FinalSite_omega, M8_p_beta, M8_q_beta);*/
				}
			else if (M8option == 2) /* direct omega */
				{
				M8_FinalSite_omega = M8_omegaP1;
				/*fprintf (stderr, "\n option 2, omega = %lf \n", M8_FinalSite_omega);*/
				}
			else
				{
				fprintf (fpmpi, "\n Error in M8option (%d): EvolveSequenceOnTree_Codon \n", M8option);
				exit(1);
				}
			

			if (M8_FinalSite_omega == -1.0) /* Check point */
				{
				fprintf (fpmpi, "\n Error in M8_FinalSite_omega (-1): EvolveSequenceOnTree_Codon \n");
				exit(1);
				}

			/*fprintf (stderr, "\n M8: Site %d, M8_FinalSite_omega = %lf  \n", i, M8_FinalSite_omega);*/
			/*omega = M8_FinalSite_omega;*/
			
			omega = roundit(M8_FinalSite_omega,5);

			/*fprintf (stderr, "\n M8: Site %d, omega = %lf  \n", i, omega);*/
			/*if (omega < 0.001)
				omega = 0.00;*/

			buildCodonMatrix_Qij_Cijk ();

			if (doPrintOmegasPerSitefiles == YES) /* print omegas to file */
				{
				fprintf(fpOmegasPerSitePrint,"Site %d - Omega %3.5f\n", i, omega);
				}
			}


		if (doM9 == YES || doM10 == YES) /* for each site */
			{		/* M910_P0, M910_P1; M910_p_beta M910_q_beta; OmegaRateHetM910_1 OmegaM910_1 OmegaInitM910_1 */

			for (j=1; j<=2; j++)
				cumProbCatM910[j] = 0;
			cumProbCatM910[0] = 0;
			cumProbCatM910[1] = M910_P0;
			cumProbCatM910[2] = M910_P0 + M910_P1;

			ran = RandomUniform(seed);
			M910_FinalSite_omega = bbinInOmegaCat (ran, cumProbCatM910, 2);
			j = 0;
			/*fprintf (stderr, "\n M910_FinalSite_omega (or category) = %d, ran = %lf \n", M910_FinalSite_omega, ran);*/


			if (M910_FinalSite_omega == 1) /* beta distribt */
				{
				/*fprintf (stderr, "\n M910_p_beta = %lf, M910_q_beta = %lf \n", M910_p_beta, M910_q_beta);*/	
				betaVar = RandomBeta (M910_p_beta, M910_q_beta, seed); /* Thanks to David Posada! */
				VarOmegaM910 = betaVar;

				omega = roundit(VarOmegaM910,5);
			
				/*fprintf (stderr, "\n M9 or M10: Site %d, M910_p_beta = %lf, M910_q_beta = %lf, betaVar = %lf, VarOmegaM910 = %lf, omega = %lf \n", i, M910_p_beta, M910_q_beta, betaVar, VarOmegaM910, omega);*/	
				}
			else if (M910_FinalSite_omega == 2) /* gamma distribt */
				{
				if (doM9 == YES) /* GammaVarRateOmegaM910, VarOmegaM910 */
					{
					GammaVarRateOmegaM910 = RndGamma (OmegaRateHetM910_1, seed) / OmegaRateHetM910_1; 
					VarOmegaM910 = OmegaInitM910_1*GammaVarRateOmegaM910;
					omega = roundit(VarOmegaM910,5);
					}
				else if (doM10 == YES) 
					{
					GammaVarRateOmegaM910 = RndGamma (OmegaRateHetM910_1, seed) / OmegaRateHetM910_1; 
					VarOmegaM910 = OmegaInitM910_1*GammaVarRateOmegaM910;
					omega = roundit(VarOmegaM910,5);

					omega = omega + 1; /* in Model M10, omega from the beta distribution is +1, so here always > 1: PSSs */
					}
				else
					{
					fprintf (stderr, "\n ERROR in EvolveSequenceOnTree_Codon function, M9 or M10 codon model. \n");
					exit (-1);
					}
				}
			else
				{
				fprintf (stderr, "\n ERROR in EvolveSequenceOnTree_Codon function, M9 or M10 codon model. Parameter M910_FinalSite_omega must be 1 or 2 (%d) \n", M910_FinalSite_omega);
				exit (-1);
				}

			/*fprintf(stderr,"Site %d (case %d) - Omega %3.5f\n", i, M910_FinalSite_omega, omega);*/
			/*fprintf(stderr,"Site %d - Omega %3.5f\n", i, omega);*/
			buildCodonMatrix_Qij_Cijk ();


			if (doPrintOmegasPerSitefiles == YES) /* print omegas to file */
				{
				fprintf(fpOmegasPerSitePrint,"Site %d - Omega %3.5f\n", i, omega);
				}			
		
			}
		}

		/*** End ALL VARIABLE CODON MODELS ***/



		/*fprintf (fpmpi, "\n--- COMIENZA RED SOBRE CODON %d ---\n", i);*/
		for (a=0; a<nextAvailable; a++) /*Para ver si este codon se rompe en su evolucion*/
			{
			q = nodes + a;
			//fprintf (fpmpi, "\n\n q->breakCodon = %d \n\n", q->breakCodon);
			if (i == q->breakCodon)
				{
				Cbroke = YES; /* el codon i se rompe */
				/*fprintf (fpmpi, "Este codon se rompe de este nodo, q->index = %d,  q->label = %d \n", q->index, q->label);*/
				}
			}

		if (RandomUniform(seed) < pinv)		
			varRate = 0.0;
		else
			{
			if (doRateHet == YES)
				varRate = RndGamma (alpha, seed) / alpha; 
			else
				varRate = 1; 
			}
		if (doHetVectorFile == YES)
			{
			varRate = varRate*vectorHetRates[i-1];
			}
		

		if (i == (arrayIndBreakpointsOrd_C[w]+1) && indNumRE != 0)
			w++;
		
		w = 0; /* NETRECODON Ahora solo hay un nodo raiz, "GMRCA" base de toda la red */
		if (doRepitEvol == NO)
		  SimulateDataForSite_Codon_RECURSIVE_NET (treeRootInit[w], i, numSites, m, numOmegaCat, varRate, seed, Cbroke);
		}
	/*fprintf (fpmpi, "\n\n SALE DE LA RECURSION \n\n");*/
	


	if (doRepitEvol == NO) 
		free (arrayIndBreakpointsOrd_C);
	else /* Reorganiza si la evolucion no fue valida */
		{
		/*fprintf (fpmpi, "\n\n SALE CON CODONES STOP \n\n");*/
		/*exit (2);*/
		for (a=0; a<nextAvailable; a++) /*reorganiza los nodos como al inicio*/
			{
			q = nodes + a;
			q->passNumber = 0;
			}
		numMU = 0;
		numMU_S = 0;
		numMU_NS = 0;
		numEqual2 = numEqual1 = numDifCodSameAA = numDifCodDifAA = numNonSyn0 = numNonSyn1 = numNonSyn2 = 0;
		}



	}



/* To round decimals in a number */
double roundit(double d,int dig) /* d is a double number, dig is the number of decimals to cut */
	{
	double c;
	long double m = powl(10,dig);
	c = roundl(d*m) / m;
	return c;
	}








/********************************** SimulateDataForSite_Nucleotide_RECURSIVE_NET ***********************************/
/* Simulates the nucleotide substitution process for a given nucleotide */

void SimulateDataForSite_Nucleotide_RECURSIVE_NET (TreeNode *p, int siteNucleotide, int numSites, double m, double varRate, double kappa, long int *seed)
	{
	int			i, k, step, control;
	double		ran, cumProb[4], Pij[4][4];
	double 		a, b;
	TreeNode *q;
	TreeSegment *s;
	
//	TreeNode *q, *r;


	/*
	fprintf (fpmpi, "\n codon = %d", siteCodon);
	*/
	q = NULL;
	a = 0;
	b = 0;
	step = 0;
	k = 0;
	control = 0;
	

	
	if (numRE == 0) /*** NO HAY NINGUNA REC ***/
		{
		if (p != NULL)
			{
			/*fprintf (fpmpi, "\n\n--Pasa por p->label = %d--\n", p->label);*/
			if (p->anc1 != NULL) // todos aquellos nodos que no son el GMRCA
				{
				/*fprintf (fpmpi, "\n COAL p->anc1 != NULL.. p->label = %d\n", p->label);*/		
				if (p->isOutgroup == YES) // llegada al nodo outgroup
					{
					SubstitutionMatrix (Pij, p->length * m, kappa, varRate, p_i);
					}
				else //llegada a cualquier nodo que no es outgroup
					{
					SubstitutionMatrix (Pij, (p->anc1->time - p->time) * m, kappa, varRate, p_i);
					}
			
				/* Introduce Mutacion */
				cumProb[0] = Pij[matrix[pos(p->anc1->label,siteNucleotide,numSites)]][0];
				for (i=1; i<4; i++)
					cumProb[i] = cumProb[i-1] + Pij[matrix[pos(p->anc1->label,siteNucleotide,numSites)]][i];
				ran = RandomUniform(seed);

				/*if (p->label == 1)
					{
					fprintf(stderr,"\n ***** p->label = %d, p->index = %d,  p->time = %lf, (p->anc1->time - p->time) = %lf, sitioNum = %d, deme = %d, node_original = %d \n", p->label, p->index,  p->time, (p->anc1->time - p->time), siteNum, p->indexOldMigPop, p->NetIndex);
					}*/
				if (ran >= 0.0 && ran <= cumProb[0])
					matrix[pos(p->label,siteNucleotide,numSites)] = 0; 
				else if (ran > cumProb[0] && ran <= cumProb[1])
					matrix[pos(p->label,siteNucleotide,numSites)] = 1; 
				else if (ran > cumProb[1] && ran <= cumProb[2])
					matrix[pos(p->label,siteNucleotide,numSites)] = 2; 
				else
					matrix[pos(p->label,siteNucleotide,numSites)] = 3; 
			

				if (matrix[pos(p->label,siteNucleotide,numSites)] != matrix[pos(p->anc1->label,siteNucleotide,numSites)])
					{
					numMU++;	
					/*fprintf(stderr,"\n < MUT (no rec), numMU = %d \n", numMU);*/
					}
			

				/*fprintf (stderr, " matrix[pos(p->label,siteNucleotide,numSites)] = %d, matrix[pos(p->anc1->label,siteNucleotide,numSites)] = %d, numMU = %d \n", matrix[pos(p->label,siteNucleotide,numSites)], matrix[pos(p->anc1->label,siteNucleotide,numSites)], numMU);
				fprintf (stderr, " (p->anc1->time - p->time) = %lf \n", (p->anc1->time - p->time));*/
				/* fin Mutacion */
				}


			/* It crosses the tree */
			SimulateDataForSite_Nucleotide_RECURSIVE_NET (p->left, siteNucleotide, numSites, m, varRate, kappa, seed);
			SimulateDataForSite_Nucleotide_RECURSIVE_NET (p->right, siteNucleotide, numSites, m, varRate, kappa, seed);	
			if (thereisOutgroup == YES)
				SimulateDataForSite_Nucleotide_RECURSIVE_NET (p->outgroup, siteNucleotide, numSites, m, varRate, kappa, seed);	
			}
		}
	else  /*** HAY RECOMBINACIONES ***/
		{
			
		if (p != NULL)
			{
			/*fprintf (fpmpi, "\n\n--Pasa por p->label = %d, p->index = %d--\n", p->label, p->index);*/

			k = 0;
			for (step = 0; step < p->numSegNode; step++)	/* pasan aquellos nodos contenidos por el NUCLEOTIDE, que es llamado siteNucleotide */			
				{
				s = segments + post(step,p->index,distance);				
				if (s->sStart <= siteNucleotide && s->sEnd >= siteNucleotide)
					k++;
				}

			if (p->anc1 != NULL && p->isOutgroup == YES) /* pasa el outgroup si lo hay */
				k++;



			if (p->anc1 != NULL && k > 0) // todos aquellos nodos que no son el GMRCA
				{
				/*fprintf (fpmpi, "\n Entra en BETWEEN p->anc1 != NULL.. p->label = %d\n", p->label);*/			
				if (p->isOutgroup == YES) // llegada al nodo outgroup
					{
					SubstitutionMatrix (Pij, p->length * m, kappa, varRate, p_i);
					}
				else // llegada a cualquier nodo que no es outgroup
					{
					if (matrix[pos(p->anc1->label,siteNucleotide,numSites)] > -1) /* va por anc1 */
						SubstitutionMatrix (Pij, (p->anc1->time - p->time) * m, kappa, varRate, p_i);
					else /* va por anc2 */ /* Sept 2012 */
						SubstitutionMatrix (Pij, (p->anc2->time - p->time) * m, kappa, varRate, p_i);
					}
			


				/* Introduce Mutacion */
				if (matrix[pos(p->anc1->label,siteNucleotide,numSites)] > -1) /* va por anc1 */
					{

					cumProb[0] = Pij[matrix[pos(p->anc1->label,siteNucleotide,numSites)]][0];
					for (i=1; i<4; i++)
						cumProb[i] = cumProb[i-1] + Pij[matrix[pos(p->anc1->label,siteNucleotide,numSites)]][i];
					ran = RandomUniform(seed);

					/*if (p->label == 1)
						{
						fprintf(stderr,"\n ***** p->label = %d, p->index = %d,  p->time = %lf, (p->anc1->time - p->time) = %lf, sitioNum = %d, deme = %d, node_original = %d \n", p->label, p->index,  p->time, (p->anc1->time - p->time), siteNum, p->indexOldMigPop, p->NetIndex);
						}*/
					if (ran >= 0.0 && ran <= cumProb[0])
						matrix[pos(p->label,siteNucleotide,numSites)] = 0; 
					else if (ran > cumProb[0] && ran <= cumProb[1])
						matrix[pos(p->label,siteNucleotide,numSites)] = 1; 
					else if (ran > cumProb[1] && ran <= cumProb[2])
						matrix[pos(p->label,siteNucleotide,numSites)] = 2; 
					else
						matrix[pos(p->label,siteNucleotide,numSites)] = 3; 


					if (matrix[pos(p->label,siteNucleotide,numSites)] != matrix[pos(p->anc1->label,siteNucleotide,numSites)])
						{
						numMU++;
						/*fprintf(stderr,"\n < MUT (no rompe codon, por anc1), numMU = %d \n", numMU);*/
						}
			
					/*fprintf (stderr, " matrix[pos(p->label,siteNucleotide,numSites)] = %d, matrix[pos(p->anc1->label,siteNucleotide,numSites)] = %d, numMU = %d \n", matrix[pos(p->label,siteNucleotide,numSites)], matrix[pos(p->anc1->label,siteNucleotide,numSites)], numMU);
					fprintf (stderr, " (p->anc1->time - p->time) = %lf \n", (p->anc1->time - p->time));*/
						


					/* check  section */
					/*if (matrix[pos(p->anc1->label,siteNucleotide,numSites)] < 0) 
						{
						fprintf (stderr, "\n\n Warning in RECURSIVE_NET function (1): p->anc1->label = %d\n", p->anc1->label);
						exit (-1);
						}
					for (step = 0; step < p->anc1->numSegNode; step++)			
						{
						s = segments + post(step,p->anc1->index,distance);				
						if (s->sStart <= siteNucleotide && s->sEnd >= siteNucleotide)
						control++;
						}
					if (control == 0)
						{
						fprintf (stderr, "\n\n Warning in RECURSIVE_NET function (1): control = %d\n", control);
						exit (-1);
						}*/
					}
				else /* va por anc2 */
					{

					cumProb[0] = Pij[matrix[pos(p->anc2->label,siteNucleotide,numSites)]][0];
					for (i=1; i<4; i++)
						cumProb[i] = cumProb[i-1] + Pij[matrix[pos(p->anc2->label,siteNucleotide,numSites)]][i];
					ran = RandomUniform(seed);								
					/*fprintf (fpmpi, "\n ran = %lf ",ran);*/


					if (ran >= 0.0 && ran <= cumProb[0])
						matrix[pos(p->label,siteNucleotide,numSites)] = 0; 
					else if (ran > cumProb[0] && ran <= cumProb[1])
						matrix[pos(p->label,siteNucleotide,numSites)] = 1; 
					else if (ran > cumProb[1] && ran <= cumProb[2])
						matrix[pos(p->label,siteNucleotide,numSites)] = 2; 
					else
						matrix[pos(p->label,siteNucleotide,numSites)] = 3; 


					if (matrix[pos(p->label,siteNucleotide,numSites)] != matrix[pos(p->anc2->label,siteNucleotide,numSites)])
						{
						numMU++;
						/*fprintf(stderr,"\n < MUT (no rompe codon, por anc2), numMU = %d \n", numMU);*/
						}
					


					/*fprintf (stderr, " matrix[pos(p->label,siteNucleotide,numSites)] = %d, matrix[pos(p->anc2->label,siteNucleotide,numSites)] = %d, numMU = %d \n", matrix[pos(p->label,siteNucleotide,numSites)], matrix[pos(p->anc2->label,siteNucleotide,numSites)], numMU);
					fprintf (stderr, " (p->anc2->time - p->time) = %lf \n", (p->anc2->time - p->time));*/
					
					/* check section */
					/*if (matrixC[pos(p->anc2->label,siteNucleotide,numSites)] < 0) 
						{
						fprintf (stderr, "\n\n Warning in RECURSIVE_NET function (2): p->anc2->label = %d\n", p->anc2->label);
						exit (-1);
						}
					for (step = 0; step < p->anc2->numSegNode; step++)			
						{
						s = segments + post(step,p->anc2->index,distance);				
						if (s->sStart <= siteNucleotide && s->sEnd >= siteNucleotide)
							control++;
						}
					if (control == 0) 
						{
						fprintf (stderr, "\n\n Warning in RECURSIVE_NET function (2): control = %d\n", control);
						exit (-1);
						}*/
					}


				/* fin Mutacion */
				}
		
			/* It crosses the tree */
			if (k > 0)
				{
				SimulateDataForSite_Nucleotide_RECURSIVE_NET (p->left, siteNucleotide, numSites, m, varRate, kappa, seed);
				SimulateDataForSite_Nucleotide_RECURSIVE_NET (p->right, siteNucleotide, numSites, m, varRate, kappa, seed);
				}
			if (thereisOutgroup == YES)
				SimulateDataForSite_Nucleotide_RECURSIVE_NET (p->outgroup, siteNucleotide, numSites, m, varRate, kappa, seed);	
			}
				
				
		}
		
	}










/********************************** SimulateDataForSite_AA_RECURSIVE_NET ***********************************/
/* Simulates the aa substitution process for a given aa */

void SimulateDataForSite_AA_RECURSIVE_NET (TreeNode *p, int siteNucleotide, int numSites, double m, double varRate, long int *seed)
	{
	int			i, k, step, control;
	double		ran, cumProb[20], Pij[20][20];
	double 		a, b;
	TreeNode *q;
	TreeSegment *s;
	
//	TreeNode *q, *r;


	/*
	fprintf (fpmpi, "\n codon = %d", siteCodon);
	*/
	q = NULL;
	a = 0;
	b = 0;
	step = 0;
	k = 0;
	control = 0;
	

	
	if (numRE == 0) /*** NO HAY NINGUNA REC ***/
		{
		if (p != NULL)
			{
			/*fprintf (fpmpi, "\n\n--Pasa por p->label = %d--\n", p->label);*/
			if (p->anc1 != NULL) // todos aquellos nodos que no son el GMRCA
				{
				/*fprintf (fpmpi, "\n COAL p->anc1 != NULL.. p->label = %d\n", p->label);*/		
				if (p->isOutgroup == YES) // llegada al nodo outgroup
					{
					AAevolModel (Pij, p->length * m, varRate);
					}
				else //llegada a cualquier nodo que no es outgroup
					{
					AAevolModel (Pij, (p->anc1->time - p->time) * m, varRate);
					}
			
				/* Introduce Mutacion */
				cumProb[0] = Pij[matrix[pos(p->anc1->label,siteNucleotide,numSites)]][0];
				for (i=1; i<20; i++)
					cumProb[i] = cumProb[i-1] + Pij[matrix[pos(p->anc1->label,siteNucleotide,numSites)]][i];
				ran = RandomUniform(seed);

				/*if (p->label == 1)
					{
					fprintf(stderr,"\n ***** p->label = %d, p->index = %d,  p->time = %lf, (p->anc1->time - p->time) = %lf, sitioNum = %d, deme = %d, node_original = %d \n", p->label, p->index,  p->time, (p->anc1->time - p->time), siteNum, p->indexOldMigPop, p->NetIndex);
					}*/
				if (ran >= 0.0 && ran <= cumProb[0])
					matrix[pos(p->label,siteNucleotide,numSites)] = 0; 
				else if (ran > cumProb[0] && ran <= cumProb[1])
					matrix[pos(p->label,siteNucleotide,numSites)] = 1; 
				else if (ran > cumProb[1] && ran <= cumProb[2])
					matrix[pos(p->label,siteNucleotide,numSites)] = 2;
				else if (ran > cumProb[2] && ran <= cumProb[3])
					matrix[pos(p->label,siteNucleotide,numSites)] = 3; 
				else if (ran > cumProb[3] && ran <= cumProb[4])
					matrix[pos(p->label,siteNucleotide,numSites)] = 4;
				else if (ran > cumProb[4] && ran <= cumProb[5])
					matrix[pos(p->label,siteNucleotide,numSites)] = 5; 
				else if (ran > cumProb[5] && ran <= cumProb[6])
					matrix[pos(p->label,siteNucleotide,numSites)] = 6;
				else if (ran > cumProb[6] && ran <= cumProb[7])
					matrix[pos(p->label,siteNucleotide,numSites)] = 7; 
				else if (ran > cumProb[7] && ran <= cumProb[8])
					matrix[pos(p->label,siteNucleotide,numSites)] = 8;
				else if (ran > cumProb[8] && ran <= cumProb[9])
					matrix[pos(p->label,siteNucleotide,numSites)] = 9; 
				else if (ran > cumProb[9] && ran <= cumProb[10])
					matrix[pos(p->label,siteNucleotide,numSites)] = 10;
				else if (ran > cumProb[10] && ran <= cumProb[11])
					matrix[pos(p->label,siteNucleotide,numSites)] = 11; 
				else if (ran > cumProb[11] && ran <= cumProb[12])
					matrix[pos(p->label,siteNucleotide,numSites)] = 12;
				else if (ran > cumProb[12] && ran <= cumProb[13])
					matrix[pos(p->label,siteNucleotide,numSites)] = 13; 
				else if (ran > cumProb[13] && ran <= cumProb[14])
					matrix[pos(p->label,siteNucleotide,numSites)] = 14;
				else if (ran > cumProb[14] && ran <= cumProb[15])
					matrix[pos(p->label,siteNucleotide,numSites)] = 15; 
				else if (ran > cumProb[15] && ran <= cumProb[16])
					matrix[pos(p->label,siteNucleotide,numSites)] = 16;
				else if (ran > cumProb[16] && ran <= cumProb[17])
					matrix[pos(p->label,siteNucleotide,numSites)] = 17; 
				else if (ran > cumProb[17] && ran <= cumProb[18])
					matrix[pos(p->label,siteNucleotide,numSites)] = 18;
				else
					matrix[pos(p->label,siteNucleotide,numSites)] = 19; 
			

				if (matrix[pos(p->label,siteNucleotide,numSites)] != matrix[pos(p->anc1->label,siteNucleotide,numSites)])
					{
					numMU++;	
					/*fprintf(stderr,"\n < MUT (no rec), numMU = %d \n", numMU);*/
					}
			

				/*fprintf (stderr, " matrix[pos(p->label,siteNucleotide,numSites)] = %d, matrix[pos(p->anc1->label,siteNucleotide,numSites)] = %d, numMU = %d \n", matrix[pos(p->label,siteNucleotide,numSites)], matrix[pos(p->anc1->label,siteNucleotide,numSites)], numMU);
				fprintf (stderr, " (p->anc1->time - p->time) = %lf \n", (p->anc1->time - p->time));*/
				/* fin Mutacion */
				}


			/* It crosses the tree */
			SimulateDataForSite_AA_RECURSIVE_NET (p->left, siteNucleotide, numSites, m, varRate, seed);
			SimulateDataForSite_AA_RECURSIVE_NET (p->right, siteNucleotide, numSites, m, varRate, seed);	
			if (thereisOutgroup == YES)
				SimulateDataForSite_AA_RECURSIVE_NET (p->outgroup, siteNucleotide, numSites, m, varRate, seed);	
			}
		}
	else  /*** HAY RECOMBINACIONES ***/ /* .... EL CODON NO SE ROMPE CON RECOMBINACIONES .... */
		{
			
		if (p != NULL)
			{
			/*fprintf (fpmpi, "\n\n--Pasa por p->label = %d, p->index = %d--\n", p->label, p->index);*/

			k = 0;
			for (step = 0; step < p->numSegNode; step++)	/* pasan aquellos nodos contenidos por el NUCLEOTIDE, que es llamado siteNucleotide */			
				{
				s = segments + post(step,p->index,distance);				
				if (s->sStart <= siteNucleotide && s->sEnd >= siteNucleotide)
					k++;
				}

			if (p->anc1 != NULL && p->isOutgroup == YES) /* pasa el outgroup si lo hay */
				k++;



			if (p->anc1 != NULL && k > 0) // todos aquellos nodos que no son el GMRCA
				{
				/*fprintf (fpmpi, "\n Entra en BETWEEN p->anc1 != NULL.. p->label = %d\n", p->label);*/			
				if (p->isOutgroup == YES) // llegada al nodo outgroup
					{
					AAevolModel (Pij, p->length * m, varRate);
					}
				else // llegada a cualquier nodo que no es outgroup
					{
					if (matrix[pos(p->anc1->label,siteNucleotide,numSites)] > -1) /* va por anc1 */
						AAevolModel (Pij, (p->anc1->time - p->time) * m, varRate);
					else /* va por anc2 */ /* sept 2012 */
						AAevolModel (Pij, (p->anc2->time - p->time) * m, varRate);
					}
			


				/* Introduce Mutacion */
				if (matrix[pos(p->anc1->label,siteNucleotide,numSites)] > -1) /* va por anc1 */
					{

					cumProb[0] = Pij[matrix[pos(p->anc1->label,siteNucleotide,numSites)]][0];
					for (i=1; i<20; i++)
						cumProb[i] = cumProb[i-1] + Pij[matrix[pos(p->anc1->label,siteNucleotide,numSites)]][i];
					ran = RandomUniform(seed);

					/*if (p->label == 1)
						{
						fprintf(stderr,"\n ***** p->label = %d, p->index = %d,  p->time = %lf, (p->anc1->time - p->time) = %lf, sitioNum = %d, deme = %d, node_original = %d \n", p->label, p->index,  p->time, (p->anc1->time - p->time), siteNum, p->indexOldMigPop, p->NetIndex);
						}*/
					if (ran >= 0.0 && ran <= cumProb[0])
						matrix[pos(p->label,siteNucleotide,numSites)] = 0; 
					else if (ran > cumProb[0] && ran <= cumProb[1])
						matrix[pos(p->label,siteNucleotide,numSites)] = 1; 
					else if (ran > cumProb[1] && ran <= cumProb[2])
						matrix[pos(p->label,siteNucleotide,numSites)] = 2;
					else if (ran > cumProb[2] && ran <= cumProb[3])
						matrix[pos(p->label,siteNucleotide,numSites)] = 3; 
					else if (ran > cumProb[3] && ran <= cumProb[4])
						matrix[pos(p->label,siteNucleotide,numSites)] = 4;
					else if (ran > cumProb[4] && ran <= cumProb[5])
						matrix[pos(p->label,siteNucleotide,numSites)] = 5; 
					else if (ran > cumProb[5] && ran <= cumProb[6])
						matrix[pos(p->label,siteNucleotide,numSites)] = 6;
					else if (ran > cumProb[6] && ran <= cumProb[7])
						matrix[pos(p->label,siteNucleotide,numSites)] = 7; 
					else if (ran > cumProb[7] && ran <= cumProb[8])
						matrix[pos(p->label,siteNucleotide,numSites)] = 8;
					else if (ran > cumProb[8] && ran <= cumProb[9])
						matrix[pos(p->label,siteNucleotide,numSites)] = 9; 
					else if (ran > cumProb[9] && ran <= cumProb[10])
						matrix[pos(p->label,siteNucleotide,numSites)] = 10;
					else if (ran > cumProb[10] && ran <= cumProb[11])
						matrix[pos(p->label,siteNucleotide,numSites)] = 11; 
					else if (ran > cumProb[11] && ran <= cumProb[12])
						matrix[pos(p->label,siteNucleotide,numSites)] = 12;
					else if (ran > cumProb[12] && ran <= cumProb[13])
						matrix[pos(p->label,siteNucleotide,numSites)] = 13; 
					else if (ran > cumProb[13] && ran <= cumProb[14])
						matrix[pos(p->label,siteNucleotide,numSites)] = 14;
					else if (ran > cumProb[14] && ran <= cumProb[15])
						matrix[pos(p->label,siteNucleotide,numSites)] = 15; 
					else if (ran > cumProb[15] && ran <= cumProb[16])
						matrix[pos(p->label,siteNucleotide,numSites)] = 16;
					else if (ran > cumProb[16] && ran <= cumProb[17])
						matrix[pos(p->label,siteNucleotide,numSites)] = 17; 
					else if (ran > cumProb[17] && ran <= cumProb[18])
						matrix[pos(p->label,siteNucleotide,numSites)] = 18;
					else
						matrix[pos(p->label,siteNucleotide,numSites)] = 19; 


					if (matrix[pos(p->label,siteNucleotide,numSites)] != matrix[pos(p->anc1->label,siteNucleotide,numSites)])
						{
						numMU++;
						/*fprintf(stderr,"\n < MUT (no rompe codon, por anc1), numMU = %d \n", numMU);*/
						}
			
					/*fprintf (stderr, " matrix[pos(p->label,siteNucleotide,numSites)] = %d, matrix[pos(p->anc1->label,siteNucleotide,numSites)] = %d, numMU = %d \n", matrix[pos(p->label,siteNucleotide,numSites)], matrix[pos(p->anc1->label,siteNucleotide,numSites)], numMU);
					fprintf (stderr, " (p->anc1->time - p->time) = %lf \n", (p->anc1->time - p->time));*/
						


					/* check  section */
					/*if (matrix[pos(p->anc1->label,siteNucleotide,numSites)] < 0) 
						{
						fprintf (stderr, "\n\n Warning in RECURSIVE_NET function (1): p->anc1->label = %d\n", p->anc1->label);
						exit (-1);
						}
					for (step = 0; step < p->anc1->numSegNode; step++)			
						{
						s = segments + post(step,p->anc1->index,distance);				
						if (s->sStart <= siteNucleotide && s->sEnd >= siteNucleotide)
						control++;
						}
					if (control == 0)
						{
						fprintf (stderr, "\n\n Warning in RECURSIVE_NET function (1): control = %d\n", control);
						exit (-1);
						}*/
					}
				else /* va por anc2 */
					{

					cumProb[0] = Pij[matrix[pos(p->anc2->label,siteNucleotide,numSites)]][0];
					for (i=1; i<20; i++)
						cumProb[i] = cumProb[i-1] + Pij[matrix[pos(p->anc2->label,siteNucleotide,numSites)]][i];
					ran = RandomUniform(seed);								
					/*fprintf (fpmpi, "\n ran = %lf ",ran);*/



					if (ran >= 0.0 && ran <= cumProb[0])
						matrix[pos(p->label,siteNucleotide,numSites)] = 0; 
					else if (ran > cumProb[0] && ran <= cumProb[1])
						matrix[pos(p->label,siteNucleotide,numSites)] = 1; 
					else if (ran > cumProb[1] && ran <= cumProb[2])
						matrix[pos(p->label,siteNucleotide,numSites)] = 2;
					else if (ran > cumProb[2] && ran <= cumProb[3])
						matrix[pos(p->label,siteNucleotide,numSites)] = 3; 
					else if (ran > cumProb[3] && ran <= cumProb[4])
						matrix[pos(p->label,siteNucleotide,numSites)] = 4;
					else if (ran > cumProb[4] && ran <= cumProb[5])
						matrix[pos(p->label,siteNucleotide,numSites)] = 5; 
					else if (ran > cumProb[5] && ran <= cumProb[6])
						matrix[pos(p->label,siteNucleotide,numSites)] = 6;
					else if (ran > cumProb[6] && ran <= cumProb[7])
						matrix[pos(p->label,siteNucleotide,numSites)] = 7; 
					else if (ran > cumProb[7] && ran <= cumProb[8])
						matrix[pos(p->label,siteNucleotide,numSites)] = 8;
					else if (ran > cumProb[8] && ran <= cumProb[9])
						matrix[pos(p->label,siteNucleotide,numSites)] = 9; 
					else if (ran > cumProb[9] && ran <= cumProb[10])
						matrix[pos(p->label,siteNucleotide,numSites)] = 10;
					else if (ran > cumProb[10] && ran <= cumProb[11])
						matrix[pos(p->label,siteNucleotide,numSites)] = 11; 
					else if (ran > cumProb[11] && ran <= cumProb[12])
						matrix[pos(p->label,siteNucleotide,numSites)] = 12;
					else if (ran > cumProb[12] && ran <= cumProb[13])
						matrix[pos(p->label,siteNucleotide,numSites)] = 13; 
					else if (ran > cumProb[13] && ran <= cumProb[14])
						matrix[pos(p->label,siteNucleotide,numSites)] = 14;
					else if (ran > cumProb[14] && ran <= cumProb[15])
						matrix[pos(p->label,siteNucleotide,numSites)] = 15; 
					else if (ran > cumProb[15] && ran <= cumProb[16])
						matrix[pos(p->label,siteNucleotide,numSites)] = 16;
					else if (ran > cumProb[16] && ran <= cumProb[17])
						matrix[pos(p->label,siteNucleotide,numSites)] = 17; 
					else if (ran > cumProb[17] && ran <= cumProb[18])
						matrix[pos(p->label,siteNucleotide,numSites)] = 18;
					else
						matrix[pos(p->label,siteNucleotide,numSites)] = 19; 



					if (matrix[pos(p->label,siteNucleotide,numSites)] != matrix[pos(p->anc2->label,siteNucleotide,numSites)])
						{
						numMU++;
						/*fprintf(stderr,"\n < MUT (no rompe codon, por anc2), numMU = %d \n", numMU);*/
						}
					


					/*fprintf (stderr, " matrix[pos(p->label,siteNucleotide,numSites)] = %d, matrix[pos(p->anc2->label,siteNucleotide,numSites)] = %d, numMU = %d \n", matrix[pos(p->label,siteNucleotide,numSites)], matrix[pos(p->anc2->label,siteNucleotide,numSites)], numMU);
					fprintf (stderr, " (p->anc2->time - p->time) = %lf \n", (p->anc2->time - p->time));*/
					
					/* check section */
					/*if (matrixC[pos(p->anc2->label,siteNucleotide,numSites)] < 0) 
						{
						fprintf (stderr, "\n\n Warning in RECURSIVE_NET function (2): p->anc2->label = %d\n", p->anc2->label);
						exit (-1);
						}
					for (step = 0; step < p->anc2->numSegNode; step++)			
						{
						s = segments + post(step,p->anc2->index,distance);				
						if (s->sStart <= siteNucleotide && s->sEnd >= siteNucleotide)
							control++;
						}
					if (control == 0) 
						{
						fprintf (stderr, "\n\n Warning in RECURSIVE_NET function (2): control = %d\n", control);
						exit (-1);
						}*/
					}


				/* fin Mutacion */
				}
		
			/* It crosses the tree */
			if (k > 0)
				{
				SimulateDataForSite_AA_RECURSIVE_NET (p->left, siteNucleotide, numSites, m, varRate, seed);
				SimulateDataForSite_AA_RECURSIVE_NET (p->right, siteNucleotide, numSites, m, varRate, seed);
				}
			if (thereisOutgroup == YES)
				SimulateDataForSite_AA_RECURSIVE_NET (p->outgroup, siteNucleotide, numSites, m, varRate, seed);	
			}
				
				
		}
		
	}






/********************************** SimulateDataForSite_Codon_RECURSIVE_NET ***********************************/
/* Simulates the codon substitution process for a given codon */

void SimulateDataForSite_Codon_RECURSIVE_NET (TreeNode *p, int siteCodon, int numSites, double m, int numOmegaCat, double varRate, long int *seed, int Cbroke)
	{
	int			i, j, k, step, NOcontinueNode, doCombineCodons, control;
	double		ran, cumProb[NUMCOD], Pij[NUMCOD][NUMCOD];
	double a,b;
	int nuc1, nuc2, nuc3, InCodon1, InCodon2, brokePosition, outCodon;
	int aminoacid1, aminoacid2;
	TreeNode *q;
	TreeSegment *s;
	
//	TreeNode *q, *r;


	/*
	fprintf (fpmpi, "\n codon = %d", siteCodon);
	*/
	q = NULL;
	a = 0;
	b = 0;
	step = 0;
	k = 0;
	control = 0;
	nuc3 = siteCodon*3;
	nuc2 = siteCodon*3-1;
	nuc1 = siteCodon*3-2;
	NOcontinueNode = 0;
	doCombineCodons = NO;
	InCodon1 = 0;
	InCodon2 = 0;
	brokePosition = 0;

	if (doRepitEvol == NO) /* control by codon stop formed by recombination inside of codons */
		{
		if (numRE == 0) /*** NO HAY NINGUNA REC ***/
			{
			if (p != NULL)
				{
				/*fprintf (fpmpi, "\n\n--Pasa por p->label = %d--\n", p->label);*/
				if (p->anc1 != NULL) // todos aquellos nodos que no son el GMRCA
					{
					/*fprintf (fpmpi, "\n COAL p->anc1 != NULL.. p->label = %d\n", p->label);*/		
					if (p->isOutgroup == YES) // llegada al nodo outgroup
						{
						if (doVariableDnDsBranches == NO)
							{
							if (doOmegaCat == YES || doOmegaRateHetDisc == YES)
								CodonModel_Cat (Pij, p->length * m, varRate);
							else /* omega cte or doOmegaRateHetCont == YES or doM6 == YES or doM9 or doM10 or doMG94 */
								CodonModel (Pij, p->length * m, varRate);
							}
						else /* dN/dS varies per branch */
							{
							CodonModel_specialBranches (Pij, p->length * m, varRate, seed, siteCodon, p->label, p->anc1->label, p->index, p->anc1->index, p->BBM0omg);
							}
						}
					else //llegada a cualquier nodo que no es outgroup
						{
						if (doVariableDnDsBranches == NO)
							{
							if (doOmegaCat == YES || doOmegaRateHetDisc == YES)
								CodonModel_Cat (Pij, (p->anc1->time - p->time) * m, varRate);
							else /* omega cte o doOmegaRateHetCont == YES or doM6 == YES */
								CodonModel (Pij, (p->anc1->time - p->time) * m, varRate);
							}
						else /* dN/dS varies per branch */
							{
							CodonModel_specialBranches (Pij, (p->anc1->time - p->time) * m, varRate, seed, siteCodon, p->label, p->anc1->label, p->index, p->anc1->index, p->BBM0omg);
							}
						}
			
					/* Introduce Mutacion */
					cumProb[0] = Pij[matrixC[pos(p->anc1->label,siteCodon,numSites)]][0];
					j = matrixC[pos(p->anc1->label,siteCodon,numSites)];
			
					/*fprintf (fpmpi, "\n Pij[%d][x]", j);		
					fprintf (fpmpi, "\n matrixC[pos(p->anc1->label,siteCodon,numSites) = %d", matrixC[pos(p->anc1->label,siteCodon,numSites)]);
					fprintf (fpmpi, "\n cumProb[0] = %lf", cumProb[0]);*/
			
					for (i=1; i<NUMCOD; i++)
						{
						cumProb[i] = cumProb[i-1] + Pij[matrixC[pos(p->anc1->label,siteCodon,numSites)]][i];
						/*fprintf (fpmpi, "\n cumProb[%d] = %lf", i, cumProb[i]);*/
						}
								
					ran = RandomUniform(seed);
					matrixC[pos(p->label,siteCodon,numSites)] = bbin(ran, cumProb); /* binary search in the probabilities */
			
					if (matrixC[pos(p->label,siteCodon,numSites)] > 60)  /* check */
						{
						for (i=0; i<NUMCOD; i++)
							{
							fprintf (stderr, "\n");
							a = 0;
							for (j=0; j<NUMCOD; j++)
								{
								fprintf (stderr, "P[%d][%d] = %3.2f ",i,j,Pij[i][j]);
								a = a + Pij[i][j];
								}
							fprintf (stderr, "\n a = %lf \n\n", a);
							}
				
						fprintf (stderr, "\n SimulateDataForSite_Codon: 1. stop codon22 %d\n", matrixC[pos(p->label,siteCodon,numSites)]);
						exit(-1);
						}
			
					if (matrixC[pos(p->label,siteCodon,numSites)] != matrixC[pos(p->anc1->label,siteCodon,numSites)])
						{
						numMU++;
						/*fprintf(stderr,"\n < MUT (no rec b), numMU = %d \n", numMU);*/

						aminoacid1 = codonTable_DnDs(matrixC[pos(p->label,siteCodon,numSites)]);
						aminoacid2 = codonTable_DnDs(matrixC[pos(p->anc1->label,siteCodon,numSites)]);
						if (aminoacid1 == aminoacid2)
							{
							numMU_S++;
							/*fprintf (stderr, "\n Syn mut: %d to %d, numMU_S = %d \n", aminoacid1, aminoacid2, numMU_S);*/
							}
						else
							{
							numMU_NS++;
							/*fprintf (stderr, "\n NonSyn mut: %d to %d, numMU_NS = %d \n", aminoacid1, aminoacid2, numMU_NS);*/
							}
						if ((aminoacid1 == -1) || (aminoacid2 == -1))
							{
							fprintf (stderr, "\n error in type of mutations %d %d\n", aminoacid1, aminoacid2);
							exit(-1);
							}
						aminoacid1 = aminoacid2 = -1;
						}

				/*	fprintf (stderr, " Node %d to %d - matrixC[pos(p->label,siteCodon,numSites)] = %d, matrixC[pos(p->anc1->label,siteCodon,numSites)] = %d, numMU = %d \n", p->index, p->anc1->index, matrixC[pos(p->label,siteCodon,numSites)], matrixC[pos(p->anc1->label,siteCodon,numSites)], numMU);
					fprintf (stderr, " (p->anc1->time - p->time) = %lf \n", (p->anc1->time - p->time)); */
					/* fin Mutacion */
					}
		
				/* It crosses the tree */
				SimulateDataForSite_Codon_RECURSIVE_NET (p->left, siteCodon, numSites, m, numOmegaCat, varRate, seed, Cbroke);
				SimulateDataForSite_Codon_RECURSIVE_NET (p->right, siteCodon, numSites, m, numOmegaCat, varRate, seed, Cbroke);	
				if (thereisOutgroup == YES)
					SimulateDataForSite_Codon_RECURSIVE_NET (p->outgroup, siteCodon, numSites, m, numOmegaCat, varRate, seed, Cbroke);	
				}
			}
		else  /*** HAY RECOMBINACIONES ***/
			{
			if (Cbroke == NO) /* ESTE CODON NO SE ROMPE CON RECOMBINACIONES */
				{
				if (p != NULL)
					{
					/*fprintf (fpmpi, "\n\n--Pasa por p->label = %d, p->index = %d--\n", p->label, p->index);*/

					k = 0;
					for (step = 0; step < p->numSegNode; step++)	/* pasan aquellos nodos contenidos por el codon */			
						{
						s = segments + post(step,p->index,distance);				
						if (s->sStart <= nuc2 && s->sEnd >= nuc2)
							k++;
						}

					if (p->anc1 != NULL && p->isOutgroup == YES) /* pasa el outgroup si lo hay */
						k++;


					if (p->anc1 != NULL && k > 0) // todos aquellos nodos que no son el GMRCA
						{
						/*fprintf (fpmpi, "\n Entra en BETWEEN p->anc1 != NULL.. p->label = %d\n", p->label);*/			

						if (p->isOutgroup == YES) // llegada al nodo outgroup
							{
							if (doVariableDnDsBranches == NO)
								{
								if (doOmegaCat == YES || doOmegaRateHetDisc == YES)
									CodonModel_Cat (Pij, p->length * m, varRate);
								else /* omega cte o doOmegaRateHetCont == YES or doM6 == YES */
									CodonModel (Pij, p->length * m, varRate);
								}
							else /* dN/dS varies per branch */
								{
								CodonModel_specialBranches (Pij, p->length * m, varRate, seed, siteCodon, p->label, p->anc1->label, p->index, p->anc1->index, p->BBM0omg);
								}
							}
						else // llegada a cualquier nodo que no es outgroup
							{
							if (matrixC[pos(p->anc1->label,siteCodon,numSites)] > -1) /* va por anc1 */
								{
								if (doVariableDnDsBranches == NO)
									{
									if (doOmegaCat == YES || doOmegaRateHetDisc == YES)
										CodonModel_Cat (Pij, (p->anc1->time - p->time) * m, varRate);
									else /* omega cte o doOmegaRateHetCont == YES or doM6 == YES */
										CodonModel (Pij, (p->anc1->time - p->time) * m, varRate);
									}
								else /* dN/dS varies per branch */
									{
									CodonModel_specialBranches (Pij, (p->anc1->time - p->time) * m, varRate, seed, siteCodon, p->label, p->anc1->label, p->index, p->anc1->index, p->BBM0omg);
									}
								}
							else /* va por anc2 */ /* sept 2012 */
								{
								if (doVariableDnDsBranches == NO)
									{
									if (doOmegaCat == YES || doOmegaRateHetDisc == YES)
										CodonModel_Cat (Pij, (p->anc2->time - p->time) * m, varRate);
									else /* omega cte o doOmegaRateHetCont == YES or doM6 == YES */
										CodonModel (Pij, (p->anc2->time - p->time) * m, varRate);
									}
								else /* dN/dS varies per branch */
									{
									CodonModel_specialBranches (Pij, (p->anc2->time - p->time) * m, varRate, seed, siteCodon, p->label, p->anc2->label, p->index, p->anc2->index, p->BBM0omg);
									}
								}
							}
			
						/* Introduce Mutacion */
						if (matrixC[pos(p->anc1->label,siteCodon,numSites)] > -1) /* va por anc1 */
							{
							cumProb[0] = Pij[matrixC[pos(p->anc1->label,siteCodon,numSites)]][0];
							j = matrixC[pos(p->anc1->label,siteCodon,numSites)];
			
							/*fprintf (fpmpi, "\n Pij[%d][x]", j);		
							fprintf (fpmpi, "\n matrixC[pos(p->anc1->label,siteCodon,numSites) = %d", matrixC[pos(p->anc1->label,siteCodon,numSites)]);
							fprintf (fpmpi, "\n cumProb[0] = %lf", cumProb[0]);*/
			
							for (i=1; i<NUMCOD; i++)
								{
								cumProb[i] = cumProb[i-1] + Pij[matrixC[pos(p->anc1->label,siteCodon,numSites)]][i];
								/*fprintf (fpmpi, "\n cumProb[%d] = %lf", i, cumProb[i]);*/
								}
								
							ran = RandomUniform(seed);
							/*fprintf (fpmpi, "\n ran = %lf ",ran);*/
							matrixC[pos(p->label,siteCodon,numSites)] = bbin(ran, cumProb); /* binary search in the probabilities */
						
							/*if (matrixC[pos(p->label,siteCodon,numSites)] > 60)*/  /* check */
							/*	{
								for (i=0; i<NUMCOD; i++)
									{
									fprintf (stderr, "\n");
									a = 0;
									for (j=0; j<NUMCOD; j++)
										{
										fprintf (stderr, "P[%d][%d] = %3.2f ",i,j,Pij[i][j]);
										a = a + Pij[i][j];
										}
									fprintf (stderr, "\n a = %lf \n\n", a);
									}
				
								fprintf (stderr, "\n stop codon22 %d\n", matrixC[pos(p->label,siteCodon,numSites)]);
								exit(-1);
								}*/
			
							if (matrixC[pos(p->label,siteCodon,numSites)] != matrixC[pos(p->anc1->label,siteCodon,numSites)])
								{
								numMU++;
								/*fprintf(stderr,"\n < MUT (rec por anc1 b), numMU = %d \n", numMU);*/

								aminoacid1 = codonTable_DnDs(matrixC[pos(p->label,siteCodon,numSites)]);
								aminoacid2 = codonTable_DnDs(matrixC[pos(p->anc1->label,siteCodon,numSites)]);
								if (aminoacid1 == aminoacid2)
									{
									numMU_S++;
									/*fprintf (stderr, "\n Syn mut: %d to %d, numMU_S = %d \n", aminoacid1, aminoacid2, numMU_S);*/
									}
								else
									{
									numMU_NS++;
									/*fprintf (stderr, "\n NonSyn mut: %d to %d, numMU_NS = %d \n", aminoacid1, aminoacid2, numMU_NS);*/
									}
								if ((aminoacid1 == -1) || (aminoacid2 == -1))
									{
									fprintf (stderr, "\n error in type of mutations %d %d\n", aminoacid1, aminoacid2);
									exit(-1);
									}
								aminoacid1 = aminoacid2 = -1;
								}
						/*	fprintf (stderr, " Node %d to %d - matrixC[pos(p->label,siteCodon,numSites)] = %d, matrixC[pos(p->anc1->label,siteCodon,numSites)] = %d, numMU = %d \n",  p->index, p->anc1->index, matrixC[pos(p->label,siteCodon,numSites)], matrixC[pos(p->anc1->label,siteCodon,numSites)], numMU);
							fprintf (stderr, " (p->anc1->time - p->time) = %lf \n", (p->anc1->time - p->time)); */
						
							/* check  section */
							/*if (matrixC[pos(p->anc1->label,siteCodon,numSites)] < 0) 
								{
								fprintf (stderr, "\n\n Warning in RECURSIVE_NET function (1): p->anc1->label = %d\n", p->anc1->label);
								exit (-1);
								}
							for (step = 0; step < p->anc1->numSegNode; step++)			
								{
								s = segments + post(step,p->anc1->index,distance);				
								if (s->sStart <= nuc2 && s->sEnd >= nuc2)
									control++;
								}
							if (control == 0)
								{
								fprintf (stderr, "\n\n Warning in RECURSIVE_NET function (1): control = %d\n", control);
								exit (-1);
								}*/
							}
						else /* va por anc2 */
							{
							cumProb[0] = Pij[matrixC[pos(p->anc2->label,siteCodon,numSites)]][0];
							j = matrixC[pos(p->anc2->label,siteCodon,numSites)];
			
							/*fprintf (fpmpi, "\n Pij[%d][x]", j);		
							fprintf (fpmpi, "\n matrixC[pos(p->anc1->label,siteCodon,numSites) = %d", matrixC[pos(p->anc1->label,siteCodon,numSites)]);
							fprintf (fpmpi, "\n cumProb[0] = %lf", cumProb[0]);*/
			
							for (i=1; i<NUMCOD; i++)
								{
								cumProb[i] = cumProb[i-1] + Pij[matrixC[pos(p->anc2->label,siteCodon,numSites)]][i];
								/*fprintf (fpmpi, "\n cumProb[%d] = %lf", i, cumProb[i]);*/
								}
								
							ran = RandomUniform(seed);
							/*fprintf (fpmpi, "\n ran = %lf ",ran);*/
							matrixC[pos(p->label,siteCodon,numSites)] = bbin(ran, cumProb); /* binary search in the probabilities */
						
							/*if (matrixC[pos(p->label,siteCodon,numSites)] > 60)*/  /* check */
							/*	{
								for (i=0; i<NUMCOD; i++)
									{
									fprintf (stderr, "\n");
									a = 0;
									for (j=0; j<NUMCOD; j++)
										{
										fprintf (stderr, "P[%d][%d] = %3.2f ",i,j,Pij[i][j]);
										a = a + Pij[i][j];
										}
									fprintf (stderr, "\n a = %lf \n\n", a);
									}
				
								fprintf (stderr, "\n stop codon22 %d\n", matrixC[pos(p->label,siteCodon,numSites)]);
								exit(-1);
								}*/
			
							if (matrixC[pos(p->label,siteCodon,numSites)] != matrixC[pos(p->anc2->label,siteCodon,numSites)])
								{
								numMU++;
								/*fprintf(stderr,"\n < MUT (rec por anc2b), numMU = %d \n", numMU);*/


								/* NEW MA */
								aminoacid1 = codonTable_DnDs(matrixC[pos(p->label,siteCodon,numSites)]);
								aminoacid2 = codonTable_DnDs(matrixC[pos(p->anc2->label,siteCodon,numSites)]);
								if (aminoacid1 == aminoacid2)
									{
									numMU_S++;
									/*fprintf (stderr, "\n Syn mut: %d to %d, numMU_S = %d \n", aminoacid1, aminoacid2, numMU_S);*/
									}
								else
									{
									numMU_NS++;
									/*fprintf (stderr, "\n NonSyn mut: %d to %d, numMU_NS = %d \n", aminoacid1, aminoacid2, numMU_NS);*/
									}
								if ((aminoacid1 == -1) || (aminoacid2 == -1))
									{
									fprintf (stderr, "\n error in type of mutations %d %d\n", aminoacid1, aminoacid2);
									exit(-1);
									}
								aminoacid1 = aminoacid2 = -1;
								}
						/*	fprintf (stderr, " Node %d to %d - matrixC[pos(p->label,siteCodon,numSites)] = %d, matrixC[pos(p->anc2->label,siteCodon,numSites)] = %d, numMU = %d \n",  p->index, p->anc1->index, matrixC[pos(p->label,siteCodon,numSites)], matrixC[pos(p->anc2->label,siteCodon,numSites)], numMU);
							fprintf (stderr, " (p->anc2->time - p->time) = %lf \n", (p->anc2->time - p->time)); */
							
							/* check section */
							/*if (matrixC[pos(p->anc2->label,siteCodon,numSites)] < 0) 
								{
								fprintf (stderr, "\n\n Warning in RECURSIVE_NET function (2): p->anc2->label = %d\n", p->anc2->label);
								exit (-1);
								}
							for (step = 0; step < p->anc2->numSegNode; step++)			
								{
								s = segments + post(step,p->anc2->index,distance);				
								if (s->sStart <= nuc2 && s->sEnd >= nuc2)
									control++;
								}
							if (control == 0) 
								{
								fprintf (stderr, "\n\n Warning in RECURSIVE_NET function (2): control = %d\n", control);
								exit (-1);
								}*/
							}


						/* fin Mutacion */
						}
		
					/* It crosses the tree */
					if (k > 0)
						{
						SimulateDataForSite_Codon_RECURSIVE_NET (p->left, siteCodon, numSites, m, numOmegaCat, varRate, seed, Cbroke);
						SimulateDataForSite_Codon_RECURSIVE_NET (p->right, siteCodon, numSites, m, numOmegaCat, varRate, seed, Cbroke);
						}
					if (thereisOutgroup == YES)
						SimulateDataForSite_Codon_RECURSIVE_NET (p->outgroup, siteCodon, numSites, m, numOmegaCat, varRate, seed, Cbroke);	
					}
				}
			else  /* ESTE CODON SI ROMPE CON RECOMBINACIONES */
				{
				NOcontinueNode = 0;
			
				if (p != NULL)
					{
					k = 0;
					/*fprintf (fpmpi, "\n\n-- DENTRO DE CODON ROTO POR REC: Pasa por p->label = %d, p->index = %d--\n", p->label, p->index);*/

					if (p->anc1 != NULL && p->isOutgroup == YES) /* pasa el outgroup si lo hay */
						k++;
					for (step = 0; step < p->numSegNode; step++)	/* pasan aquellos nodos contenidos por el codon */			
						{
						s = segments + post(step,p->index,distance);				
						if ((s->sStart <= nuc1 && s->sEnd >= nuc1) || (s->sStart <= nuc2 && s->sEnd >= nuc2) || (s->sStart <= nuc3 && s->sEnd >= nuc3)) /* se continua por la evolucion de los 3 nuc q contiene */
							{
							k++;
							}
						}
					/*fprintf (fpmpi, "-- nuc1: %d, nuc2: %d, nuc3: %d --\n", nuc1, nuc2, nuc3);*/

					if (p->breakCodon == siteCodon) /* Special recombinant node */
						{
						
						q = p->sib;

						if (p->passNumber == 0)
							NOcontinueNode = 1;
						if (p->passNumber > 0) /* esta llegando por segunda vez, hay que hacer superposicin de codones mediante corte nuc */
							{
							NOcontinueNode = 0;
							doCombineCodons = YES;
							/*fprintf (fpmpi, " p->passNumber = %d", p->passNumber);*/
							}
					
						/*p->passNumber++;*/ /* MA add: hoy borre esto. july 2009 */
						q->passNumber++;
						
						/*fprintf (fpmpi, "\n** El nodo p->label = %d (p->index = %d) es recombinante y rompe al codon", p->label, p->index);
						fprintf (fpmpi, " Su Sib es p->passNumber = %d, q->label = %d (q->index = %d), p->whereBreakCodon = %d **", p->passNumber, q->label, q->index, p->whereBreakCodon);*/
						}


					if (p->anc1 != NULL && k > 0) // todos aquellos nodos que no son el GMRCA
						{
						/*fprintf (fpmpi, "\n Entra en INSIDE p->anc1 != NULL.. p->label = %d \n", p->label);*/					
						
						if (p->isOutgroup == YES) // llegada al nodo outgroup
							{
							if (doVariableDnDsBranches == NO)
								{
								if (doOmegaCat == YES || doOmegaRateHetDisc == YES)
									CodonModel_Cat (Pij, p->length * m, varRate);
								else /* omega cte o doOmegaRateHetCont == YES or doM6 == YES */
									CodonModel (Pij, p->length * m, varRate);
								}
							else /* dN/dS varies per branch */
								{
								CodonModel_specialBranches (Pij, p->length * m, varRate, seed, siteCodon, p->label, p->anc1->label, p->index, p->anc1->index, p->BBM0omg);
								}
							}
						else // llegada a cualquier nodo que no es outgroup
							{
							if (matrixC[pos(p->anc1->label,siteCodon,numSites)] > -1) /* va por anc1 */
								{
								if (doVariableDnDsBranches == NO)
									{
									if (doOmegaCat == YES || doOmegaRateHetDisc == YES)
										CodonModel_Cat (Pij, (p->anc1->time - p->time) * m, varRate);
									else /* omega cte o doOmegaRateHetCont == YES or doM6 == YES */
										CodonModel (Pij, (p->anc1->time - p->time) * m, varRate);
									}
								else /* dN/dS varies per branch */
									{
									CodonModel_specialBranches (Pij, (p->anc1->time - p->time) * m, varRate, seed, siteCodon, p->label, p->anc1->label, p->index, p->anc1->index, p->BBM0omg);
									}
								}
							else /* va por anc2 */ /* sept 2012 */
								{
								if (doVariableDnDsBranches == NO)
									{
									if (doOmegaCat == YES || doOmegaRateHetDisc == YES)
										CodonModel_Cat (Pij, (p->anc2->time - p->time) * m, varRate);
									else /* omega cte o doOmegaRateHetCont == YES or doM6 == YES */
										CodonModel (Pij, (p->anc2->time - p->time) * m, varRate);
									}
								else /* dN/dS varies per branch */
									{
									CodonModel_specialBranches (Pij, (p->anc2->time - p->time) * m, varRate, seed, siteCodon, p->label, p->anc2->label, p->index, p->anc2->index, p->BBM0omg);
									}
								}
							}
			
						/* Introduce Mutacion */
						if (matrixC[pos(p->anc1->label,siteCodon,numSites)] > -1) /* va por anc1 */
							{
							cumProb[0] = Pij[matrixC[pos(p->anc1->label,siteCodon,numSites)]][0];
							j = matrixC[pos(p->anc1->label,siteCodon,numSites)];
							/*fprintf (fpmpi, "\n Pij[%d][x]", j);		
							fprintf (fpmpi, "\n matrixC[pos(p->anc1->label,siteCodon,numSites) = %d", matrixC[pos(p->anc1->label,siteCodon,numSites)]);
							fprintf (fpmpi, "\n cumProb[0] = %lf", cumProb[0]);*/
							for (i=1; i<NUMCOD; i++)
								{
								cumProb[i] = cumProb[i-1] + Pij[matrixC[pos(p->anc1->label,siteCodon,numSites)]][i];
								/*fprintf (fpmpi, "\n cumProb[%d] = %lf", i, cumProb[i]);*/
								}
								
							ran = RandomUniform(seed);
							matrixC[pos(p->label,siteCodon,numSites)] = bbin(ran, cumProb); /* binary search in the probabilities */
							/*fprintf (fpmpi, "\n ran = %lf ",ran);*/
					
							/*if (matrixC[pos(p->label,siteCodon,numSites)] > 60)*/  /* check */
							/*	{
								for (i=0; i<NUMCOD; i++)
									{
									fprintf (stderr, "\n");
									a = 0;
									for (j=0; j<NUMCOD; j++)
										{
										fprintf (stderr, "P[%d][%d] = %3.2f ",i,j,Pij[i][j]);
										a = a + Pij[i][j];
										}
									fprintf (stderr, "\n a = %lf \n\n", a);
									}
								fprintf (stderr, "\n stop codon22 %d\n", matrixC[pos(p->label,siteCodon,numSites)]);
								exit(-1);
								}*/

							if (matrixC[pos(p->label,siteCodon,numSites)] != matrixC[pos(p->anc1->label,siteCodon,numSites)])
								{
								numMU++;
								/*fprintf(stderr,"\n < MUT (rec SI por anc1), numMU = %d \n", numMU);*/

								aminoacid1 = codonTable_DnDs(matrixC[pos(p->label,siteCodon,numSites)]);
								aminoacid2 = codonTable_DnDs(matrixC[pos(p->anc1->label,siteCodon,numSites)]);
								if (aminoacid1 == aminoacid2)
									{
									numMU_S++;
									/*fprintf (stderr, "\n Syn mut: %d to %d, numMU_S = %d \n", aminoacid1, aminoacid2, numMU_S);*/
									}
								else
									{
									numMU_NS++;
									/*fprintf (stderr, "\n NonSyn mut: %d to %d, numMU_NS = %d \n", aminoacid1, aminoacid2, numMU_NS);*/
									}
								if ((aminoacid1 == -1) || (aminoacid2 == -1))
									{
									fprintf (stderr, "\n error in type of mutations %d %d\n", aminoacid1, aminoacid2);
									exit(-1);
									}
								aminoacid1 = aminoacid2 = -1;
								}
						/*	fprintf (stderr, " Node %d to %d - matrixC[pos(p->label,siteCodon,numSites)] = %d, matrixC[pos(p->anc1->label,siteCodon,numSites)] = %d, numMU = %d \n",  p->index, p->anc1->index, matrixC[pos(p->label,siteCodon,numSites)], matrixC[pos(p->anc1->label,siteCodon,numSites)], numMU);
							fprintf (stderr, " (p->anc1->time - p->time) = %lf \n", (p->anc1->time - p->time)); */

							/* check section */
							if (matrixC[pos(p->anc1->label,siteCodon,numSites)] < 0) 
								{
								fprintf (stderr, "\n\n Warning in RECURSIVE_NET function (3): p->anc1->label = %d\n", p->anc1->label);
								exit (-1);
								}
							for (step = 0; step < p->anc1->numSegNode; step++)			
								{
								s = segments + post(step,p->anc1->index,distance);				
								if ((s->sStart <= nuc1 && s->sEnd >= nuc1) || (s->sStart <= nuc2 && s->sEnd >= nuc2) || (s->sStart <= nuc3 && s->sEnd >= nuc3))
									control++;
								}
							if (control == 0)
								{
								fprintf (stderr, "\n\n Warning in RECURSIVE_NET function (3): control = %d\n", control);
								exit (-1);
								}
							}
						else /* va por anc2 */
							{
							cumProb[0] = Pij[matrixC[pos(p->anc2->label,siteCodon,numSites)]][0];
							j = matrixC[pos(p->anc2->label,siteCodon,numSites)];
							/*fprintf (fpmpi, "\n Pij[%d][x]", j);		
							fprintf (fpmpi, "\n matrixC[pos(p->anc1->label,siteCodon,numSites) = %d", matrixC[pos(p->anc1->label,siteCodon,numSites)]);
							fprintf (fpmpi, "\n cumProb[0] = %lf", cumProb[0]);*/
							for (i=1; i<NUMCOD; i++)
								{
								cumProb[i] = cumProb[i-1] + Pij[matrixC[pos(p->anc2->label,siteCodon,numSites)]][i];
								/*fprintf (fpmpi, "\n cumProb[%d] = %lf", i, cumProb[i]);*/
								}
								
							ran = RandomUniform(seed);
							matrixC[pos(p->label,siteCodon,numSites)] = bbin(ran, cumProb); /* binary search in the probabilities */
							/*fprintf (fpmpi, "\n ran = %lf ",ran);*/
					
							/*if (matrixC[pos(p->label,siteCodon,numSites)] > 60)*/  /* check */
								/*{
								for (i=0; i<NUMCOD; i++)
									{
									fprintf (stderr, "\n");
									a = 0;
									for (j=0; j<NUMCOD; j++)
										{
										fprintf (stderr, "P[%d][%d] = %3.2f ",i,j,Pij[i][j]);
										a = a + Pij[i][j];
										}
									fprintf (stderr, "\n a = %lf \n\n", a);
									}
								fprintf (stderr, "\n stop codon22 %d\n", matrixC[pos(p->label,siteCodon,numSites)]);
								exit(-1);
								}*/
			
							if (matrixC[pos(p->label,siteCodon,numSites)] != matrixC[pos(p->anc2->label,siteCodon,numSites)])
								{
								numMU++;
								/*fprintf(stderr,"\n < MUT (rec SI por anc2), numMU = %d \n", numMU);*/

								/* NEW MA */
								aminoacid1 = codonTable_DnDs(matrixC[pos(p->label,siteCodon,numSites)]);
								aminoacid2 = codonTable_DnDs(matrixC[pos(p->anc2->label,siteCodon,numSites)]);
								if (aminoacid1 == aminoacid2)
									{
									numMU_S++;
									/*fprintf (stderr, "\n Syn mut: %d to %d, numMU_S = %d \n", aminoacid1, aminoacid2, numMU_S);*/
									}
								else
									{
									numMU_NS++;
									/*fprintf (stderr, "\n NonSyn mut: %d to %d, numMU_NS = %d \n", aminoacid1, aminoacid2, numMU_NS);*/
									}
								if ((aminoacid1 == -1) || (aminoacid2 == -1))
									{
									fprintf (stderr, "\n error in type of mutations %d %d\n", aminoacid1, aminoacid2);
									exit(-1);
									}
								aminoacid1 = aminoacid2 = -1;
								}
						/*	fprintf (stderr, " Node %d to %d - matrixC[pos(p->label,siteCodon,numSites)] = %d, matrixC[pos(p->anc2->label,siteCodon,numSites)] = %d, numMU = %d \n",  p->index, p->anc1->index, matrixC[pos(p->label,siteCodon,numSites)], matrixC[pos(p->anc2->label,siteCodon,numSites)], numMU);
							fprintf (stderr, " (p->anc2->time - p->time) = %lf \n", (p->anc2->time - p->time)); */
							
							/* check section */
							if (matrixC[pos(p->anc2->label,siteCodon,numSites)] < 0) 
								{
								fprintf (stderr, "\n\n Warning in RECURSIVE_NET function (4): p->anc2->label = %d\n", p->anc2->label);
								exit (-1);
								}
							for (step = 0; step < p->anc2->numSegNode; step++)			
								{
								s = segments + post(step,p->anc2->index,distance);				
								if ((s->sStart <= nuc1 && s->sEnd >= nuc1) || (s->sStart <= nuc2 && s->sEnd >= nuc2) || (s->sStart <= nuc3 && s->sEnd >= nuc3))
									control++;
								}
							if (control == 0)
								{
								fprintf (stderr, "\n\n Warning in RECURSIVE_NET function (4): control = %d\n", control);
								exit (-1);
								}
							}
						/* fin Mutacion */

						/* Combining the codons of these recombinant nodes */
						if (doCombineCodons == YES) 
							{
							/*fprintf (fpmpi, "\n In doCombineCodons --\n");*/

							if (p->whereBreakCodon == 3)
								{
								InCodon2 = matrixC[pos(p->label,siteCodon,numSites)];
								InCodon1 = matrixC[pos(q->label,siteCodon,numSites)];
								brokePosition = q->whereBreakCodon;
								/*fprintf (stderr, "\n Case P: brokePosition = %d, InCodon1 = %d (q->label = %d, q->index = %d), InCodon2 = %d\n", brokePosition, InCodon1, q->label, q->index, InCodon2);*/
								}
							else if (q->whereBreakCodon == 3)
								{
								InCodon2 = matrixC[pos(q->label,siteCodon,numSites)];
								InCodon1 = matrixC[pos(p->label,siteCodon,numSites)];
								brokePosition = p->whereBreakCodon;
								/*fprintf (stderr, "\n Case q: brokePosition = %d, InCodon1 = %d, InCodon2 = %d\n", brokePosition, InCodon1, InCodon2);*/
								}
							else
								{
								fprintf (stderr, "\n\n Warning in SimulateDataForSite_Codon_RECURSIVE_NET \n");
								exit(-1);
								}
							outCodon = CombineTwoCodons (InCodon1, InCodon2, brokePosition); /*function combine y paste*/
							if (noisy > 3)
								{
								/*fprintf (stderr, " InCodon1 = %d, InCodon2 = %d, brokePosition = %d", InCodon1, InCodon2, brokePosition);*/
								fprintf (stderr, " Combining two codon by recombination: Codon1 = %d, Codon2 = %d", InCodon1, InCodon2);
								fprintf (stderr, " to the new Codon = %d \n", outCodon);
								}

							matrixC[pos(p->label,siteCodon,numSites)] = outCodon;
							matrixC[pos(q->label,siteCodon,numSites)] = outCodon;
							/*fprintf (stderr, " NEW FOR!!: p->label = %d, q->label = %d, matrixC[pos(p->label,siteCodon,numSites)] = %d, numMU = %d \n\n", p->label, q->label, matrixC[pos(p->label,siteCodon,numSites)], numMU);*/
							}
						/* fin Mutacion */
						}
		
					/* It crosses the tree */
					if (doRepitEvol == NO)
						{
						if (NOcontinueNode == 0 && k > 0)
							{
							SimulateDataForSite_Codon_RECURSIVE_NET (p->left, siteCodon, numSites, m, numOmegaCat, varRate, seed, Cbroke);
							SimulateDataForSite_Codon_RECURSIVE_NET (p->right, siteCodon, numSites, m, numOmegaCat, varRate, seed, Cbroke);
							}
						else
							NOcontinueNode = 0;	
						if (thereisOutgroup == YES)
							SimulateDataForSite_Codon_RECURSIVE_NET (p->outgroup, siteCodon, numSites, m, numOmegaCat, varRate, seed, Cbroke);	
						}
					}
				}
			}
		}
	}




/********************************** CombineTwoCodons ***********************************/
/* It combines two codons to make a new codon based in a broke position  */

int		CombineTwoCodons (int InCodon1, int InCodon2, int brokePosition)
	{
	int outCodon, nucNumber1[3], nucNumber2[3], nucOutNumber[3];
	char  nuc1[3], nuc2[3]/*, out[3]*/;
	int i, j, k, a, b, c;

	outCodon = j = k = a = b = c = 0;
	for (i=0; i<=2; i++)
		{
		nucNumber1[i] = -1;
		nucNumber2[i] = -1;
		nucOutNumber[i] = -1;
		}

	if (InCodon1 == InCodon2)
		outCodon = InCodon1;
	else
		{
		number_to_codon(InCodon1, nuc1);
		number_to_codon(InCodon2, nuc2);

		for (i=0; i<=2; i++)
			{
			if (nuc1[i] == 'A')
				nucNumber1[i] = 0;
			else if (nuc1[i] == 'C')
				nucNumber1[i] = 1;
			else if (nuc1[i] == 'G')
				nucNumber1[i] = 2;
			else if (nuc1[i] == 'T')
				nucNumber1[i] = 3;
			else {			
				fprintf (fpmpi, "error in codon of CombineTwoCodons (1)\n"); 			
				exit(-1);
				}
			}
		for (i=0; i<=2; i++)
			{
			if (nuc2[i] == 'A')
				nucNumber2[i] = 0;
			else if (nuc2[i] == 'C')
				nucNumber2[i] = 1;
			else if (nuc2[i] == 'G')
				nucNumber2[i] = 2;
			else if (nuc2[i] == 'T')
				nucNumber2[i] = 3;
			else {			
				fprintf (fpmpi, "error in codon of CombineTwoCodons (2)\n"); 			
				exit(-1);
				}
			}

		/*for (i = 0; i<=2; i++)
			{
			fprintf (stderr, " nucNumber1[%d] = %d, nucNumber2[%d] = %d \n", i, nucNumber1[i], i, nucNumber2[i]);			
			}*/		

		/*j = makeCodonFromNuc (nucNumber1[0], nucNumber1[1], nucNumber1[2]);
		k = makeCodonFromNuc (nucNumber2[0], nucNumber2[1], nucNumber2[2]);
		fprintf (stderr, "\n codon1 = %d, codon2 = %d \n", j, k);*/
		/* Codon crossing */
		if (brokePosition == 1)
			{
			nucOutNumber[0] = nucNumber1[0];
			nucOutNumber[1] = nucNumber2[1];
			nucOutNumber[2] = nucNumber2[2];
			}
		else if (brokePosition == 2)
			{
			nucOutNumber[0] = nucNumber1[0];
			nucOutNumber[1] = nucNumber1[1];
			nucOutNumber[2] = nucNumber2[2];
			}
		else 
			{			
			fprintf (fpmpi, "error in codon of CombineTwoCodons - Across codons\n"); 			
			exit(-1);
			}
		/*for (i = 0; i<=2; i++)
			{
			fprintf (stderr, " nucOutNumber[%d] = %d\n", i, nucOutNumber[i]);			
			}*/
		/*nucOutNumber[0] = 3;
		nucOutNumber[1] = 0;
		nucOutNumber[1] = 0;*/
		
		/* STOP CODONS TAA TAG TGA */
		if (nucOutNumber[0] == 3)
			if ((nucOutNumber[1] == 0 && nucOutNumber[2] == 0) || (nucOutNumber[1] == 0 && nucOutNumber[2] == 2) || (nucOutNumber[1] == 2 && nucOutNumber[2] == 0))
				{
				if (noisy > 1)
					fprintf (fpmpi, "\nStop codon created from the recombination inside of the codon \nRestarting the evolution model from the GMRCA .. \n");
				/*exit(-1);*/
				doRepitEvol = YES; /* Repit the evolution of the sequences */
				numStopCodonREC++; 			
				}


		if (doRepitEvol == NO)
			outCodon = makeCodonFromNuc (nucOutNumber[0], nucOutNumber[1], nucOutNumber[2]); /* Warning and END if the new codon is STOP */
		else
			outCodon = -1;
		
		
		/*number_to_codon(outCodon, out);
		for (i=0; i<=2; i++)
			{
			if (out[i] == 'A')
				{
				nucOutNumber[i] = 0;
				fprintf (fpmpi, " nucOutNumber[%d] = %d\n", i, nucOutNumber[i]); 
				}
			else if (out[i] == 'C')
				{
				nucOutNumber[i] = 1;
				fprintf (fpmpi, " nucOutNumber[%d] = %d\n", i, nucOutNumber[i]);
				}
			else if (out[i] == 'G')
				{
				nucOutNumber[i] = 2;
				fprintf (fpmpi, " nucOutNumber[%d] = %d\n", i, nucOutNumber[i]);
				}
			else if (out[i] == 'T')
				{
				nucOutNumber[i] = 3;
				fprintf (fpmpi, " nucOutNumber[%d] = %d\n", i, nucOutNumber[i]);
				}
			else {			
				fprintf (fpmpi, "error in codon of CombineTwoCodons (2)\n"); 			
				exit(-1);
				}
			}*/

		}

	
	/* Results */
	/*if (InCodon1 == InCodon2) 
		{
		numEqual2++; 
		}
	if ((InCodon1 != InCodon2) && (outCodon > -1))
		{
		if ((InCodon1 == outCodon) || (InCodon2 == outCodon))
			numEqual1++;
		if ((InCodon1 != outCodon) && (InCodon2 != outCodon))
			{
			a = codonTable_DnDs(InCodon1);
			b = codonTable_DnDs(InCodon2);
			c = codonTable_DnDs(outCodon);

			if ((c == a) || (c == b))
				numDifCodSameAA++;
			if ((c != a) && (c != b))
				numDifCodDifAA++;
			}
		}*/
	/*numEqual2, numEqual1, numDifCodSameAA, numDifCodDifAA;*/
	if (outCodon > -1)
		{
		a = codonTable_DnDs(InCodon1);
		b = codonTable_DnDs(InCodon2);
		c = codonTable_DnDs(outCodon);
		if ((a == c) && (b == c))
			numNonSyn0++;
		if ((c != a) && (c != b))
			numNonSyn2++;
		if ((c != a) && (c == b))
			numNonSyn1++;
		if ((c == a) && (c != b))
			numNonSyn1++;
		}


	return (outCodon);
	}












/********************************** SimulateDataForSite_Codon ***********************************/
/* Simulates the nucleotide substitution process for a given codon */

/*void SimulateDataForSite_Codon (TreeNode *p, int siteCodon, int numSites, double m, int numOmegaCat, double varRate, long int *seed)
	{
	int			i, j;
	double		ran, cumProb[NUMCOD], Pij[NUMCOD][NUMCOD];
	double a,b;
	int aminoacid1, aminoacid2;
	
	
	a = 0;
	b = 0;
	
	if (p != NULL)
		{
		if (p->anc1 != NULL) 
			{			
			if (p->isOutgroup == YES)
				{
				if (doOmegaCat == YES || doOmegaRateHetDisc == YES)
					CodonModel_Cat (Pij, p->length * m, varRate, numOmegaCat, seed);
				else 																*/			/* omega cte or doOmegaRateHetCont == YES or doM6 == YES */
	/*				CodonModel (Pij, p->length * m, varRate, seed);
				}
			else
				{
				if (doOmegaCat == YES || doOmegaRateHetDisc == YES)
					CodonModel_Cat (Pij, (p->anc1->time - p->time) * m, varRate, numOmegaCat, seed);
				else 																*/			/* omega cte or doOmegaRateHetCont == YES or doM6 == YES */
	/*				CodonModel (Pij, (p->anc1->time - p->time) * m, varRate, seed);
				}
			
			cumProb[0] = Pij[matrixC[pos(p->anc1->label,siteCodon,numSites)]][0];
			j = matrixC[pos(p->anc1->label,siteCodon,numSites)]; */
			
			/*fprintf (fpmpi, "\n Pij[%d][x]", j);		
			fprintf (fpmpi, "\n matrixC[pos(p->anc1->label,siteCodon,numSites) = %d", matrixC[pos(p->anc1->label,siteCodon,numSites)]);
			fprintf (fpmpi, "\n cumProb[0] = %lf", cumProb[0]);
			*/
			
	/*		for (i=1; i<NUMCOD; i++)
				{
				cumProb[i] = cumProb[i-1] + Pij[matrixC[pos(p->anc1->label,siteCodon,numSites)]][i];	*/
				/*
				fprintf (fpmpi, "\n cumProb[%d] = %lf", i, cumProb[i]);
				*/
	/*			}
								
			ran = RandomUniform(seed);
			matrixC[pos(p->label,siteCodon,numSites)] = bbin(ran, cumProb); 	*/								/* binary search in the probabilities */
			
	/*		if (matrixC[pos(p->label,siteCodon,numSites)] > 60)  				*/								/* check */
	/*			{
				for (i=0; i<NUMCOD; i++)
					{
					fprintf (stderr, "\n");
					a = 0;
					for (j=0; j<NUMCOD; j++)
						{
						fprintf (stderr, "P[%d][%d] = %3.2f ",i,j,Pij[i][j]);
						a = a + Pij[i][j];
						}
					fprintf (stderr, "\n a = %lf \n\n", a);
					}
				
				fprintf (stderr, "\n SimulateDataForSite_Codon: 2. stop codon22 %d\n", matrixC[pos(p->label,siteCodon,numSites)]);
				exit(-1);
				}
			
			if (matrixC[pos(p->label,siteCodon,numSites)] != matrixC[pos(p->anc1->label,siteCodon,numSites)])
				{
				numMU++;
				aminoacid1 = codonTable_DnDs(matrixC[pos(p->label,siteCodon,numSites)]);
				aminoacid2 = codonTable_DnDs(matrixC[pos(p->anc1->label,siteCodon,numSites)]);
				if (aminoacid1 == aminoacid2)
					numMU_S++;
				else
					numMU_NS++;
				if ((aminoacid1 == -1) || (aminoacid2 == -1))
					{
					fprintf (stderr, "\n error in type of mutations %d %d\n", aminoacid1, aminoacid2);
					exit(-1);
					}
				aminoacid1 = aminoacid2 = -1;
				}
				
			}	*/
		
		/* It crosses the tree */
	/*	SimulateDataForSite_Codon (p->left, siteCodon, numSites, m, numOmegaCat, varRate, seed);
		SimulateDataForSite_Codon (p->right, siteCodon, numSites, m, numOmegaCat, varRate, seed);	
		if (thereisOutgroup == YES)
			SimulateDataForSite_Codon (p->outgroup, siteCodon, numSites, m, numOmegaCat, varRate, seed);	
		}
	}	*/




/***************** bbin_EnterMRCA *****************/
/* binary search of the codon MRCA sequence */
int bbin_EnterMRCA (double dat, double *v)
	{
     int init,end,middle;
     init = 0;
     end = 63;
    
	 if (dat >= 0 && dat <= v[0])
		return 0;
	 
	 while (init <= end) 
		{
		middle = (init+end)/2;
         
		if (dat > v[middle-1] && dat <= v[middle])
			return (middle);
		else if (dat > v[middle])
			init = middle+1;
		else 
			end = middle-1;
		}
	
	fprintf (fpmpi, "\n Warning in bbin_EnterMRCA function");
     exit (-1);
	 return -1;
	}




/***************** bbin *****************/
/* binary search of the probabilities */
int bbin (double dat, double *v)
	{
     int init,end,middle;
     init = 0;
     end = NUMCOD;
    
	 if (dat >= 0 && dat <= v[0])
		return 0;
	 
	 while (init <= end) 
		{
		middle = (init+end)/2;
         
		if (dat > v[middle-1] && dat <= v[middle])
			return (middle);
		else if (dat > v[middle])
			init = middle+1;
		else 
			end = middle-1;
		}
	
	fprintf (fpmpi, "\n Warning in bbin function");	
     exit (-1);
	 return -1;
	}


/***************** bbinDemes *****************/
/* binary search in the probabilities with demes*/
int bbinDemes (double dat, double *v, int n)
	{
	int init,end,middle;
	 
	if (dat >= 0 && dat <= v[1])
		return (1); /* first population */
	 
     init = 1;
     end = n;
    
	 while (init <= end) 
		{
		middle = (init+end)/2;
         
		if (dat > v[middle-1] && dat <= v[middle])
			return (middle);
		else if (dat > v[middle])
			init = middle+1;
		else 
			end = middle-1;
		}
	
	fprintf (fpmpi, "\n Warning in bbinDemes function");
     exit (-1);
	 return -1;
	}




/***************** bbinInOmegaCat *****************/
/* binary search in the probabilities with demes */
int bbinInOmegaCat (double dat, double *v, int n)
	{
	int init,end,middle;
	 
	if (dat >= 0 && dat <= v[1])
		return (1); /* first population */
	 
     init = 1;
     end = n;
    
	 while (init <= end) 
		{
		middle = (init+end)/2;
         
		if (dat > v[middle-1] && dat <= v[middle])
			return (middle);
		else if (dat > v[middle])
			init = middle+1;
		else 
			end = middle-1;
		}
	
	fprintf (fpmpi, "\n Warning in bbinInOmegaCat function");
     exit (-1);
	 return -1;
	}







/********************************** EnterCodonMRCA_File ***********************************/
/* Enter the MRCA sequence (from input file or by the nucleotide frequencies) for codon model */

int		EnterCodonMRCA_File (TreeNode *p, int siteNum, int numNuc, char *MRCAsequence, int out_C[4])
	{
	int			j;
	j = -1;
	
	if (p != NULL)
		{
		if (p->anc1 == NULL) /* root */		
			{
			if (doMRCAFile == YES)
				matrix[pos(p->label,siteNum,numNuc)] = WhichNucNumber(MRCAsequence[siteNum-1]);
			else
				{
				fprintf (fpmpi, "\n Warning in EnterCodonMRCA_File");				
				exit (-1);
				}
			out_C[0] = p->label;
			j = matrix[pos(p->label,siteNum,numNuc)];
			}
		}
	return (j);
	}


/********************************** EnterCodonMRCA_Freq ***********************************/
/* Enter the MRCA sequence (from input file or by the nucleotide frequencies) for codon model */

int		EnterCodonMRCA_Freq (TreeNode *p, int siteNum, int sitePosition, int numNuc, int out_C[4], int codon[3])
	{
	int			j;
	j = -1;


	if (p != NULL)
		{
		if (p->anc1 == NULL) /* root */		
			{
			if (doMRCAFile == YES)
				{
				fprintf (fpmpi, "\n Warning in EnterCodonMRCA_Freq");				
				exit (-1);
				}
			else
				{

				/*fprintf (fpmpi, "\nMRCA p->index = %d", p->index);	
				if (p->label == 1)
					{
					fprintf(stderr,"\n ***** p->label = %d, p->index = %d, p->time = %lf, sitioNum = %d \n", p->label, p->index,  p->time, siteNum);
					}*/


				if (sitePosition == 1)
					matrix[pos(p->label,siteNum,numNuc)] = codon[0];
				else if (sitePosition == 2)
					matrix[pos(p->label,siteNum,numNuc)] = codon[1];
				else if (sitePosition == 3)
					matrix[pos(p->label,siteNum,numNuc)] = codon[2];
				else
					{
					fprintf (stderr, "\nWarning in generates de MRCA sequence from nucleotide frequencies");					
					exit(-1);
					}
				}
			out_C[0] = p->label;
			j = matrix[pos(p->label,siteNum,numNuc)];
			}
		}
	return (j);
	}





/********************* buildCodonMatrix_Qij_Cijk **********************/
/* It builds the Qij and Cijk matrix to codon Model */
/* This fuction was verified perfectly by Nielsen codon model Code */
static void	buildCodonMatrix_Qij_Cijk ()
	{
	int i, j, m, w;
	double k[NUMCOD], AAcontribution;
	
	/*double Qij_C[NUMCOD][NUMCOD], double omega, double titv, double p_i[4], double p_i_codon[12]*/ /* Global Variables */	
	/* rows = leave codons, columns = arrive codons */
		
	/* initiallity */
	m = 0;
	AAcontribution = 1.00;

	for (i = 0; i < NUMCOD; i++)
		{
		k[i] = 0.0;
		for (j = 0; j < NUMCOD; j++)
			Qij_C[i][j] = 0.0;
		}
	for (w=0;w<NUMCOD;w++)
		Root_C[w] = 0.0;
	for (w=0;w<NUMCOD*NUMCOD*NUMCOD*NUMCOD;w++)
		Cijk_C[w] = 0.0;

	for (i = 0; i < NUMCOD; i++)
		{
		for (j = 0; j < NUMCOD; j++)
			{
			Qij_CC[m] = 0;
			/*fprintf (stderr, "\nQij_CC[%d] = %3.2f ", m, Qij_CC[m]);*/
			m++;
			}
		}
	m = i = j = 0;
	/*fprintf (stderr,"\n \n buildCodonMatrix_Qij_Cijk: omega = %lf \n\n\n", omega);*/	


	/* Qij matrix building */
	for (i = 0; i < NUMCOD; i++)
		{
		for (j = 0; j < NUMCOD; j++)
			{
			if (numdif_codon(i,j) == 1)	/* only when there is 1 change */ 
				{
				Qij_C[i][j] = codonTable_frequencies(j) /*0.25*/; 	/* frequencies of arrive codon. Main diagonal (0 substitutions) and more than 1 substitution = 0 */
																	/* from here single those of 1 single change are affected, more than 1 change = 0 (something*0 = 0) */
				if (codonTable_DnDs(i) != codonTable_DnDs(j))
					{				
					Qij_C[i][j] = Qij_C[i][j]*omega;							/* nonsynonymous substitutions */
					
					/* ONLY if crossed also with an empirical aa model */
					if (doGY94xAAmodel == YES) 
						{
						AAcontribution = giveAAcontribution(i,j);
						Qij_C[i][j] = Qij_C[i][j]*AAcontribution;
						/*fprintf(stderr,"\n Codon change %d %d; AAcontribution = %lf \n", i, j, AAcontribution);*/
						}
					}
				
				/*fprintf(stderr,"\n \n omega = %lf", omega);*/
				
				if (doCodon_HKY == YES)										/* Codon Model HKY */
					{
					if (codon_tr_tv(i, j) == 0) /* only transitions */
						Qij_C[i][j] = Qij_C[i][j]*/*titv*/kappa;
					}
				
				if (doCodon_GTR == YES)										/* Codon Model GTR */
					Qij_C[i][j] = Qij_C[i][j]*codon_Rmat(i,j); 
				
				if (doCodon_NGTR == YES)									/* Codon Model non variable GTR */
					{
					Qij_C[i][j] = Qij_C[i][j]*codon_NRmat(i,j);
					/*fprintf (stderr,"\n ESPECIAL, codon_NRmat = %lf, Qij_C[%d][%d] = %lf", codon_NRmat(i,j), i, j, Qij_C[i][j]);*/
					}
				}
			}
		}	
	
	
	/* MAIN diagonal (row sum = 0) */
	mr = 0;
	for (i = 0; i < NUMCOD; i++)
		for (j = 0; j < NUMCOD; j++)
			k[i] = k[i] + Qij_C[i][j];
	for (i = 0; i < NUMCOD; i++)
		for (j = 0; j < NUMCOD; j++)
			if (i == j)
				{
				Qij_C[i][j] = 0.0;
				Qij_C[i][j] = 0.0-k[i];
				
				mr -= Qij_C[i][j]*codonTable_frequencies(j); /* mr, will be Eigen input */
				}
	/* scala factor is good (Felsenstein book, pag 205) */

	/* Qij_CC[4096], matrix Qij_C in just a vector */
	for (i = 0; i < NUMCOD; i++)
		{
		for (j = 0; j < NUMCOD; j++)
			{
			Qij_CC[m] = Qij_C[i][j];
			/*fprintf (stderr, "\nQij_CC[%d] = %3.2f ", m, Qij_CC[m]);*/
			m++;
			}
		}
	
	/* Active to see the Qij matrix */
	/*fprintf (stderr, "\nIn the matrix Qij_C, End:");
	for (i = 0; i < NUMCOD; i++)
		for (j = 0; j < NUMCOD; j++)
			fprintf (stderr, "\nQij_C[%d][%d] = %lf ", i, j, Qij_C[i][j]);*/
			
	/* Doing eigen */
	EigenREV_Codon(Root_C, Cijk_C); /* Root_C y Cijk_C bilds in eigen. Input Qij_CC and mr. EYE!, Qij_CC change by Eigen */
	
	
	/*for (i = 0; i< NUMCOD*NUMCOD*NUMCOD*NUMCOD;i++)
		fprintf (stderr, " \n Cijk_C [%d] = %3.2f ", i, Cijk_C[i]);*/
	/*for (i = 0; i< NUMCOD;i++)
		fprintf (stderr, " \n Root_C [%d] = %3.2f ", i, Root_C[i]);*/
	}





/********************* buildCodonMatrix_MG94_Qij_Cijk **********************/
/* It builds the Qij and Cijk matrix to MG94 codon Model */
static void	buildCodonMatrix_MG94_Qij_Cijk ()
	{
	int i, j, m, w;
	double k[NUMCOD];
	char codonX[3], codonY[3];
	int NtIs, z, positionChange;
	double myFreqHere;
	
	/*double Qij_C[NUMCOD][NUMCOD], double omega, double titv, double p_i[4], double p_i_codon[12]*/ /* Global Variables */	
	/* rows = leave codons, columns = arrive codons */
		
	/* initiallity */
	m = 0;
	NtIs = -1;
	myFreqHere = 0.0;
	positionChange = -1;

	for (i = 0; i < NUMCOD; i++)
		{
		k[i] = 0.0;
		for (j = 0; j < NUMCOD; j++)
			Qij_C[i][j] = 0.0;
		}
	for (w=0;w<NUMCOD;w++)
		Root_C[w] = 0.0;
	for (w=0;w<NUMCOD*NUMCOD*NUMCOD*NUMCOD;w++)
		Cijk_C[w] = 0.0;

	for (i = 0; i < NUMCOD; i++)
		{
		for (j = 0; j < NUMCOD; j++)
			{
			Qij_CC[m] = 0;
			/*fprintf (stderr, "\nQij_CC[%d] = %3.2f ", m, Qij_CC[m]);*/
			m++;
			}
		}
	m = i = j = 0;
	/*fprintf (stderr,"\n\n buildCodonMatrix_MG94_Qij_Cijk: SynRate = %lf, NonSynRate = %lf\n\n\n", SynRate, NonSynRate);*/


	/* Qij matrix building */
	for (i = 0; i < NUMCOD; i++)
		{
		for (j = 0; j < NUMCOD; j++)
			{
			if (numdif_codon(i,j) == 1)	/* only when there is 1 change */ /* from here single those of 1 single change are affected, more than 1 change = 0 (something*0 = 0) */
				{

				/* Frequency */
				number_to_codon(i, codonX);
				number_to_codon(j, codonY);

				for (z=0; z<3; z++) /* here we compare both codons, i and j, for each position */
					{
					if (codonX[z] != codonY[z]) /* in this position it is the difference: positionChange = 0, 1, 2 */
						{
						positionChange = z;					

						/* which is the arrival nucleotide for this position of the arrival codon?: NtIs = 0, 1, 2, 3 */
						if (codonY[z] == 'A')
							{
							NtIs = 0;
							}
						if (codonY[z] == 'C')
							{
							NtIs = 1;
							}
						if (codonY[z] == 'G')
							{
							NtIs = 2;
							}
						if (codonY[z] == 'T')
							{
							NtIs = 3;
							}
						}
					}


				if (positionChange == 0)
					{
					myFreqHere = p_i_codon[NtIs];
					}
				else if (positionChange == 1)
					{
					myFreqHere = p_i_codon[NtIs+4];
					}
				else if (positionChange == 2)
					{
					myFreqHere = p_i_codon[NtIs+8];
					}
				else
					{
					fprintf (fpmpi, "\n Error in buildCodonMatrix_MG94_Qij_Cijk, parameter positionChange (%d) \n", positionChange);
					exit(-1);
					}

				Qij_C[i][j] = myFreqHere; 	/* MG94 codon model = frequency of arrived nucleotide in the arrived codon */
																	

				/* rates */
				if (codonTable_DnDs(i) != codonTable_DnDs(j))	/* nonsynonymous substitution */			
					Qij_C[i][j] = Qij_C[i][j]*NonSynRate;							
				if (codonTable_DnDs(i) != codonTable_DnDs(j))	/* synonymous substitution */			
					Qij_C[i][j] = Qij_C[i][j]*SynRate;								

				/*fprintf(stderr,"\n\n SynRate = %lf, NonSynRate = %lf\n", SynRate, NonSynRate);*/


				/* nt models */				
				if (doCodon_HKY == YES)										/* Codon Model HKY */
					{
					if (codon_tr_tv(i, j) == 0) /* only transitions */
						Qij_C[i][j] = Qij_C[i][j]*/*titv*/kappa;
					}
				
				if (doCodon_GTR == YES)										/* Codon Model GTR */
					Qij_C[i][j] = Qij_C[i][j]*codon_Rmat(i,j); 
				
				if (doCodon_NGTR == YES)									/* Codon Model non variable GTR */
					{
					Qij_C[i][j] = Qij_C[i][j]*codon_NRmat(i,j);
					/*fprintf (stderr,"\n SPECIAL, codon_NRmat = %lf, Qij_C[%d][%d] = %lf", codon_NRmat(i,j), i, j, Qij_C[i][j]);*/
					}
				}
			}
		}	
	
	
	/* MAIN diagonal (row sum = 0) */
	mr = 0;
	for (i = 0; i < NUMCOD; i++)
		for (j = 0; j < NUMCOD; j++)
			k[i] = k[i] + Qij_C[i][j];
	for (i = 0; i < NUMCOD; i++)
		for (j = 0; j < NUMCOD; j++)
			if (i == j)
				{
				Qij_C[i][j] = 0.0;
				Qij_C[i][j] = 0.0-k[i];
				
				mr -= Qij_C[i][j]*codonTable_frequencies(j); /* mr, will be Eigen input */
				}
	/* scala factor is good (Felsenstein book, pag 205) */

	/* Qij_CC[4096], matrix Qij_C in just a vector */
	for (i = 0; i < NUMCOD; i++)
		{
		for (j = 0; j < NUMCOD; j++)
			{
			Qij_CC[m] = Qij_C[i][j];
			/*fprintf (stderr, "\nQij_CC[%d] = %3.2f ", m, Qij_CC[m]);*/
			m++;
			}
		}
	
	/* Active to see the Qij matrix */
	/*fprintf (stderr, "\nIn the matrix Qij_C, End:");
	for (i = 0; i < NUMCOD; i++)
		for (j = 0; j < NUMCOD; j++)
			fprintf (stderr, "\nQij_C[%d][%d] = %lf ", i, j, Qij_C[i][j]);*/
			
	/* Doing eigen */
	EigenREV_Codon(Root_C, Cijk_C); /* Root_C y Cijk_C bilds in eigen. Input Qij_CC and mr. EYE!, Qij_CC change by Eigen */
	
	
	/*for (i = 0; i< NUMCOD*NUMCOD*NUMCOD*NUMCOD;i++)
		fprintf (stderr, " \n Cijk_C [%d] = %3.2f ", i, Cijk_C[i]);*/
	/*for (i = 0; i< NUMCOD;i++)
		fprintf (stderr, " \n Root_C [%d] = %3.2f ", i, Root_C[i]);*/
	}







/********************* buildCodonMatrix_Qij_Cijk **********************/
/* It builds the Qij and Cijk matrix to empirical codon Model */
static void	buildCodonMatrix_EmpiricalCodonModel_Qij_Cijk ()
	{
	int i, j, m, w;
	double k[NUMCOD], sumPi_Codb;
	
	/*double Qij_C[NUMCOD][NUMCOD], double omega, double titv, double p_i[4], double p_i_codon[12]*/ /* Global Variables */	
	/* rows = leave codons, columns = arrive codons */
		
	/* initiallity */
	m = 0;
	for (i = 0; i < NUMCOD; i++)
		{
		k[i] = 0.0;
		for (j = 0; j < NUMCOD; j++)
			Qij_C[i][j] = -1;
		}
	for (w=0;w<NUMCOD;w++)
		Root_C[w] = 0.0;
	for (w=0;w<NUMCOD*NUMCOD*NUMCOD*NUMCOD;w++)
		Cijk_C[w] = 0.0;

	for (i = 0; i < NUMCOD; i++)
		{
		for (j = 0; j < NUMCOD; j++)
			{
			Qij_CC[m] = 0;
			/*fprintf (stderr, "\nQij_CC[%d] = %3.2f ", m, Qij_CC[m]);*/
			m++;
			}
		}
	m = i = j = 0;
	/*fprintf (stderr,"\n\n In buildCodonMatrix_EmpiricalCodonModel_Qij_Cijk \n\n");*/	



	/*** Qij matrix building ***/
	/** 1. make matrix **/
	Empirical_Codon_model ();


	/* check if the matrix is symmetric: [0][1] = [1][0] */
	for (i = 0; i < NUMCOD; i++)
		for (j = 0; j < NUMCOD; j++)
			{
			if (i == j) /* cjeck main diagonal, should be = 0 */
				{
				if (Qij_C[i][j] > 0.00000000001 || Qij_C[i][j] < -0.00000000001)
					{
					if (noisy > 2)
						fprintf (stderr, "\n\n> Warning in the emperical codon matrix. Main diagonal is different to 0: Q[%d][%d] = %lf \n\n", i, j, Qij_C[i][j]);
					}
				}
			else /* [0][1] = [1][0] */
				{
				if (Qij_C[i][j] != Qij_C[j][i])
					{
					if (noisy > 2)
						fprintf (stderr, "\n\n> Warning in the emperical codon matrix. Matrix is not symmetric: Q[%d][%d] (%lf) = Q[%d][%d] (%lf) \n\n", i, j, Qij_C[i][j], j, i, Qij_C[j][i]);
					}

				}			
			}




	/** 2. Add frequencies **/
	/* If the user specify codon frequencies, such frequencies are considered; otherwise, the frequencies from the ECM are used */
	if (doFreqGiven == YES && NumberFrequencies == 12)
		{
		for (i = 0; i < NUMCOD; i++)
			{
			for (j = 0; j < NUMCOD; j++)
				{
				Qij_C[i][j] = Qij_C[i][j]*codonTable_frequencies(j);
				}
			}
		}
	else
		{
		/* check */
		for (i = 0; i < NUMCOD; i++) 
			if (Qij_CF[i] < 0 || Qij_CF[i] > 1)
				{
				fprintf (stderr, "ERROR: Bad number of ECM frequencies (it must to be between 0 and 1) (%lf)\n\n", Qij_CF[i]);
				PrintUsage();
				}

		/* Freqs must sum 1 */
		sumPi_Codb = 0.0;
		for (i = 0; i < NUMCOD; i++)
			{
			sumPi_Codb = sumPi_Codb + Qij_CF[i];
			}
		if (sumPi_Codb != 1.0) 
			{
			for (i = 0; i < NUMCOD; i++)
				{
				Qij_CF[i]/=sumPi_Codb;
				}
			}

		/* see freqs */
		/*for (j = 0; j < NUMCOD; j++)
			{
			fprintf (stderr, "\n Freqs: Qij_CF[%d] = %lf ", j, Qij_CF[j]);
			}*/


		for (i = 0; i < NUMCOD; i++)
			{
			for (j = 0; j < NUMCOD; j++)
				{
				Qij_C[i][j] = Qij_C[i][j]*Qij_CF[j];
				}
			}
		}

	
	/** 3. MAIN diagonal (row sum = 0) **/
	mr = 0;
	for (i = 0; i < NUMCOD; i++)
		for (j = 0; j < NUMCOD; j++)
			k[i] = k[i] + Qij_C[i][j];
	for (i = 0; i < NUMCOD; i++)
		for (j = 0; j < NUMCOD; j++)
			if (i == j)
				{
				Qij_C[i][j] = 0.0;
				Qij_C[i][j] = 0.0-k[i];
				
				if (doFreqGiven == YES && NumberFrequencies == 12)
					{
					mr -= Qij_C[i][j]*codonTable_frequencies(j); /* mr, will be Eigen input */
					}
				else
					{
					mr -= Qij_C[i][j]*Qij_CF[j]; /* mr, will be Eigen input */
					}
				}
	/* scala factor is good (Felsenstein book, pag 205) */


	/* Active to see the Qij matrix */
	/*fprintf (stderr, "\nIn the matrix Qij_C, End:");
	for (i = 0; i < NUMCOD; i++)
		for (j = 0; j < NUMCOD; j++)
			fprintf (stderr, "\n Qij_C[%d][%d] = %lf ", i, j, Qij_C[i][j]);*/



	/* Qij_CC[4096], matrix Qij_C in just a vector */
	for (i = 0; i < NUMCOD; i++)
		{
		for (j = 0; j < NUMCOD; j++)
			{
			Qij_CC[m] = Qij_C[i][j];
			/*fprintf (stderr, "\nQij_CC[%d] = %3.2f ", m, Qij_CC[m]);*/
			m++;
			}
		}
	
	/* Active to see the Qij matrix */
	/*fprintf (stderr, "\nIn the matrix Qij_C, End:");
	for (i = 0; i < NUMCOD; i++)
		for (j = 0; j < NUMCOD; j++)
			fprintf (stderr, "\nQij_C[%d][%d] = %lf ", i, j, Qij_C[i][j]);*/
			
	/* Doing eigen */
	EigenREV_Codon(Root_C, Cijk_C); /* Root_C y Cijk_C bilds in eigen. Input Qij_CC and mr. EYE!, Qij_CC change by Eigen */
	
	
	/*for (i = 0; i< NUMCOD*NUMCOD*NUMCOD*NUMCOD;i++)
		fprintf (stderr, " \n Cijk_C [%d] = %3.2f ", i, Cijk_C[i]);*/
	/*for (i = 0; i< NUMCOD;i++)
		fprintf (stderr, " \n Root_C [%d] = %3.2f ", i, Root_C[i]);*/
	}











/********************* buildAAMatrix_Qij_Cijk **********************/
/* It builds the Qij and Cijk matrix to amino acid  Model */
static void	buildAAMatrix_Qij_Cijk ()
	{
	int i, j, m, w;
	double k[NUMAA], sumPi_AAb;
	
	/* double 	Rmat_AA[NUMAA+2], Qij_AAa[NUMAA*NUMAA], Cijk_AA[NUMAA*NUMAA*NUMAA*NUMAA], Root_AA[NUMAA], Qij_AA[NUMAA][NUMAA]; */ /* Global Variables */	

	/* rows = leaving amino acids, columns = arriving amino acids */	
	/* 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 */
	/* A R N D C Q E G H I L K M F P S T W Y V */ 



	/* initiallity */
	m = 0;
	for (i = 0; i < NUMAA; i++)
		{
		k[i] = 0.0;
		for (j = 0; j < NUMAA; j++)
			Qij_AA[i][j] = 0.0;
		}
	for (w=0;w<NUMAA;w++)
		Root_AA[w] = 0.0;
	for (w=0;w<NUMAA*NUMAA*NUMAA*NUMAA;w++)
		Cijk_AA[w] = 0.0;


	for (i = 0; i < NUMAA; i++)
		{
		for (j = 0; j < NUMAA; j++)
			{
			Qij_AAa[m] = 0;
			/*fprintf (stderr, "\nQij_AAa[%d] = %3.2f ", m, Qij_AAa[m]);*/
			m++;
			}
		}
	m = i = j = 0;
	/*fprintf(stderr,"\n \n buildAAMatrix_Qij_Cijk: model = %s\n\n\n", modelAA);*/	


	/*** Qij matrix building ***/
	/** 1. Choice of the empirical model -> assign rates of change **/ 
	/* Models implemented: Blosum62, CpRev, Dayhoff, DayhoffDCMUT, HIVb, HIVw, JTT, JonesDCMUT, LG, Mtart, Mtmam, Mtrev24, RtRev, VT, WAG */
	
	Empirical_AA_model ();



	/* check if the matrix is symmetric: [0][1] = [1][0] */
	for (i = 0; i < NUMAA; i++)
		for (j = 0; j < NUMAA; j++)
			{
			if (i == j) /* cjeck main diagonal, should be = 0 */
				{
				if (Qij_AA[i][j] > 0.00000000001 || Qij_AA[i][j] < -0.00000000001)
					{
					if (noisy > 3)
						fprintf (stderr, "\n\n> Warning in the emperical amino acid matrix. Main diagonal is different to 0: Q[%d][%d] = %lf \n\n", i, j, Qij_AA[i][j]);
					}
				}
			else /* [0][1] = [1][0] */
				{
				if (Qij_AA[i][j] != Qij_AA[j][i])
					{
					if (noisy > 3)
						fprintf (stderr, "\n\n> Warning in the emperical amino acid matrix. Matrix is not symmetric: Q[%d][%d] (%lf) = Q[%d][%d] (%lf) \n\n", i, j, Qij_AA[i][j], j, i, Qij_AA[j][i]);
					}

				}			
			}


	/* Active to see the EAAM Qij matrix and Freqs */
	/*fprintf (stderr, "\nIn the matrix Qij_AA:\n");
	for (i = 0; i < NUMAA; i++)
		for (j = 0; j < NUMAA; j++)
			{
			fprintf (stderr, "Qij_AA[%d][%d] = %lf ", i, j, Qij_AA[i][j]);
			if (j == NUMAA-1)
				fprintf (stderr, "\n");
			}
	for (j = 0; j < NUMAA; j++)
		{
		fprintf (stderr, "\n Freqs: AA_EM_Pi[%d] = %lf ", j, AA_EM_Pi[j]);
		}*/



	/** 2. Add frequencies **/
	/* If the user specify aa frequencies, such frequencies are considered; otherwise, the frequencies from the EM are used */
	/* 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 */
	/* A R N D C Q E G H I L K M F P S T W Y V */
	if (doFreqGiven == YES && NumberFrequencies == 20)
		{
		for (i = 0; i < NUMAA; i++)
			{
			for (j = 0; j < NUMAA; j++)
				{
				Qij_AA[i][j] = Qij_AA[i][j]*p_i_aa[j];
				}
			}
		}
	else
		{
		/* check */
		for (i = 0; i < NUMAA; i++) 
			if (AA_EM_Pi[i] < 0 || AA_EM_Pi[i] > 1)
					{
					fprintf (stderr, "ERROR: Bad number of EAAM frequencies (it must to be between 0 and 1) (%lf)\n\n", AA_EM_Pi[i]);
					PrintUsage();
					}

		/* Freqs must sum 1 */
		sumPi_AAb = 0.0;
		for (i = 0; i < NUMAA; i++)
			{
			sumPi_AAb = sumPi_AAb + AA_EM_Pi[i];
			}
		if (sumPi_AAb != 1.0) 
			{
			for (i = 0; i < NUMAA; i++)
				{
				AA_EM_Pi[i]/=sumPi_AAb;
				}
			}

		/* see freqs */
		/*for (j = 0; j < NUMAA; j++)
			{
			fprintf (stderr, "\n Freqs: AA_EM_Pi[%d] = %lf ", j, AA_EM_Pi[j]);
			}*/


		for (i = 0; i < NUMAA; i++)
			{
			for (j = 0; j < NUMAA; j++)
				{
				Qij_AA[i][j] = Qij_AA[i][j]*AA_EM_Pi[j];

				}
			}
		}



	/** 3. Main diagonal (row sum = 0) **/
	mr = 0;
	for (i = 0; i < NUMAA; i++)
		for (j = 0; j < NUMAA; j++)
			k[i] = k[i] + Qij_AA[i][j];
	for (i = 0; i < NUMAA; i++)
		for (j = 0; j < NUMAA; j++)
			if (i == j)
				{
				Qij_AA[i][j] = 0.0;
				Qij_AA[i][j] = 0.0-k[i];
				
				if (doFreqGiven == YES && NumberFrequencies == 20)
					{
					mr -= Qij_AA[i][j]*p_i_aa[j]; /* mr, will be Eigen input */
					}
				else
					{
					mr -= Qij_AA[i][j]*AA_EM_Pi[j]; /* mr, will be Eigen input */
					}
				
				}


	/* Active to see the Qij matrix */
	/*fprintf (stderr, "\nIn the matrix Qij_AA, End:");
	for (i = 0; i < NUMAA; i++)
		for (j = 0; j < NUMAA; j++)
			fprintf (stderr, "\nQij_AA[%d][%d] = %lf ", i, j, Qij_AA[i][j]);*/




	/*** Qij_AAa[400], matrix Qij_AA in just a vector ***/
	for (i = 0; i < NUMAA; i++)
		{
		for (j = 0; j < NUMAA; j++)
			{
			Qij_AAa[m] = Qij_AA[i][j];
			/*fprintf (stderr, "\nQij_AAa[%d] = %3.2f ", m, Qij_AAa[m]);*/
			m++;
			}
		}


			
	/* Doing eigen */
	EigenREV_AA(Root_AA, Cijk_AA); /* Root_AA y Cijk_AA builds in eigen. Input Qij_AAa and mr.    EYE!, Qij_AAa change by Eigen */
	
	
	/*for (i = 0; i< NUMAA*NUMAA*NUMAA*NUMAA;i++)
		fprintf (stderr, " \n Cijk_AA [%d] = %3.2f ", i, Cijk_AA[i]);*/
	/*for (i = 0; i< NUMAA;i++)
		fprintf (stderr, " \n Root_AA [%d] = %3.2f ", i, Root_AA[i]);*/
	}







/****************************** Empirical_AA_model *******************************/
/*Empirical amino acid models*/
 static void Empirical_AA_model ()
	{
	int i, j;
	
	if (doBlosum62 == YES)
		{
		Qij_AA[0][0] = 0.000000000000; Qij_AA[0][1] = 0.735790389698; Qij_AA[0][2] = 0.485391055466; Qij_AA[0][3] = 0.543161820899; Qij_AA[0][4] = 1.459995310470; 
		Qij_AA[0][5] = 1.199705704602; Qij_AA[0][6] = 1.170949042800; Qij_AA[0][7] = 1.955883574960; Qij_AA[0][8] = 0.716241444998; Qij_AA[0][9] = 0.605899003687; 
		Qij_AA[0][10] = 0.800016530518; Qij_AA[0][11] = 1.295201266783; Qij_AA[0][12] = 1.253758266664; Qij_AA[0][13] = 0.492964679748; Qij_AA[0][14] = 1.173275900924; 
		Qij_AA[0][15] = 4.325092687057; Qij_AA[0][16] = 1.729178019485; Qij_AA[0][17] = 0.465839367725; Qij_AA[0][18] = 0.718206697586; Qij_AA[0][19] = 2.187774522005; 
		Qij_AA[1][0] = 0.735790389698; Qij_AA[1][1] = 0.000000000000; Qij_AA[1][2] = 1.297446705134; Qij_AA[1][3] = 0.500964408555; Qij_AA[1][4] = 0.227826574209; 
		Qij_AA[1][5] = 3.020833610064; Qij_AA[1][6] = 1.360574190420; Qij_AA[1][7] = 0.418763308518; Qij_AA[1][8] = 1.456141166336; Qij_AA[1][9] = 0.232036445142; 
		Qij_AA[1][10] = 0.622711669692; Qij_AA[1][11] = 5.411115141489; Qij_AA[1][12] = 0.983692987457; Qij_AA[1][13] = 0.371644693209; Qij_AA[1][14] = 0.448133661718; 
		Qij_AA[1][15] = 1.122783104210; Qij_AA[1][16] = 0.914665954563; Qij_AA[1][17] = 0.426382310122; Qij_AA[1][18] = 0.720517441216; Qij_AA[1][19] = 0.438388343772; 
		Qij_AA[2][0] = 0.485391055466; Qij_AA[2][1] = 1.297446705134; Qij_AA[2][2] = 0.000000000000; Qij_AA[2][3] = 3.180100048216; Qij_AA[2][4] = 0.397358949897; 
		Qij_AA[2][5] = 1.839216146992; Qij_AA[2][6] = 1.240488508640; Qij_AA[2][7] = 1.355872344485; Qij_AA[2][8] = 2.414501434208; Qij_AA[2][9] = 0.283017326278; 
		Qij_AA[2][10] = 0.211888159615; Qij_AA[2][11] = 1.593137043457; Qij_AA[2][12] = 0.648441278787; Qij_AA[2][13] = 0.354861249223; Qij_AA[2][14] = 0.494887043702; 
		Qij_AA[2][15] = 2.904101656456; Qij_AA[2][16] = 1.898173634533; Qij_AA[2][17] = 0.191482046247; Qij_AA[2][18] = 0.538222519037; Qij_AA[2][19] = 0.312858797993; 
		Qij_AA[3][0] = 0.543161820899; Qij_AA[3][1] = 0.500964408555; Qij_AA[3][2] = 3.180100048216; Qij_AA[3][3] = 0.000000000000; Qij_AA[3][4] = 0.240836614802; 
		Qij_AA[3][5] = 1.190945703396; Qij_AA[3][6] = 3.761625208368; Qij_AA[3][7] = 0.798473248968; Qij_AA[3][8] = 0.778142664022; Qij_AA[3][9] = 0.418555732462; 
		Qij_AA[3][10] = 0.218131577594; Qij_AA[3][11] = 1.032447924952; Qij_AA[3][12] = 0.222621897958; Qij_AA[3][13] = 0.281730694207; Qij_AA[3][14] = 0.730628272998; 
		Qij_AA[3][15] = 1.582754142065; Qij_AA[3][16] = 0.934187509431; Qij_AA[3][17] = 0.145345046279; Qij_AA[3][18] = 0.261422208965; Qij_AA[3][19] = 0.258129289418; 
		Qij_AA[4][0] = 1.459995310470; Qij_AA[4][1] = 0.227826574209; Qij_AA[4][2] = 0.397358949897; Qij_AA[4][3] = 0.240836614802; Qij_AA[4][4] = 0.000000000000; 
		Qij_AA[4][5] = 0.329801504630; Qij_AA[4][6] = 0.140748891814; Qij_AA[4][7] = 0.418203192284; Qij_AA[4][8] = 0.354058109831; Qij_AA[4][9] = 0.774894022794; 
		Qij_AA[4][10] = 0.831842640142; Qij_AA[4][11] = 0.285078800906; Qij_AA[4][12] = 0.767688823480; Qij_AA[4][13] = 0.441337471187; Qij_AA[4][14] = 0.356008498769; 
		Qij_AA[4][15] = 1.197188415094; Qij_AA[4][16] = 1.119831358516; Qij_AA[4][17] = 0.527664418872; Qij_AA[4][18] = 0.470237733696; Qij_AA[4][19] = 1.116352478606; 
		Qij_AA[5][0] = 1.199705704602; Qij_AA[5][1] = 3.020833610064; Qij_AA[5][2] = 1.839216146992; Qij_AA[5][3] = 1.190945703396; Qij_AA[5][4] = 0.329801504630; 
		Qij_AA[5][5] = 0.000000000000; Qij_AA[5][6] = 5.528919177928; Qij_AA[5][7] = 0.609846305383; Qij_AA[5][8] = 2.435341131140; Qij_AA[5][9] = 0.236202451204; 
		Qij_AA[5][10] = 0.580737093181; Qij_AA[5][11] = 3.945277674515; Qij_AA[5][12] = 2.494896077113; Qij_AA[5][13] = 0.144356959750; Qij_AA[5][14] = 0.858570575674; 
		Qij_AA[5][15] = 1.934870924596; Qij_AA[5][16] = 1.277480294596; Qij_AA[5][17] = 0.758653808642; Qij_AA[5][18] = 0.958989742850; Qij_AA[5][19] = 0.530785790125; 
		Qij_AA[6][0] = 1.170949042800; Qij_AA[6][1] = 1.360574190420; Qij_AA[6][2] = 1.240488508640; Qij_AA[6][3] = 3.761625208368; Qij_AA[6][4] = 0.140748891814; 
		Qij_AA[6][5] = 5.528919177928; Qij_AA[6][6] = 0.000000000000; Qij_AA[6][7] = 0.423579992176; Qij_AA[6][8] = 1.626891056982; Qij_AA[6][9] = 0.186848046932; 
		Qij_AA[6][10] = 0.372625175087; Qij_AA[6][11] = 2.802427151679; Qij_AA[6][12] = 0.555415397470; Qij_AA[6][13] = 0.291409084165; Qij_AA[6][14] = 0.926563934846; 
		Qij_AA[6][15] = 1.769893238937; Qij_AA[6][16] = 1.071097236007; Qij_AA[6][17] = 0.407635648938; Qij_AA[6][18] = 0.596719300346; Qij_AA[6][19] = 0.524253846338; 
		Qij_AA[7][0] = 1.955883574960; Qij_AA[7][1] = 0.418763308518; Qij_AA[7][2] = 1.355872344485; Qij_AA[7][3] = 0.798473248968; Qij_AA[7][4] = 0.418203192284; 
		Qij_AA[7][5] = 0.609846305383; Qij_AA[7][6] = 0.423579992176; Qij_AA[7][7] = 0.000000000000; Qij_AA[7][8] = 0.539859124954; Qij_AA[7][9] = 0.189296292376; 
		Qij_AA[7][10] = 0.217721159236; Qij_AA[7][11] = 0.752042440303; Qij_AA[7][12] = 0.459436173579; Qij_AA[7][13] = 0.368166464453; Qij_AA[7][14] = 0.504086599527; 
		Qij_AA[7][15] = 1.509326253224; Qij_AA[7][16] = 0.641436011405; Qij_AA[7][17] = 0.508358924638; Qij_AA[7][18] = 0.308055737035; Qij_AA[7][19] = 0.253340790190; 
		Qij_AA[8][0] = 0.716241444998; Qij_AA[8][1] = 1.456141166336; Qij_AA[8][2] = 2.414501434208; Qij_AA[8][3] = 0.778142664022; Qij_AA[8][4] = 0.354058109831; 
		Qij_AA[8][5] = 2.435341131140; Qij_AA[8][6] = 1.626891056982; Qij_AA[8][7] = 0.539859124954; Qij_AA[8][8] = 0.000000000000; Qij_AA[8][9] = 0.252718447885; 
		Qij_AA[8][10] = 0.348072209797; Qij_AA[8][11] = 1.022507035889; Qij_AA[8][12] = 0.984311525359; Qij_AA[8][13] = 0.714533703928; Qij_AA[8][14] = 0.527007339151; 
		Qij_AA[8][15] = 1.117029762910; Qij_AA[8][16] = 0.585407090225; Qij_AA[8][17] = 0.301248600780; Qij_AA[8][18] = 4.218953969389; Qij_AA[8][19] = 0.201555971750; 
		Qij_AA[9][0] = 0.605899003687; Qij_AA[9][1] = 0.232036445142; Qij_AA[9][2] = 0.283017326278; Qij_AA[9][3] = 0.418555732462; Qij_AA[9][4] = 0.774894022794; 
		Qij_AA[9][5] = 0.236202451204; Qij_AA[9][6] = 0.186848046932; Qij_AA[9][7] = 0.189296292376; Qij_AA[9][8] = 0.252718447885; Qij_AA[9][9] = 0.000000000000; 
		Qij_AA[9][10] = 3.890963773304; Qij_AA[9][11] = 0.406193586642; Qij_AA[9][12] = 3.364797763104; Qij_AA[9][13] = 1.517359325954; Qij_AA[9][14] = 0.388355409206; 
		Qij_AA[9][15] = 0.357544412460; Qij_AA[9][16] = 1.179091197260; Qij_AA[9][17] = 0.341985787540; Qij_AA[9][18] = 0.674617093228; Qij_AA[9][19] = 8.311839405458; 
		Qij_AA[10][0] = 0.800016530518; Qij_AA[10][1] = 0.622711669692; Qij_AA[10][2] = 0.211888159615; Qij_AA[10][3] = 0.218131577594; Qij_AA[10][4] = 0.831842640142; 
		Qij_AA[10][5] = 0.580737093181; Qij_AA[10][6] = 0.372625175087; Qij_AA[10][7] = 0.217721159236; Qij_AA[10][8] = 0.348072209797; Qij_AA[10][9] = 3.890963773304; 
		Qij_AA[10][10] = 0.000000000000; Qij_AA[10][11] = 0.445570274261; Qij_AA[10][12] = 6.030559379572; Qij_AA[10][13] = 2.064839703237; Qij_AA[10][14] = 0.374555687471; 
		Qij_AA[10][15] = 0.352969184527; Qij_AA[10][16] = 0.915259857694; Qij_AA[10][17] = 0.691474634600; Qij_AA[10][18] = 0.811245856323; Qij_AA[10][19] = 2.231405688913; 
		Qij_AA[11][0] = 1.295201266783; Qij_AA[11][1] = 5.411115141489; Qij_AA[11][2] = 1.593137043457; Qij_AA[11][3] = 1.032447924952; Qij_AA[11][4] = 0.285078800906; 
		Qij_AA[11][5] = 3.945277674515; Qij_AA[11][6] = 2.802427151679; Qij_AA[11][7] = 0.752042440303; Qij_AA[11][8] = 1.022507035889; Qij_AA[11][9] = 0.406193586642; 
		Qij_AA[11][10] = 0.445570274261; Qij_AA[11][11] = 0.000000000000; Qij_AA[11][12] = 1.073061184332; Qij_AA[11][13] = 0.266924750511; Qij_AA[11][14] = 1.047383450722; 
		Qij_AA[11][15] = 1.752165917819; Qij_AA[11][16] = 1.303875200799; Qij_AA[11][17] = 0.332243040634; Qij_AA[11][18] = 0.717993486900; Qij_AA[11][19] = 0.498138475304; 
		Qij_AA[12][0] = 1.253758266664; Qij_AA[12][1] = 0.983692987457; Qij_AA[12][2] = 0.648441278787; Qij_AA[12][3] = 0.222621897958; Qij_AA[12][4] = 0.767688823480; 
		Qij_AA[12][5] = 2.494896077113; Qij_AA[12][6] = 0.555415397470; Qij_AA[12][7] = 0.459436173579; Qij_AA[12][8] = 0.984311525359; Qij_AA[12][9] = 3.364797763104; 
		Qij_AA[12][10] = 6.030559379572; Qij_AA[12][11] = 1.073061184332; Qij_AA[12][12] = 0.000000000000; Qij_AA[12][13] = 1.773855168830; Qij_AA[12][14] = 0.454123625103; 
		Qij_AA[12][15] = 0.918723415746; Qij_AA[12][16] = 1.488548053722; Qij_AA[12][17] = 0.888101098152; Qij_AA[12][18] = 0.951682162246; Qij_AA[12][19] = 2.575850755315; 
		Qij_AA[13][0] = 0.492964679748; Qij_AA[13][1] = 0.371644693209; Qij_AA[13][2] = 0.354861249223; Qij_AA[13][3] = 0.281730694207; Qij_AA[13][4] = 0.441337471187; 
		Qij_AA[13][5] = 0.144356959750; Qij_AA[13][6] = 0.291409084165; Qij_AA[13][7] = 0.368166464453; Qij_AA[13][8] = 0.714533703928; Qij_AA[13][9] = 1.517359325954; 
		Qij_AA[13][10] = 2.064839703237; Qij_AA[13][11] = 0.266924750511; Qij_AA[13][12] = 1.773855168830; Qij_AA[13][13] = 0.000000000000; Qij_AA[13][14] = 0.233597909629; 
		Qij_AA[13][15] = 0.540027644824; Qij_AA[13][16] = 0.488206118793; Qij_AA[13][17] = 2.074324893497; Qij_AA[13][18] = 6.747260430801; Qij_AA[13][19] = 0.838119610178; 
		Qij_AA[14][0] = 1.173275900924; Qij_AA[14][1] = 0.448133661718; Qij_AA[14][2] = 0.494887043702; Qij_AA[14][3] = 0.730628272998; Qij_AA[14][4] = 0.356008498769; 
		Qij_AA[14][5] = 0.858570575674; Qij_AA[14][6] = 0.926563934846; Qij_AA[14][7] = 0.504086599527; Qij_AA[14][8] = 0.527007339151; Qij_AA[14][9] = 0.388355409206; 
		Qij_AA[14][10] = 0.374555687471; Qij_AA[14][11] = 1.047383450722; Qij_AA[14][12] = 0.454123625103; Qij_AA[14][13] = 0.233597909629; Qij_AA[14][14] = 0.000000000000; 
		Qij_AA[14][15] = 1.169129577716; Qij_AA[14][16] = 1.005451683149; Qij_AA[14][17] = 0.252214830027; Qij_AA[14][18] = 0.369405319355; Qij_AA[14][19] = 0.496908410676; 
		Qij_AA[15][0] = 4.325092687057; Qij_AA[15][1] = 1.122783104210; Qij_AA[15][2] = 2.904101656456; Qij_AA[15][3] = 1.582754142065; Qij_AA[15][4] = 1.197188415094; 
		Qij_AA[15][5] = 1.934870924596; Qij_AA[15][6] = 1.769893238937; Qij_AA[15][7] = 1.509326253224; Qij_AA[15][8] = 1.117029762910; Qij_AA[15][9] = 0.357544412460; 
		Qij_AA[15][10] = 0.352969184527; Qij_AA[15][11] = 1.752165917819; Qij_AA[15][12] = 0.918723415746; Qij_AA[15][13] = 0.540027644824; Qij_AA[15][14] = 1.169129577716; 
		Qij_AA[15][15] = 0.000000000000; Qij_AA[15][16] = 5.151556292270; Qij_AA[15][17] = 0.387925622098; Qij_AA[15][18] = 0.796751520761; Qij_AA[15][19] = 0.561925457442; 
		Qij_AA[16][0] = 1.729178019485; Qij_AA[16][1] = 0.914665954563; Qij_AA[16][2] = 1.898173634533; Qij_AA[16][3] = 0.934187509431; Qij_AA[16][4] = 1.119831358516; 
		Qij_AA[16][5] = 1.277480294596; Qij_AA[16][6] = 1.071097236007; Qij_AA[16][7] = 0.641436011405; Qij_AA[16][8] = 0.585407090225; Qij_AA[16][9] = 1.179091197260; 
		Qij_AA[16][10] = 0.915259857694; Qij_AA[16][11] = 1.303875200799; Qij_AA[16][12] = 1.488548053722; Qij_AA[16][13] = 0.488206118793; Qij_AA[16][14] = 1.005451683149; 
		Qij_AA[16][15] = 5.151556292270; Qij_AA[16][16] = 0.000000000000; Qij_AA[16][17] = 0.513128126891; Qij_AA[16][18] = 0.801010243199; Qij_AA[16][19] = 2.253074051176; 
		Qij_AA[17][0] = 0.465839367725; Qij_AA[17][1] = 0.426382310122; Qij_AA[17][2] = 0.191482046247; Qij_AA[17][3] = 0.145345046279; Qij_AA[17][4] = 0.527664418872; 
		Qij_AA[17][5] = 0.758653808642; Qij_AA[17][6] = 0.407635648938; Qij_AA[17][7] = 0.508358924638; Qij_AA[17][8] = 0.301248600780; Qij_AA[17][9] = 0.341985787540; 
		Qij_AA[17][10] = 0.691474634600; Qij_AA[17][11] = 0.332243040634; Qij_AA[17][12] = 0.888101098152; Qij_AA[17][13] = 2.074324893497; Qij_AA[17][14] = 0.252214830027; 
		Qij_AA[17][15] = 0.387925622098; Qij_AA[17][16] = 0.513128126891; Qij_AA[17][17] = 0.000000000000; Qij_AA[17][18] = 4.054419006558; Qij_AA[17][19] = 0.266508731426; 
		Qij_AA[18][0] = 0.718206697586; Qij_AA[18][1] = 0.720517441216; Qij_AA[18][2] = 0.538222519037; Qij_AA[18][3] = 0.261422208965; Qij_AA[18][4] = 0.470237733696; 
		Qij_AA[18][5] = 0.958989742850; Qij_AA[18][6] = 0.596719300346; Qij_AA[18][7] = 0.308055737035; Qij_AA[18][8] = 4.218953969389; Qij_AA[18][9] = 0.674617093228; 
		Qij_AA[18][10] = 0.811245856323; Qij_AA[18][11] = 0.717993486900; Qij_AA[18][12] = 0.951682162246; Qij_AA[18][13] = 6.747260430801; Qij_AA[18][14] = 0.369405319355; 
		Qij_AA[18][15] = 0.796751520761; Qij_AA[18][16] = 0.801010243199; Qij_AA[18][17] = 4.054419006558; Qij_AA[18][18] = 0.000000000000; Qij_AA[18][19] = 1.000000000000; 
		Qij_AA[19][0] = 2.187774522005; Qij_AA[19][1] = 0.438388343772; Qij_AA[19][2] = 0.312858797993; Qij_AA[19][3] = 0.258129289418; Qij_AA[19][4] = 1.116352478606; 
		Qij_AA[19][5] = 0.530785790125; Qij_AA[19][6] = 0.524253846338; Qij_AA[19][7] = 0.253340790190; Qij_AA[19][8] = 0.201555971750; Qij_AA[19][9] = 8.311839405458; 
		Qij_AA[19][10] = 2.231405688913; Qij_AA[19][11] = 0.498138475304; Qij_AA[19][12] = 2.575850755315; Qij_AA[19][13] = 0.838119610178; Qij_AA[19][14] = 0.496908410676; 
		Qij_AA[19][15] = 0.561925457442; Qij_AA[19][16] = 2.253074051176; Qij_AA[19][17] = 0.266508731426; Qij_AA[19][18] = 1.000000000000; Qij_AA[19][19] = 0.000000000000; 	


		AA_EM_Pi[0] = 0.074; 
		AA_EM_Pi[1] = 0.052; 
		AA_EM_Pi[2] = 0.045; 
		AA_EM_Pi[3] = 0.054;
		AA_EM_Pi[4] = 0.025; 
		AA_EM_Pi[5] = 0.034; 
		AA_EM_Pi[6] = 0.054; 
		AA_EM_Pi[7] = 0.074;
		AA_EM_Pi[8] = 0.026; 
		AA_EM_Pi[9] = 0.068; 
		AA_EM_Pi[10] = 0.099; 
		AA_EM_Pi[11] = 0.058;
		AA_EM_Pi[12] = 0.025; 
		AA_EM_Pi[13] = 0.047; 
		AA_EM_Pi[14] = 0.039; 
		AA_EM_Pi[15] = 0.057;
		AA_EM_Pi[16] = 0.051; 
		AA_EM_Pi[17] = 0.013; 
		AA_EM_Pi[18] = 0.032; 
		AA_EM_Pi[19] = 0.073;
		}
	else if (doCpRev == YES)
		{
		Qij_AA[0][0] =    0; Qij_AA[0][1] =  105; Qij_AA[0][2] =  227; Qij_AA[0][3] =  175; Qij_AA[0][4] =  669; 
		Qij_AA[0][5] =  157; Qij_AA[0][6] =  499; Qij_AA[0][7] =  665; Qij_AA[0][8] =   66; Qij_AA[0][9] =  145; 
		Qij_AA[0][10] =  197; Qij_AA[0][11] =  236; Qij_AA[0][12] =  185; Qij_AA[0][13] =   68; Qij_AA[0][14] =  490; 
		Qij_AA[0][15] = 2440; Qij_AA[0][16] = 1340; Qij_AA[0][17] =   14; Qij_AA[0][18] =   56; Qij_AA[0][19] =  968; 
		Qij_AA[1][0] =  105; Qij_AA[1][1] =    0; Qij_AA[1][2] =  357; Qij_AA[1][3] =   43; Qij_AA[1][4] =  823; 
		Qij_AA[1][5] = 1745; Qij_AA[1][6] =  152; Qij_AA[1][7] =  243; Qij_AA[1][8] =  715; Qij_AA[1][9] =  136; 
		Qij_AA[1][10] =  203; Qij_AA[1][11] = 4482; Qij_AA[1][12] =  125; Qij_AA[1][13] =   53; Qij_AA[1][14] =   87; 
		Qij_AA[1][15] =  385; Qij_AA[1][16] =  314; Qij_AA[1][17] =  230; Qij_AA[1][18] =  323; Qij_AA[1][19] =   92; 
		Qij_AA[2][0] =  227; Qij_AA[2][1] =  357; Qij_AA[2][2] =    0; Qij_AA[2][3] = 4435; Qij_AA[2][4] =  538; 
		Qij_AA[2][5] =  768; Qij_AA[2][6] = 1055; Qij_AA[2][7] =  653; Qij_AA[2][8] = 1405; Qij_AA[2][9] =  168; 
		Qij_AA[2][10] =  113; Qij_AA[2][11] = 2430; Qij_AA[2][12] =   61; Qij_AA[2][13] =   97; Qij_AA[2][14] =  173; 
		Qij_AA[2][15] = 2085; Qij_AA[2][16] = 1393; Qij_AA[2][17] =   40; Qij_AA[2][18] =  754; Qij_AA[2][19] =   83; 
		Qij_AA[3][0] =  175; Qij_AA[3][1] =   43; Qij_AA[3][2] = 4435; Qij_AA[3][3] =    0; Qij_AA[3][4] =   10; 
		Qij_AA[3][5] =  400; Qij_AA[3][6] = 3691; Qij_AA[3][7] =  431; Qij_AA[3][8] =  331; Qij_AA[3][9] =   10; 
		Qij_AA[3][10] =   10; Qij_AA[3][11] =  412; Qij_AA[3][12] =   47; Qij_AA[3][13] =   22; Qij_AA[3][14] =  170; 
		Qij_AA[3][15] =  590; Qij_AA[3][16] =  266; Qij_AA[3][17] =   18; Qij_AA[3][18] =  281; Qij_AA[3][19] =   75; 
		Qij_AA[4][0] =  669; Qij_AA[4][1] =  823; Qij_AA[4][2] =  538; Qij_AA[4][3] =   10; Qij_AA[4][4] =    0; 
		Qij_AA[4][5] =   10; Qij_AA[4][6] =   10; Qij_AA[4][7] =  303; Qij_AA[4][8] =  441; Qij_AA[4][9] =  280; 
		Qij_AA[4][10] =  396; Qij_AA[4][11] =   48; Qij_AA[4][12] =  159; Qij_AA[4][13] =  726; Qij_AA[4][14] =  285; 
		Qij_AA[4][15] = 2331; Qij_AA[4][16] =  576; Qij_AA[4][17] =  435; Qij_AA[4][18] = 1466; Qij_AA[4][19] =  592; 
		Qij_AA[5][0] =  157; Qij_AA[5][1] = 1745; Qij_AA[5][2] =  768; Qij_AA[5][3] =  400; Qij_AA[5][4] =   10; 
		Qij_AA[5][5] =    0; Qij_AA[5][6] = 3122; Qij_AA[5][7] =  133; Qij_AA[5][8] = 1269; Qij_AA[5][9] =   92; 
		Qij_AA[5][10] =  286; Qij_AA[5][11] = 3313; Qij_AA[5][12] =  202; Qij_AA[5][13] =   10; Qij_AA[5][14] =  323; 
		Qij_AA[5][15] =  396; Qij_AA[5][16] =  241; Qij_AA[5][17] =   53; Qij_AA[5][18] =  391; Qij_AA[5][19] =   54; 
		Qij_AA[6][0] =  499; Qij_AA[6][1] =  152; Qij_AA[6][2] = 1055; Qij_AA[6][3] = 3691; Qij_AA[6][4] =   10; 
		Qij_AA[6][5] = 3122; Qij_AA[6][6] =    0; Qij_AA[6][7] =  379; Qij_AA[6][8] =  162; Qij_AA[6][9] =  148; 
		Qij_AA[6][10] =   82; Qij_AA[6][11] = 2629; Qij_AA[6][12] =  113; Qij_AA[6][13] =  145; Qij_AA[6][14] =  185; 
		Qij_AA[6][15] =  568; Qij_AA[6][16] =  369; Qij_AA[6][17] =   63; Qij_AA[6][18] =  142; Qij_AA[6][19] =  200; 
		Qij_AA[7][0] =  665; Qij_AA[7][1] =  243; Qij_AA[7][2] =  653; Qij_AA[7][3] =  431; Qij_AA[7][4] =  303; 
		Qij_AA[7][5] =  133; Qij_AA[7][6] =  379; Qij_AA[7][7] =    0; Qij_AA[7][8] =   19; Qij_AA[7][9] =   40; 
		Qij_AA[7][10] =   20; Qij_AA[7][11] =  263; Qij_AA[7][12] =   21; Qij_AA[7][13] =   25; Qij_AA[7][14] =   28; 
		Qij_AA[7][15] =  691; Qij_AA[7][16] =   92; Qij_AA[7][17] =   82; Qij_AA[7][18] =   10; Qij_AA[7][19] =   91; 
		Qij_AA[8][0] =   66; Qij_AA[8][1] =  715; Qij_AA[8][2] = 1405; Qij_AA[8][3] =  331; Qij_AA[8][4] =  441; 
		Qij_AA[8][5] = 1269; Qij_AA[8][6] =  162; Qij_AA[8][7] =   19; Qij_AA[8][8] =    0; Qij_AA[8][9] =   29; 
		Qij_AA[8][10] =   66; Qij_AA[8][11] =  305; Qij_AA[8][12] =   10; Qij_AA[8][13] =  127; Qij_AA[8][14] =  152; 
		Qij_AA[8][15] =  303; Qij_AA[8][16] =   32; Qij_AA[8][17] =   69; Qij_AA[8][18] = 1971; Qij_AA[8][19] =   25; 
		Qij_AA[9][0] =  145; Qij_AA[9][1] =  136; Qij_AA[9][2] =  168; Qij_AA[9][3] =   10; Qij_AA[9][4] =  280; 
		Qij_AA[9][5] =   92; Qij_AA[9][6] =  148; Qij_AA[9][7] =   40; Qij_AA[9][8] =   29; Qij_AA[9][9] =    0; 
		Qij_AA[9][10] = 1745; Qij_AA[9][11] =  345; Qij_AA[9][12] = 1772; Qij_AA[9][13] =  454; Qij_AA[9][14] =  117; 
		Qij_AA[9][15] =  216; Qij_AA[9][16] = 1040; Qij_AA[9][17] =   42; Qij_AA[9][18] =   89; Qij_AA[9][19] = 4797; 
		Qij_AA[10][0] =  197; Qij_AA[10][1] =  203; Qij_AA[10][2] =  113; Qij_AA[10][3] =   10; Qij_AA[10][4] =  396; 
		Qij_AA[10][5] =  286; Qij_AA[10][6] =   82; Qij_AA[10][7] =   20; Qij_AA[10][8] =   66; Qij_AA[10][9] = 1745; 
		Qij_AA[10][10] =    0; Qij_AA[10][11] =  218; Qij_AA[10][12] = 1351; Qij_AA[10][13] = 1268; Qij_AA[10][14] =  219; 
		Qij_AA[10][15] =  516; Qij_AA[10][16] =  156; Qij_AA[10][17] =  159; Qij_AA[10][18] =  189; Qij_AA[10][19] =  865; 
		Qij_AA[11][0] =  236; Qij_AA[11][1] = 4482; Qij_AA[11][2] = 2430; Qij_AA[11][3] =  412; Qij_AA[11][4] =   48; 
		Qij_AA[11][5] = 3313; Qij_AA[11][6] = 2629; Qij_AA[11][7] =  263; Qij_AA[11][8] =  305; Qij_AA[11][9] =  345; 
		Qij_AA[11][10] =  218; Qij_AA[11][11] =    0; Qij_AA[11][12] =  193; Qij_AA[11][13] =   72; Qij_AA[11][14] =  302; 
		Qij_AA[11][15] =  868; Qij_AA[11][16] =  918; Qij_AA[11][17] =   10; Qij_AA[11][18] =  247; Qij_AA[11][19] =  249; 
		Qij_AA[12][0] =  185; Qij_AA[12][1] =  125; Qij_AA[12][2] =   61; Qij_AA[12][3] =   47; Qij_AA[12][4] =  159; 
		Qij_AA[12][5] =  202; Qij_AA[12][6] =  113; Qij_AA[12][7] =   21; Qij_AA[12][8] =   10; Qij_AA[12][9] = 1772; 
		Qij_AA[12][10] = 1351; Qij_AA[12][11] =  193; Qij_AA[12][12] =    0; Qij_AA[12][13] =  327; Qij_AA[12][14] =  100; 
		Qij_AA[12][15] =   93; Qij_AA[12][16] =  645; Qij_AA[12][17] =   86; Qij_AA[12][18] =  215; Qij_AA[12][19] =  475; 
		Qij_AA[13][0] =   68; Qij_AA[13][1] =   53; Qij_AA[13][2] =   97; Qij_AA[13][3] =   22; Qij_AA[13][4] =  726; 
		Qij_AA[13][5] =   10; Qij_AA[13][6] =  145; Qij_AA[13][7] =   25; Qij_AA[13][8] =  127; Qij_AA[13][9] =  454; 
		Qij_AA[13][10] = 1268; Qij_AA[13][11] =   72; Qij_AA[13][12] =  327; Qij_AA[13][13] =    0; Qij_AA[13][14] =   43; 
		Qij_AA[13][15] =  487; Qij_AA[13][16] =  148; Qij_AA[13][17] =  468; Qij_AA[13][18] = 2370; Qij_AA[13][19] =  317; 
		Qij_AA[14][0] =  490; Qij_AA[14][1] =   87; Qij_AA[14][2] =  173; Qij_AA[14][3] =  170; Qij_AA[14][4] =  285; 
		Qij_AA[14][5] =  323; Qij_AA[14][6] =  185; Qij_AA[14][7] =   28; Qij_AA[14][8] =  152; Qij_AA[14][9] =  117; 
		Qij_AA[14][10] =  219; Qij_AA[14][11] =  302; Qij_AA[14][12] =  100; Qij_AA[14][13] =   43; Qij_AA[14][14] =    0; 
		Qij_AA[14][15] = 1202; Qij_AA[14][16] =  260; Qij_AA[14][17] =   49; Qij_AA[14][18] =   97; Qij_AA[14][19] =  122; 
		Qij_AA[15][0] = 2440; Qij_AA[15][1] =  385; Qij_AA[15][2] = 2085; Qij_AA[15][3] =  590; Qij_AA[15][4] = 2331; 
		Qij_AA[15][5] =  396; Qij_AA[15][6] =  568; Qij_AA[15][7] =  691; Qij_AA[15][8] =  303; Qij_AA[15][9] =  216; 
		Qij_AA[15][10] =  516; Qij_AA[15][11] =  868; Qij_AA[15][12] =   93; Qij_AA[15][13] =  487; Qij_AA[15][14] = 1202; 
		Qij_AA[15][15] =    0; Qij_AA[15][16] = 2151; Qij_AA[15][17] =   73; Qij_AA[15][18] =  522; Qij_AA[15][19] =  167; 
		Qij_AA[16][0] = 1340; Qij_AA[16][1] =  314; Qij_AA[16][2] = 1393; Qij_AA[16][3] =  266; Qij_AA[16][4] =  576; 
		Qij_AA[16][5] =  241; Qij_AA[16][6] =  369; Qij_AA[16][7] =   92; Qij_AA[16][8] =   32; Qij_AA[16][9] = 1040; 
		Qij_AA[16][10] =  156; Qij_AA[16][11] =  918; Qij_AA[16][12] =  645; Qij_AA[16][13] =  148; Qij_AA[16][14] =  260; 
		Qij_AA[16][15] = 2151; Qij_AA[16][16] =    0; Qij_AA[16][17] =   29; Qij_AA[16][18] =   71; Qij_AA[16][19] =  760; 
		Qij_AA[17][0] =   14; Qij_AA[17][1] =  230; Qij_AA[17][2] =   40; Qij_AA[17][3] =   18; Qij_AA[17][4] =  435; 
		Qij_AA[17][5] =   53; Qij_AA[17][6] =   63; Qij_AA[17][7] =   82; Qij_AA[17][8] =   69; Qij_AA[17][9] =   42; 
		Qij_AA[17][10] =  159; Qij_AA[17][11] =   10; Qij_AA[17][12] =   86; Qij_AA[17][13] =  468; Qij_AA[17][14] =   49; 
		Qij_AA[17][15] =   73; Qij_AA[17][16] =   29; Qij_AA[17][17] =    0; Qij_AA[17][18] =  346; Qij_AA[17][19] =   10; 
		Qij_AA[18][0] =   56; Qij_AA[18][1] =  323; Qij_AA[18][2] =  754; Qij_AA[18][3] =  281; Qij_AA[18][4] = 1466; 
		Qij_AA[18][5] =  391; Qij_AA[18][6] =  142; Qij_AA[18][7] =   10; Qij_AA[18][8] = 1971; Qij_AA[18][9] =   89; 
		Qij_AA[18][10] =  189; Qij_AA[18][11] =  247; Qij_AA[18][12] =  215; Qij_AA[18][13] = 2370; Qij_AA[18][14] =   97; 
		Qij_AA[18][15] =  522; Qij_AA[18][16] =   71; Qij_AA[18][17] =  346; Qij_AA[18][18] =    0; Qij_AA[18][19] =  119; 
		Qij_AA[19][0] =  968; Qij_AA[19][1] =   92; Qij_AA[19][2] =   83; Qij_AA[19][3] =   75; Qij_AA[19][4] =  592; 
		Qij_AA[19][5] =   54; Qij_AA[19][6] =  200; Qij_AA[19][7] =   91; Qij_AA[19][8] =   25; Qij_AA[19][9] = 4797; 
		Qij_AA[19][10] =  865; Qij_AA[19][11] =  249; Qij_AA[19][12] =  475; Qij_AA[19][13] =  317; Qij_AA[19][14] =  122; 
		Qij_AA[19][15] =  167; Qij_AA[19][16] =  760; Qij_AA[19][17] =   10; Qij_AA[19][18] =  119; Qij_AA[19][19] =    0; 


		AA_EM_Pi[0] = 0.076;
		AA_EM_Pi[1] = 0.062;
		AA_EM_Pi[2] = 0.041;
		AA_EM_Pi[3] = 0.037;
		AA_EM_Pi[4] = 0.009;
		AA_EM_Pi[5] = 0.038;
		AA_EM_Pi[6] = 0.049;
		AA_EM_Pi[7] = 0.084;
		AA_EM_Pi[8] = 0.025;
		AA_EM_Pi[9] = 0.081;
		AA_EM_Pi[10] = 0.101;
		AA_EM_Pi[11] = 0.050;
		AA_EM_Pi[12] = 0.022;
		AA_EM_Pi[13] = 0.051;
		AA_EM_Pi[14] = 0.043;
		AA_EM_Pi[15] = 0.062;
		AA_EM_Pi[16] = 0.054;
		AA_EM_Pi[17] = 0.018;
		AA_EM_Pi[18] = 0.031;
		AA_EM_Pi[19] = 0.066;
		}
 	else if (doDayhoff == YES)
		{
		Qij_AA[0][0] =   0; Qij_AA[0][1] =  27; Qij_AA[0][2] =  98; Qij_AA[0][3] = 120; Qij_AA[0][4] =  36; 
		Qij_AA[0][5] =  89; Qij_AA[0][6] = 198; Qij_AA[0][7] = 240; Qij_AA[0][8] =  23; Qij_AA[0][9] =  65; 
		Qij_AA[0][10] =  41; Qij_AA[0][11] =  26; Qij_AA[0][12] =  72; Qij_AA[0][13] =  18; Qij_AA[0][14] = 250; 
		Qij_AA[0][15] = 409; Qij_AA[0][16] = 371; Qij_AA[0][17] =   0; Qij_AA[0][18] =  24; Qij_AA[0][19] = 208; 
		Qij_AA[1][0] =  27; Qij_AA[1][1] =   0; Qij_AA[1][2] =  32; Qij_AA[1][3] =   0; Qij_AA[1][4] =  23; 
		Qij_AA[1][5] = 246; Qij_AA[1][6] =   1; Qij_AA[1][7] =   9; Qij_AA[1][8] = 240; Qij_AA[1][9] =  64; 
		Qij_AA[1][10] =  15; Qij_AA[1][11] = 464; Qij_AA[1][12] =  90; Qij_AA[1][13] =  14; Qij_AA[1][14] = 103; 
		Qij_AA[1][15] = 154; Qij_AA[1][16] =  26; Qij_AA[1][17] = 201; Qij_AA[1][18] =   8; Qij_AA[1][19] =  24; 
		Qij_AA[2][0] =  98; Qij_AA[2][1] =  32; Qij_AA[2][2] =   0; Qij_AA[2][3] = 905; Qij_AA[2][4] =   0; 
		Qij_AA[2][5] = 103; Qij_AA[2][6] = 148; Qij_AA[2][7] = 139; Qij_AA[2][8] = 535; Qij_AA[2][9] =  77; 
		Qij_AA[2][10] =  34; Qij_AA[2][11] = 318; Qij_AA[2][12] =   1; Qij_AA[2][13] =  14; Qij_AA[2][14] =  42; 
		Qij_AA[2][15] = 495; Qij_AA[2][16] = 229; Qij_AA[2][17] =  23; Qij_AA[2][18] =  95; Qij_AA[2][19] =  15; 
		Qij_AA[3][0] = 120; Qij_AA[3][1] =   0; Qij_AA[3][2] = 905; Qij_AA[3][3] =   0; Qij_AA[3][4] =   0; 
		Qij_AA[3][5] = 134; Qij_AA[3][6] = 1153; Qij_AA[3][7] = 125; Qij_AA[3][8] =  86; Qij_AA[3][9] =  24; 
		Qij_AA[3][10] =   0; Qij_AA[3][11] =  71; Qij_AA[3][12] =   0; Qij_AA[3][13] =   0; Qij_AA[3][14] =  13; 
		Qij_AA[3][15] =  95; Qij_AA[3][16] =  66; Qij_AA[3][17] =   0; Qij_AA[3][18] =   0; Qij_AA[3][19] =  18; 
		Qij_AA[4][0] =  36; Qij_AA[4][1] =  23; Qij_AA[4][2] =   0; Qij_AA[4][3] =   0; Qij_AA[4][4] =   0; 
		Qij_AA[4][5] =   0; Qij_AA[4][6] =   0; Qij_AA[4][7] =  11; Qij_AA[4][8] =  28; Qij_AA[4][9] =  44; 
		Qij_AA[4][10] =   0; Qij_AA[4][11] =   0; Qij_AA[4][12] =   0; Qij_AA[4][13] =   0; Qij_AA[4][14] =  19; 
		Qij_AA[4][15] = 161; Qij_AA[4][16] =  16; Qij_AA[4][17] =   0; Qij_AA[4][18] =  96; Qij_AA[4][19] =  49; 
		Qij_AA[5][0] =  89; Qij_AA[5][1] = 246; Qij_AA[5][2] = 103; Qij_AA[5][3] = 134; Qij_AA[5][4] =   0; 
		Qij_AA[5][5] =   0; Qij_AA[5][6] = 716; Qij_AA[5][7] =  28; Qij_AA[5][8] = 606; Qij_AA[5][9] =  18; 
		Qij_AA[5][10] =  73; Qij_AA[5][11] = 153; Qij_AA[5][12] = 114; Qij_AA[5][13] =   0; Qij_AA[5][14] = 153; 
		Qij_AA[5][15] =  56; Qij_AA[5][16] =  53; Qij_AA[5][17] =   0; Qij_AA[5][18] =   0; Qij_AA[5][19] =  35; 
		Qij_AA[6][0] = 198; Qij_AA[6][1] =   1; Qij_AA[6][2] = 148; Qij_AA[6][3] = 1153; Qij_AA[6][4] =   0; 
		Qij_AA[6][5] = 716; Qij_AA[6][6] =   0; Qij_AA[6][7] =  81; Qij_AA[6][8] =  43; Qij_AA[6][9] =  61; 
		Qij_AA[6][10] =  11; Qij_AA[6][11] =  83; Qij_AA[6][12] =  30; Qij_AA[6][13] =   0; Qij_AA[6][14] =  51; 
		Qij_AA[6][15] =  79; Qij_AA[6][16] =  34; Qij_AA[6][17] =   0; Qij_AA[6][18] =  22; Qij_AA[6][19] =  37; 
		Qij_AA[7][0] = 240; Qij_AA[7][1] =   9; Qij_AA[7][2] = 139; Qij_AA[7][3] = 125; Qij_AA[7][4] =  11; 
		Qij_AA[7][5] =  28; Qij_AA[7][6] =  81; Qij_AA[7][7] =   0; Qij_AA[7][8] =  10; Qij_AA[7][9] =   0; 
		Qij_AA[7][10] =   7; Qij_AA[7][11] =  27; Qij_AA[7][12] =  17; Qij_AA[7][13] =  15; Qij_AA[7][14] =  34; 
		Qij_AA[7][15] = 234; Qij_AA[7][16] =  30; Qij_AA[7][17] =   0; Qij_AA[7][18] =   0; Qij_AA[7][19] =  54; 
		Qij_AA[8][0] =  23; Qij_AA[8][1] = 240; Qij_AA[8][2] = 535; Qij_AA[8][3] =  86; Qij_AA[8][4] =  28; 
		Qij_AA[8][5] = 606; Qij_AA[8][6] =  43; Qij_AA[8][7] =  10; Qij_AA[8][8] =   0; Qij_AA[8][9] =   7; 
		Qij_AA[8][10] =  44; Qij_AA[8][11] =  26; Qij_AA[8][12] =   0; Qij_AA[8][13] =  48; Qij_AA[8][14] =  94; 
		Qij_AA[8][15] =  35; Qij_AA[8][16] =  22; Qij_AA[8][17] =  27; Qij_AA[8][18] = 127; Qij_AA[8][19] =  44; 
		Qij_AA[9][0] =  65; Qij_AA[9][1] =  64; Qij_AA[9][2] =  77; Qij_AA[9][3] =  24; Qij_AA[9][4] =  44; 
		Qij_AA[9][5] =  18; Qij_AA[9][6] =  61; Qij_AA[9][7] =   0; Qij_AA[9][8] =   7; Qij_AA[9][9] =   0; 
		Qij_AA[9][10] = 257; Qij_AA[9][11] =  46; Qij_AA[9][12] = 336; Qij_AA[9][13] = 196; Qij_AA[9][14] =  12; 
		Qij_AA[9][15] =  24; Qij_AA[9][16] = 192; Qij_AA[9][17] =   0; Qij_AA[9][18] =  37; Qij_AA[9][19] = 889; 
		Qij_AA[10][0] =  41; Qij_AA[10][1] =  15; Qij_AA[10][2] =  34; Qij_AA[10][3] =   0; Qij_AA[10][4] =   0; 
		Qij_AA[10][5] =  73; Qij_AA[10][6] =  11; Qij_AA[10][7] =   7; Qij_AA[10][8] =  44; Qij_AA[10][9] = 257; 
		Qij_AA[10][10] =   0; Qij_AA[10][11] =  18; Qij_AA[10][12] = 527; Qij_AA[10][13] = 157; Qij_AA[10][14] =  32; 
		Qij_AA[10][15] =  17; Qij_AA[10][16] =  33; Qij_AA[10][17] =  46; Qij_AA[10][18] =  28; Qij_AA[10][19] = 175; 
		Qij_AA[11][0] =  26; Qij_AA[11][1] = 464; Qij_AA[11][2] = 318; Qij_AA[11][3] =  71; Qij_AA[11][4] =   0; 
		Qij_AA[11][5] = 153; Qij_AA[11][6] =  83; Qij_AA[11][7] =  27; Qij_AA[11][8] =  26; Qij_AA[11][9] =  46; 
		Qij_AA[11][10] =  18; Qij_AA[11][11] =   0; Qij_AA[11][12] = 243; Qij_AA[11][13] =   0; Qij_AA[11][14] =  33; 
		Qij_AA[11][15] =  96; Qij_AA[11][16] = 136; Qij_AA[11][17] =   0; Qij_AA[11][18] =  13; Qij_AA[11][19] =  10; 
		Qij_AA[12][0] =  72; Qij_AA[12][1] =  90; Qij_AA[12][2] =   1; Qij_AA[12][3] =   0; Qij_AA[12][4] =   0; 
		Qij_AA[12][5] = 114; Qij_AA[12][6] =  30; Qij_AA[12][7] =  17; Qij_AA[12][8] =   0; Qij_AA[12][9] = 336; 
		Qij_AA[12][10] = 527; Qij_AA[12][11] = 243; Qij_AA[12][12] =   0; Qij_AA[12][13] =  92; Qij_AA[12][14] =  17; 
		Qij_AA[12][15] =  62; Qij_AA[12][16] = 104; Qij_AA[12][17] =   0; Qij_AA[12][18] =   0; Qij_AA[12][19] = 258; 
		Qij_AA[13][0] =  18; Qij_AA[13][1] =  14; Qij_AA[13][2] =  14; Qij_AA[13][3] =   0; Qij_AA[13][4] =   0; 
		Qij_AA[13][5] =   0; Qij_AA[13][6] =   0; Qij_AA[13][7] =  15; Qij_AA[13][8] =  48; Qij_AA[13][9] = 196; 
		Qij_AA[13][10] = 157; Qij_AA[13][11] =   0; Qij_AA[13][12] =  92; Qij_AA[13][13] =   0; Qij_AA[13][14] =  11; 
		Qij_AA[13][15] =  46; Qij_AA[13][16] =  13; Qij_AA[13][17] =  76; Qij_AA[13][18] = 698; Qij_AA[13][19] =  12; 
		Qij_AA[14][0] = 250; Qij_AA[14][1] = 103; Qij_AA[14][2] =  42; Qij_AA[14][3] =  13; Qij_AA[14][4] =  19; 
		Qij_AA[14][5] = 153; Qij_AA[14][6] =  51; Qij_AA[14][7] =  34; Qij_AA[14][8] =  94; Qij_AA[14][9] =  12; 
		Qij_AA[14][10] =  32; Qij_AA[14][11] =  33; Qij_AA[14][12] =  17; Qij_AA[14][13] =  11; Qij_AA[14][14] =   0; 
		Qij_AA[14][15] = 245; Qij_AA[14][16] =  78; Qij_AA[14][17] =   0; Qij_AA[14][18] =   0; Qij_AA[14][19] =  48; 
		Qij_AA[15][0] = 409; Qij_AA[15][1] = 154; Qij_AA[15][2] = 495; Qij_AA[15][3] =  95; Qij_AA[15][4] = 161; 
		Qij_AA[15][5] =  56; Qij_AA[15][6] =  79; Qij_AA[15][7] = 234; Qij_AA[15][8] =  35; Qij_AA[15][9] =  24; 
		Qij_AA[15][10] =  17; Qij_AA[15][11] =  96; Qij_AA[15][12] =  62; Qij_AA[15][13] =  46; Qij_AA[15][14] = 245; 
		Qij_AA[15][15] =   0; Qij_AA[15][16] = 550; Qij_AA[15][17] =  75; Qij_AA[15][18] =  34; Qij_AA[15][19] =  30; 
		Qij_AA[16][0] = 371; Qij_AA[16][1] =  26; Qij_AA[16][2] = 229; Qij_AA[16][3] =  66; Qij_AA[16][4] =  16; 
		Qij_AA[16][5] =  53; Qij_AA[16][6] =  34; Qij_AA[16][7] =  30; Qij_AA[16][8] =  22; Qij_AA[16][9] = 192; 
		Qij_AA[16][10] =  33; Qij_AA[16][11] = 136; Qij_AA[16][12] = 104; Qij_AA[16][13] =  13; Qij_AA[16][14] =  78; 
		Qij_AA[16][15] = 550; Qij_AA[16][16] =   0; Qij_AA[16][17] =   0; Qij_AA[16][18] =  42; Qij_AA[16][19] = 157; 
		Qij_AA[17][0] =   0; Qij_AA[17][1] = 201; Qij_AA[17][2] =  23; Qij_AA[17][3] =   0; Qij_AA[17][4] =   0; 
		Qij_AA[17][5] =   0; Qij_AA[17][6] =   0; Qij_AA[17][7] =   0; Qij_AA[17][8] =  27; Qij_AA[17][9] =   0; 
		Qij_AA[17][10] =  46; Qij_AA[17][11] =   0; Qij_AA[17][12] =   0; Qij_AA[17][13] =  76; Qij_AA[17][14] =   0; 
		Qij_AA[17][15] =  75; Qij_AA[17][16] =   0; Qij_AA[17][17] =   0; Qij_AA[17][18] =  61; Qij_AA[17][19] =   0; 
		Qij_AA[18][0] =  24; Qij_AA[18][1] =   8; Qij_AA[18][2] =  95; Qij_AA[18][3] =   0; Qij_AA[18][4] =  96; 
		Qij_AA[18][5] =   0; Qij_AA[18][6] =  22; Qij_AA[18][7] =   0; Qij_AA[18][8] = 127; Qij_AA[18][9] =  37; 
		Qij_AA[18][10] =  28; Qij_AA[18][11] =  13; Qij_AA[18][12] =   0; Qij_AA[18][13] = 698; Qij_AA[18][14] =   0; 
		Qij_AA[18][15] =  34; Qij_AA[18][16] =  42; Qij_AA[18][17] =  61; Qij_AA[18][18] =   0; Qij_AA[18][19] =  28; 
		Qij_AA[19][0] = 208; Qij_AA[19][1] =  24; Qij_AA[19][2] =  15; Qij_AA[19][3] =  18; Qij_AA[19][4] =  49; 
		Qij_AA[19][5] =  35; Qij_AA[19][6] =  37; Qij_AA[19][7] =  54; Qij_AA[19][8] =  44; Qij_AA[19][9] = 889; 
		Qij_AA[19][10] = 175; Qij_AA[19][11] =  10; Qij_AA[19][12] = 258; Qij_AA[19][13] =  12; Qij_AA[19][14] =  48; 
		Qij_AA[19][15] =  30; Qij_AA[19][16] = 157; Qij_AA[19][17] =   0; Qij_AA[19][18] =  28; Qij_AA[19][19] =   0;


		AA_EM_Pi[0] = 0.087127;
		AA_EM_Pi[1] = 0.040904;
		AA_EM_Pi[2] = 0.040432;
		AA_EM_Pi[3] = 0.046872;
		AA_EM_Pi[4] = 0.033474;
		AA_EM_Pi[5] = 0.038255;
		AA_EM_Pi[6] = 0.049530;
		AA_EM_Pi[7] = 0.088612;
		AA_EM_Pi[8] = 0.033618;
		AA_EM_Pi[9] = 0.036886;
		AA_EM_Pi[10] = 0.085357;
		AA_EM_Pi[11] = 0.080482;
		AA_EM_Pi[12] = 0.014753;
		AA_EM_Pi[13] = 0.039772;
		AA_EM_Pi[14] = 0.050680;
		AA_EM_Pi[15] = 0.069577;
		AA_EM_Pi[16] = 0.058542;
		AA_EM_Pi[17] = 0.010494;
		AA_EM_Pi[18] = 0.029916;
		AA_EM_Pi[19] = 0.064718;
		}
	else if (doDayhoffDCMUT == YES)
		{
		Qij_AA[0][0] = 0;			Qij_AA[0][1] = 0.267828;	Qij_AA[0][2] = 0.984474;	Qij_AA[0][3] = 1.19981;	
		Qij_AA[0][4] = 0.360016;	Qij_AA[0][5] = 0.887753;	Qij_AA[0][6] = 1.96117;	Qij_AA[0][7] = 2.38611;	
		Qij_AA[0][8] = 0.228116;	Qij_AA[0][9] = 0.653416;	Qij_AA[0][10] = 0.406431;	Qij_AA[0][11] = 0.258635;	
		Qij_AA[0][12] = 0.71784;	Qij_AA[0][13] = 0.183641;	Qij_AA[0][14] = 2.48592;	Qij_AA[0][15] = 4.05187;	
		Qij_AA[0][16] = 3.68037;	Qij_AA[0][17] = 0;		Qij_AA[0][18] = 0.244139;	Qij_AA[0][19] = 2.05956;	
		Qij_AA[1][0] = 0.267828;	Qij_AA[1][1] = 0;			Qij_AA[1][2] = 0.327059;	Qij_AA[1][3] = 0;	
		Qij_AA[1][4] = 0.232374;	Qij_AA[1][5] = 2.43994;	Qij_AA[1][6] = 0;			Qij_AA[1][7] = 0.087791;	
		Qij_AA[1][8] = 2.38315;	Qij_AA[1][9] = 0.632629;	Qij_AA[1][10] = 0.154924;	Qij_AA[1][11] = 4.61012;	
		Qij_AA[1][12] = 0.896321;	Qij_AA[1][13] = 0.136906;	Qij_AA[1][14] = 1.02831;	Qij_AA[1][15] = 1.53159;	
		Qij_AA[1][16] = 0.265745;	Qij_AA[1][17] = 2.00137;	Qij_AA[1][18] = 0.078012;	Qij_AA[1][19] = 0.240368;	
		Qij_AA[2][0] = 0.984474;	Qij_AA[2][1] = 0.327059;	Qij_AA[2][2] = 0;			Qij_AA[2][3] = 8.93151;	
		Qij_AA[2][4] = 0;			Qij_AA[2][5] = 1.02851;	Qij_AA[2][6] = 1.49341;	Qij_AA[2][7] = 1.38535;	
		Qij_AA[2][8] = 5.29002;	Qij_AA[2][9] = 0.768024;	Qij_AA[2][10] = 0.341113;	Qij_AA[2][11] = 3.14837;	
		Qij_AA[2][12] = 0;		Qij_AA[2][13] = 0.138503;	Qij_AA[2][14] = 0.419244;	Qij_AA[2][15] = 4.88589;	
		Qij_AA[2][16] = 2.2717;	Qij_AA[2][17] = 0.224968;	Qij_AA[2][18] = 0.94694;	Qij_AA[2][19] = 0.158067;	
		Qij_AA[3][0] = 1.19981;	Qij_AA[3][1] = 0;			Qij_AA[3][2] = 8.93151;	Qij_AA[3][3] = 0;	
		Qij_AA[3][4] = 0;			Qij_AA[3][5] = 1.34855;	Qij_AA[3][6] = 11.3887;	Qij_AA[3][7] = 1.24098;	
		Qij_AA[3][8] = 0.868241;	Qij_AA[3][9] = 0.239248;	Qij_AA[3][10] = 0;		Qij_AA[3][11] = 0.716913;	
		Qij_AA[3][12] = 0;		Qij_AA[3][13] = 0;		Qij_AA[3][14] = 0.13394;	Qij_AA[3][15] = 0.956097;	
		Qij_AA[3][16] = 0.66093;	Qij_AA[3][17] = 0;		Qij_AA[3][18] = 0;		Qij_AA[3][19] = 0.178316;	
		Qij_AA[4][0] = 0.360016;	Qij_AA[4][1] = 0.232374;	Qij_AA[4][2] = 0;			Qij_AA[4][3] = 0;	
		Qij_AA[4][4] = 0;			Qij_AA[4][5] = 0;			Qij_AA[4][6] = 0;			Qij_AA[4][7] = 0.107278;	
		Qij_AA[4][8] = 0.282729;	Qij_AA[4][9] = 0.438074;	Qij_AA[4][10] = 0;		Qij_AA[4][11] = 0;	
		Qij_AA[4][12] = 0;		Qij_AA[4][13] = 0;		Qij_AA[4][14] = 0.18755;	Qij_AA[4][15] = 1.59836;	
		Qij_AA[4][16] = 0.162366;	Qij_AA[4][17] = 0;		Qij_AA[4][18] = 0.953164;	Qij_AA[4][19] = 0.484678;	
		Qij_AA[5][0] = 0.887753;	Qij_AA[5][1] = 2.43994;	Qij_AA[5][2] = 1.02851;	Qij_AA[5][3] = 1.34855;	
		Qij_AA[5][4] = 0;			Qij_AA[5][5] = 0;			Qij_AA[5][6] = 7.08602;	Qij_AA[5][7] = 0.281581;	
		Qij_AA[5][8] = 6.01161;	Qij_AA[5][9] = 0.180393;	Qij_AA[5][10] = 0.730772;	Qij_AA[5][11] = 1.51908;	
		Qij_AA[5][12] = 1.1275;	Qij_AA[5][13] = 0;		Qij_AA[5][14] = 1.52619;	Qij_AA[5][15] = 0.561828;	
		Qij_AA[5][16] = 0.525651;	Qij_AA[5][17] = 0;		Qij_AA[5][18] = 0;		Qij_AA[5][19] = 0.346983;	
		Qij_AA[6][0] = 1.96117;	Qij_AA[6][1] = 0;			Qij_AA[6][2] = 1.49341;	Qij_AA[6][3] = 11.3887;	
		Qij_AA[6][4] = 0;			Qij_AA[6][5] = 7.08602;	Qij_AA[6][6] = 0;			Qij_AA[6][7] = 0.811907;	
		Qij_AA[6][8] = 0.439469;	Qij_AA[6][9] = 0.609526;	Qij_AA[6][10] = 0.11288;	Qij_AA[6][11] = 0.830078;	
		Qij_AA[6][12] = 0.304803;	Qij_AA[6][13] = 0;		Qij_AA[6][14] = 0.507003;	Qij_AA[6][15] = 0.793999;	
		Qij_AA[6][16] = 0.340156;	Qij_AA[6][17] = 0;		Qij_AA[6][18] = 0.214717;	Qij_AA[6][19] = 0.36725;	
		Qij_AA[7][0] = 2.38611;	Qij_AA[7][1] = 0.087791;	Qij_AA[7][2] = 1.38535;	Qij_AA[7][3] = 1.24098;	
		Qij_AA[7][4] = 0.107278;	Qij_AA[7][5] = 0.281581;	Qij_AA[7][6] = 0.811907;	Qij_AA[7][7] = 0;	
		Qij_AA[7][8] = 0.106802;	Qij_AA[7][9] = 0;			Qij_AA[7][10] = 0.071514;	Qij_AA[7][11] = 0.267683;	
		Qij_AA[7][12] = 0.170372;	Qij_AA[7][13] = 0.153478;	Qij_AA[7][14] = 0.347153;	Qij_AA[7][15] = 2.32224;	
		Qij_AA[7][16] = 0.306662;	Qij_AA[7][17] = 0;		Qij_AA[7][18] = 0;		Qij_AA[7][19] = 0.538165;	
		Qij_AA[8][0] = 0.228116;	Qij_AA[8][1] = 2.38315;	Qij_AA[8][2] = 5.29002;	Qij_AA[8][3] = 0.868241;	
		Qij_AA[8][4] = 0.282729;	Qij_AA[8][5] = 6.01161;	Qij_AA[8][6] = 0.439469;	Qij_AA[8][7] = 0.106802;	
		Qij_AA[8][8] = 0;			Qij_AA[8][9] = 0.076981;	Qij_AA[8][10] = 0.443504;	Qij_AA[8][11] = 0.270475;	
		Qij_AA[8][12] = 0;		Qij_AA[8][13] = 0.475927;	Qij_AA[8][14] = 0.933709;	Qij_AA[8][15] = 0.353643;	
		Qij_AA[8][16] = 0.226333;	Qij_AA[8][17] = 0.270564;	Qij_AA[8][18] = 1.2654;	Qij_AA[8][19] = 0.438715;	
		Qij_AA[9][0] = 0.653416;	Qij_AA[9][1] = 0.632629;	Qij_AA[9][2] = 0.768024;	Qij_AA[9][3] = 0.239248;	
		Qij_AA[9][4] = 0.438074;	Qij_AA[9][5] = 0.180393;	Qij_AA[9][6] = 0.609526;	Qij_AA[9][7] = 0;	
		Qij_AA[9][8] = 0.076981;	Qij_AA[9][9] = 0;			Qij_AA[9][10] = 2.55668;	Qij_AA[9][11] = 0.460857;	
		Qij_AA[9][12] = 3.33273;	Qij_AA[9][13] = 1.95195;	Qij_AA[9][14] = 0.119152;	Qij_AA[9][15] = 0.247955;	
		Qij_AA[9][16] = 1.90074;	Qij_AA[9][17] = 0;		Qij_AA[9][18] = 0.374834;	Qij_AA[9][19] = 8.81004;	
		Qij_AA[10][0] = 0.406431;	Qij_AA[10][1] = 0.154924;	Qij_AA[10][2] = 0.341113;	Qij_AA[10][3] = 0;	
		Qij_AA[10][4] = 0;		Qij_AA[10][5] = 0.730772;	Qij_AA[10][6] = 0.11288;	Qij_AA[10][7] = 0.071514;	
		Qij_AA[10][8] = 0.443504;	Qij_AA[10][9] = 2.55668;	Qij_AA[10][10] = 0;		Qij_AA[10][11] = 0.180629;	
		Qij_AA[10][12] = 5.23011;	Qij_AA[10][13] = 1.56516;	Qij_AA[10][14] = 0.316258;	Qij_AA[10][15] = 0.171432;	
		Qij_AA[10][16] = 0.33109;	Qij_AA[10][17] = 0.461776;	Qij_AA[10][18] = 0.286572;	Qij_AA[10][19] = 1.74516;	
		Qij_AA[11][0] = 0.258635;	Qij_AA[11][1] = 4.61012;	Qij_AA[11][2] = 3.14837;	Qij_AA[11][3] = 0.716913;	
		Qij_AA[11][4] = 0;		Qij_AA[11][5] = 1.51908;	Qij_AA[11][6] = 0.830078;	Qij_AA[11][7] = 0.267683;	
		Qij_AA[11][8] = 0.270475;	Qij_AA[11][9] = 0.460857;	Qij_AA[11][10] = 0.180629;	Qij_AA[11][11] = 0;	
		Qij_AA[11][12] = 2.41174;	Qij_AA[11][13] = 0;		Qij_AA[11][14] = 0.335419;	Qij_AA[11][15] = 0.954557;	
		Qij_AA[11][16] = 1.3506;	Qij_AA[11][17] = 0;		Qij_AA[11][18] = 0.132142;	Qij_AA[11][19] = 0.10385;	
		Qij_AA[12][0] = 0.71784;	Qij_AA[12][1] = 0.896321;	Qij_AA[12][2] = 0;		Qij_AA[12][3] = 0;	
		Qij_AA[12][4] = 0;		Qij_AA[12][5] = 1.1275;	Qij_AA[12][6] = 0.304803;	Qij_AA[12][7] = 0.170372;	
		Qij_AA[12][8] = 0;		Qij_AA[12][9] = 3.33273;	Qij_AA[12][10] = 5.23011;	Qij_AA[12][11] = 2.41174;	
		Qij_AA[12][12] = 0;		Qij_AA[12][13] = 0.92186;	Qij_AA[12][14] = 0.170205;	Qij_AA[12][15] = 0.619951;	
		Qij_AA[12][16] = 1.03153;	Qij_AA[12][17] = 0;		Qij_AA[12][18] = 0;		Qij_AA[12][19] = 2.56596;	
		Qij_AA[13][0] = 0.183641;	Qij_AA[13][1] = 0.136906;	Qij_AA[13][2] = 0.138503;	Qij_AA[13][3] = 0;	
		Qij_AA[13][4] = 0;		Qij_AA[13][5] = 0;		Qij_AA[13][6] = 0;		Qij_AA[13][7] = 0.153478;	
		Qij_AA[13][8] = 0.475927;	Qij_AA[13][9] = 1.95195;	Qij_AA[13][10] = 1.56516;	Qij_AA[13][11] = 0;	
		Qij_AA[13][12] = 0.92186;	Qij_AA[13][13] = 0;		Qij_AA[13][14] = 0.110506;	Qij_AA[13][15] = 0.459901;	
		Qij_AA[13][16] = 0.136655;	Qij_AA[13][17] = 0.762354;	Qij_AA[13][18] = 6.95263;	Qij_AA[13][19] = 0.123606;	
		Qij_AA[14][0] = 2.48592;	Qij_AA[14][1] = 1.02831;	Qij_AA[14][2] = 0.419244;	Qij_AA[14][3] = 0.13394;	
		Qij_AA[14][4] = 0.18755;	Qij_AA[14][5] = 1.52619;	Qij_AA[14][6] = 0.507003;	Qij_AA[14][7] = 0.347153;	
		Qij_AA[14][8] = 0.933709;	Qij_AA[14][9] = 0.119152;	Qij_AA[14][10] = 0.316258;	Qij_AA[14][11] = 0.335419;	
		Qij_AA[14][12] = 0.170205;	Qij_AA[14][13] = 0.110506;	Qij_AA[14][14] = 0;		Qij_AA[14][15] = 2.4272;	
		Qij_AA[14][16] = 0.782857;	Qij_AA[14][17] = 0;		Qij_AA[14][18] = 0;		Qij_AA[14][19] = 0.485026;	
		Qij_AA[15][0] = 4.05187;	Qij_AA[15][1] = 1.53159;	Qij_AA[15][2] = 4.88589;	Qij_AA[15][3] = 0.956097;	
		Qij_AA[15][4] = 1.59836;	Qij_AA[15][5] = 0.561828;	Qij_AA[15][6] = 0.793999;	Qij_AA[15][7] = 2.32224;	
		Qij_AA[15][8] = 0.353643;	Qij_AA[15][9] = 0.247955;	Qij_AA[15][10] = 0.171432;	Qij_AA[15][11] = 0.954557;	
		Qij_AA[15][12] = 0.619951;	Qij_AA[15][13] = 0.459901;	Qij_AA[15][14] = 2.4272;	Qij_AA[15][15] = 0;	
		Qij_AA[15][16] = 5.43667;	Qij_AA[15][17] = 0.740819;	Qij_AA[15][18] = 0.336289;	Qij_AA[15][19] = 0.303836;	
		Qij_AA[16][0] = 3.68037;	Qij_AA[16][1] = 0.265745;	Qij_AA[16][2] = 2.2717;	Qij_AA[16][3] = 0.66093;	
		Qij_AA[16][4] = 0.162366;	Qij_AA[16][5] = 0.525651;	Qij_AA[16][6] = 0.340156;	Qij_AA[16][7] = 0.306662;	
		Qij_AA[16][8] = 0.226333;	Qij_AA[16][9] = 1.90074;	Qij_AA[16][10] = 0.33109;	Qij_AA[16][11] = 1.3506;	
		Qij_AA[16][12] = 1.03153;	Qij_AA[16][13] = 0.136655;	Qij_AA[16][14] = 0.782857;	Qij_AA[16][15] = 5.43667;	
		Qij_AA[16][16] = 0;		Qij_AA[16][17] = 0;		Qij_AA[16][18] = 0.417839;	Qij_AA[16][19] = 1.562;	
		Qij_AA[17][0] = 0;		Qij_AA[17][1] = 2.00137;	Qij_AA[17][2] = 0.224968;	Qij_AA[17][3] = 0;	
		Qij_AA[17][4] = 0;		Qij_AA[17][5] = 0;		Qij_AA[17][6] = 0;		Qij_AA[17][7] = 0;	
		Qij_AA[17][8] = 0.270564;	Qij_AA[17][9] = 0;		Qij_AA[17][10] = 0.461776;Qij_AA[17][11] = 0;	
		Qij_AA[17][12] = 0;		Qij_AA[17][13] = 0.762354;	Qij_AA[17][14] = 0;		Qij_AA[17][15] = 0.740819;	
		Qij_AA[17][16] = 0;		Qij_AA[17][17] = 0;		Qij_AA[17][18] = 0.60807;	Qij_AA[17][19] = 0;	
		Qij_AA[18][0] = 0.244139;	Qij_AA[18][1] = 0.078012;	Qij_AA[18][2] = 0.94694;	Qij_AA[18][3] = 0;	
		Qij_AA[18][4] = 0.953164;	Qij_AA[18][5] = 0;		Qij_AA[18][6] = 0.214717;	Qij_AA[18][7] = 0;	
		Qij_AA[18][8] = 1.2654;	Qij_AA[18][9] = 0.374834;	Qij_AA[18][10] = 0.286572;	Qij_AA[18][11] = 0.132142;	
		Qij_AA[18][12] = 0;		Qij_AA[18][13] = 6.95263;	Qij_AA[18][14] = 0;		Qij_AA[18][15] = 0.336289;	
		Qij_AA[18][16] = 0.417839;	Qij_AA[18][17] = 0.60807;	Qij_AA[18][18] = 0;		Qij_AA[18][19] = 0.279379;	
		Qij_AA[19][0] = 2.05956;	Qij_AA[19][1] = 0.240368;	Qij_AA[19][2] = 0.158067;	Qij_AA[19][3] = 0.178316;	
		Qij_AA[19][4] = 0.484678;	Qij_AA[19][5] = 0.346983;	Qij_AA[19][6] = 0.36725;	Qij_AA[19][7] = 0.538165;	
		Qij_AA[19][8] = 0.438715;	Qij_AA[19][9] = 8.81004;	Qij_AA[19][10] = 1.74516;	Qij_AA[19][11] = 0.10385;	
		Qij_AA[19][12] = 2.56596;	Qij_AA[19][13] = 0.123606;Qij_AA[19][14] = 0.485026;	Qij_AA[19][15] = 0.303836;	
		Qij_AA[19][16] = 1.562;	Qij_AA[19][17] = 0;		Qij_AA[19][18] = 0.279379;	Qij_AA[19][19] = 0;


		AA_EM_Pi[0] = 0.087127;
		AA_EM_Pi[1] = 0.040904;
		AA_EM_Pi[2] = 0.040432;
		AA_EM_Pi[3] = 0.046872;
		AA_EM_Pi[4] = 0.033474;
		AA_EM_Pi[5] = 0.038255;
		AA_EM_Pi[6] = 0.04953;
		AA_EM_Pi[7] = 0.088612;
		AA_EM_Pi[8] = 0.033619;
		AA_EM_Pi[9] = 0.036886;
		AA_EM_Pi[10] = 0.085357;
		AA_EM_Pi[11] = 0.080481;
		AA_EM_Pi[12] = 0.014753;
		AA_EM_Pi[13] = 0.039772;
		AA_EM_Pi[14] = 0.05068;
		AA_EM_Pi[15] = 0.069577;
		AA_EM_Pi[16] = 0.058542;
		AA_EM_Pi[17] = 0.010494;
		AA_EM_Pi[18] = 0.029916;
		AA_EM_Pi[19] = 0.064718;
		}
	else if (doHIVb == YES)
		{
		Qij_AA[0][0] = 0;				Qij_AA[0][1] = 0.307507;		Qij_AA[0][2] = 0.005;			Qij_AA[0][3] = 1.45504;	
		Qij_AA[0][4] = 0.123758;		Qij_AA[0][5] = 0.0551128;		Qij_AA[0][6] = 1.48135;		Qij_AA[0][7] = 2.13536;	
		Qij_AA[0][8] = 0.0847613;		Qij_AA[0][9] = 0.005;			Qij_AA[0][10] = 0.215256;		Qij_AA[0][11] = 0.005;	
		Qij_AA[0][12] = 0.0186643;	Qij_AA[0][13] = 0.0141269;	Qij_AA[0][14] = 2.12217;		Qij_AA[0][15] = 2.46633;	
		Qij_AA[0][16] = 15.9183;		Qij_AA[0][17] = 0.005;		Qij_AA[0][18] = 0.005;		Qij_AA[0][19] = 7.61428;	
		Qij_AA[1][0] = 0.307507;		Qij_AA[1][1] = 0;				Qij_AA[1][2] = 0.295543;		Qij_AA[1][3] = 0.005;	
		Qij_AA[1][4] = 0.351721;		Qij_AA[1][5] = 3.4215;		Qij_AA[1][6] = 0.0749218;		Qij_AA[1][7] = 3.65345;	
		Qij_AA[1][8] = 9.04044;		Qij_AA[1][9] = 0.677289;		Qij_AA[1][10] = 0.701427;		Qij_AA[1][11] = 20.45;	
		Qij_AA[1][12] = 2.51394;		Qij_AA[1][13] = 0.005;		Qij_AA[1][14] = 1.28355;		Qij_AA[1][15] = 3.4791;	
		Qij_AA[1][16] = 2.86868;		Qij_AA[1][17] = 0.991338;		Qij_AA[1][18] = 0.00991826;	Qij_AA[1][19] = 0.0812454;	
		Qij_AA[2][0] = 0.005;			Qij_AA[2][1] = 0.295543;		Qij_AA[2][2] = 0;				Qij_AA[2][3] = 17.6612;	
		Qij_AA[2][4] = 0.0860642;		Qij_AA[2][5] = 0.672052;		Qij_AA[2][6] = 0.0792633;		Qij_AA[2][7] = 0.323401;	
		Qij_AA[2][8] = 7.64585;		Qij_AA[2][9] = 0.680565;		Qij_AA[2][10] = 0.005;		Qij_AA[2][11] = 7.90443;	
		Qij_AA[2][12] = 0.005;		Qij_AA[2][13] = 0.005;		Qij_AA[2][14] = 0.00739578;	Qij_AA[2][15] = 13.1447;	
		Qij_AA[2][16] = 6.88667;		Qij_AA[2][17] = 0.005;		Qij_AA[2][18] = 1.76417;		Qij_AA[2][19] = 0.026656;	
		Qij_AA[3][0] = 1.45504;		Qij_AA[3][1] = 0.005;			Qij_AA[3][2] = 17.6612;		Qij_AA[3][3] = 0;	
		Qij_AA[3][4] = 0.005;			Qij_AA[3][5] = 0.005;			Qij_AA[3][6] = 10.5872;		Qij_AA[3][7] = 2.83806;	
		Qij_AA[3][8] = 1.9169;		Qij_AA[3][9] = 0.0176792;		Qij_AA[3][10] = 0.00876048;	Qij_AA[3][11] = 0.005;	
		Qij_AA[3][12] = 0.005;		Qij_AA[3][13] = 0.005;		Qij_AA[3][14] = 0.0342658;	Qij_AA[3][15] = 0.52823;	
		Qij_AA[3][16] = 0.274724;		Qij_AA[3][17] = 0.005;		Qij_AA[3][18] = 0.674653;		Qij_AA[3][19] = 1.04793;	
		Qij_AA[4][0] = 0.123758;		Qij_AA[4][1] = 0.351721;		Qij_AA[4][2] = 0.0860642;		Qij_AA[4][3] = 0.005;	
		Qij_AA[4][4] = 0;				Qij_AA[4][5] = 0.005;			Qij_AA[4][6] = 0.005;			Qij_AA[4][7] = 0.897871;	
		Qij_AA[4][8] = 0.240073;		Qij_AA[4][9] = 0.005;			Qij_AA[4][10] = 0.129777;		Qij_AA[4][11] = 0.005;	
		Qij_AA[4][12] = 0.005;		Qij_AA[4][13] = 9.29815;		Qij_AA[4][14] = 0.005;		Qij_AA[4][15] = 4.69314;	
		Qij_AA[4][16] = 0.739969;		Qij_AA[4][17] = 2.63277;		Qij_AA[4][18] = 7.57932;		Qij_AA[4][19] = 0.420027;	
		Qij_AA[5][0] = 0.0551128;		Qij_AA[5][1] = 3.4215;		Qij_AA[5][2] = 0.672052;		Qij_AA[5][3] = 0.005;	
		Qij_AA[5][4] = 0.005;			Qij_AA[5][5] = 0;				Qij_AA[5][6] = 2.5602;		Qij_AA[5][7] = 0.0619137;	
		Qij_AA[5][8] = 7.05545;		Qij_AA[5][9] = 0.005;			Qij_AA[5][10] = 1.49456;		Qij_AA[5][11] = 6.54737;	
		Qij_AA[5][12] = 0.303676;		Qij_AA[5][13] = 0.005;		Qij_AA[5][14] = 4.47211;		Qij_AA[5][15] = 0.116311;	
		Qij_AA[5][16] = 0.243589;		Qij_AA[5][17] = 0.026656;		Qij_AA[5][18] = 0.113033;		Qij_AA[5][19] = 0.0209153;	
		Qij_AA[6][0] = 1.48135;		Qij_AA[6][1] = 0.0749218;		Qij_AA[6][2] = 0.0792633;		Qij_AA[6][3] = 10.5872;	
		Qij_AA[6][4] = 0.005;			Qij_AA[6][5] = 2.5602;		Qij_AA[6][6] = 0;				Qij_AA[6][7] = 3.92775;	
		Qij_AA[6][8] = 0.11974;		Qij_AA[6][9] = 0.00609079;	Qij_AA[6][10] = 0.005;		Qij_AA[6][11] = 4.61482;	
		Qij_AA[6][12] = 0.175789;		Qij_AA[6][13] = 0.005;		Qij_AA[6][14] = 0.0120226;	Qij_AA[6][15] = 0.005;	
		Qij_AA[6][16] = 0.289774;		Qij_AA[6][17] = 0.005;		Qij_AA[6][18] = 0.0792633;	Qij_AA[6][19] = 1.02847;	
		Qij_AA[7][0] = 2.13536;		Qij_AA[7][1] = 3.65345;		Qij_AA[7][2] = 0.323401;		Qij_AA[7][3] = 2.83806;	
		Qij_AA[7][4] = 0.897871;		Qij_AA[7][5] = 0.0619137;		Qij_AA[7][6] = 3.92775;		Qij_AA[7][7] = 0;	
		Qij_AA[7][8] = 0.005;			Qij_AA[7][9] = 0.005;			Qij_AA[7][10] = 0.005;		Qij_AA[7][11] = 0.521705;	
		Qij_AA[7][12] = 0.005;		Qij_AA[7][13] = 0.291561;		Qij_AA[7][14] = 0.005;		Qij_AA[7][15] = 4.38041;	
		Qij_AA[7][16] = 0.369615;		Qij_AA[7][17] = 1.21674;		Qij_AA[7][18] = 0.005;		Qij_AA[7][19] = 0.953155;	
		Qij_AA[8][0] = 0.0847613;		Qij_AA[8][1] = 9.04044;		Qij_AA[8][2] = 7.64585;		Qij_AA[8][3] = 1.9169;	
		Qij_AA[8][4] = 0.240073;		Qij_AA[8][5] = 7.05545;		Qij_AA[8][6] = 0.11974;		Qij_AA[8][7] = 0.005;	
		Qij_AA[8][8] = 0;				Qij_AA[8][9] = 0.103111;		Qij_AA[8][10] = 1.74171;		Qij_AA[8][11] = 0.005;	
		Qij_AA[8][12] = 0.005;		Qij_AA[8][13] = 0.145558;		Qij_AA[8][14] = 2.45318;		Qij_AA[8][15] = 0.382747;	
		Qij_AA[8][16] = 0.711594;		Qij_AA[8][17] = 0.0695179;	Qij_AA[8][18] = 18.6943;		Qij_AA[8][19] = 0.005;	
		Qij_AA[9][0] = 0.005;			Qij_AA[9][1] = 0.677289;		Qij_AA[9][2] = 0.680565;		Qij_AA[9][3] = 0.0176792;	
		Qij_AA[9][4] = 0.005;			Qij_AA[9][5] = 0.005;			Qij_AA[9][6] = 0.00609079;	Qij_AA[9][7] = 0.005;	
		Qij_AA[9][8] = 0.103111;		Qij_AA[9][9] = 0;				Qij_AA[9][10] = 5.95879;		Qij_AA[9][11] = 0.322319;	
		Qij_AA[9][12] = 11.2065;		Qij_AA[9][13] = 3.39836;		Qij_AA[9][14] = 0.0410593;	Qij_AA[9][15] = 1.21803;	
		Qij_AA[9][16] = 8.61217;		Qij_AA[9][17] = 0.005;		Qij_AA[9][18] = 0.148168;		Qij_AA[9][19] = 17.7389;	
		Qij_AA[10][0] = 0.215256;		Qij_AA[10][1] = 0.701427;		Qij_AA[10][2] = 0.005;		Qij_AA[10][3] = 0.00876048;	
		Qij_AA[10][4] = 0.129777;		Qij_AA[10][5] = 1.49456;		Qij_AA[10][6] = 0.005;		Qij_AA[10][7] = 0.005;	
		Qij_AA[10][8] = 1.74171;		Qij_AA[10][9] = 5.95879;		Qij_AA[10][10] = 0;			Qij_AA[10][11] = 0.0814995;	
		Qij_AA[10][12] = 5.31961;		Qij_AA[10][13] = 8.52484;		Qij_AA[10][14] = 2.07757;		Qij_AA[10][15] = 0.927656;	
		Qij_AA[10][16] = 0.0437673;	Qij_AA[10][17] = 0.748843;	Qij_AA[10][18] = 0.111986;	Qij_AA[10][19] = 1.41036;	
		Qij_AA[11][0] = 0.005;		Qij_AA[11][1] = 20.45;		Qij_AA[11][2] = 7.90443;		Qij_AA[11][3] = 0.005;	
		Qij_AA[11][4] = 0.005;		Qij_AA[11][5] = 6.54737;		Qij_AA[11][6] = 4.61482;		Qij_AA[11][7] = 0.521705;	
		Qij_AA[11][8] = 0.005;		Qij_AA[11][9] = 0.322319;		Qij_AA[11][10] = 0.0814995;	Qij_AA[11][11] = 0;	
		Qij_AA[11][12] = 1.28246;		Qij_AA[11][13] = 0.0342658;	Qij_AA[11][14] = 0.0313862;	Qij_AA[11][15] = 0.504111;	
		Qij_AA[11][16] = 4.67142;		Qij_AA[11][17] = 0.005;		Qij_AA[11][18] = 0.005;		Qij_AA[11][19] = 0.265829;	
		Qij_AA[12][0] = 0.0186643;	Qij_AA[12][1] = 2.51394;		Qij_AA[12][2] = 0.005;		Qij_AA[12][3] = 0.005;	
		Qij_AA[12][4] = 0.005;		Qij_AA[12][5] = 0.303676;		Qij_AA[12][6] = 0.175789;		Qij_AA[12][7] = 0.005;	
		Qij_AA[12][8] = 0.005;		Qij_AA[12][9] = 11.2065;		Qij_AA[12][10] = 5.31961;		Qij_AA[12][11] = 1.28246;	
		Qij_AA[12][12] = 0;			Qij_AA[12][13] = 0.188025;	Qij_AA[12][14] = 0.005;		Qij_AA[12][15] = 0.005;	
		Qij_AA[12][16] = 4.94026;		Qij_AA[12][17] = 0.089078;	Qij_AA[12][18] = 0.005;		Qij_AA[12][19] = 6.8532;	
		Qij_AA[13][0] = 0.0141269;	Qij_AA[13][1] = 0.005;		Qij_AA[13][2] = 0.005;		Qij_AA[13][3] = 0.005;	
		Qij_AA[13][4] = 9.29815;		Qij_AA[13][5] = 0.005;		Qij_AA[13][6] = 0.005;		Qij_AA[13][7] = 0.291561;	
		Qij_AA[13][8] = 0.145558;		Qij_AA[13][9] = 3.39836;		Qij_AA[13][10] = 8.52484;		Qij_AA[13][11] = 0.0342658;	
		Qij_AA[13][12] = 0.188025;	Qij_AA[13][13] = 0;			Qij_AA[13][14] = 0.005;		Qij_AA[13][15] = 0.956472;	
		Qij_AA[13][16] = 0.0141269;	Qij_AA[13][17] = 0.829343;	Qij_AA[13][18] = 15.34;		Qij_AA[13][19] = 0.723274;	
		Qij_AA[14][0] = 2.12217;		Qij_AA[14][1] = 1.28355;		Qij_AA[14][2] = 0.00739578;	Qij_AA[14][3] = 0.0342658;	
		Qij_AA[14][4] = 0.005;		Qij_AA[14][5] = 4.47211;		Qij_AA[14][6] = 0.0120226;	Qij_AA[14][7] = 0.005;	
		Qij_AA[14][8] = 2.45318;		Qij_AA[14][9] = 0.0410593;	Qij_AA[14][10] = 2.07757;		Qij_AA[14][11] = 0.0313862;	
		Qij_AA[14][12] = 0.005;		Qij_AA[14][13] = 0.005;		Qij_AA[14][14] = 0;			Qij_AA[14][15] = 5.37762;	
		Qij_AA[14][16] = 2.01417;		Qij_AA[14][17] = 0.0444506;	Qij_AA[14][18] = 0.0304381;	Qij_AA[14][19] = 0.005;	
		Qij_AA[15][0] = 2.46633;		Qij_AA[15][1] = 3.4791;		Qij_AA[15][2] = 13.1447;		Qij_AA[15][3] = 0.52823;	
		Qij_AA[15][4] = 4.69314;		Qij_AA[15][5] = 0.116311;		Qij_AA[15][6] = 0.005;		Qij_AA[15][7] = 4.38041;	
		Qij_AA[15][8] = 0.382747;		Qij_AA[15][9] = 1.21803;		Qij_AA[15][10] = 0.927656;	Qij_AA[15][11] = 0.504111;	
		Qij_AA[15][12] = 0.005;		Qij_AA[15][13] = 0.956472;	Qij_AA[15][14] = 5.37762;		Qij_AA[15][15] = 0;	
		Qij_AA[15][16] = 8.93107;		Qij_AA[15][17] = 0.0248728;	Qij_AA[15][18] = 0.648024;	Qij_AA[15][19] = 0.0749218;	
		Qij_AA[16][0] = 15.9183;		Qij_AA[16][1] = 2.86868;		Qij_AA[16][2] = 6.88667;		Qij_AA[16][3] = 0.274724;	
		Qij_AA[16][4] = 0.739969;		Qij_AA[16][5] = 0.243589;		Qij_AA[16][6] = 0.289774;		Qij_AA[16][7] = 0.369615;	
		Qij_AA[16][8] = 0.711594;		Qij_AA[16][9] = 8.61217;		Qij_AA[16][10] = 0.0437673;	Qij_AA[16][11] = 4.67142;	
		Qij_AA[16][12] = 4.94026;		Qij_AA[16][13] = 0.0141269;	Qij_AA[16][14] = 2.01417;		Qij_AA[16][15] = 8.93107;	
		Qij_AA[16][16] = 0;			Qij_AA[16][17] = 0.005;		Qij_AA[16][18] = 0.105652;	Qij_AA[16][19] = 0.709226;	
		Qij_AA[17][0] = 0.005;		Qij_AA[17][1] = 0.991338;		Qij_AA[17][2] = 0.005;		Qij_AA[17][3] = 0.005;	
		Qij_AA[17][4] = 2.63277;		Qij_AA[17][5] = 0.026656;		Qij_AA[17][6] = 0.005;		Qij_AA[17][7] = 1.21674;	
		Qij_AA[17][8] = 0.0695179;	Qij_AA[17][9] = 0.005;		Qij_AA[17][10] = 0.748843;	Qij_AA[17][11] = 0.005;	
		Qij_AA[17][12] = 0.089078;	Qij_AA[17][13] = 0.829343;	Qij_AA[17][14] = 0.0444506;	Qij_AA[17][15] = 0.0248728;	
		Qij_AA[17][16] = 0.005;		Qij_AA[17][17] = 0;			Qij_AA[17][18] = 1.28022;		Qij_AA[17][19] = 0.005;	
		Qij_AA[18][0] = 0.005;		Qij_AA[18][1] = 0.00991826;	Qij_AA[18][2] = 1.76417;		Qij_AA[18][3] = 0.674653;	
		Qij_AA[18][4] = 7.57932;		Qij_AA[18][5] = 0.113033;		Qij_AA[18][6] = 0.0792633;	Qij_AA[18][7] = 0.005;	
		Qij_AA[18][8] = 18.6943;		Qij_AA[18][9] = 0.148168;		Qij_AA[18][10] = 0.111986;	Qij_AA[18][11] = 0.005;	
		Qij_AA[18][12] = 0.005;		Qij_AA[18][13] = 15.34;		Qij_AA[18][14] = 0.0304381;	Qij_AA[18][15] = 0.648024;	
		Qij_AA[18][16] = 0.105652;	Qij_AA[18][17] = 1.28022;		Qij_AA[18][18] = 0;			Qij_AA[18][19] = 0.0410593;	
		Qij_AA[19][0] = 7.61428;		Qij_AA[19][1] = 0.0812454;	Qij_AA[19][2] = 0.026656;		Qij_AA[19][3] = 1.04793;	
		Qij_AA[19][4] = 0.420027;		Qij_AA[19][5] = 0.0209153;	Qij_AA[19][6] = 1.02847;		Qij_AA[19][7] = 0.953155;	
		Qij_AA[19][8] = 0.005;		Qij_AA[19][9] = 17.7389;		Qij_AA[19][10] = 1.41036;		Qij_AA[19][11] = 0.265829;	
		Qij_AA[19][12] = 6.8532;		Qij_AA[19][13] = 0.723274;	Qij_AA[19][14] = 0.005;		Qij_AA[19][15] = 0.0749218;	
		Qij_AA[19][16] = 0.709226;	Qij_AA[19][17] = 0.005;		Qij_AA[19][18] = 0.0410593;	Qij_AA[19][19] = 0;	

		AA_EM_Pi[0] = 0.0604902;
		AA_EM_Pi[1] = 0.0660397;
		AA_EM_Pi[2] = 0.0441278;
		AA_EM_Pi[3] = 0.042109;
		AA_EM_Pi[4] = 0.0200759;
		AA_EM_Pi[5] = 0.0536065;
		AA_EM_Pi[6] = 0.0715674;
		AA_EM_Pi[7] = 0.0723082;
		AA_EM_Pi[8] = 0.0222939;
		AA_EM_Pi[9] = 0.0697306;
		AA_EM_Pi[10] = 0.0988511;
		AA_EM_Pi[11] = 0.0569682;
		AA_EM_Pi[12] = 0.0197683;
		AA_EM_Pi[13] = 0.0288094;
		AA_EM_Pi[14] = 0.0460253;
		AA_EM_Pi[15] = 0.0506043;
		AA_EM_Pi[16] = 0.0536368;
		AA_EM_Pi[17] = 0.0330116;
		AA_EM_Pi[18] = 0.0283502;
		AA_EM_Pi[19] = 0.0616252;
		}
	else if (doHIVw == YES)
		{
		Qij_AA[0][0] = 0;				Qij_AA[0][1] = 0.0744808;		Qij_AA[0][2] = 0.617509;		Qij_AA[0][3] = 4.43521;	
		Qij_AA[0][4] = 0.167653;		Qij_AA[0][5] = 0.005;			Qij_AA[0][6] = 5.56325;		Qij_AA[0][7] = 1.8685;	
		Qij_AA[0][8] = 0.005;			Qij_AA[0][9] = 0.005;			Qij_AA[0][10] = 0.16024;		Qij_AA[0][11] = 0.592784;	
		Qij_AA[0][12] = 0.005;		Qij_AA[0][13] = 0.597923;		Qij_AA[0][14] = 1.00981;		Qij_AA[0][15] = 8.5942;	
		Qij_AA[0][16] = 24.1422;		Qij_AA[0][17] = 0.005;		Qij_AA[0][18] = 0.005;		Qij_AA[0][19] = 24.8094;	
		Qij_AA[1][0] = 0.0744808;		Qij_AA[1][1] = 0;				Qij_AA[1][2] = 0.16024;		Qij_AA[1][3] = 0.0674539;	
		Qij_AA[1][4] = 2.86364;		Qij_AA[1][5] = 10.6746;		Qij_AA[1][6] = 0.0251632;		Qij_AA[1][7] = 13.4379;	
		Qij_AA[1][8] = 6.84405;		Qij_AA[1][9] = 1.34069;		Qij_AA[1][10] = 0.586757;		Qij_AA[1][11] = 39.8897;	
		Qij_AA[1][12] = 3.28652;		Qij_AA[1][13] = 0.005;		Qij_AA[1][14] = 0.404723;		Qij_AA[1][15] = 8.35024;	
		Qij_AA[1][16] = 0.928203;		Qij_AA[1][17] = 5.96564;		Qij_AA[1][18] = 0.005;		Qij_AA[1][19] = 0.279425;	
		Qij_AA[2][0] = 0.617509;		Qij_AA[2][1] = 0.16024;		Qij_AA[2][2] = 0;				Qij_AA[2][3] = 29.4087;	
		Qij_AA[2][4] = 0.0604932;		Qij_AA[2][5] = 0.342068;		Qij_AA[2][6] = 0.201526;		Qij_AA[2][7] = 0.0604932;	
		Qij_AA[2][8] = 8.59876;		Qij_AA[2][9] = 0.987028;		Qij_AA[2][10] = 0.005;		Qij_AA[2][11] = 10.6655;	
		Qij_AA[2][12] = 0.201526;		Qij_AA[2][13] = 0.005;		Qij_AA[2][14] = 0.344848;		Qij_AA[2][15] = 14.5699;	
		Qij_AA[2][16] = 4.54206;		Qij_AA[2][17] = 0.005;		Qij_AA[2][18] = 5.06475;		Qij_AA[2][19] = 0.0744808;	
		Qij_AA[3][0] = 4.43521;		Qij_AA[3][1] = 0.0674539;		Qij_AA[3][2] = 29.4087;		Qij_AA[3][3] = 0;	
		Qij_AA[3][4] = 0.005;			Qij_AA[3][5] = 0.005;			Qij_AA[3][6] = 12.1233;		Qij_AA[3][7] = 10.3969;	
		Qij_AA[3][8] = 2.31779;		Qij_AA[3][9] = 0.145124;		Qij_AA[3][10] = 0.005;		Qij_AA[3][11] = 0.894313;	
		Qij_AA[3][12] = 0.005;		Qij_AA[3][13] = 0.005;		Qij_AA[3][14] = 0.005;		Qij_AA[3][15] = 0.427881;	
		Qij_AA[3][16] = 0.630395;		Qij_AA[3][17] = 0.005;		Qij_AA[3][18] = 2.28154;		Qij_AA[3][19] = 2.91786;	
		Qij_AA[4][0] = 0.167653;		Qij_AA[4][1] = 2.86364;		Qij_AA[4][2] = 0.0604932;		Qij_AA[4][3] = 0.005;	
		Qij_AA[4][4] = 0;				Qij_AA[4][5] = 0.005;			Qij_AA[4][6] = 0.005;			Qij_AA[4][7] = 0.0489798;	
		Qij_AA[4][8] = 0.005;			Qij_AA[4][9] = 0.005;			Qij_AA[4][10] = 0.005;		Qij_AA[4][11] = 0.005;	
		Qij_AA[4][12] = 0.005;		Qij_AA[4][13] = 0.362959;		Qij_AA[4][14] = 0.005;		Qij_AA[4][15] = 1.12195;	
		Qij_AA[4][16] = 0.005;		Qij_AA[4][17] = 5.49894;		Qij_AA[4][18] = 8.34835;		Qij_AA[4][19] = 0.005;	
		Qij_AA[5][0] = 0.005;			Qij_AA[5][1] = 10.6746;		Qij_AA[5][2] = 0.342068;		Qij_AA[5][3] = 0.005;	
		Qij_AA[5][4] = 0.005;			Qij_AA[5][5] = 0;				Qij_AA[5][6] = 3.20656;		Qij_AA[5][7] = 0.0604932;	
		Qij_AA[5][8] = 18.5465;		Qij_AA[5][9] = 0.0342252;		Qij_AA[5][10] = 2.89048;		Qij_AA[5][11] = 13.0705;	
		Qij_AA[5][12] = 0.005;		Qij_AA[5][13] = 0.005;		Qij_AA[5][14] = 3.04502;		Qij_AA[5][15] = 0.16024;	
		Qij_AA[5][16] = 0.203091;		Qij_AA[5][17] = 0.0443298;	Qij_AA[5][18] = 0.005;		Qij_AA[5][19] = 0.005;	
		Qij_AA[6][0] = 5.56325;		Qij_AA[6][1] = 0.0251632;		Qij_AA[6][2] = 0.201526;		Qij_AA[6][3] = 12.1233;	
		Qij_AA[6][4] = 0.005;			Qij_AA[6][5] = 3.20656;		Qij_AA[6][6] = 0;				Qij_AA[6][7] = 14.7801;	
		Qij_AA[6][8] = 0.005;			Qij_AA[6][9] = 0.0390512;		Qij_AA[6][10] = 0.129839;		Qij_AA[6][11] = 23.9626;	
		Qij_AA[6][12] = 0.005;		Qij_AA[6][13] = 0.005;		Qij_AA[6][14] = 0.005;		Qij_AA[6][15] = 0.005;	
		Qij_AA[6][16] = 0.458743;		Qij_AA[6][17] = 0.005;		Qij_AA[6][18] = 0.005;		Qij_AA[6][19] = 2.19952;	
		Qij_AA[7][0] = 1.8685;		Qij_AA[7][1] = 13.4379;		Qij_AA[7][2] = 0.0604932;		Qij_AA[7][3] = 10.3969;	
		Qij_AA[7][4] = 0.0489798;		Qij_AA[7][5] = 0.0604932;		Qij_AA[7][6] = 14.7801;		Qij_AA[7][7] = 0;	
		Qij_AA[7][8] = 0.005;			Qij_AA[7][9] = 0.005;			Qij_AA[7][10] = 0.0489798;	Qij_AA[7][11] = 0.279425;	
		Qij_AA[7][12] = 0.0489798;	Qij_AA[7][13] = 0.005;		Qij_AA[7][14] = 0.005;		Qij_AA[7][15] = 6.27966;	
		Qij_AA[7][16] = 0.0489798;	Qij_AA[7][17] = 2.8258;		Qij_AA[7][18] = 0.005;		Qij_AA[7][19] = 2.79622;	
		Qij_AA[8][0] = 0.005;			Qij_AA[8][1] = 6.84405;		Qij_AA[8][2] = 8.59876;		Qij_AA[8][3] = 2.31779;	
		Qij_AA[8][4] = 0.005;			Qij_AA[8][5] = 18.5465;		Qij_AA[8][6] = 0.005;			Qij_AA[8][7] = 0.005;	
		Qij_AA[8][8] = 0;				Qij_AA[8][9] = 0.005;			Qij_AA[8][10] = 1.76382;		Qij_AA[8][11] = 0.22406;	
		Qij_AA[8][12] = 0.005;		Qij_AA[8][13] = 0.005;		Qij_AA[8][14] = 13.9444;		Qij_AA[8][15] = 0.725157;	
		Qij_AA[8][16] = 0.95956;		Qij_AA[8][17] = 0.005;		Qij_AA[8][18] = 47.4889;		Qij_AA[8][19] = 0.827479;	
		Qij_AA[9][0] = 0.005;			Qij_AA[9][1] = 1.34069;		Qij_AA[9][2] = 0.987028;		Qij_AA[9][3] = 0.145124;	
		Qij_AA[9][4] = 0.005;			Qij_AA[9][5] = 0.0342252;		Qij_AA[9][6] = 0.0390512;		Qij_AA[9][7] = 0.005;	
		Qij_AA[9][8] = 0.005;			Qij_AA[9][9] = 0;				Qij_AA[9][10] = 9.10246;		Qij_AA[9][11] = 0.817481;	
		Qij_AA[9][12] = 17.3064;		Qij_AA[9][13] = 1.48288;		Qij_AA[9][14] = 0.005;		Qij_AA[9][15] = 0.740091;	
		Qij_AA[9][16] = 9.36345;		Qij_AA[9][17] = 0.005;		Qij_AA[9][18] = 0.114512;		Qij_AA[9][19] = 24.8231;	
		Qij_AA[10][0] = 0.16024;		Qij_AA[10][1] = 0.586757;		Qij_AA[10][2] = 0.005;		Qij_AA[10][3] = 0.005;	
		Qij_AA[10][4] = 0.005;		Qij_AA[10][5] = 2.89048;		Qij_AA[10][6] = 0.129839;		Qij_AA[10][7] = 0.0489798;	
		Qij_AA[10][8] = 1.76382;		Qij_AA[10][9] = 9.10246;		Qij_AA[10][10] = 0;			Qij_AA[10][11] = 0.005;	
		Qij_AA[10][12] = 11.3839;		Qij_AA[10][13] = 7.48781;		Qij_AA[10][14] = 9.83095;		Qij_AA[10][15] = 6.14396;	
		Qij_AA[10][16] = 0.005;		Qij_AA[10][17] = 1.37031;		Qij_AA[10][18] = 0.005;		Qij_AA[10][19] = 2.95344;	
		Qij_AA[11][0] = 0.592784;		Qij_AA[11][1] = 39.8897;		Qij_AA[11][2] = 10.6655;		Qij_AA[11][3] = 0.894313;	
		Qij_AA[11][4] = 0.005;		Qij_AA[11][5] = 13.0705;		Qij_AA[11][6] = 23.9626;		Qij_AA[11][7] = 0.279425;	
		Qij_AA[11][8] = 0.22406;		Qij_AA[11][9] = 0.817481;		Qij_AA[11][10] = 0.005;		Qij_AA[11][11] = 0;	
		Qij_AA[11][12] = 4.09564;		Qij_AA[11][13] = 0.005;		Qij_AA[11][14] = 0.111928;	Qij_AA[11][15] = 0.005;	
		Qij_AA[11][16] = 4.04802;		Qij_AA[11][17] = 0.005;		Qij_AA[11][18] = 0.005;		Qij_AA[11][19] = 0.128065;	
		Qij_AA[12][0] = 0.005;		Qij_AA[12][1] = 3.28652;		Qij_AA[12][2] = 0.201526;		Qij_AA[12][3] = 0.005;	
		Qij_AA[12][4] = 0.005;		Qij_AA[12][5] = 0.005;		Qij_AA[12][6] = 0.005;		Qij_AA[12][7] = 0.0489798;	
		Qij_AA[12][8] = 0.005;		Qij_AA[12][9] = 17.3064;		Qij_AA[12][10] = 11.3839;		Qij_AA[12][11] = 4.09564;	
		Qij_AA[12][12] = 0;			Qij_AA[12][13] = 0.005;		Qij_AA[12][14] = 0.005;		Qij_AA[12][15] = 0.392575;	
		Qij_AA[12][16] = 7.41313;		Qij_AA[12][17] = 0.005;		Qij_AA[12][18] = 0.579198;	Qij_AA[12][19] = 14.7683;	
		Qij_AA[13][0] = 0.597923;		Qij_AA[13][1] = 0.005;		Qij_AA[13][2] = 0.005;		Qij_AA[13][3] = 0.005;	
		Qij_AA[13][4] = 0.362959;		Qij_AA[13][5] = 0.005;		Qij_AA[13][6] = 0.005;		Qij_AA[13][7] = 0.005;	
		Qij_AA[13][8] = 0.005;		Qij_AA[13][9] = 1.48288;		Qij_AA[13][10] = 7.48781;		Qij_AA[13][11] = 0.005;	
		Qij_AA[13][12] = 0.005;		Qij_AA[13][13] = 0;			Qij_AA[13][14] = 0.0342252;	Qij_AA[13][15] = 4.27939;	
		Qij_AA[13][16] = 0.114512;	Qij_AA[13][17] = 0.005;		Qij_AA[13][18] = 4.12728;		Qij_AA[13][19] = 2.28;	
		Qij_AA[14][0] = 1.00981;		Qij_AA[14][1] = 0.404723;		Qij_AA[14][2] = 0.344848;		Qij_AA[14][3] = 0.005;	
		Qij_AA[14][4] = 0.005;		Qij_AA[14][5] = 3.04502;		Qij_AA[14][6] = 0.005;		Qij_AA[14][7] = 0.005;	
		Qij_AA[14][8] = 13.9444;		Qij_AA[14][9] = 0.005;		Qij_AA[14][10] = 9.83095;		Qij_AA[14][11] = 0.111928;	
		Qij_AA[14][12] = 0.005;		Qij_AA[14][13] = 0.0342252;	Qij_AA[14][14] = 0;			Qij_AA[14][15] = 14.249;	
		Qij_AA[14][16] = 4.33701;		Qij_AA[14][17] = 0.005;		Qij_AA[14][18] = 0.005;		Qij_AA[14][19] = 0.005;	
		Qij_AA[15][0] = 8.5942;		Qij_AA[15][1] = 8.35024;		Qij_AA[15][2] = 14.5699;		Qij_AA[15][3] = 0.427881;	
		Qij_AA[15][4] = 1.12195;		Qij_AA[15][5] = 0.16024;		Qij_AA[15][6] = 0.005;		Qij_AA[15][7] = 6.27966;	
		Qij_AA[15][8] = 0.725157;		Qij_AA[15][9] = 0.740091;		Qij_AA[15][10] = 6.14396;		Qij_AA[15][11] = 0.005;	
		Qij_AA[15][12] = 0.392575;	Qij_AA[15][13] = 4.27939;		Qij_AA[15][14] = 14.249;		Qij_AA[15][15] = 0;	
		Qij_AA[15][16] = 6.34079;		Qij_AA[15][17] = 1.10156;		Qij_AA[15][18] = 0.933142;	Qij_AA[15][19] = 0.862637;	
		Qij_AA[16][0] = 24.1422;		Qij_AA[16][1] = 0.928203;		Qij_AA[16][2] = 4.54206;		Qij_AA[16][3] = 0.630395;	
		Qij_AA[16][4] = 0.005;		Qij_AA[16][5] = 0.203091;		Qij_AA[16][6] = 0.458743;		Qij_AA[16][7] = 0.0489798;	
		Qij_AA[16][8] = 0.95956;		Qij_AA[16][9] = 9.36345;		Qij_AA[16][10] = 0.005;		Qij_AA[16][11] = 4.04802;	
		Qij_AA[16][12] = 7.41313;		Qij_AA[16][13] = 0.114512;	Qij_AA[16][14] = 4.33701;		Qij_AA[16][15] = 6.34079;	
		Qij_AA[16][16] = 0;			Qij_AA[16][17] = 0.005;		Qij_AA[16][18] = 0.490608;	Qij_AA[16][19] = 0.005;	
		Qij_AA[17][0] = 0.005;		Qij_AA[17][1] = 5.96564;		Qij_AA[17][2] = 0.005;		Qij_AA[17][3] = 0.005;	
		Qij_AA[17][4] = 5.49894;		Qij_AA[17][5] = 0.0443298;	Qij_AA[17][6] = 0.005;		Qij_AA[17][7] = 2.8258;	
		Qij_AA[17][8] = 0.005;		Qij_AA[17][9] = 0.005;		Qij_AA[17][10] = 1.37031;		Qij_AA[17][11] = 0.005;	
		Qij_AA[17][12] = 0.005;		Qij_AA[17][13] = 0.005;		Qij_AA[17][14] = 0.005;		Qij_AA[17][15] = 1.10156;	
		Qij_AA[17][16] = 0.005;		Qij_AA[17][17] = 0;			Qij_AA[17][18] = 0.005;		Qij_AA[17][19] = 0.005;	
		Qij_AA[18][0] = 0.005;		Qij_AA[18][1] = 0.005;		Qij_AA[18][2] = 5.06475;		Qij_AA[18][3] = 2.28154;	
		Qij_AA[18][4] = 8.34835;		Qij_AA[18][5] = 0.005;		Qij_AA[18][6] = 0.005;		Qij_AA[18][7] = 0.005;	
		Qij_AA[18][8] = 47.4889;		Qij_AA[18][9] = 0.114512;		Qij_AA[18][10] = 0.005;		Qij_AA[18][11] = 0.005;	
		Qij_AA[18][12] = 0.579198;	Qij_AA[18][13] = 4.12728;		Qij_AA[18][14] = 0.005;		Qij_AA[18][15] = 0.933142;	
		Qij_AA[18][16] = 0.490608;	Qij_AA[18][17] = 0.005;		Qij_AA[18][18] = 0;			Qij_AA[18][19] = 1.35482;	
		Qij_AA[19][0] = 24.8094;		Qij_AA[19][1] = 0.279425;		Qij_AA[19][2] = 0.0744808;	Qij_AA[19][3] = 2.91786;	
		Qij_AA[19][4] = 0.005;		Qij_AA[19][5] = 0.005;		Qij_AA[19][6] = 2.19952;		Qij_AA[19][7] = 2.79622;	
		Qij_AA[19][8] = 0.827479;		Qij_AA[19][9] = 24.8231;		Qij_AA[19][10] = 2.95344;		Qij_AA[19][11] = 0.128065;	
		Qij_AA[19][12] = 14.7683;		Qij_AA[19][13] = 2.28;		Qij_AA[19][14] = 0.005;		Qij_AA[19][15] = 0.862637;	
		Qij_AA[19][16] = 0.005;		Qij_AA[19][17] = 0.005;		Qij_AA[19][18] = 1.35482;		Qij_AA[19][19] = 0;	

		AA_EM_Pi[0] = 0.0377494;
		AA_EM_Pi[1] = 0.057321;
		AA_EM_Pi[2] = 0.0891129;
		AA_EM_Pi[3] = 0.0342034;
		AA_EM_Pi[4] = 0.0240105;
		AA_EM_Pi[5] = 0.0437824;
		AA_EM_Pi[6] = 0.0618606;
		AA_EM_Pi[7] = 0.0838496;
		AA_EM_Pi[8] = 0.0156076;
		AA_EM_Pi[9] = 0.0983641;
		AA_EM_Pi[10] = 0.0577867;
		AA_EM_Pi[11] = 0.0641682;
		AA_EM_Pi[12] = 0.0158419;
		AA_EM_Pi[13] = 0.0422741;
		AA_EM_Pi[14] = 0.0458601;
		AA_EM_Pi[15] = 0.0550846;
		AA_EM_Pi[16] = 0.0813774;
		AA_EM_Pi[17] = 0.019597;
		AA_EM_Pi[18] = 0.0205847;
		AA_EM_Pi[19] = 0.0515639;
		}
	else if (doJTT == YES)
		{
		Qij_AA[0][0] =   0; Qij_AA[0][1] =  58; Qij_AA[0][2] =  54; Qij_AA[0][3] =  81; Qij_AA[0][4] =  56; 
		Qij_AA[0][5] =  57; Qij_AA[0][6] = 105; Qij_AA[0][7] = 179; Qij_AA[0][8] =  27; Qij_AA[0][9] =  36; 
		Qij_AA[0][10] =  30; Qij_AA[0][11] =  35; Qij_AA[0][12] =  54; Qij_AA[0][13] =  15; Qij_AA[0][14] = 194; 
		Qij_AA[0][15] = 378; Qij_AA[0][16] = 475; Qij_AA[0][17] =   9; Qij_AA[0][18] =  11; Qij_AA[0][19] = 298; 
		Qij_AA[1][0] =  58; Qij_AA[1][1] =   0; Qij_AA[1][2] =  45; Qij_AA[1][3] =  16; Qij_AA[1][4] = 113; 
		Qij_AA[1][5] = 310; Qij_AA[1][6] =  29; Qij_AA[1][7] = 137; Qij_AA[1][8] = 328; Qij_AA[1][9] =  22; 
		Qij_AA[1][10] =  38; Qij_AA[1][11] = 646; Qij_AA[1][12] =  44; Qij_AA[1][13] =   5; Qij_AA[1][14] =  74; 
		Qij_AA[1][15] = 101; Qij_AA[1][16] =  64; Qij_AA[1][17] = 126; Qij_AA[1][18] =  20; Qij_AA[1][19] =  17; 
		Qij_AA[2][0] =  54; Qij_AA[2][1] =  45; Qij_AA[2][2] =   0; Qij_AA[2][3] = 528; Qij_AA[2][4] =  34; 
		Qij_AA[2][5] =  86; Qij_AA[2][6] =  58; Qij_AA[2][7] =  81; Qij_AA[2][8] = 391; Qij_AA[2][9] =  47; 
		Qij_AA[2][10] =  12; Qij_AA[2][11] = 263; Qij_AA[2][12] =  30; Qij_AA[2][13] =  10; Qij_AA[2][14] =  15; 
		Qij_AA[2][15] = 503; Qij_AA[2][16] = 232; Qij_AA[2][17] =   8; Qij_AA[2][18] =  70; Qij_AA[2][19] =  16; 
		Qij_AA[3][0] =  81; Qij_AA[3][1] =  16; Qij_AA[3][2] = 528; Qij_AA[3][3] =   0; Qij_AA[3][4] =  10; 
		Qij_AA[3][5] =  49; Qij_AA[3][6] = 767; Qij_AA[3][7] = 130; Qij_AA[3][8] = 112; Qij_AA[3][9] =  11; 
		Qij_AA[3][10] =   7; Qij_AA[3][11] =  26; Qij_AA[3][12] =  15; Qij_AA[3][13] =   4; Qij_AA[3][14] =  15; 
		Qij_AA[3][15] =  59; Qij_AA[3][16] =  38; Qij_AA[3][17] =   4; Qij_AA[3][18] =  46; Qij_AA[3][19] =  31; 
		Qij_AA[4][0] =  56; Qij_AA[4][1] = 113; Qij_AA[4][2] =  34; Qij_AA[4][3] =  10; Qij_AA[4][4] =   0; 
		Qij_AA[4][5] =   9; Qij_AA[4][6] =   5; Qij_AA[4][7] =  59; Qij_AA[4][8] =  69; Qij_AA[4][9] =  17; 
		Qij_AA[4][10] =  23; Qij_AA[4][11] =   7; Qij_AA[4][12] =  31; Qij_AA[4][13] =  78; Qij_AA[4][14] =  14; 
		Qij_AA[4][15] = 223; Qij_AA[4][16] =  42; Qij_AA[4][17] = 115; Qij_AA[4][18] = 209; Qij_AA[4][19] =  62; 
		Qij_AA[5][0] =  57; Qij_AA[5][1] = 310; Qij_AA[5][2] =  86; Qij_AA[5][3] =  49; Qij_AA[5][4] =   9; 
		Qij_AA[5][5] =   0; Qij_AA[5][6] = 323; Qij_AA[5][7] =  26; Qij_AA[5][8] = 597; Qij_AA[5][9] =   9; 
		Qij_AA[5][10] =  72; Qij_AA[5][11] = 292; Qij_AA[5][12] =  43; Qij_AA[5][13] =   4; Qij_AA[5][14] = 164; 
		Qij_AA[5][15] =  53; Qij_AA[5][16] =  51; Qij_AA[5][17] =  18; Qij_AA[5][18] =  24; Qij_AA[5][19] =  20; 
		Qij_AA[6][0] = 105; Qij_AA[6][1] =  29; Qij_AA[6][2] =  58; Qij_AA[6][3] = 767; Qij_AA[6][4] =   5; 
		Qij_AA[6][5] = 323; Qij_AA[6][6] =   0; Qij_AA[6][7] = 119; Qij_AA[6][8] =  26; Qij_AA[6][9] =  12; 
		Qij_AA[6][10] =   9; Qij_AA[6][11] = 181; Qij_AA[6][12] =  18; Qij_AA[6][13] =   5; Qij_AA[6][14] =  18; 
		Qij_AA[6][15] =  30; Qij_AA[6][16] =  32; Qij_AA[6][17] =  10; Qij_AA[6][18] =   7; Qij_AA[6][19] =  45; 
		Qij_AA[7][0] = 179; Qij_AA[7][1] = 137; Qij_AA[7][2] =  81; Qij_AA[7][3] = 130; Qij_AA[7][4] =  59; 
		Qij_AA[7][5] =  26; Qij_AA[7][6] = 119; Qij_AA[7][7] =   0; Qij_AA[7][8] =  23; Qij_AA[7][9] =   6; 
		Qij_AA[7][10] =   6; Qij_AA[7][11] =  27; Qij_AA[7][12] =  14; Qij_AA[7][13] =   5; Qij_AA[7][14] =  24; 
		Qij_AA[7][15] = 201; Qij_AA[7][16] =  33; Qij_AA[7][17] =  55; Qij_AA[7][18] =   8; Qij_AA[7][19] =  47; 
		Qij_AA[8][0] =  27; Qij_AA[8][1] = 328; Qij_AA[8][2] = 391; Qij_AA[8][3] = 112; Qij_AA[8][4] =  69; 
		Qij_AA[8][5] = 597; Qij_AA[8][6] =  26; Qij_AA[8][7] =  23; Qij_AA[8][8] =   0; Qij_AA[8][9] =  16; 
		Qij_AA[8][10] =  56; Qij_AA[8][11] =  45; Qij_AA[8][12] =  33; Qij_AA[8][13] =  40; Qij_AA[8][14] = 115; 
		Qij_AA[8][15] =  73; Qij_AA[8][16] =  46; Qij_AA[8][17] =   8; Qij_AA[8][18] = 573; Qij_AA[8][19] =  11; 
		Qij_AA[9][0] =  36; Qij_AA[9][1] =  22; Qij_AA[9][2] =  47; Qij_AA[9][3] =  11; Qij_AA[9][4] =  17; 
		Qij_AA[9][5] =   9; Qij_AA[9][6] =  12; Qij_AA[9][7] =   6; Qij_AA[9][8] =  16; Qij_AA[9][9] =   0; 
		Qij_AA[9][10] = 229; Qij_AA[9][11] =  21; Qij_AA[9][12] = 479; Qij_AA[9][13] =  89; Qij_AA[9][14] =  10; 
		Qij_AA[9][15] =  40; Qij_AA[9][16] = 245; Qij_AA[9][17] =   9; Qij_AA[9][18] =  32; Qij_AA[9][19] = 961; 
		Qij_AA[10][0] =  30; Qij_AA[10][1] =  38; Qij_AA[10][2] =  12; Qij_AA[10][3] =   7; Qij_AA[10][4] =  23; 
		Qij_AA[10][5] =  72; Qij_AA[10][6] =   9; Qij_AA[10][7] =   6; Qij_AA[10][8] =  56; Qij_AA[10][9] = 229; 
		Qij_AA[10][10] =   0; Qij_AA[10][11] =  14; Qij_AA[10][12] = 388; Qij_AA[10][13] = 248; Qij_AA[10][14] = 102; 
		Qij_AA[10][15] =  59; Qij_AA[10][16] =  25; Qij_AA[10][17] =  52; Qij_AA[10][18] =  24; Qij_AA[10][19] = 180; 
		Qij_AA[11][0] =  35; Qij_AA[11][1] = 646; Qij_AA[11][2] = 263; Qij_AA[11][3] =  26; Qij_AA[11][4] =   7; 
		Qij_AA[11][5] = 292; Qij_AA[11][6] = 181; Qij_AA[11][7] =  27; Qij_AA[11][8] =  45; Qij_AA[11][9] =  21; 
		Qij_AA[11][10] =  14; Qij_AA[11][11] =   0; Qij_AA[11][12] =  65; Qij_AA[11][13] =   4; Qij_AA[11][14] =  21; 
		Qij_AA[11][15] =  47; Qij_AA[11][16] = 103; Qij_AA[11][17] =  10; Qij_AA[11][18] =   8; Qij_AA[11][19] =  14; 
		Qij_AA[12][0] =  54; Qij_AA[12][1] =  44; Qij_AA[12][2] =  30; Qij_AA[12][3] =  15; Qij_AA[12][4] =  31; 
		Qij_AA[12][5] =  43; Qij_AA[12][6] =  18; Qij_AA[12][7] =  14; Qij_AA[12][8] =  33; Qij_AA[12][9] = 479; 
		Qij_AA[12][10] = 388; Qij_AA[12][11] =  65; Qij_AA[12][12] =   0; Qij_AA[12][13] =  43; Qij_AA[12][14] =  16; 
		Qij_AA[12][15] =  29; Qij_AA[12][16] = 226; Qij_AA[12][17] =  24; Qij_AA[12][18] =  18; Qij_AA[12][19] = 323; 
		Qij_AA[13][0] =  15; Qij_AA[13][1] =   5; Qij_AA[13][2] =  10; Qij_AA[13][3] =   4; Qij_AA[13][4] =  78; 
		Qij_AA[13][5] =   4; Qij_AA[13][6] =   5; Qij_AA[13][7] =   5; Qij_AA[13][8] =  40; Qij_AA[13][9] =  89; 
		Qij_AA[13][10] = 248; Qij_AA[13][11] =   4; Qij_AA[13][12] =  43; Qij_AA[13][13] =   0; Qij_AA[13][14] =  17; 
		Qij_AA[13][15] =  92; Qij_AA[13][16] =  12; Qij_AA[13][17] =  53; Qij_AA[13][18] = 536; Qij_AA[13][19] =  62; 
		Qij_AA[14][0] = 194; Qij_AA[14][1] =  74; Qij_AA[14][2] =  15; Qij_AA[14][3] =  15; Qij_AA[14][4] =  14; 
		Qij_AA[14][5] = 164; Qij_AA[14][6] =  18; Qij_AA[14][7] =  24; Qij_AA[14][8] = 115; Qij_AA[14][9] =  10; 
		Qij_AA[14][10] = 102; Qij_AA[14][11] =  21; Qij_AA[14][12] =  16; Qij_AA[14][13] =  17; Qij_AA[14][14] =   0; 
		Qij_AA[14][15] = 285; Qij_AA[14][16] = 118; Qij_AA[14][17] =   6; Qij_AA[14][18] =  10; Qij_AA[14][19] =  23; 
		Qij_AA[15][0] = 378; Qij_AA[15][1] = 101; Qij_AA[15][2] = 503; Qij_AA[15][3] =  59; Qij_AA[15][4] = 223; 
		Qij_AA[15][5] =  53; Qij_AA[15][6] =  30; Qij_AA[15][7] = 201; Qij_AA[15][8] =  73; Qij_AA[15][9] =  40; 
		Qij_AA[15][10] =  59; Qij_AA[15][11] =  47; Qij_AA[15][12] =  29; Qij_AA[15][13] =  92; Qij_AA[15][14] = 285; 
		Qij_AA[15][15] =   0; Qij_AA[15][16] = 477; Qij_AA[15][17] =  35; Qij_AA[15][18] =  63; Qij_AA[15][19] =  38; 
		Qij_AA[16][0] = 475; Qij_AA[16][1] =  64; Qij_AA[16][2] = 232; Qij_AA[16][3] =  38; Qij_AA[16][4] =  42; 
		Qij_AA[16][5] =  51; Qij_AA[16][6] =  32; Qij_AA[16][7] =  33; Qij_AA[16][8] =  46; Qij_AA[16][9] = 245; 
		Qij_AA[16][10] =  25; Qij_AA[16][11] = 103; Qij_AA[16][12] = 226; Qij_AA[16][13] =  12; Qij_AA[16][14] = 118; 
		Qij_AA[16][15] = 477; Qij_AA[16][16] =   0; Qij_AA[16][17] =  12; Qij_AA[16][18] =  21; Qij_AA[16][19] = 112; 
		Qij_AA[17][0] =   9; Qij_AA[17][1] = 126; Qij_AA[17][2] =   8; Qij_AA[17][3] =   4; Qij_AA[17][4] = 115; 
		Qij_AA[17][5] =  18; Qij_AA[17][6] =  10; Qij_AA[17][7] =  55; Qij_AA[17][8] =   8; Qij_AA[17][9] =   9; 
		Qij_AA[17][10] =  52; Qij_AA[17][11] =  10; Qij_AA[17][12] =  24; Qij_AA[17][13] =  53; Qij_AA[17][14] =   6; 
		Qij_AA[17][15] =  35; Qij_AA[17][16] =  12; Qij_AA[17][17] =   0; Qij_AA[17][18] =  71; Qij_AA[17][19] =  25; 
		Qij_AA[18][0] =  11; Qij_AA[18][1] =  20; Qij_AA[18][2] =  70; Qij_AA[18][3] =  46; Qij_AA[18][4] = 209; 
		Qij_AA[18][5] =  24; Qij_AA[18][6] =   7; Qij_AA[18][7] =   8; Qij_AA[18][8] = 573; Qij_AA[18][9] =  32; 
		Qij_AA[18][10] =  24; Qij_AA[18][11] =   8; Qij_AA[18][12] =  18; Qij_AA[18][13] = 536; Qij_AA[18][14] =  10; 
		Qij_AA[18][15] =  63; Qij_AA[18][16] =  21; Qij_AA[18][17] =  71; Qij_AA[18][18] =   0; Qij_AA[18][19] =  16; 
		Qij_AA[19][0] = 298; Qij_AA[19][1] =  17; Qij_AA[19][2] =  16; Qij_AA[19][3] =  31; Qij_AA[19][4] =  62; 
		Qij_AA[19][5] =  20; Qij_AA[19][6] =  45; Qij_AA[19][7] =  47; Qij_AA[19][8] =  11; Qij_AA[19][9] = 961; 
		Qij_AA[19][10] = 180; Qij_AA[19][11] =  14; Qij_AA[19][12] = 323; Qij_AA[19][13] =  62; Qij_AA[19][14] =  23; 
		Qij_AA[19][15] =  38; Qij_AA[19][16] = 112; Qij_AA[19][17] =  25; Qij_AA[19][18] =  16; Qij_AA[19][19] =   0; 


		AA_EM_Pi[0] = 0.076748;
		AA_EM_Pi[1] = 0.051691;
		AA_EM_Pi[2] = 0.042645;
		AA_EM_Pi[3] = 0.051544;
		AA_EM_Pi[4] = 0.019803;
		AA_EM_Pi[5] = 0.040752;
		AA_EM_Pi[6] = 0.061830;
		AA_EM_Pi[7] = 0.073152;
		AA_EM_Pi[8] = 0.022944;
		AA_EM_Pi[9] = 0.053761;
		AA_EM_Pi[10] = 0.091904;
		AA_EM_Pi[11] = 0.058676;
		AA_EM_Pi[12] = 0.023826;
		AA_EM_Pi[13] = 0.040126;
		AA_EM_Pi[14] = 0.050901;
		AA_EM_Pi[15] = 0.068765;
		AA_EM_Pi[16] = 0.058565;
		AA_EM_Pi[17] = 0.014261;
		AA_EM_Pi[18] = 0.032102;
		AA_EM_Pi[19] = 0.066005;
		}
	else if (doJonesDCMUT == YES) 
		{
		Qij_AA[0][0]=0;			Qij_AA[0][1]=0.531678; 	Qij_AA[0][2]=0.557967; 	Qij_AA[0][3]=0.827445; 	Qij_AA[0][4]=0.574478; 	
		Qij_AA[0][5]=0.556725; 	Qij_AA[0][6]=1.066681; 	Qij_AA[0][7]=1.740159; 	Qij_AA[0][8]=0.21997; 	Qij_AA[0][9]=0.361684; 	
		Qij_AA[0][10]=0.310007; 	Qij_AA[0][11]=0.369437; 	Qij_AA[0][12]=0.469395; 	Qij_AA[0][13]=0.138293; 	Qij_AA[0][14]=1.959599; 	
		Qij_AA[0][15]=3.887095; 		Qij_AA[0][16]=4.582565; 	Qij_AA[0][17]=0.084329; 	Qij_AA[0][18]=0.139492; 	Qij_AA[0][19]=2.924161; 		
		Qij_AA[1][0]=0.531678; 	Qij_AA[1][1]=0;			Qij_AA[1][2]=0.451095; 	Qij_AA[1][3]=0.154899; 	Qij_AA[1][4]=1.019843; 	
		Qij_AA[1][5]=3.021995; 	Qij_AA[1][6]=0.318483; 	Qij_AA[1][7]=1.359652; 	Qij_AA[1][8]=3.210671; 	Qij_AA[1][9]=0.239195; 	
		Qij_AA[1][10]=0.372261; 	Qij_AA[1][11]=6.529255; 	Qij_AA[1][12]=0.431045; 	Qij_AA[1][13]=0.065314; 	Qij_AA[1][14]=0.710489; 	
		Qij_AA[1][15]=1.001551; 		Qij_AA[1][16]=0.650282; 	Qij_AA[1][17]=1.257961; 	Qij_AA[1][18]=0.235601; 	Qij_AA[1][19]=0.171995; 		
		Qij_AA[2][0]=0.557967; 	Qij_AA[2][1]=0.451095; 	Qij_AA[2][2]=0; 			Qij_AA[2][3]=5.54953; 	Qij_AA[2][4]=0.313311; 	
		Qij_AA[2][5]=0.768834; 	Qij_AA[2][6]=0.578115; 	Qij_AA[2][7]=0.773313; 	Qij_AA[2][8]=4.025778; 	Qij_AA[2][9]=0.491003; 	
		Qij_AA[2][10]=0.137289; 	Qij_AA[2][11]=2.529517; 	Qij_AA[2][12]=0.33072; 	Qij_AA[2][13]=0.073481; 	Qij_AA[2][14]=0.121804; 	
		Qij_AA[2][15]=5.057964; 		Qij_AA[2][16]=2.351311; 	Qij_AA[2][17]=0.0277; 	Qij_AA[2][18]=0.700693; 	Qij_AA[2][19]=0.164525; 		
		Qij_AA[3][0]=0.827445; 	Qij_AA[3][1]=0.154899; 	Qij_AA[3][2]=5.54953; 	Qij_AA[3][3]=0;			Qij_AA[3][4]=0.105625; 	
		Qij_AA[3][5]=0.521646; 	Qij_AA[3][6]=7.766557; 	Qij_AA[3][7]=1.272434; 	Qij_AA[3][8]=1.032342; 	Qij_AA[3][9]=0.115968; 	
		Qij_AA[3][10]=0.061486; 	Qij_AA[3][11]=0.282466; 	Qij_AA[3][12]=0.190001; 	Qij_AA[3][13]=0.032522; 	Qij_AA[3][14]=0.127164; 	
		Qij_AA[3][15]=0.589268; 		Qij_AA[3][16]=0.425159; 	Qij_AA[3][17]=0.057466; 	Qij_AA[3][18]=0.453952; 	Qij_AA[3][19]=0.315261; 		
		Qij_AA[4][0]=0.574478; 	Qij_AA[4][1]=1.019843; 	Qij_AA[4][2]=0.313311; 	Qij_AA[4][3]=0.105625; 	Qij_AA[4][4]=0; 			
		Qij_AA[4][5]=0.091304; 	Qij_AA[4][6]=0.053907; 	Qij_AA[4][7]=0.546389; 	Qij_AA[4][8]=0.724998; 	Qij_AA[4][9]=0.150559; 	
		Qij_AA[4][10]=0.164593; 	Qij_AA[4][11]=0.049009; 	Qij_AA[4][12]=0.409202; 	Qij_AA[4][13]=0.678335; 	Qij_AA[4][14]=0.123653; 	
		Qij_AA[4][15]=2.155331; 		Qij_AA[4][16]=0.469823; 	Qij_AA[4][17]=1.104181; 	Qij_AA[4][18]=2.114852; 	Qij_AA[4][19]=0.621323; 		
		Qij_AA[5][0]=0.556725; 	Qij_AA[5][1]=3.021995; 	Qij_AA[5][2]=0.768834; 	Qij_AA[5][3]=0.521646; 	Qij_AA[5][4]=0.091304; 	
		Qij_AA[5][5]=0;			Qij_AA[5][6]=3.417706; 	Qij_AA[5][7]=0.231294; 	Qij_AA[5][8]=5.68408; 	Qij_AA[5][9]=0.07827; 	
		Qij_AA[5][10]=0.709004; 	Qij_AA[5][11]=2.966732; 	Qij_AA[5][12]=0.456901; 	Qij_AA[5][13]=0.045683; 	Qij_AA[5][14]=1.608126; 	
		Qij_AA[5][15]=0.548807; 		Qij_AA[5][16]=0.523825; 	Qij_AA[5][17]=0.172206; 	Qij_AA[5][18]=0.254745; 	Qij_AA[5][19]=0.179771; 		
		Qij_AA[6][0]=1.066681; 	Qij_AA[6][1]=0.318483; 	Qij_AA[6][2]=0.578115; 	Qij_AA[6][3]=7.766557; 	Qij_AA[6][4]=0.053907; 	
		Qij_AA[6][5]=3.417706; 	Qij_AA[6][6]=0;			Qij_AA[6][7]=1.115632; 	Qij_AA[6][8]=0.243768; 	Qij_AA[6][9]=0.111773; 	
		Qij_AA[6][10]=0.097485; 	Qij_AA[6][11]=1.731684; 	Qij_AA[6][12]=0.175084; 	Qij_AA[6][13]=0.043829; 	Qij_AA[6][14]=0.191994; 	
		Qij_AA[6][15]=0.312449; 		Qij_AA[6][16]=0.331584; 	Qij_AA[6][17]=0.114381; 	Qij_AA[6][18]=0.063452; 	Qij_AA[6][19]=0.465271; 		
		Qij_AA[7][0]=1.740159; 	Qij_AA[7][1]=1.359652; 	Qij_AA[7][2]=0.773313; 	Qij_AA[7][3]=1.272434; 	Qij_AA[7][4]=0.546389; 	
		Qij_AA[7][5]=0.231294; 	Qij_AA[7][6]=1.115632; 	Qij_AA[7][7]=0; 			Qij_AA[7][8]=0.201696; 	Qij_AA[7][9]=0.053769; 	
		Qij_AA[7][10]=0.069492; 	Qij_AA[7][11]=0.26984; 	Qij_AA[7][12]=0.130379; 	Qij_AA[7][13]=0.050212; 	Qij_AA[7][14]=0.208081; 	
		Qij_AA[7][15]=1.874296; 		Qij_AA[7][16]=0.316862; 	Qij_AA[7][17]=0.54418; 	Qij_AA[7][18]=0.0525; 	Qij_AA[7][19]=0.47014; 		
		Qij_AA[8][0]=0.21997; 	Qij_AA[8][1]=3.210671; 	Qij_AA[8][2]=4.025778; 	Qij_AA[8][3]=1.032342; 	Qij_AA[8][4]=0.724998; 	
		Qij_AA[8][5]=5.68408; 	Qij_AA[8][6]=0.243768; 	Qij_AA[8][7]=0.201696; 	Qij_AA[8][8]=0;			Qij_AA[8][9]=0.181788; 	
		Qij_AA[8][10]=0.540571; 	Qij_AA[8][11]=0.525096; 	Qij_AA[8][12]=0.32966; 	Qij_AA[8][13]=0.453428; 	Qij_AA[8][14]=1.141961; 	
		Qij_AA[8][15]=0.743458; 		Qij_AA[8][16]=0.477355; 	Qij_AA[8][17]=0.128193; 	Qij_AA[8][18]=5.8484; 	Qij_AA[8][19]=0.121827; 		
		Qij_AA[9][0]=0.361684; 	Qij_AA[9][1]=0.239195; 	Qij_AA[9][2]=0.491003; 	Qij_AA[9][3]=0.115968; 	Qij_AA[9][4]=0.150559; 	
		Qij_AA[9][5]=0.07827; 	Qij_AA[9][6]=0.111773; 	Qij_AA[9][7]=0.053769; 	Qij_AA[9][8]=0.181788; 	Qij_AA[9][9]=0;			
		Qij_AA[9][10]=2.335139; 	Qij_AA[9][11]=0.202562; 	Qij_AA[9][12]=4.831666; 	Qij_AA[9][13]=0.77709; 	Qij_AA[9][14]=0.09858; 	
		Qij_AA[9][15]=0.405119; 		Qij_AA[9][16]=2.553806; 	Qij_AA[9][17]=0.13451; 	Qij_AA[9][18]=0.303445; 	Qij_AA[9][19]=9.533943; 		
		Qij_AA[10][0]=0.310007; 	Qij_AA[10][1]=0.372261; 	Qij_AA[10][2]=0.137289; 	Qij_AA[10][3]=0.061486; 	Qij_AA[10][4]=0.164593; 
		Qij_AA[10][5]=0.709004; 	Qij_AA[10][6]=0.097485; 	Qij_AA[10][7]=0.069492; 	Qij_AA[10][8]=0.540571; 	Qij_AA[10][9]=2.335139;
		Qij_AA[10][10]=0; 		Qij_AA[10][11]=0.146481; 	Qij_AA[10][12]=3.856906; 	Qij_AA[10][13]=2.500294; 	Qij_AA[10][14]=1.060504; 
		Qij_AA[10][15]=0.592511; 	Qij_AA[10][16]=0.272514; 	Qij_AA[10][17]=0.530324; 	Qij_AA[10][18]=0.241094; 	Qij_AA[10][19]=1.761439; 		
		Qij_AA[11][0]=0.369437; 	Qij_AA[11][1]=6.529255; 	Qij_AA[11][2]=2.529517; 	Qij_AA[11][3]=0.282466; 	Qij_AA[11][4]=0.049009;
		Qij_AA[11][5]=2.966732; 	Qij_AA[11][6]=1.731684; 	Qij_AA[11][7]=0.26984; 	Qij_AA[11][8]=0.525096; 	Qij_AA[11][9]=0.202562;
		Qij_AA[11][10]=0.146481; 	Qij_AA[11][11]=0;			Qij_AA[11][12]=0.624581; 	Qij_AA[11][13]=0.024521; 	Qij_AA[11][14]=0.216345; 
		Qij_AA[11][15]=0.474478; 	Qij_AA[11][16]=0.965641; 	Qij_AA[11][17]=0.089134; 	Qij_AA[11][18]=0.087904; 	Qij_AA[11][19]=0.124066; 		
		Qij_AA[12][0]=0.469395; 	Qij_AA[12][1]=0.431045; 	Qij_AA[12][2]=0.33072; 	Qij_AA[12][3]=0.190001; 	Qij_AA[12][4]=0.409202;
		Qij_AA[12][5]=0.456901; 	Qij_AA[12][6]=0.175084; 	Qij_AA[12][7]=0.130379; 	Qij_AA[12][8]=0.32966; 	Qij_AA[12][9]=4.831666;
		Qij_AA[12][10]=3.856906; 	Qij_AA[12][11]=0.624581; 	Qij_AA[12][12]=0;			Qij_AA[12][13]=0.436181; 	Qij_AA[12][14]=0.164215; 
		Qij_AA[12][15]=0.285564; 	Qij_AA[12][16]=2.114728; 	Qij_AA[12][17]=0.201334; 	Qij_AA[12][18]=0.18987; 	Qij_AA[12][19]=3.038533; 		
		Qij_AA[13][0]=0.138293; 	Qij_AA[13][1]=0.065314; 	Qij_AA[13][2]=0.073481; 	Qij_AA[13][3]=0.032522; 	Qij_AA[13][4]=0.678335; 
		Qij_AA[13][5]=0.045683; 	Qij_AA[13][6]=0.043829; 	Qij_AA[13][7]=0.050212; 	Qij_AA[13][8]=0.453428; 	Qij_AA[13][9]=0.77709; 	
		Qij_AA[13][10]=2.500294; 	Qij_AA[13][11]=0.024521; 	Qij_AA[13][12]=0.436181; 	Qij_AA[13][13]=0;			Qij_AA[13][14]=0.148483; 
		Qij_AA[13][15]=0.943971; 	Qij_AA[13][16]=0.138904; 	Qij_AA[13][17]=0.537922; 	Qij_AA[13][18]=5.484236; 	Qij_AA[13][19]=0.593478; 		
		Qij_AA[14][0]=1.959599; 	Qij_AA[14][1]=0.710489; 	Qij_AA[14][2]=0.121804; 	Qij_AA[14][3]=0.127164; 	Qij_AA[14][4]=0.123653;
		Qij_AA[14][5]=1.608126; 	Qij_AA[14][6]=0.191994; 	Qij_AA[14][7]=0.208081; 	Qij_AA[14][8]=1.141961; 	Qij_AA[14][9]=0.09858; 
		Qij_AA[14][10]=1.060504; 	Qij_AA[14][11]=0.216345; 	Qij_AA[14][12]=0.164215; 	Qij_AA[14][13]=0.148483; 	Qij_AA[14][14]=0;
		Qij_AA[14][15]=2.788406; 	Qij_AA[14][16]=1.176961; 	Qij_AA[14][17]=0.069965; 	Qij_AA[14][18]=0.11385; 	Qij_AA[14][19]=0.211561; 		
		Qij_AA[15][0]=3.887095; 	Qij_AA[15][1]=1.001551; 	Qij_AA[15][2]=5.057964; 	Qij_AA[15][3]=0.589268; 	Qij_AA[15][4]=2.155331;
		Qij_AA[15][5]=0.548807; 	Qij_AA[15][6]=0.312449; 	Qij_AA[15][7]=1.874296; 	Qij_AA[15][8]=0.743458; 	Qij_AA[15][9]=0.405119;
		Qij_AA[15][10]=0.592511; 	Qij_AA[15][11]=0.474478; 	Qij_AA[15][12]=0.285564; 	Qij_AA[15][13]=0.943971; 	Qij_AA[15][14]=2.788406; 
		Qij_AA[15][15]=0;			Qij_AA[15][16]=4.777647; 	Qij_AA[15][17]=0.310927; 	Qij_AA[15][18]=0.628608; 	Qij_AA[15][19]=0.408532; 		
		Qij_AA[16][0]=4.582565; 	Qij_AA[16][1]=0.650282; 	Qij_AA[16][2]=2.351311; 	Qij_AA[16][3]=0.425159; 	Qij_AA[16][4]=0.469823; 
		Qij_AA[16][5]=0.523825; 	Qij_AA[16][6]=0.331584; 	Qij_AA[16][7]=0.316862; 	Qij_AA[16][8]=0.477355; 	Qij_AA[16][9]=2.553806;
		Qij_AA[16][10]=0.272514; 	Qij_AA[16][11]=0.965641; 	Qij_AA[16][12]=2.114728; 	Qij_AA[16][13]=0.138904; 	Qij_AA[16][14]=1.176961; 
		Qij_AA[16][15]=4.777647; 	Qij_AA[16][16]=0;			Qij_AA[16][17]=0.080556; 	Qij_AA[16][18]=0.201094; 	Qij_AA[16][19]=1.14398; 		
		Qij_AA[17][0]=0.084329; 	Qij_AA[17][1]=1.257961; 	Qij_AA[17][2]=0.0277; 	Qij_AA[17][3]=0.057466; 	Qij_AA[17][4]=1.104181;
		Qij_AA[17][5]=0.172206; 	Qij_AA[17][6]=0.114381; 	Qij_AA[17][7]=0.54418; 	Qij_AA[17][8]=0.128193; 	Qij_AA[17][9]=0.13451;
		Qij_AA[17][10]=0.530324; 	Qij_AA[17][11]=0.089134; 	Qij_AA[17][12]=0.201334; 	Qij_AA[17][13]=0.537922; 	Qij_AA[17][14]=0.069965; 
		Qij_AA[17][15]=0.310927; 	Qij_AA[17][16]=0.080556; 	Qij_AA[17][17]=0;			Qij_AA[17][18]=0.747889; 	Qij_AA[17][19]=0.239697; 		
		Qij_AA[18][0]=0.139492; 	Qij_AA[18][1]=0.235601; 	Qij_AA[18][2]=0.700693; 	Qij_AA[18][3]=0.453952; 	Qij_AA[18][4]=2.114852;
		Qij_AA[18][5]=0.254745; 	Qij_AA[18][6]=0.063452; 	Qij_AA[18][7]=0.0525; 	Qij_AA[18][8]=5.8484; 	Qij_AA[18][9]=0.303445;
		Qij_AA[18][10]=0.241094; 	Qij_AA[18][11]=0.087904; 	Qij_AA[18][12]=0.18987; 	Qij_AA[18][13]=5.484236; 	Qij_AA[18][14]=0.11385; 
		Qij_AA[18][15]=0.628608; 	Qij_AA[18][16]=0.201094; 	Qij_AA[18][17]=0.747889; 	Qij_AA[18][18]=0;			Qij_AA[18][19]=0.165473; 		
		Qij_AA[19][0]=2.924161; 	Qij_AA[19][1]=0.171995; 	Qij_AA[19][2]=0.164525; 	Qij_AA[19][3]=0.315261; 	Qij_AA[19][4]=0.621323; 
		Qij_AA[19][5]=0.179771; 	Qij_AA[19][6]=0.465271; 	Qij_AA[19][7]=0.47014; 	Qij_AA[19][8]=0.121827; 	Qij_AA[19][9]=9.533943; 
		Qij_AA[19][10]=1.761439; 	Qij_AA[19][11]=0.124066; 	Qij_AA[19][12]=3.038533; 	Qij_AA[19][13]=0.593478; 	Qij_AA[19][14]=0.211561; 
		Qij_AA[19][15]=0.408532; 	Qij_AA[19][16]=1.14398; 	Qij_AA[19][17]=0.239697; 	Qij_AA[19][18]=0.165473; 	Qij_AA[19][19]=0; 		

		
		AA_EM_Pi[0]=0.076862; 
		AA_EM_Pi[1]=0.051057; 
		AA_EM_Pi[2]=0.042546; 
		AA_EM_Pi[3]=0.051269; 
		AA_EM_Pi[4]=0.020279; 
		AA_EM_Pi[5]=0.041061; 
		AA_EM_Pi[6]=0.06182; 
		AA_EM_Pi[7]=0.074714; 
		AA_EM_Pi[8]=0.022983; 
		AA_EM_Pi[9]=0.052569; 
		AA_EM_Pi[10]=0.091111; 
		AA_EM_Pi[11]=0.059498; 
		AA_EM_Pi[12]=0.023414; 
		AA_EM_Pi[13]=0.04053; 
		AA_EM_Pi[14]=0.050532; 
		AA_EM_Pi[15]=0.068225; 
		AA_EM_Pi[16]=0.058518; 
		AA_EM_Pi[17]=0.014336; 
		AA_EM_Pi[18]=0.032303; 
		AA_EM_Pi[19]=0.066374; 
		}
	else if (doLG == YES)
		{
		Qij_AA[0][0] = 0;			Qij_AA[1][0] = 0.425093;	Qij_AA[2][0] = 0.276818;	Qij_AA[3][0] = 0.395144;	Qij_AA[4][0] = 2.489084;	Qij_AA[5][0] = 0.969894;	Qij_AA[6][0] = 1.038545;	Qij_AA[7][0] = 2.066040;	Qij_AA[8][0] = 0.358858;	Qij_AA[9][0] = 0.149830;	
		Qij_AA[10][0] = 0.395337;	Qij_AA[11][0] = 0.536518;	Qij_AA[12][0] = 1.124035;	Qij_AA[13][0] = 0.253701;	Qij_AA[14][0] = 1.177651;	Qij_AA[15][0] = 4.727182;	Qij_AA[16][0] = 2.139501;	Qij_AA[17][0] = 0.180717;	Qij_AA[18][0] = 0.218959;	Qij_AA[19][0] = 2.547870;
		Qij_AA[0][1] = 0.425093;	Qij_AA[1][1] = 0;			Qij_AA[2][1] = 0.751878;	Qij_AA[3][1] = 0.123954;	Qij_AA[4][1] = 0.534551;	Qij_AA[5][1] = 2.807908;	Qij_AA[6][1] = 0.363970;	Qij_AA[7][1] = 0.390192;	Qij_AA[8][1] = 2.426601;	Qij_AA[9][1] = 0.126991;	
		Qij_AA[10][1] = 0.301848;	Qij_AA[11][1] = 6.326067;	Qij_AA[12][1] = 0.484133;	Qij_AA[13][1] = 0.052722;	Qij_AA[14][1] = 0.332533;	Qij_AA[15][1] = 0.858151;	Qij_AA[16][1] = 0.578987;	Qij_AA[17][1] = 0.593607;	Qij_AA[18][1] = 0.314440;	Qij_AA[19][1] = 0.170887;
		Qij_AA[0][2] = 0.276818;	Qij_AA[1][2] = 0.751878;	Qij_AA[2][2] = 0;			Qij_AA[3][2] = 5.076149;	Qij_AA[4][2] = 0.528768;	Qij_AA[5][2] = 1.695752;	Qij_AA[6][2] = 0.541712;	Qij_AA[7][2] = 1.437645;	Qij_AA[8][2] = 4.509238;	Qij_AA[9][2] = 0.191503;	
		Qij_AA[10][2] = 0.068427;	Qij_AA[11][2] = 2.145078;	Qij_AA[12][2] = 0.371004;	Qij_AA[13][2] = 0.089525;	Qij_AA[14][2] = 0.161787;	Qij_AA[15][2] = 4.008358;	Qij_AA[16][2] = 2.000679;	Qij_AA[17][2] = 0.045376;	Qij_AA[18][2] = 0.612025;	Qij_AA[19][2] = 0.083688;
		Qij_AA[0][3] = 0.395144;	Qij_AA[1][3] = 0.123954;	Qij_AA[2][3] = 5.076149;	Qij_AA[3][3] = 0;			Qij_AA[4][3] = 0.062556;	Qij_AA[5][3] = 0.523386;	Qij_AA[6][3] = 5.243870;	Qij_AA[7][3] = 0.844926;	Qij_AA[8][3] = 0.927114;	Qij_AA[9][3] = 0.010690;	
		Qij_AA[10][3] = 0.015076;	Qij_AA[11][3] = 0.282959;	Qij_AA[12][3] = 0.025548;	Qij_AA[13][3] = 0.017416;	Qij_AA[14][3] = 0.394456;	Qij_AA[15][3] = 1.240275;	Qij_AA[16][3] = 0.425860;	Qij_AA[17][3] = 0.029890;	Qij_AA[18][3] = 0.135107;	Qij_AA[19][3] = 0.037967;
		Qij_AA[0][4] = 2.489084;	Qij_AA[1][4] = 0.534551;	Qij_AA[2][4] = 0.528768;	Qij_AA[3][4] = 0.062556;	Qij_AA[4][4] = 0;			Qij_AA[5][4] = 0.084808;	Qij_AA[6][4] = 0.003499;	Qij_AA[7][4] = 0.569265;	Qij_AA[8][4] = 0.640543;	Qij_AA[9][4] = 0.320627;	
		Qij_AA[10][4] = 0.594007;	Qij_AA[11][4] = 0.013266;	Qij_AA[12][4] = 0.893680;	Qij_AA[13][4] = 1.105251;	Qij_AA[14][4] = 0.075382;	Qij_AA[15][4] = 2.784478;	Qij_AA[16][4] = 1.143480;	Qij_AA[17][4] = 0.670128;	Qij_AA[18][4] = 1.165532;	Qij_AA[19][4] = 1.959291;
		Qij_AA[0][5] = 0.969894;	Qij_AA[1][5] = 2.807908;	Qij_AA[2][5] = 1.695752;	Qij_AA[3][5] = 0.523386;	Qij_AA[4][5] = 0.084808;	Qij_AA[5][5] = 0;			Qij_AA[6][5] = 4.128591;	Qij_AA[7][5] = 0.267959;	Qij_AA[8][5] = 4.813505;	Qij_AA[9][5] = 0.072854;	
		Qij_AA[10][5] = 0.582457;	Qij_AA[11][5] = 3.234294;	Qij_AA[12][5] = 1.672569;	Qij_AA[13][5] = 0.035855;	Qij_AA[14][5] = 0.624294;	Qij_AA[15][5] = 1.223828;	Qij_AA[16][5] = 1.080136;	Qij_AA[17][5] = 0.236199;	Qij_AA[18][5] = 0.257336;	Qij_AA[19][5] = 0.210332;
		Qij_AA[0][6] = 1.038545;	Qij_AA[1][6] = 0.363970;	Qij_AA[2][6] = 0.541712;	Qij_AA[3][6] = 5.243870;	Qij_AA[4][6] = 0.003499;	Qij_AA[5][6] = 4.128591;	Qij_AA[6][6] = 0;			Qij_AA[7][6] = 0.348847;	Qij_AA[8][6] = 0.423881;	Qij_AA[9][6] = 0.044265;	
		Qij_AA[10][6] = 0.069673;	Qij_AA[11][6] = 1.807177;	Qij_AA[12][6] = 0.173735;	Qij_AA[13][6] = 0.018811;	Qij_AA[14][6] = 0.419409;	Qij_AA[15][6] = 0.611973;	Qij_AA[16][6] = 0.604545;	Qij_AA[17][6] = 0.077852;	Qij_AA[18][6] = 0.120037;	Qij_AA[19][6] = 0.245034;
		Qij_AA[0][7] = 2.066040;	Qij_AA[1][7] = 0.390192;	Qij_AA[2][7] = 1.437645;	Qij_AA[3][7] = 0.844926;	Qij_AA[4][7] = 0.569265;	Qij_AA[5][7] = 0.267959;	Qij_AA[6][7] = 0.348847;	Qij_AA[7][7] = 0;			Qij_AA[8][7] = 0.311484;	Qij_AA[9][7] = 0.008705;	
		Qij_AA[10][7] = 0.044261;	Qij_AA[11][7] = 0.296636;	Qij_AA[12][7] = 0.139538;	Qij_AA[13][7] = 0.089586;	Qij_AA[14][7] = 0.196961;	Qij_AA[15][7] = 1.739990;	Qij_AA[16][7] = 0.129836;	Qij_AA[17][7] = 0.268491;	Qij_AA[18][7] = 0.054679;	Qij_AA[19][7] = 0.076701;
		Qij_AA[0][8] = 0.358858;	Qij_AA[1][8] = 2.426601;	Qij_AA[2][8] = 4.509238;	Qij_AA[3][8] = 0.927114;	Qij_AA[4][8] = 0.640543;	Qij_AA[5][8] = 4.813505;	Qij_AA[6][8] = 0.423881;	Qij_AA[7][8] = 0.311484;	Qij_AA[8][8] = 0;			Qij_AA[9][8] = 0.108882;	
		Qij_AA[10][8] = 0.366317;	Qij_AA[11][8] = 0.697264;	Qij_AA[12][8] = 0.442472;	Qij_AA[13][8] = 0.682139;	Qij_AA[14][8] = 0.508851;	Qij_AA[15][8] = 0.990012;	Qij_AA[16][8] = 0.584262;	Qij_AA[17][8] = 0.597054;	Qij_AA[18][8] = 5.306834;	Qij_AA[19][8] = 0.119013;
		Qij_AA[0][9] = 0.149830;	Qij_AA[1][9] = 0.126991;	Qij_AA[2][9] = 0.191503;	Qij_AA[3][9] = 0.010690;	Qij_AA[4][9] = 0.320627;	Qij_AA[5][9] = 0.072854;	Qij_AA[6][9] = 0.044265;	Qij_AA[7][9] = 0.008705;	Qij_AA[8][9] = 0.108882;	Qij_AA[9][9] = 0;			
		Qij_AA[10][9] = 4.145067;	Qij_AA[11][9] = 0.159069;	Qij_AA[12][9] = 4.273607;	Qij_AA[13][9] = 1.112727;	Qij_AA[14][9] = 0.078281;	Qij_AA[15][9] = 0.064105;	Qij_AA[16][9] = 1.033739;	Qij_AA[17][9] = 0.111660;	Qij_AA[18][9] = 0.232523;	Qij_AA[19][9] = 10.649107;
		Qij_AA[0][10] = 0.395337;	Qij_AA[1][10] = 0.301848;	Qij_AA[2][10] = 0.068427;	Qij_AA[3][10] = 0.015076;	Qij_AA[4][10] = 0.594007;	Qij_AA[5][10] = 0.582457;	Qij_AA[6][10] = 0.069673;	Qij_AA[7][10] = 0.044261;	Qij_AA[8][10] = 0.366317;	Qij_AA[9][10] = 4.145067;	
		Qij_AA[10][10] = 0;			Qij_AA[11][10] = 0.137500;	Qij_AA[12][10] = 6.312358;	Qij_AA[13][10] = 2.592692;	Qij_AA[14][10] = 0.249060;	Qij_AA[15][10] = 0.182287;	Qij_AA[16][10] = 0.302936;	Qij_AA[17][10] = 0.619632;	Qij_AA[18][10] = 0.299648;	Qij_AA[19][10] = 1.702745;
		Qij_AA[0][11] = 0.536518;	Qij_AA[1][11] = 6.326067;	Qij_AA[2][11] = 2.145078;	Qij_AA[3][11] = 0.282959;	Qij_AA[4][11] = 0.013266;	Qij_AA[5][11] = 3.234294;	Qij_AA[6][11] = 1.807177;	Qij_AA[7][11] = 0.296636;	Qij_AA[8][11] = 0.697264;	Qij_AA[9][11] = 0.159069;	
		Qij_AA[10][11] = 0.137500;	Qij_AA[11][11] = 0;			Qij_AA[12][11] = 0.656604;	Qij_AA[13][11] = 0.023918;	Qij_AA[14][11] = 0.390322;	Qij_AA[15][11] = 0.748683;	Qij_AA[16][11] = 1.136863;	Qij_AA[17][11] = 0.049906;	Qij_AA[18][11] = 0.131932;	Qij_AA[19][11] = 0.185202;
		Qij_AA[0][12] = 1.124035;	Qij_AA[1][12] = 0.484133;	Qij_AA[2][12] = 0.371004;	Qij_AA[3][12] = 0.025548;	Qij_AA[4][12] = 0.893680;	Qij_AA[5][12] = 1.672569;	Qij_AA[6][12] = 0.173735;	Qij_AA[7][12] = 0.139538;	Qij_AA[8][12] = 0.442472;	Qij_AA[9][12] = 4.273607;	
		Qij_AA[10][12] = 6.312358;	Qij_AA[11][12] = 0.656604;	Qij_AA[12][12] = 0;			Qij_AA[13][12] = 1.798853;	Qij_AA[14][12] = 0.099849;	Qij_AA[15][12] = 0.346960;	Qij_AA[16][12] = 2.020366;	Qij_AA[17][12] = 0.696175;	Qij_AA[18][12] = 0.481306;	Qij_AA[19][12] = 1.898718;
		Qij_AA[0][13] = 0.253701;	Qij_AA[1][13] = 0.052722;	Qij_AA[2][13] = 0.089525;	Qij_AA[3][13] = 0.017416;	Qij_AA[4][13] = 1.105251;	Qij_AA[5][13] = 0.035855;	Qij_AA[6][13] = 0.018811;	Qij_AA[7][13] = 0.089586;	Qij_AA[8][13] = 0.682139;	Qij_AA[9][13] = 1.112727;	
		Qij_AA[10][13] = 2.592692;	Qij_AA[11][13] = 0.023918;	Qij_AA[12][13] = 1.798853;	Qij_AA[13][13] = 0;			Qij_AA[14][13] = 0.094464;	Qij_AA[15][13] = 0.361819;	Qij_AA[16][13] = 0.165001;	Qij_AA[17][13] = 2.457121;	Qij_AA[18][13] = 7.803902;	Qij_AA[19][13] = 0.654683;
		Qij_AA[0][14] = 1.177651;	Qij_AA[1][14] = 0.332533;	Qij_AA[2][14] = 0.161787;	Qij_AA[3][14] = 0.394456;	Qij_AA[4][14] = 0.075382;	Qij_AA[5][14] = 0.624294;	Qij_AA[6][14] = 0.419409;	Qij_AA[7][14] = 0.196961;	Qij_AA[8][14] = 0.508851;	Qij_AA[9][14] = 0.078281;	
		Qij_AA[10][14] = 0.249060;	Qij_AA[11][14] = 0.390322;	Qij_AA[12][14] = 0.099849;	Qij_AA[13][14] = 0.094464;	Qij_AA[14][14] = 0;			Qij_AA[15][14] = 1.338132;	Qij_AA[16][14] = 0.571468;	Qij_AA[17][14] = 0.095131;	Qij_AA[18][14] = 0.089613;	Qij_AA[19][14] = 0.296501;
		Qij_AA[0][15] = 4.727182;	Qij_AA[1][15] = 0.858151;	Qij_AA[2][15] = 4.008358;	Qij_AA[3][15] = 1.240275;	Qij_AA[4][15] = 2.784478;	Qij_AA[5][15] = 1.223828;	Qij_AA[6][15] = 0.611973;	Qij_AA[7][15] = 1.739990;	Qij_AA[8][15] = 0.990012;	Qij_AA[9][15] = 0.064105;	
		Qij_AA[10][15] = 0.182287;	Qij_AA[11][15] = 0.748683;	Qij_AA[12][15] = 0.346960;	Qij_AA[13][15] = 0.361819;	Qij_AA[14][15] = 1.338132;	Qij_AA[15][15] = 0;			Qij_AA[16][15] = 6.472279;	Qij_AA[17][15] = 0.248862;	Qij_AA[18][15] = 0.400547;	Qij_AA[19][15] = 0.098369;																	
		Qij_AA[0][16] = 2.139501;	Qij_AA[1][16] = 0.578987;	Qij_AA[2][16] = 2.000679;	Qij_AA[3][16] = 0.425860;	Qij_AA[4][16] = 1.143480;	Qij_AA[5][16] = 1.080136;	Qij_AA[6][16] = 0.604545;	Qij_AA[7][16] = 0.129836;	Qij_AA[8][16] = 0.584262;	Qij_AA[9][16] = 1.033739;	
		Qij_AA[10][16] = 0.302936;	Qij_AA[11][16] = 1.136863;	Qij_AA[12][16] = 2.020366;	Qij_AA[13][16] = 0.165001;	Qij_AA[14][16] = 0.571468;	Qij_AA[15][16] = 6.472279;	Qij_AA[16][16] = 0;			Qij_AA[17][16] = 0.140825;	Qij_AA[18][16] = 0.245841;	Qij_AA[19][16] = 2.188158;
		Qij_AA[0][17] = 0.180717;	Qij_AA[1][17] = 0.593607;	Qij_AA[2][17] = 0.045376;	Qij_AA[3][17] = 0.029890;	Qij_AA[4][17] = 0.670128;	Qij_AA[5][17] = 0.236199;	Qij_AA[6][17] = 0.077852;	Qij_AA[7][17] = 0.268491;	Qij_AA[8][17] = 0.597054;	Qij_AA[9][17] = 0.111660;	
		Qij_AA[10][17] = 0.619632;	Qij_AA[11][17] = 0.049906;	Qij_AA[12][17] = 0.696175;	Qij_AA[13][17] = 2.457121;	Qij_AA[14][17] = 0.095131;	Qij_AA[15][17] = 0.248862;	Qij_AA[16][17] = 0.140825;	Qij_AA[17][17] = 0;			Qij_AA[18][17] = 3.151815;	Qij_AA[19][17] = 0.189510;
		Qij_AA[0][18] = 0.218959;	Qij_AA[1][18] = 0.314440;	Qij_AA[2][18] = 0.612025;	Qij_AA[3][18] = 0.135107;	Qij_AA[4][18] = 1.165532;	Qij_AA[5][18] = 0.257336;	Qij_AA[6][18] = 0.120037;	Qij_AA[7][18] = 0.054679;	Qij_AA[8][18] = 5.306834;	Qij_AA[9][18] = 0.232523;	
		Qij_AA[10][18] = 0.299648;	Qij_AA[11][18] = 0.131932;	Qij_AA[12][18] = 0.481306;	Qij_AA[13][18] = 7.803902;	Qij_AA[14][18] = 0.089613;	Qij_AA[15][18] = 0.400547;	Qij_AA[16][18] = 0.245841;	Qij_AA[17][18] = 3.151815;	Qij_AA[18][18] = 0;			Qij_AA[19][18] = 0.249313;
		Qij_AA[0][19] = 2.547870;	Qij_AA[1][19] = 0.170887;	Qij_AA[2][19] = 0.083688;	Qij_AA[3][19] = 0.037967;	Qij_AA[4][19] = 1.959291;	Qij_AA[5][19] = 0.210332;	Qij_AA[6][19] = 0.245034;	Qij_AA[7][19] = 0.076701;	Qij_AA[8][19] = 0.119013;	Qij_AA[9][19] = 10.649107;	
		Qij_AA[10][19] = 1.702745;	Qij_AA[11][19] = 0.185202;	Qij_AA[12][19] = 1.898718;	Qij_AA[13][19] = 0.654683;	Qij_AA[14][19] = 0.296501;	Qij_AA[15][19] = 0.098369;	Qij_AA[16][19] = 2.188158;	Qij_AA[17][19] = 0.189510;	Qij_AA[18][19] = 0.249313;	Qij_AA[19][19] = 0;


		AA_EM_Pi[0] = 0.079066;
		AA_EM_Pi[1] = 0.055941;
		AA_EM_Pi[2] = 0.041977;
		AA_EM_Pi[3] = 0.053052;
		AA_EM_Pi[4] = 0.012937;
		AA_EM_Pi[5] = 0.040767;
		AA_EM_Pi[6] = 0.071586;
		AA_EM_Pi[7] = 0.057337;
		AA_EM_Pi[8] = 0.022355; 
		AA_EM_Pi[9] = 0.062157; 
		AA_EM_Pi[10] = 0.099081; 
		AA_EM_Pi[11] = 0.064600; 
		AA_EM_Pi[12] = 0.022951; 
		AA_EM_Pi[13] = 0.042302; 
		AA_EM_Pi[14] = 0.044040; 
		AA_EM_Pi[15] = 0.061197; 
		AA_EM_Pi[16] = 0.053287; 
		AA_EM_Pi[17] = 0.012066; 
		AA_EM_Pi[18] = 0.034155; 
		AA_EM_Pi[19] = 0.069147;		
		}
	else if (doMtart == YES)
		{
		Qij_AA[0][0] = 0;			Qij_AA[0][1] = 0.2;		Qij_AA[0][2] = 0.2;		Qij_AA[0][3] = 0.6;	
		Qij_AA[0][4] = 253.5;		Qij_AA[0][5] = 0.2;		Qij_AA[0][6] = 0.2;		Qij_AA[0][7] = 199.8;	
		Qij_AA[0][8] = 0.2;		Qij_AA[0][9] = 25.7;		Qij_AA[0][10] = 3.7;		Qij_AA[0][11] = 0.2;	
		Qij_AA[0][12] = 120.6;	Qij_AA[0][13] = 13.1;		Qij_AA[0][14] = 49.3;		Qij_AA[0][15] = 673;	
		Qij_AA[0][16] = 243.9;	Qij_AA[0][17] = 0.2;		Qij_AA[0][18] = 1.2;		Qij_AA[0][19] = 339.9;	
		Qij_AA[1][0] = 0.2;		Qij_AA[1][1] = 0;			Qij_AA[1][2] = 0.2;		Qij_AA[1][3] = 4.3;	
		Qij_AA[1][4] = 35.5;		Qij_AA[1][5] = 154;		Qij_AA[1][6] = 0.2;		Qij_AA[1][7] = 0.2;	
		Qij_AA[1][8] = 41.3;		Qij_AA[1][9] = 1.8;		Qij_AA[1][10] = 1.8;		Qij_AA[1][11] = 208.6;	
		Qij_AA[1][12] = 5.2;		Qij_AA[1][13] = 4.7;		Qij_AA[1][14] = 0.2;		Qij_AA[1][15] = 2.7;	
		Qij_AA[1][16] = 0.2;		Qij_AA[1][17] = 0.2;		Qij_AA[1][18] = 3.9;		Qij_AA[1][19] = 0.2;	
		Qij_AA[2][0] = 0.2;		Qij_AA[2][1] = 0.2;		Qij_AA[2][2] = 0;			Qij_AA[2][3] = 500.2;	
		Qij_AA[2][4] = 98.2;		Qij_AA[2][5] = 261.8;		Qij_AA[2][6] = 183;		Qij_AA[2][7] = 120.5;	
		Qij_AA[2][8] = 179.5;		Qij_AA[2][9] = 21.3;		Qij_AA[2][10] = 12.6;		Qij_AA[2][11] = 467.3;	
		Qij_AA[2][12] = 78.8;		Qij_AA[2][13] = 19.7;		Qij_AA[2][14] = 16.5;		Qij_AA[2][15] = 398.4;	
		Qij_AA[2][16] = 165.9;	Qij_AA[2][17] = 7.7;		Qij_AA[2][18] = 251.2;	Qij_AA[2][19] = 22.6;	
		Qij_AA[3][0] = 0.6;		Qij_AA[3][1] = 4.3;		Qij_AA[3][2] = 500.2;		Qij_AA[3][3] = 0;	
		Qij_AA[3][4] = 10.6;		Qij_AA[3][5] = 0.2;		Qij_AA[3][6] = 861.8;		Qij_AA[3][7] = 12.5;	
		Qij_AA[3][8] = 0.2;		Qij_AA[3][9] = 6.6;		Qij_AA[3][10] = 1.2;		Qij_AA[3][11] = 1.7;	
		Qij_AA[3][12] = 0.2;		Qij_AA[3][13] = 0.2;		Qij_AA[3][14] = 0.2;		Qij_AA[3][15] = 44.4;	
		Qij_AA[3][16] = 0.2;		Qij_AA[3][17] = 0.2;		Qij_AA[3][18] = 0.2;		Qij_AA[3][19] = 0.2;	
		Qij_AA[4][0] = 253.5;		Qij_AA[4][1] = 35.5;		Qij_AA[4][2] = 98.2;		Qij_AA[4][3] = 10.6;	
		Qij_AA[4][4] = 0;			Qij_AA[4][5] = 0.2;		Qij_AA[4][6] = 0.2;		Qij_AA[4][7] = 80.5;	
		Qij_AA[4][8] = 12.4;		Qij_AA[4][9] = 63;		Qij_AA[4][10] = 78.7;		Qij_AA[4][11] = 0.2;	
		Qij_AA[4][12] = 312.3;	Qij_AA[4][13] = 184.1;	Qij_AA[4][14] = 0.2;		Qij_AA[4][15] = 664.2;	
		Qij_AA[4][16] = 182.8;	Qij_AA[4][17] = 21.6;		Qij_AA[4][18] = 72;		Qij_AA[4][19] = 350.4;	
		Qij_AA[5][0] = 0.2;		Qij_AA[5][1] = 154;		Qij_AA[5][2] = 261.8;		Qij_AA[5][3] = 0.2;	
		Qij_AA[5][4] = 0.2;		Qij_AA[5][5] = 0;			Qij_AA[5][6] = 261.6;		Qij_AA[5][7] = 2.6;	
		Qij_AA[5][8] = 313.5;		Qij_AA[5][9] = 10.5;		Qij_AA[5][10] = 16.3;		Qij_AA[5][11] = 349.3;	
		Qij_AA[5][12] = 67.3;		Qij_AA[5][13] = 0.2;		Qij_AA[5][14] = 39.3;		Qij_AA[5][15] = 52.4;	
		Qij_AA[5][16] = 43.7;		Qij_AA[5][17] = 6.7;		Qij_AA[5][18] = 86.7;		Qij_AA[5][19] = 0.2;	
		Qij_AA[6][0] = 0.2;		Qij_AA[6][1] = 0.2;		Qij_AA[6][2] = 183;		Qij_AA[6][3] = 861.8;	
		Qij_AA[6][4] = 0.2;		Qij_AA[6][5] = 261.6;		Qij_AA[6][6] = 0;			Qij_AA[6][7] = 43.9;	
		Qij_AA[6][8] = 15.2;		Qij_AA[6][9] = 6.8;		Qij_AA[6][10] = 1.7;		Qij_AA[6][11] = 106.3;	
		Qij_AA[6][12] = 0.2;		Qij_AA[6][13] = 0.2;		Qij_AA[6][14] = 7.9;		Qij_AA[6][15] = 31.5;	
		Qij_AA[6][16] = 43.4;		Qij_AA[6][17] = 11;		Qij_AA[6][18] = 7.7;		Qij_AA[6][19] = 13.6;	
		Qij_AA[7][0] = 199.8;		Qij_AA[7][1] = 0.2;		Qij_AA[7][2] = 120.5;		Qij_AA[7][3] = 12.5;	
		Qij_AA[7][4] = 80.5;		Qij_AA[7][5] = 2.6;		Qij_AA[7][6] = 43.9;		Qij_AA[7][7] = 0;	
		Qij_AA[7][8] = 0.2;		Qij_AA[7][9] = 2.7;		Qij_AA[7][10] = 1.4;		Qij_AA[7][11] = 0.2;	
		Qij_AA[7][12] = 55.7;		Qij_AA[7][13] = 0.8;		Qij_AA[7][14] = 0.2;		Qij_AA[7][15] = 226;	
		Qij_AA[7][16] = 0.2;		Qij_AA[7][17] = 1.9;		Qij_AA[7][18] = 8.6;		Qij_AA[7][19] = 2.6;	
		Qij_AA[8][0] = 0.2;		Qij_AA[8][1] = 41.3;		Qij_AA[8][2] = 179.5;		Qij_AA[8][3] = 0.2;	
		Qij_AA[8][4] = 12.4;		Qij_AA[8][5] = 313.5;		Qij_AA[8][6] = 15.2;		Qij_AA[8][7] = 0.2;	
		Qij_AA[8][8] = 0;			Qij_AA[8][9] = 0.2;		Qij_AA[8][10] = 5.5;		Qij_AA[8][11] = 0.2;	
		Qij_AA[8][12] = 0.2;		Qij_AA[8][13] = 13.8;		Qij_AA[8][14] = 0.8;		Qij_AA[8][15] = 10.6;	
		Qij_AA[8][16] = 18.6;		Qij_AA[8][17] = 0.2;		Qij_AA[8][18] = 191.4;	Qij_AA[8][19] = 0.2;	
		Qij_AA[9][0] = 25.7;		Qij_AA[9][1] = 1.8;		Qij_AA[9][2] = 21.3;		Qij_AA[9][3] = 6.6;	
		Qij_AA[9][4] = 63;		Qij_AA[9][5] = 10.5;		Qij_AA[9][6] = 6.8;		Qij_AA[9][7] = 2.7;	
		Qij_AA[9][8] = 0.2;		Qij_AA[9][9] = 0;			Qij_AA[9][10] = 514.5;	Qij_AA[9][11] = 3.5;	
		Qij_AA[9][12] = 514.8;	Qij_AA[9][13] = 117.9;	Qij_AA[9][14] = 0.2;		Qij_AA[9][15] = 7.2;	
		Qij_AA[9][16] = 203.7;	Qij_AA[9][17] = 0.2;		Qij_AA[9][18] = 12.3;		Qij_AA[9][19] = 1854.5;	
		Qij_AA[10][0] = 3.7;		Qij_AA[10][1] = 1.8;		Qij_AA[10][2] = 12.6;		Qij_AA[10][3] = 1.2;	
		Qij_AA[10][4] = 78.7;		Qij_AA[10][5] = 16.3;		Qij_AA[10][6] = 1.7;		Qij_AA[10][7] = 1.4;	
		Qij_AA[10][8] = 5.5;		Qij_AA[10][9] = 514.5;	Qij_AA[10][10] = 0;		Qij_AA[10][11] = 3.8;	
		Qij_AA[10][12] = 885.5;	Qij_AA[10][13] = 262.6;	Qij_AA[10][14] = 12.2;	Qij_AA[10][15] = 8.2;	
		Qij_AA[10][16] = 47.8;	Qij_AA[10][17] = 21.1;	Qij_AA[10][18] = 19.8;	Qij_AA[10][19] = 84.7;	
		Qij_AA[11][0] = 0.2;		Qij_AA[11][1] = 208.6;	Qij_AA[11][2] = 467.3;	Qij_AA[11][3] = 1.7;	
		Qij_AA[11][4] = 0.2;		Qij_AA[11][5] = 349.3;	Qij_AA[11][6] = 106.3;	Qij_AA[11][7] = 0.2;	
		Qij_AA[11][8] = 0.2;		Qij_AA[11][9] = 3.5;		Qij_AA[11][10] = 3.8;		Qij_AA[11][11] = 0;	
		Qij_AA[11][12] = 105.6;	Qij_AA[11][13] = 10.7;	Qij_AA[11][14] = 16.8;	Qij_AA[11][15] = 144.2;	
		Qij_AA[11][16] = 69.5;	Qij_AA[11][17] = 16;		Qij_AA[11][18] = 117.1;	Qij_AA[11][19] = 26.1;	
		Qij_AA[12][0] = 120.6;	Qij_AA[12][1] = 5.2;		Qij_AA[12][2] = 78.8;		Qij_AA[12][3] = 0.2;	
		Qij_AA[12][4] = 312.3;	Qij_AA[12][5] = 67.3;		Qij_AA[12][6] = 0.2;		Qij_AA[12][7] = 55.7;	
		Qij_AA[12][8] = 0.2;		Qij_AA[12][9] = 514.8;	Qij_AA[12][10] = 885.5;	Qij_AA[12][11] = 105.6;	
		Qij_AA[12][12] = 0;		Qij_AA[12][13] = 321.6;	Qij_AA[12][14] = 5.3;		Qij_AA[12][15] = 111.7;	
		Qij_AA[12][16] = 288.6;	Qij_AA[12][17] = 70.7;	Qij_AA[12][18] = 70.9;	Qij_AA[12][19] = 281.3;	
		Qij_AA[13][0] = 13.1;		Qij_AA[13][1] = 4.7;		Qij_AA[13][2] = 19.7;		Qij_AA[13][3] = 0.2;	
		Qij_AA[13][4] = 184.1;	Qij_AA[13][5] = 0.2;		Qij_AA[13][6] = 0.2;		Qij_AA[13][7] = 0.8;	
		Qij_AA[13][8] = 13.8;		Qij_AA[13][9] = 117.9;	Qij_AA[13][10] = 262.6;	Qij_AA[13][11] = 10.7;	
		Qij_AA[13][12] = 321.6;	Qij_AA[13][13] = 0;		Qij_AA[13][14] = 14.6;	Qij_AA[13][15] = 36.1;	
		Qij_AA[13][16] = 13.5;	Qij_AA[13][17] = 53.7;	Qij_AA[13][18] = 791.6;	Qij_AA[13][19] = 51.9;	
		Qij_AA[14][0] = 49.3;		Qij_AA[14][1] = 0.2;		Qij_AA[14][2] = 16.5;		Qij_AA[14][3] = 0.2;	
		Qij_AA[14][4] = 0.2;		Qij_AA[14][5] = 39.3;		Qij_AA[14][6] = 7.9;		Qij_AA[14][7] = 0.2;	
		Qij_AA[14][8] = 0.8;		Qij_AA[14][9] = 0.2;		Qij_AA[14][10] = 12.2;	Qij_AA[14][11] = 16.8;	
		Qij_AA[14][12] = 5.3;		Qij_AA[14][13] = 14.6;	Qij_AA[14][14] = 0;		Qij_AA[14][15] = 86.5;	
		Qij_AA[14][16] = 46.8;	Qij_AA[14][17] = 0.2;		Qij_AA[14][18] = 18.4;	Qij_AA[14][19] = 31.7;	
		Qij_AA[15][0] = 673;		Qij_AA[15][1] = 2.7;		Qij_AA[15][2] = 398.4;	Qij_AA[15][3] = 44.4;	
		Qij_AA[15][4] = 664.2;	Qij_AA[15][5] = 52.4;		Qij_AA[15][6] = 31.5;		Qij_AA[15][7] = 226;	
		Qij_AA[15][8] = 10.6;		Qij_AA[15][9] = 7.2;		Qij_AA[15][10] = 8.2;		Qij_AA[15][11] = 144.2;	
		Qij_AA[15][12] = 111.7;	Qij_AA[15][13] = 36.1;	Qij_AA[15][14] = 86.5;	Qij_AA[15][15] = 0;	
		Qij_AA[15][16] = 660.4;	Qij_AA[15][17] = 2.4;		Qij_AA[15][18] = 30.5;	Qij_AA[15][19] = 60.6;	
		Qij_AA[16][0] = 243.9;	Qij_AA[16][1] = 0.2;		Qij_AA[16][2] = 165.9;	Qij_AA[16][3] = 0.2;	
		Qij_AA[16][4] = 182.8;	Qij_AA[16][5] = 43.7;		Qij_AA[16][6] = 43.4;		Qij_AA[16][7] = 0.2;	
		Qij_AA[16][8] = 18.6;		Qij_AA[16][9] = 203.7;	Qij_AA[16][10] = 47.8;	Qij_AA[16][11] = 69.5;	
		Qij_AA[16][12] = 288.6;	Qij_AA[16][13] = 13.5;	Qij_AA[16][14] = 46.8;	Qij_AA[16][15] = 660.4;	
		Qij_AA[16][16] = 0;		Qij_AA[16][17] = 0.2;		Qij_AA[16][18] = 46;		Qij_AA[16][19] = 544.1;	
		Qij_AA[17][0] = 0.2;		Qij_AA[17][1] = 0.2;		Qij_AA[17][2] = 7.7;		Qij_AA[17][3] = 0.2;	
		Qij_AA[17][4] = 21.6;		Qij_AA[17][5] = 6.7;		Qij_AA[17][6] = 11;		Qij_AA[17][7] = 1.9;	
		Qij_AA[17][8] = 0.2;		Qij_AA[17][9] = 0.2;		Qij_AA[17][10] = 21.1;	Qij_AA[17][11] = 16;	
		Qij_AA[17][12] = 70.7;	Qij_AA[17][13] = 53.7;	Qij_AA[17][14] = 0.2;		Qij_AA[17][15] = 2.4;	
		Qij_AA[17][16] = 0.2;		Qij_AA[17][17] = 0;		Qij_AA[17][18] = 37.7;	Qij_AA[17][19] = 0.2;	
		Qij_AA[18][0] = 1.2;		Qij_AA[18][1] = 3.9;		Qij_AA[18][2] = 251.2;	Qij_AA[18][3] = 0.2;	
		Qij_AA[18][4] = 72;		Qij_AA[18][5] = 86.7;		Qij_AA[18][6] = 7.7;		Qij_AA[18][7] = 8.6;	
		Qij_AA[18][8] = 191.4;	Qij_AA[18][9] = 12.3;		Qij_AA[18][10] = 19.8;	Qij_AA[18][11] = 117.1;	
		Qij_AA[18][12] = 70.9;	Qij_AA[18][13] = 791.6;	Qij_AA[18][14] = 18.4;	Qij_AA[18][15] = 30.5;	
		Qij_AA[18][16] = 46;		Qij_AA[18][17] = 37.7;	Qij_AA[18][18] = 0;		Qij_AA[18][19] = 1.6;	
		Qij_AA[19][0] = 339.9;	Qij_AA[19][1] = 0.2;		Qij_AA[19][2] = 22.6;		Qij_AA[19][3] = 0.2;	
		Qij_AA[19][4] = 350.4;	Qij_AA[19][5] = 0.2;		Qij_AA[19][6] = 13.6;		Qij_AA[19][7] = 2.6;	
		Qij_AA[19][8] = 0.2;		Qij_AA[19][9] = 1854.5;	Qij_AA[19][10] = 84.7;	Qij_AA[19][11] = 26.1;	
		Qij_AA[19][12] = 281.3;	Qij_AA[19][13] = 51.9;	Qij_AA[19][14] = 31.7;	Qij_AA[19][15] = 60.6;	
		Qij_AA[19][16] = 544.1;	Qij_AA[19][17] = 0.2;		Qij_AA[19][18] = 1.6;		Qij_AA[19][19] = 0;	

		AA_EM_Pi[0] = 0.054116;
		AA_EM_Pi[1] = 0.018227;
		AA_EM_Pi[2] = 0.039903;
		AA_EM_Pi[3] = 0.02016;
		AA_EM_Pi[4] = 0.009709;
		AA_EM_Pi[5] = 0.018781;
		AA_EM_Pi[6] = 0.024289;
		AA_EM_Pi[7] = 0.068183;
		AA_EM_Pi[8] = 0.024518;
		AA_EM_Pi[9] = 0.092639;
		AA_EM_Pi[10] = 0.148658;
		AA_EM_Pi[11] = 0.021718;
		AA_EM_Pi[12] = 0.061453;
		AA_EM_Pi[13] = 0.088668;
		AA_EM_Pi[14] = 0.041826;
		AA_EM_Pi[15] = 0.09103;
		AA_EM_Pi[16] = 0.049194;
		AA_EM_Pi[17] = 0.029786;
		AA_EM_Pi[18] = 0.039443;
		AA_EM_Pi[19] = 0.057701;
		}
	else if (doMtmam == YES)
		{
		Qij_AA[0][0] =   0; Qij_AA[0][1] =  32; Qij_AA[0][2] =   2; Qij_AA[0][3] =  11; Qij_AA[0][4] =   0;
		Qij_AA[0][5] =   0; Qij_AA[0][6] =   0; Qij_AA[0][7] =  78; Qij_AA[0][8] =   8; Qij_AA[0][9] =  75;
		Qij_AA[0][10] =  21; Qij_AA[0][11] =   0; Qij_AA[0][12] =  76; Qij_AA[0][13] =   0; Qij_AA[0][14] =  53;
		Qij_AA[0][15] = 342; Qij_AA[0][16] = 681; Qij_AA[0][17] =   5; Qij_AA[0][18] =   0; Qij_AA[0][19] = 398;
		Qij_AA[1][0] =  32; Qij_AA[1][1] =   0; Qij_AA[1][2] =   4; Qij_AA[1][3] =   0; Qij_AA[1][4] = 186;
		Qij_AA[1][5] = 246; Qij_AA[1][6] =   0; Qij_AA[1][7] =  18; Qij_AA[1][8] = 232; Qij_AA[1][9] =   0;
		Qij_AA[1][10] =   6; Qij_AA[1][11] =  50; Qij_AA[1][12] =   0; Qij_AA[1][13] =   0; Qij_AA[1][14] =   9;
		Qij_AA[1][15] =   3; Qij_AA[1][16] =   0; Qij_AA[1][17] =  16; Qij_AA[1][18] =   0; Qij_AA[1][19] =   0;
		Qij_AA[2][0] =   2; Qij_AA[2][1] =   4; Qij_AA[2][2] =   0; Qij_AA[2][3] = 864; Qij_AA[2][4] =   0;
		Qij_AA[2][5] =   8; Qij_AA[2][6] =   0; Qij_AA[2][7] =  47; Qij_AA[2][8] = 458; Qij_AA[2][9] =  19;
		Qij_AA[2][10] =   0; Qij_AA[2][11] = 408; Qij_AA[2][12] =  21; Qij_AA[2][13] =   6; Qij_AA[2][14] =  33;
		Qij_AA[2][15] = 446; Qij_AA[2][16] = 110; Qij_AA[2][17] =   6; Qij_AA[2][18] = 156; Qij_AA[2][19] =   0;
		Qij_AA[3][0] =  11; Qij_AA[3][1] =   0; Qij_AA[3][2] = 864; Qij_AA[3][3] =   0; Qij_AA[3][4] =   0;
		Qij_AA[3][5] =  49; Qij_AA[3][6] = 569; Qij_AA[3][7] =  79; Qij_AA[3][8] =  11; Qij_AA[3][9] =   0;
		Qij_AA[3][10] =   0; Qij_AA[3][11] =   0; Qij_AA[3][12] =   0; Qij_AA[3][13] =   5; Qij_AA[3][14] =   2;
		Qij_AA[3][15] =  16; Qij_AA[3][16] =   0; Qij_AA[3][17] =   0; Qij_AA[3][18] =   0; Qij_AA[3][19] =  10;
		Qij_AA[4][0] =   0; Qij_AA[4][1] = 186; Qij_AA[4][2] =   0; Qij_AA[4][3] =   0; Qij_AA[4][4] =   0;
		Qij_AA[4][5] =   0; Qij_AA[4][6] =   0; Qij_AA[4][7] =   0; Qij_AA[4][8] = 305; Qij_AA[4][9] =  41;
		Qij_AA[4][10] =  27; Qij_AA[4][11] =   0; Qij_AA[4][12] =   0; Qij_AA[4][13] =   7; Qij_AA[4][14] =   0;
		Qij_AA[4][15] = 347; Qij_AA[4][16] = 114; Qij_AA[4][17] =  65; Qij_AA[4][18] = 530; Qij_AA[4][19] =   0;
		Qij_AA[5][0] =   0; Qij_AA[5][1] = 246; Qij_AA[5][2] =   8; Qij_AA[5][3] =  49; Qij_AA[5][4] =   0;
		Qij_AA[5][5] =   0; Qij_AA[5][6] = 274; Qij_AA[5][7] =   0; Qij_AA[5][8] = 550; Qij_AA[5][9] =   0;
		Qij_AA[5][10] =  20; Qij_AA[5][11] = 242; Qij_AA[5][12] =  22; Qij_AA[5][13] =   0; Qij_AA[5][14] =  51;
		Qij_AA[5][15] =  30; Qij_AA[5][16] =   0; Qij_AA[5][17] =   0; Qij_AA[5][18] =  54; Qij_AA[5][19] =  33;
		Qij_AA[6][0] =   0; Qij_AA[6][1] =   0; Qij_AA[6][2] =   0; Qij_AA[6][3] = 569; Qij_AA[6][4] =   0;
		Qij_AA[6][5] = 274; Qij_AA[6][6] =   0; Qij_AA[6][7] =  22; Qij_AA[6][8] =  22; Qij_AA[6][9] =   0;
		Qij_AA[6][10] =   0; Qij_AA[6][11] = 215; Qij_AA[6][12] =   0; Qij_AA[6][13] =   0; Qij_AA[6][14] =   0;
		Qij_AA[6][15] =  21; Qij_AA[6][16] =   4; Qij_AA[6][17] =   0; Qij_AA[6][18] =   0; Qij_AA[6][19] =  20;
		Qij_AA[7][0] =  78; Qij_AA[7][1] =  18; Qij_AA[7][2] =  47; Qij_AA[7][3] =  79; Qij_AA[7][4] =   0;
		Qij_AA[7][5] =   0; Qij_AA[7][6] =  22; Qij_AA[7][7] =   0; Qij_AA[7][8] =   0; Qij_AA[7][9] =   0;
		Qij_AA[7][10] =   0; Qij_AA[7][11] =   0; Qij_AA[7][12] =   0; Qij_AA[7][13] =   0; Qij_AA[7][14] =   0;
		Qij_AA[7][15] = 112; Qij_AA[7][16] =   0; Qij_AA[7][17] =   0; Qij_AA[7][18] =   1; Qij_AA[7][19] =   5;
		Qij_AA[8][0] =   8; Qij_AA[8][1] = 232; Qij_AA[8][2] = 458; Qij_AA[8][3] =  11; Qij_AA[8][4] = 305;
		Qij_AA[8][5] = 550; Qij_AA[8][6] =  22; Qij_AA[8][7] =   0; Qij_AA[8][8] =   0; Qij_AA[8][9] =   0;
		Qij_AA[8][10] =  26; Qij_AA[8][11] =   0; Qij_AA[8][12] =   0; Qij_AA[8][13] =   0; Qij_AA[8][14] =  53;
		Qij_AA[8][15] =  20; Qij_AA[8][16] =   1; Qij_AA[8][17] =   0; Qij_AA[8][18] =1525; Qij_AA[8][19] =   0;
		Qij_AA[9][0] =  75; Qij_AA[9][1] =   0; Qij_AA[9][2] =  19; Qij_AA[9][3] =   0; Qij_AA[9][4] =  41;
		Qij_AA[9][5] =   0; Qij_AA[9][6] =   0; Qij_AA[9][7] =   0; Qij_AA[9][8] =   0; Qij_AA[9][9] =   0;
		Qij_AA[9][10] = 232; Qij_AA[9][11] =   6; Qij_AA[9][12] = 378; Qij_AA[9][13] =  57; Qij_AA[9][14] =   5;
		Qij_AA[9][15] =   0; Qij_AA[9][16] = 360; Qij_AA[9][17] =   0; Qij_AA[9][18] =  16; Qij_AA[9][19] =2220;
		Qij_AA[10][0] =  21; Qij_AA[10][1] =   6; Qij_AA[10][2] =   0; Qij_AA[10][3] =   0; Qij_AA[10][4] =  27;
		Qij_AA[10][5] =  20; Qij_AA[10][6] =   0; Qij_AA[10][7] =   0; Qij_AA[10][8] =  26; Qij_AA[10][9] = 232;
		Qij_AA[10][10] =   0; Qij_AA[10][11] =   4; Qij_AA[10][12] = 609; Qij_AA[10][13] = 246; Qij_AA[10][14] =  43;
		Qij_AA[10][15] =  74; Qij_AA[10][16] =  34; Qij_AA[10][17] =  12; Qij_AA[10][18] =  25; Qij_AA[10][19] = 100;
		Qij_AA[11][0] =   0; Qij_AA[11][1] =  50; Qij_AA[11][2] = 408; Qij_AA[11][3] =   0; Qij_AA[11][4] =   0;
		Qij_AA[11][5] = 242; Qij_AA[11][6] = 215; Qij_AA[11][7] =   0; Qij_AA[11][8] =   0; Qij_AA[11][9] =   6;
		Qij_AA[11][10] =   4; Qij_AA[11][11] =   0; Qij_AA[11][12] =  59; Qij_AA[11][13] =   0; Qij_AA[11][14] =  18;
		Qij_AA[11][15] =  65; Qij_AA[11][16] =  50; Qij_AA[11][17] =   0; Qij_AA[11][18] =  67; Qij_AA[11][19] =   0;
		Qij_AA[12][0] =  76; Qij_AA[12][1] =   0; Qij_AA[12][2] =  21; Qij_AA[12][3] =   0; Qij_AA[12][4] =   0;
		Qij_AA[12][5] =  22; Qij_AA[12][6] =   0; Qij_AA[12][7] =   0; Qij_AA[12][8] =   0; Qij_AA[12][9] = 378;
		Qij_AA[12][10] = 609; Qij_AA[12][11] =  59; Qij_AA[12][12] =   0; Qij_AA[12][13] =  11; Qij_AA[12][14] =   0;
		Qij_AA[12][15] =  47; Qij_AA[12][16] = 691; Qij_AA[12][17] =  13; Qij_AA[12][18] =   0; Qij_AA[12][19] = 832;
		Qij_AA[13][0] =   0; Qij_AA[13][1] =   0; Qij_AA[13][2] =   6; Qij_AA[13][3] =   5; Qij_AA[13][4] =   7;
		Qij_AA[13][5] =   0; Qij_AA[13][6] =   0; Qij_AA[13][7] =   0; Qij_AA[13][8] =   0; Qij_AA[13][9] =  57;
		Qij_AA[13][10] = 246; Qij_AA[13][11] =   0; Qij_AA[13][12] =  11; Qij_AA[13][13] =   0; Qij_AA[13][14] =  17;
		Qij_AA[13][15] =  90; Qij_AA[13][16] =   8; Qij_AA[13][17] =   0; Qij_AA[13][18] = 682; Qij_AA[13][19] =   6;
		Qij_AA[14][0] =  53; Qij_AA[14][1] =   9; Qij_AA[14][2] =  33; Qij_AA[14][3] =   2; Qij_AA[14][4] =   0;
		Qij_AA[14][5] =  51; Qij_AA[14][6] =   0; Qij_AA[14][7] =   0; Qij_AA[14][8] =  53; Qij_AA[14][9] =   5;
		Qij_AA[14][10] =  43; Qij_AA[14][11] =  18; Qij_AA[14][12] =   0; Qij_AA[14][13] =  17; Qij_AA[14][14] =   0;
		Qij_AA[14][15] = 202; Qij_AA[14][16] =  78; Qij_AA[14][17] =   7; Qij_AA[14][18] =   8; Qij_AA[14][19] =   0;
		Qij_AA[15][0] = 342; Qij_AA[15][1] =   3; Qij_AA[15][2] = 446; Qij_AA[15][3] =  16; Qij_AA[15][4] = 347;
		Qij_AA[15][5] =  30; Qij_AA[15][6] =  21; Qij_AA[15][7] = 112; Qij_AA[15][8] =  20; Qij_AA[15][9] =   0;
		Qij_AA[15][10] =  74; Qij_AA[15][11] =  65; Qij_AA[15][12] =  47; Qij_AA[15][13] =  90; Qij_AA[15][14] = 202;
		Qij_AA[15][15] =   0; Qij_AA[15][16] = 614; Qij_AA[15][17] =  17; Qij_AA[15][18] = 107; Qij_AA[15][19] =   0;
		Qij_AA[16][0] = 681; Qij_AA[16][1] =   0; Qij_AA[16][2] = 110; Qij_AA[16][3] =   0; Qij_AA[16][4] = 114;
		Qij_AA[16][5] =   0; Qij_AA[16][6] =   4; Qij_AA[16][7] =   0; Qij_AA[16][8] =   1; Qij_AA[16][9] = 360;
		Qij_AA[16][10] =  34; Qij_AA[16][11] =  50; Qij_AA[16][12] = 691; Qij_AA[16][13] =   8; Qij_AA[16][14] =  78;
		Qij_AA[16][15] = 614; Qij_AA[16][16] =   0; Qij_AA[16][17] =   0; Qij_AA[16][18] =   0; Qij_AA[16][19] = 237;
		Qij_AA[17][0] =   5; Qij_AA[17][1] =  16; Qij_AA[17][2] =   6; Qij_AA[17][3] =   0; Qij_AA[17][4] =  65;
		Qij_AA[17][5] =   0; Qij_AA[17][6] =   0; Qij_AA[17][7] =   0; Qij_AA[17][8] =   0; Qij_AA[17][9] =   0;
		Qij_AA[17][10] =  12; Qij_AA[17][11] =   0; Qij_AA[17][12] =  13; Qij_AA[17][13] =   0; Qij_AA[17][14] =   7;
		Qij_AA[17][15] =  17; Qij_AA[17][16] =   0; Qij_AA[17][17] =   0; Qij_AA[17][18] =  14; Qij_AA[17][19] =   0;
		Qij_AA[18][0] =   0; Qij_AA[18][1] =   0; Qij_AA[18][2] = 156; Qij_AA[18][3] =   0; Qij_AA[18][4] = 530;
		Qij_AA[18][5] =  54; Qij_AA[18][6] =   0; Qij_AA[18][7] =   1; Qij_AA[18][8] =1525; Qij_AA[18][9] =  16;
		Qij_AA[18][10] =  25; Qij_AA[18][11] =  67; Qij_AA[18][12] =   0; Qij_AA[18][13] = 682; Qij_AA[18][14] =   8;
		Qij_AA[18][15] = 107; Qij_AA[18][16] =   0; Qij_AA[18][17] =  14; Qij_AA[18][18] =   0; Qij_AA[18][19] =   0;
		Qij_AA[19][0] = 398; Qij_AA[19][1] =   0; Qij_AA[19][2] =   0; Qij_AA[19][3] =  10; Qij_AA[19][4] =   0;
		Qij_AA[19][5] =  33; Qij_AA[19][6] =  20; Qij_AA[19][7] =   5; Qij_AA[19][8] =   0; Qij_AA[19][9] =2220;
		Qij_AA[19][10] = 100; Qij_AA[19][11] =   0; Qij_AA[19][12] = 832; Qij_AA[19][13] =   6; Qij_AA[19][14] =   0;
		Qij_AA[19][15] =   0; Qij_AA[19][16] = 237; Qij_AA[19][17] =   0; Qij_AA[19][18] =   0; Qij_AA[19][19] =   0;


		AA_EM_Pi[0] = 0.0692;
		AA_EM_Pi[1] = 0.0184;
		AA_EM_Pi[2] = 0.0400;
		AA_EM_Pi[3] = 0.0186;
		AA_EM_Pi[4] = 0.0065;
		AA_EM_Pi[5] = 0.0238;
		AA_EM_Pi[6] = 0.0236;
		AA_EM_Pi[7] = 0.0557;
		AA_EM_Pi[8] = 0.0277;
		AA_EM_Pi[9] = 0.0905;
		AA_EM_Pi[10] = 0.1675;
		AA_EM_Pi[11] = 0.0221;
		AA_EM_Pi[12] = 0.0561;
		AA_EM_Pi[13] = 0.0611;
		AA_EM_Pi[14] = 0.0536;
		AA_EM_Pi[15] = 0.0725;
		AA_EM_Pi[16] = 0.0870;
		AA_EM_Pi[17] = 0.0293;
		AA_EM_Pi[18] = 0.0340;
		AA_EM_Pi[19] = 0.0428;
		}
	else if (doMtrev24 == YES)
		{
		Qij_AA[0][0] =   0.00; Qij_AA[0][1] =  23.18; Qij_AA[0][2] =  26.95; Qij_AA[0][3] =  17.67; Qij_AA[0][4] =  59.93;
		Qij_AA[0][5] =   1.90; Qij_AA[0][6] =   9.77; Qij_AA[0][7] = 120.71; Qij_AA[0][8] =  13.90; Qij_AA[0][9] =  96.49;
		Qij_AA[0][10] =  25.46; Qij_AA[0][11] =   8.36; Qij_AA[0][12] = 141.88; Qij_AA[0][13] =   6.37; Qij_AA[0][14] =  54.31;
		Qij_AA[0][15] = 387.86; Qij_AA[0][16] = 480.72; Qij_AA[0][17] =   1.90; Qij_AA[0][18] =   6.48; Qij_AA[0][19] = 195.06;
		Qij_AA[1][0] =  23.18; Qij_AA[1][1] =   0.00; Qij_AA[1][2] =  13.24; Qij_AA[1][3] =   1.90; Qij_AA[1][4] = 103.33;
		Qij_AA[1][5] = 220.99; Qij_AA[1][6] =   1.90; Qij_AA[1][7] =  23.03; Qij_AA[1][8] = 165.23; Qij_AA[1][9] =   1.90;
		Qij_AA[1][10] =  15.58; Qij_AA[1][11] = 141.40; Qij_AA[1][12] =   1.90; Qij_AA[1][13] =   4.69; Qij_AA[1][14] =  23.64;
		Qij_AA[1][15] =   6.04; Qij_AA[1][16] =   2.08; Qij_AA[1][17] =  21.95; Qij_AA[1][18] =   1.90; Qij_AA[1][19] =   7.64;
		Qij_AA[2][0] =  26.95; Qij_AA[2][1] =  13.24; Qij_AA[2][2] =   0.00; Qij_AA[2][3] = 794.38; Qij_AA[2][4] =  58.94;
		Qij_AA[2][5] = 173.56; Qij_AA[2][6] =  63.05; Qij_AA[2][7] =  53.30; Qij_AA[2][8] = 496.13; Qij_AA[2][9] =  27.10;
		Qij_AA[2][10] =  15.16; Qij_AA[2][11] = 608.70; Qij_AA[2][12] =  65.41; Qij_AA[2][13] =  15.20; Qij_AA[2][14] =  73.31;
		Qij_AA[2][15] = 494.39; Qij_AA[2][16] = 238.46; Qij_AA[2][17] =  10.68; Qij_AA[2][18] = 191.36; Qij_AA[2][19] =   1.90;
		Qij_AA[3][0] =  17.67; Qij_AA[3][1] =   1.90; Qij_AA[3][2] = 794.38; Qij_AA[3][3] =   0.00; Qij_AA[3][4] =   1.90;
		Qij_AA[3][5] =  55.28; Qij_AA[3][6] = 583.55; Qij_AA[3][7] =  56.77; Qij_AA[3][8] = 113.99; Qij_AA[3][9] =   4.34;
		Qij_AA[3][10] =   1.90; Qij_AA[3][11] =   2.31; Qij_AA[3][12] =   1.90; Qij_AA[3][13] =   4.98; Qij_AA[3][14] =  13.43;
		Qij_AA[3][15] =  69.02; Qij_AA[3][16] =  28.01; Qij_AA[3][17] =  19.86; Qij_AA[3][18] =  21.21; Qij_AA[3][19] =   1.90;
		Qij_AA[4][0] =  59.93; Qij_AA[4][1] = 103.33; Qij_AA[4][2] =  58.94; Qij_AA[4][3] =   1.90; Qij_AA[4][4] =   0.00;
		Qij_AA[4][5] =  75.24; Qij_AA[4][6] =   1.90; Qij_AA[4][7] =  30.71; Qij_AA[4][8] = 141.49; Qij_AA[4][9] =  62.73;
		Qij_AA[4][10] =  25.65; Qij_AA[4][11] =   1.90; Qij_AA[4][12] =   6.18; Qij_AA[4][13] =  70.80; Qij_AA[4][14] =  31.26;
		Qij_AA[4][15] = 277.05; Qij_AA[4][16] = 179.97; Qij_AA[4][17] =  33.60; Qij_AA[4][18] = 254.77; Qij_AA[4][19] =   1.90;
		Qij_AA[5][0] =   1.90; Qij_AA[5][1] = 220.99; Qij_AA[5][2] = 173.56; Qij_AA[5][3] =  55.28; Qij_AA[5][4] =  75.24;
		Qij_AA[5][5] =   0.00; Qij_AA[5][6] = 313.56; Qij_AA[5][7] =   6.75; Qij_AA[5][8] = 582.40; Qij_AA[5][9] =   8.34;
		Qij_AA[5][10] =  39.70; Qij_AA[5][11] = 465.58; Qij_AA[5][12] =  47.37; Qij_AA[5][13] =  19.11; Qij_AA[5][14] = 137.29;
		Qij_AA[5][15] =  54.11; Qij_AA[5][16] =  94.93; Qij_AA[5][17] =   1.90; Qij_AA[5][18] =  38.82; Qij_AA[5][19] =  19.00;
		Qij_AA[6][0] =   9.77; Qij_AA[6][1] =   1.90; Qij_AA[6][2] =  63.05; Qij_AA[6][3] = 583.55; Qij_AA[6][4] =   1.90;
		Qij_AA[6][5] = 313.56; Qij_AA[6][6] =   0.00; Qij_AA[6][7] =  28.28; Qij_AA[6][8] =  49.12; Qij_AA[6][9] =   3.31;
		Qij_AA[6][10] =   1.90; Qij_AA[6][11] = 313.86; Qij_AA[6][12] =   1.90; Qij_AA[6][13] =   2.67; Qij_AA[6][14] =  12.83;
		Qij_AA[6][15] =  54.71; Qij_AA[6][16] =  14.82; Qij_AA[6][17] =   1.90; Qij_AA[6][18] =  13.12; Qij_AA[6][19] =  21.14;
		Qij_AA[7][0] = 120.71; Qij_AA[7][1] =  23.03; Qij_AA[7][2] =  53.30; Qij_AA[7][3] =  56.77; Qij_AA[7][4] =  30.71;
		Qij_AA[7][5] =   6.75; Qij_AA[7][6] =  28.28; Qij_AA[7][7] =   0.00; Qij_AA[7][8] =   1.90; Qij_AA[7][9] =   5.98;
		Qij_AA[7][10] =   2.41; Qij_AA[7][11] =  22.73; Qij_AA[7][12] =   1.90; Qij_AA[7][13] =   1.90; Qij_AA[7][14] =   1.90;
		Qij_AA[7][15] = 125.93; Qij_AA[7][16] =  11.17; Qij_AA[7][17] =  10.92; Qij_AA[7][18] =   3.21; Qij_AA[7][19] =   2.53;
		Qij_AA[8][0] =  13.90; Qij_AA[8][1] = 165.23; Qij_AA[8][2] = 496.13; Qij_AA[8][3] = 113.99; Qij_AA[8][4] = 141.49;
		Qij_AA[8][5] = 582.40; Qij_AA[8][6] =  49.12; Qij_AA[8][7] =   1.90; Qij_AA[8][8] =   0.00; Qij_AA[8][9] =  12.26;
		Qij_AA[8][10] =  11.49; Qij_AA[8][11] = 127.67; Qij_AA[8][12] =  11.97; Qij_AA[8][13] =  48.16; Qij_AA[8][14] =  60.97;
		Qij_AA[8][15] =  77.46; Qij_AA[8][16] =  44.78; Qij_AA[8][17] =   7.08; Qij_AA[8][18] = 670.14; Qij_AA[8][19] =   1.90;
		Qij_AA[9][0] =  96.49; Qij_AA[9][1] =   1.90; Qij_AA[9][2] =  27.10; Qij_AA[9][3] =   4.34; Qij_AA[9][4] =  62.73;
		Qij_AA[9][5] =   8.34; Qij_AA[9][6] =   3.31; Qij_AA[9][7] =   5.98; Qij_AA[9][8] =  12.26; Qij_AA[9][9] =   0.00;
		Qij_AA[9][10] = 329.09; Qij_AA[9][11] =  19.57; Qij_AA[9][12] = 517.98; Qij_AA[9][13] =  84.67; Qij_AA[9][14] =  20.63;
		Qij_AA[9][15] =  47.70; Qij_AA[9][16] = 368.43; Qij_AA[9][17] =   1.90; Qij_AA[9][18] =  25.01; Qij_AA[9][19] =1222.94;
		Qij_AA[10][0] =  25.46; Qij_AA[10][1] =  15.58; Qij_AA[10][2] =  15.16; Qij_AA[10][3] =   1.90; Qij_AA[10][4] =  25.65;
		Qij_AA[10][5] =  39.70; Qij_AA[10][6] =   1.90; Qij_AA[10][7] =   2.41; Qij_AA[10][8] =  11.49; Qij_AA[10][9] = 329.09;
		Qij_AA[10][10] =   0.00; Qij_AA[10][11] =  14.88; Qij_AA[10][12] = 537.53; Qij_AA[10][13] = 216.06; Qij_AA[10][14] =  40.10;
		Qij_AA[10][15] =  73.61; Qij_AA[10][16] = 126.40; Qij_AA[10][17] =  32.44; Qij_AA[10][18] =  44.15; Qij_AA[10][19] =  91.67;
		Qij_AA[11][0] =   8.36; Qij_AA[11][1] = 141.40; Qij_AA[11][2] = 608.70; Qij_AA[11][3] =   2.31; Qij_AA[11][4] =   1.90;
		Qij_AA[11][5] = 465.58; Qij_AA[11][6] = 313.86; Qij_AA[11][7] =  22.73; Qij_AA[11][8] = 127.67; Qij_AA[11][9] =  19.57;
		Qij_AA[11][10] =  14.88; Qij_AA[11][11] =   0.00; Qij_AA[11][12] =  91.37; Qij_AA[11][13] =   6.44; Qij_AA[11][14] =  50.10;
		Qij_AA[11][15] = 105.79; Qij_AA[11][16] = 136.33; Qij_AA[11][17] =  24.00; Qij_AA[11][18] =  51.17; Qij_AA[11][19] =   1.90;
		Qij_AA[12][0] = 141.88; Qij_AA[12][1] =   1.90; Qij_AA[12][2] =  65.41; Qij_AA[12][3] =   1.90; Qij_AA[12][4] =   6.18;
		Qij_AA[12][5] =  47.37; Qij_AA[12][6] =   1.90; Qij_AA[12][7] =   1.90; Qij_AA[12][8] =  11.97; Qij_AA[12][9] = 517.98;
		Qij_AA[12][10] = 537.53; Qij_AA[12][11] =  91.37; Qij_AA[12][12] =   0.00; Qij_AA[12][13] =  90.82; Qij_AA[12][14] =  18.84;
		Qij_AA[12][15] = 111.16; Qij_AA[12][16] = 528.17; Qij_AA[12][17] =  21.71; Qij_AA[12][18] =  39.96; Qij_AA[12][19] = 387.54;
		Qij_AA[13][0] =   6.37; Qij_AA[13][1] =   4.69; Qij_AA[13][2] =  15.20; Qij_AA[13][3] =   4.98; Qij_AA[13][4] =  70.80;
		Qij_AA[13][5] =  19.11; Qij_AA[13][6] =   2.67; Qij_AA[13][7] =   1.90; Qij_AA[13][8] =  48.16; Qij_AA[13][9] =  84.67;
		Qij_AA[13][10] = 216.06; Qij_AA[13][11] =   6.44; Qij_AA[13][12] =  90.82; Qij_AA[13][13] =   0.00; Qij_AA[13][14] =  17.31;
		Qij_AA[13][15] =  64.29; Qij_AA[13][16] =  33.85; Qij_AA[13][17] =   7.84; Qij_AA[13][18] = 465.58; Qij_AA[13][19] =   6.35;
		Qij_AA[14][0] =  54.31; Qij_AA[14][1] =  23.64; Qij_AA[14][2] =  73.31; Qij_AA[14][3] =  13.43; Qij_AA[14][4] =  31.26;
		Qij_AA[14][5] = 137.29; Qij_AA[14][6] =  12.83; Qij_AA[14][7] =   1.90; Qij_AA[14][8] =  60.97; Qij_AA[14][9] =  20.63;
		Qij_AA[14][10] =  40.10; Qij_AA[14][11] =  50.10; Qij_AA[14][12] =  18.84; Qij_AA[14][13] =  17.31; Qij_AA[14][14] =   0.00;
		Qij_AA[14][15] = 169.90; Qij_AA[14][16] = 128.22; Qij_AA[14][17] =   4.21; Qij_AA[14][18] =  16.21; Qij_AA[14][19] =   8.23;
		Qij_AA[15][0] = 387.86; Qij_AA[15][1] =   6.04; Qij_AA[15][2] = 494.39; Qij_AA[15][3] =  69.02; Qij_AA[15][4] = 277.05;
		Qij_AA[15][5] =  54.11; Qij_AA[15][6] =  54.71; Qij_AA[15][7] = 125.93; Qij_AA[15][8] =  77.46; Qij_AA[15][9] =  47.70;
		Qij_AA[15][10] =  73.61; Qij_AA[15][11] = 105.79; Qij_AA[15][12] = 111.16; Qij_AA[15][13] =  64.29; Qij_AA[15][14] = 169.90;
		Qij_AA[15][15] =   0.00; Qij_AA[15][16] = 597.21; Qij_AA[15][17] =  38.58; Qij_AA[15][18] =  64.92; Qij_AA[15][19] =   1.90;
		Qij_AA[16][0] = 480.72; Qij_AA[16][1] =   2.08; Qij_AA[16][2] = 238.46; Qij_AA[16][3] =  28.01; Qij_AA[16][4] = 179.97;
		Qij_AA[16][5] =  94.93; Qij_AA[16][6] =  14.82; Qij_AA[16][7] =  11.17; Qij_AA[16][8] =  44.78; Qij_AA[16][9] = 368.43;
		Qij_AA[16][10] = 126.40; Qij_AA[16][11] = 136.33; Qij_AA[16][12] = 528.17; Qij_AA[16][13] =  33.85; Qij_AA[16][14] = 128.22;
		Qij_AA[16][15] = 597.21; Qij_AA[16][16] =   0.00; Qij_AA[16][17] =   9.99; Qij_AA[16][18] =  38.73; Qij_AA[16][19] = 204.54;
		Qij_AA[17][0] =   1.90; Qij_AA[17][1] =  21.95; Qij_AA[17][2] =  10.68; Qij_AA[17][3] =  19.86; Qij_AA[17][4] =  33.60;
		Qij_AA[17][5] =   1.90; Qij_AA[17][6] =   1.90; Qij_AA[17][7] =  10.92; Qij_AA[17][8] =   7.08; Qij_AA[17][9] =   1.90;
		Qij_AA[17][10] =  32.44; Qij_AA[17][11] =  24.00; Qij_AA[17][12] =  21.71; Qij_AA[17][13] =   7.84; Qij_AA[17][14] =   4.21;
		Qij_AA[17][15] =  38.58; Qij_AA[17][16] =   9.99; Qij_AA[17][17] =   0.00; Qij_AA[17][18] =  26.25; Qij_AA[17][19] =   5.37;
		Qij_AA[18][0] =   6.48; Qij_AA[18][1] =   1.90; Qij_AA[18][2] = 191.36; Qij_AA[18][3] =  21.21; Qij_AA[18][4] = 254.77;
		Qij_AA[18][5] =  38.82; Qij_AA[18][6] =  13.12; Qij_AA[18][7] =   3.21; Qij_AA[18][8] = 670.14; Qij_AA[18][9] =  25.01;
		Qij_AA[18][10] =  44.15; Qij_AA[18][11] =  51.17; Qij_AA[18][12] =  39.96; Qij_AA[18][13] = 465.58; Qij_AA[18][14] =  16.21;
		Qij_AA[18][15] =  64.92; Qij_AA[18][16] =  38.73; Qij_AA[18][17] =  26.25; Qij_AA[18][18] =   0.00; Qij_AA[18][19] =   1.90;
		Qij_AA[19][0] = 195.06; Qij_AA[19][1] =   7.64; Qij_AA[19][2] =   1.90; Qij_AA[19][3] =   1.90; Qij_AA[19][4] =   1.90;
		Qij_AA[19][5] =  19.00; Qij_AA[19][6] =  21.14; Qij_AA[19][7] =   2.53; Qij_AA[19][8] =   1.90; Qij_AA[19][9] =1222.94;
		Qij_AA[19][10] =  91.67; Qij_AA[19][11] =   1.90; Qij_AA[19][12] = 387.54; Qij_AA[19][13] =   6.35; Qij_AA[19][14] =   8.23;
		Qij_AA[19][15] =   1.90; Qij_AA[19][16] = 204.54; Qij_AA[19][17] =   5.37; Qij_AA[19][18] =   1.90; Qij_AA[19][19] =   0.00;


		AA_EM_Pi[0] = 0.072;
		AA_EM_Pi[1] = 0.019;
		AA_EM_Pi[2] = 0.039;
		AA_EM_Pi[3] = 0.019;
		AA_EM_Pi[4] = 0.006;
		AA_EM_Pi[5] = 0.025;
		AA_EM_Pi[6] = 0.024;
		AA_EM_Pi[7] = 0.056;
		AA_EM_Pi[8] = 0.028;
		AA_EM_Pi[9] = 0.088;
		AA_EM_Pi[10] = 0.168;
		AA_EM_Pi[11] = 0.023;
		AA_EM_Pi[12] = 0.054;
		AA_EM_Pi[13] = 0.061;
		AA_EM_Pi[14] = 0.054;
		AA_EM_Pi[15] = 0.072;
		AA_EM_Pi[16] = 0.086;
		AA_EM_Pi[17] = 0.029;
		AA_EM_Pi[18] = 0.033;
		AA_EM_Pi[19] = 0.043;
		}
	else if (doRtRev == YES)
		{
		Qij_AA[0][0] =   0; Qij_AA[1][0] =  34; Qij_AA[2][0] =  51; Qij_AA[3][0] =  10; Qij_AA[4][0] = 439;
		Qij_AA[5][0] =  32; Qij_AA[6][0] =  81; Qij_AA[7][0] = 135; Qij_AA[8][0] =  30; Qij_AA[9][0] =   1;
		Qij_AA[10][0] =  45; Qij_AA[11][0] =  38; Qij_AA[12][0] = 235; Qij_AA[13][0] =   1; Qij_AA[14][0] =  97;
		Qij_AA[15][0] = 460; Qij_AA[16][0] = 258; Qij_AA[17][0] =   5; Qij_AA[18][0] =  55; Qij_AA[19][0] = 197;
		Qij_AA[0][1] =  34; Qij_AA[1][1] =   0; Qij_AA[2][1] =  35; Qij_AA[3][1] =  30; Qij_AA[4][1] =  92;
		Qij_AA[5][1] = 221; Qij_AA[6][1] =  10; Qij_AA[7][1] =  41; Qij_AA[8][1] =  90; Qij_AA[9][1] =  24;
		Qij_AA[10][1] =  18; Qij_AA[11][1] = 593; Qij_AA[12][1] =  57; Qij_AA[13][1] =   7; Qij_AA[14][1] =  24;
		Qij_AA[15][1] = 102; Qij_AA[16][1] =  64; Qij_AA[17][1] =  13; Qij_AA[18][1] =  47; Qij_AA[19][1] =  29;
		Qij_AA[0][2] =  51; Qij_AA[1][2] =  35; Qij_AA[2][2] =   0; Qij_AA[3][2] = 384; Qij_AA[4][2] = 128;
		Qij_AA[5][2] = 236; Qij_AA[6][2] =  79; Qij_AA[7][2] =  94; Qij_AA[8][2] = 320; Qij_AA[9][2] =  35;
		Qij_AA[10][2] =  15; Qij_AA[11][2] = 123; Qij_AA[12][2] =   1; Qij_AA[13][2] =  49; Qij_AA[14][2] =  33;
		Qij_AA[15][2] = 294; Qij_AA[16][2] = 148; Qij_AA[17][2] =  16; Qij_AA[18][2] =  28; Qij_AA[19][2] =  21;
		Qij_AA[0][3] =  10; Qij_AA[1][3] =  30; Qij_AA[2][3] = 384; Qij_AA[3][3] =   0; Qij_AA[4][3] =   1;
		Qij_AA[5][3] =  78; Qij_AA[6][3] = 542; Qij_AA[7][3] =  61; Qij_AA[8][3] =  91; Qij_AA[9][3] =   1;
		Qij_AA[10][3] =   5; Qij_AA[11][3] =  20; Qij_AA[12][3] =   1; Qij_AA[13][3] =   1; Qij_AA[14][3] =  55;
		Qij_AA[15][3] = 136; Qij_AA[16][3] =  55; Qij_AA[17][3] =   1; Qij_AA[18][3] =   1; Qij_AA[19][3] =   6;
		Qij_AA[0][4] = 439; Qij_AA[1][4] =  92; Qij_AA[2][4] = 128; Qij_AA[3][4] =   1; Qij_AA[4][4] =   0;
		Qij_AA[5][4] =  70; Qij_AA[6][4] =   1; Qij_AA[7][4] =  48; Qij_AA[8][4] = 124; Qij_AA[9][4] = 104;
		Qij_AA[10][4] = 110; Qij_AA[11][4] =  16; Qij_AA[12][4] = 156; Qij_AA[13][4] =  70; Qij_AA[14][4] =   1;
		Qij_AA[15][4] =  75; Qij_AA[16][4] = 117; Qij_AA[17][4] =  55; Qij_AA[18][4] = 131; Qij_AA[19][4] = 295;
		Qij_AA[0][5] =  32; Qij_AA[1][5] = 221; Qij_AA[2][5] = 236; Qij_AA[3][5] =  78; Qij_AA[4][5] =  70;
		Qij_AA[5][5] =   0; Qij_AA[6][5] = 372; Qij_AA[7][5] =  18; Qij_AA[8][5] = 387; Qij_AA[9][5] =  33;
		Qij_AA[10][5] =  54; Qij_AA[11][5] = 309; Qij_AA[12][5] = 158; Qij_AA[13][5] =   1; Qij_AA[14][5] =  68;
		Qij_AA[15][5] = 225; Qij_AA[16][5] = 146; Qij_AA[17][5] =  10; Qij_AA[18][5] =  45; Qij_AA[19][5] =  36;
		Qij_AA[0][6] =  81; Qij_AA[1][6] =  10; Qij_AA[2][6] =  79; Qij_AA[3][6] = 542; Qij_AA[4][6] =   1;
		Qij_AA[5][6] = 372; Qij_AA[6][6] =   0; Qij_AA[7][6] =  70; Qij_AA[8][6] =  34; Qij_AA[9][6] =   1;
		Qij_AA[10][6] =  21; Qij_AA[11][6] = 141; Qij_AA[12][6] =   1; Qij_AA[13][6] =   1; Qij_AA[14][6] =  52;
		Qij_AA[15][6] =  95; Qij_AA[16][6] =  82; Qij_AA[17][6] =  17; Qij_AA[18][6] =   1; Qij_AA[19][6] =  35;
		Qij_AA[0][7] = 135; Qij_AA[1][7] =  41; Qij_AA[2][7] =  94; Qij_AA[3][7] =  61; Qij_AA[4][7] =  48;
		Qij_AA[5][7] =  18; Qij_AA[6][7] =  70; Qij_AA[7][7] =   0; Qij_AA[8][7] =  68; Qij_AA[9][7] =   1;
		Qij_AA[10][7] =   3; Qij_AA[11][7] =  30; Qij_AA[12][7] =  37; Qij_AA[13][7] =   7; Qij_AA[14][7] =  17;
		Qij_AA[15][7] = 152; Qij_AA[16][7] =   7; Qij_AA[17][7] =  23; Qij_AA[18][7] =  21; Qij_AA[19][7] =   3;
		Qij_AA[0][8] =  30; Qij_AA[1][8] =  90; Qij_AA[2][8] = 320; Qij_AA[3][8] =  91; Qij_AA[4][8] = 124;
		Qij_AA[5][8] = 387; Qij_AA[6][8] =  34; Qij_AA[7][8] =  68; Qij_AA[8][8] =   0; Qij_AA[9][8] =  34;
		Qij_AA[10][8] =  51; Qij_AA[11][8] =  76; Qij_AA[12][8] = 116; Qij_AA[13][8] = 141; Qij_AA[14][8] =  44;
		Qij_AA[15][8] = 183; Qij_AA[16][8] =  49; Qij_AA[17][8] =  48; Qij_AA[18][8] = 307; Qij_AA[19][8] =   1;
		Qij_AA[0][9] =   1; Qij_AA[1][9] =  24; Qij_AA[2][9] =  35; Qij_AA[3][9] =   1; Qij_AA[4][9] = 104;
		Qij_AA[5][9] =  33; Qij_AA[6][9] =   1; Qij_AA[7][9] =   1; Qij_AA[8][9] =  34; Qij_AA[9][9] =   0;
		Qij_AA[10][9] = 385; Qij_AA[11][9] =  34; Qij_AA[12][9] = 375; Qij_AA[13][9] =  64; Qij_AA[14][9] =  10;
		Qij_AA[15][9] =   4; Qij_AA[16][9] =  72; Qij_AA[17][9] =  39; Qij_AA[18][9] =  26; Qij_AA[19][9] =1048;
		Qij_AA[0][10] =  45; Qij_AA[1][10] =  18; Qij_AA[2][10] =  15; Qij_AA[3][10] =   5; Qij_AA[4][10] = 110;
		Qij_AA[5][10] =  54; Qij_AA[6][10] =  21; Qij_AA[7][10] =   3; Qij_AA[8][10] =  51; Qij_AA[9][10] = 385;
		Qij_AA[10][10] =   0; Qij_AA[11][10] =  23; Qij_AA[12][10] = 581; Qij_AA[13][10] = 179; Qij_AA[14][10] =  22;
		Qij_AA[15][10] =  24; Qij_AA[16][10] =  25; Qij_AA[17][10] =  47; Qij_AA[18][10] =  64; Qij_AA[19][10] = 112;
		Qij_AA[0][11] =  38; Qij_AA[1][11] = 593; Qij_AA[2][11] = 123; Qij_AA[3][11] =  20; Qij_AA[4][11] =  16;
		Qij_AA[5][11] = 309; Qij_AA[6][11] = 141; Qij_AA[7][11] =  30; Qij_AA[8][11] =  76; Qij_AA[9][11] =  34;
		Qij_AA[10][11] =  23; Qij_AA[11][11] =   0; Qij_AA[12][11] = 134; Qij_AA[13][11] =  14; Qij_AA[14][11] =  43;
		Qij_AA[15][11] =  77; Qij_AA[16][11] = 110; Qij_AA[17][11] =   6; Qij_AA[18][11] =   1; Qij_AA[19][11] =  19;
		Qij_AA[0][12] = 235; Qij_AA[1][12] =  57; Qij_AA[2][12] =   1; Qij_AA[3][12] =   1; Qij_AA[4][12] = 156;
		Qij_AA[5][12] = 158; Qij_AA[6][12] =   1; Qij_AA[7][12] =  37; Qij_AA[8][12] = 116; Qij_AA[9][12] = 375;
		Qij_AA[10][12] = 581; Qij_AA[11][12] = 134; Qij_AA[12][12] =   0; Qij_AA[13][12] = 247; Qij_AA[14][12] =   1;
		Qij_AA[15][12] =   1; Qij_AA[16][12] = 131; Qij_AA[17][12] = 111; Qij_AA[18][12] =  74; Qij_AA[19][12] = 236;
		Qij_AA[0][13] =   1; Qij_AA[1][13] =   7; Qij_AA[2][13] =  49; Qij_AA[3][13] =   1; Qij_AA[4][13] =  70;
		Qij_AA[5][13] =   1; Qij_AA[6][13] =   1; Qij_AA[7][13] =   7; Qij_AA[8][13] = 141; Qij_AA[9][13] =  64;
		Qij_AA[10][13] = 179; Qij_AA[11][13] =  14; Qij_AA[12][13] = 247; Qij_AA[13][13] =   0; Qij_AA[14][13] =  11;
		Qij_AA[15][13] =  20; Qij_AA[16][13] =  69; Qij_AA[17][13] = 182; Qij_AA[18][13] =1017; Qij_AA[19][13] =  92;
		Qij_AA[0][14] =  97; Qij_AA[1][14] =  24; Qij_AA[2][14] =  33; Qij_AA[3][14] =  55; Qij_AA[4][14] =   1;
		Qij_AA[5][14] =  68; Qij_AA[6][14] =  52; Qij_AA[7][14] =  17; Qij_AA[8][14] =  44; Qij_AA[9][14] =  10;
		Qij_AA[10][14] =  22; Qij_AA[11][14] =  43; Qij_AA[12][14] =   1; Qij_AA[13][14] =  11; Qij_AA[14][14] =   0;
		Qij_AA[15][14] = 134; Qij_AA[16][14] =  62; Qij_AA[17][14] =   9; Qij_AA[18][14] =  14; Qij_AA[19][14] =  25;
		Qij_AA[0][15] = 460; Qij_AA[1][15] = 102; Qij_AA[2][15] = 294; Qij_AA[3][15] = 136; Qij_AA[4][15] =  75;
		Qij_AA[5][15] = 225; Qij_AA[6][15] =  95; Qij_AA[7][15] = 152; Qij_AA[8][15] = 183; Qij_AA[9][15] =   4;
		Qij_AA[10][15] =  24; Qij_AA[11][15] =  77; Qij_AA[12][15] =   1; Qij_AA[13][15] =  20; Qij_AA[14][15] = 134;
		Qij_AA[15][15] =   0; Qij_AA[16][15] = 671; Qij_AA[17][15] =  14; Qij_AA[18][15] =  31; Qij_AA[19][15] =  39;
		Qij_AA[0][16] = 258; Qij_AA[1][16] =  64; Qij_AA[2][16] = 148; Qij_AA[3][16] =  55; Qij_AA[4][16] = 117;
		Qij_AA[5][16] = 146; Qij_AA[6][16] =  82; Qij_AA[7][16] =   7; Qij_AA[8][16] =  49; Qij_AA[9][16] =  72;
		Qij_AA[10][16] =  25; Qij_AA[11][16] = 110; Qij_AA[12][16] = 131; Qij_AA[13][16] =  69; Qij_AA[14][16] =  62;
		Qij_AA[15][16] = 671; Qij_AA[16][16] =   0; Qij_AA[17][16] =   1; Qij_AA[18][16] =  34; Qij_AA[19][16] = 196;
		Qij_AA[0][17] =   5; Qij_AA[1][17] =  13; Qij_AA[2][17] =  16; Qij_AA[3][17] =   1; Qij_AA[4][17] =  55;
		Qij_AA[5][17] =  10; Qij_AA[6][17] =  17; Qij_AA[7][17] =  23; Qij_AA[8][17] =  48; Qij_AA[9][17] =  39;
		Qij_AA[10][17] =  47; Qij_AA[11][17] =   6; Qij_AA[12][17] = 111; Qij_AA[13][17] = 182; Qij_AA[14][17] =   9;
		Qij_AA[15][17] =  14; Qij_AA[16][17] =   1; Qij_AA[17][17] =   0; Qij_AA[18][17] = 176; Qij_AA[19][17] =  26;
		Qij_AA[0][18] =  55; Qij_AA[1][18] =  47; Qij_AA[2][18] =  28; Qij_AA[3][18] =   1; Qij_AA[4][18] = 131;
		Qij_AA[5][18] =  45; Qij_AA[6][18] =   1; Qij_AA[7][18] =  21; Qij_AA[8][18] = 307; Qij_AA[9][18] =  26;
		Qij_AA[10][18] =  64; Qij_AA[11][18] =   1; Qij_AA[12][18] =  74; Qij_AA[13][18] =1017; Qij_AA[14][18] =  14;
		Qij_AA[15][18] =  31; Qij_AA[16][18] =  34; Qij_AA[17][18] = 176; Qij_AA[18][18] =   0; Qij_AA[19][18] =  59;
		Qij_AA[0][19] = 197; Qij_AA[1][19] =  29; Qij_AA[2][19] =  21; Qij_AA[3][19] =   6; Qij_AA[4][19] = 295;
		Qij_AA[5][19] =  36; Qij_AA[6][19] =  35; Qij_AA[7][19] =   3; Qij_AA[8][19] =   1; Qij_AA[9][19] =1048;
		Qij_AA[10][19] = 112; Qij_AA[11][19] =  19; Qij_AA[12][19] = 236; Qij_AA[13][19] =  92; Qij_AA[14][19] =  25;
		Qij_AA[15][19] =  39; Qij_AA[16][19] = 196; Qij_AA[17][19] =  26; Qij_AA[18][19] =  59; Qij_AA[19][19] =   0;


		AA_EM_Pi[0] = 0.0646;
		AA_EM_Pi[1] = 0.0453;
		AA_EM_Pi[2] = 0.0376;
		AA_EM_Pi[3] = 0.0422;
		AA_EM_Pi[4] = 0.0114;
		AA_EM_Pi[5] = 0.0606;
		AA_EM_Pi[6] = 0.0607;
		AA_EM_Pi[7] = 0.0639;
		AA_EM_Pi[8] = 0.0273;
		AA_EM_Pi[9] = 0.0679;
		AA_EM_Pi[10] = 0.1018;
		AA_EM_Pi[11] = 0.0751;
		AA_EM_Pi[12] = 0.0150;
		AA_EM_Pi[13] = 0.0287;
		AA_EM_Pi[14] = 0.0681;
		AA_EM_Pi[15] = 0.0488;
		AA_EM_Pi[16] = 0.0622;
		AA_EM_Pi[17] = 0.0251;
		AA_EM_Pi[18] = 0.0318;
		AA_EM_Pi[19] = 0.0619;
		}
	else if (doVT)
		{
		Qij_AA[0][0] = 0.000000; Qij_AA[0][1] = 0.233108; Qij_AA[0][2] = 0.199097; Qij_AA[0][3] = 0.265145; Qij_AA[0][4] = 0.227333; 
		Qij_AA[0][5] = 0.310084; Qij_AA[0][6] = 0.567957; Qij_AA[0][7] = 0.876213; Qij_AA[0][8] = 0.078692; Qij_AA[0][9] = 0.222972; 
		Qij_AA[0][10] = 0.424630; Qij_AA[0][11] = 0.393245; Qij_AA[0][12] = 0.211550; Qij_AA[0][13] = 0.116646; Qij_AA[0][14] = 0.399143; 
		Qij_AA[0][15] = 1.817198; Qij_AA[0][16] = 0.877877; Qij_AA[0][17] = 0.030309; Qij_AA[0][18] = 0.087061; Qij_AA[0][19] = 1.230985; 
		Qij_AA[1][0] = 0.233108; Qij_AA[1][1] = 0.000000; Qij_AA[1][2] = 0.210797; Qij_AA[1][3] = 0.105191; Qij_AA[1][4] = 0.031726; 
		Qij_AA[1][5] = 0.493763; Qij_AA[1][6] = 0.255240; Qij_AA[1][7] = 0.156945; Qij_AA[1][8] = 0.213164; Qij_AA[1][9] = 0.081510; 
		Qij_AA[1][10] = 0.192364; Qij_AA[1][11] = 1.755838; Qij_AA[1][12] = 0.087930; Qij_AA[1][13] = 0.042569; Qij_AA[1][14] = 0.128480; 
		Qij_AA[1][15] = 0.292327; Qij_AA[1][16] = 0.204109; Qij_AA[1][17] = 0.046417; Qij_AA[1][18] = 0.097010; Qij_AA[1][19] = 0.113146; 
		Qij_AA[2][0] = 0.199097; Qij_AA[2][1] = 0.210797; Qij_AA[2][2] = 0.000000; Qij_AA[2][3] = 0.883422; Qij_AA[2][4] = 0.027495; 
		Qij_AA[2][5] = 0.275700; Qij_AA[2][6] = 0.270417; Qij_AA[2][7] = 0.362028; Qij_AA[2][8] = 0.290006; Qij_AA[2][9] = 0.087225; 
		Qij_AA[2][10] = 0.069245; Qij_AA[2][11] = 0.503060; Qij_AA[2][12] = 0.057420; Qij_AA[2][13] = 0.039769; Qij_AA[2][14] = 0.083956; 
		Qij_AA[2][15] = 0.847049; Qij_AA[2][16] = 0.471268; Qij_AA[2][17] = 0.010459; Qij_AA[2][18] = 0.093268; Qij_AA[2][19] = 0.049824; 
		Qij_AA[3][0] = 0.265145; Qij_AA[3][1] = 0.105191; Qij_AA[3][2] = 0.883422; Qij_AA[3][3] = 0.000000; Qij_AA[3][4] = 0.010313; 
		Qij_AA[3][5] = 0.205842; Qij_AA[3][6] = 1.599461; Qij_AA[3][7] = 0.311718; Qij_AA[3][8] = 0.134252; Qij_AA[3][9] = 0.011720; 
		Qij_AA[3][10] = 0.060863; Qij_AA[3][11] = 0.261101; Qij_AA[3][12] = 0.012182; Qij_AA[3][13] = 0.016577; Qij_AA[3][14] = 0.160063; 
		Qij_AA[3][15] = 0.461519; Qij_AA[3][16] = 0.178197; Qij_AA[3][17] = 0.011393; Qij_AA[3][18] = 0.051664; Qij_AA[3][19] = 0.048769; 
		Qij_AA[4][0] = 0.227333; Qij_AA[4][1] = 0.031726; Qij_AA[4][2] = 0.027495; Qij_AA[4][3] = 0.010313; Qij_AA[4][4] = 0.000000; 
		Qij_AA[4][5] = 0.004315; Qij_AA[4][6] = 0.005321; Qij_AA[4][7] = 0.050876; Qij_AA[4][8] = 0.016695; Qij_AA[4][9] = 0.046398; 
		Qij_AA[4][10] = 0.091709; Qij_AA[4][11] = 0.004067; Qij_AA[4][12] = 0.023690; Qij_AA[4][13] = 0.051127; Qij_AA[4][14] = 0.011137; 
		Qij_AA[4][15] = 0.175270; Qij_AA[4][16] = 0.079511; Qij_AA[4][17] = 0.007732; Qij_AA[4][18] = 0.042823; Qij_AA[4][19] = 0.163831; 
		Qij_AA[5][0] = 0.310084; Qij_AA[5][1] = 0.493763; Qij_AA[5][2] = 0.275700; Qij_AA[5][3] = 0.205842; Qij_AA[5][4] = 0.004315; 
		Qij_AA[5][5] = 0.000000; Qij_AA[5][6] = 0.960976; Qij_AA[5][7] = 0.128660; Qij_AA[5][8] = 0.315521; Qij_AA[5][9] = 0.054602; 
		Qij_AA[5][10] = 0.243530; Qij_AA[5][11] = 0.738208; Qij_AA[5][12] = 0.120801; Qij_AA[5][13] = 0.026235; Qij_AA[5][14] = 0.156570; 
		Qij_AA[5][15] = 0.358017; Qij_AA[5][16] = 0.248992; Qij_AA[5][17] = 0.021248; Qij_AA[5][18] = 0.062544; Qij_AA[5][19] = 0.112027; 
		Qij_AA[6][0] = 0.567957; Qij_AA[6][1] = 0.255240; Qij_AA[6][2] = 0.270417; Qij_AA[6][3] = 1.599461; Qij_AA[6][4] = 0.005321; 
		Qij_AA[6][5] = 0.960976; Qij_AA[6][6] = 0.000000; Qij_AA[6][7] = 0.250447; Qij_AA[6][8] = 0.104458; Qij_AA[6][9] = 0.046589; 
		Qij_AA[6][10] = 0.151924; Qij_AA[6][11] = 0.888630; Qij_AA[6][12] = 0.058643; Qij_AA[6][13] = 0.028168; Qij_AA[6][14] = 0.205134; 
		Qij_AA[6][15] = 0.406035; Qij_AA[6][16] = 0.321028; Qij_AA[6][17] = 0.018844; Qij_AA[6][18] = 0.055200; Qij_AA[6][19] = 0.205868; 
		Qij_AA[7][0] = 0.876213; Qij_AA[7][1] = 0.156945; Qij_AA[7][2] = 0.362028; Qij_AA[7][3] = 0.311718; Qij_AA[7][4] = 0.050876; 
		Qij_AA[7][5] = 0.128660; Qij_AA[7][6] = 0.250447; Qij_AA[7][7] = 0.000000; Qij_AA[7][8] = 0.058131; Qij_AA[7][9] = 0.051089; 
		Qij_AA[7][10] = 0.087056; Qij_AA[7][11] = 0.193243; Qij_AA[7][12] = 0.046560; Qij_AA[7][13] = 0.050143; Qij_AA[7][14] = 0.124492; 
		Qij_AA[7][15] = 0.612843; Qij_AA[7][16] = 0.136266; Qij_AA[7][17] = 0.023990; Qij_AA[7][18] = 0.037568; Qij_AA[7][19] = 0.082579; 
		Qij_AA[8][0] = 0.078692; Qij_AA[8][1] = 0.213164; Qij_AA[8][2] = 0.290006; Qij_AA[8][3] = 0.134252; Qij_AA[8][4] = 0.016695; 
		Qij_AA[8][5] = 0.315521; Qij_AA[8][6] = 0.104458; Qij_AA[8][7] = 0.058131; Qij_AA[8][8] = 0.000000; Qij_AA[8][9] = 0.020039; 
		Qij_AA[8][10] = 0.103552; Qij_AA[8][11] = 0.153323; Qij_AA[8][12] = 0.021157; Qij_AA[8][13] = 0.079807; Qij_AA[8][14] = 0.078892; 
		Qij_AA[8][15] = 0.167406; Qij_AA[8][16] = 0.101117; Qij_AA[8][17] = 0.020009; Qij_AA[8][18] = 0.286027; Qij_AA[8][19] = 0.068575; 
		Qij_AA[9][0] = 0.222972; Qij_AA[9][1] = 0.081510; Qij_AA[9][2] = 0.087225; Qij_AA[9][3] = 0.011720; Qij_AA[9][4] = 0.046398; 
		Qij_AA[9][5] = 0.054602; Qij_AA[9][6] = 0.046589; Qij_AA[9][7] = 0.051089; Qij_AA[9][8] = 0.020039; Qij_AA[9][9] = 0.000000; 
		Qij_AA[9][10] = 2.089890; Qij_AA[9][11] = 0.093181; Qij_AA[9][12] = 0.493845; Qij_AA[9][13] = 0.321020; Qij_AA[9][14] = 0.054797; 
		Qij_AA[9][15] = 0.081567; Qij_AA[9][16] = 0.376588; Qij_AA[9][17] = 0.034954; Qij_AA[9][18] = 0.086237; Qij_AA[9][19] = 3.654430; 
		Qij_AA[10][0] = 0.424630; Qij_AA[10][1] = 0.192364; Qij_AA[10][2] = 0.069245; Qij_AA[10][3] = 0.060863; Qij_AA[10][4] = 0.091709; 
		Qij_AA[10][5] = 0.243530; Qij_AA[10][6] = 0.151924; Qij_AA[10][7] = 0.087056; Qij_AA[10][8] = 0.103552; Qij_AA[10][9] = 2.089890; 
		Qij_AA[10][10] = 0.000000; Qij_AA[10][11] = 0.201204; Qij_AA[10][12] = 1.105667; Qij_AA[10][13] = 0.946499; Qij_AA[10][14] = 0.169784; 
		Qij_AA[10][15] = 0.214977; Qij_AA[10][16] = 0.243227; Qij_AA[10][17] = 0.083439; Qij_AA[10][18] = 0.189842; Qij_AA[10][19] = 1.337571; 
		Qij_AA[11][0] = 0.393245; Qij_AA[11][1] = 1.755838; Qij_AA[11][2] = 0.503060; Qij_AA[11][3] = 0.261101; Qij_AA[11][4] = 0.004067; 
		Qij_AA[11][5] = 0.738208; Qij_AA[11][6] = 0.888630; Qij_AA[11][7] = 0.193243; Qij_AA[11][8] = 0.153323; Qij_AA[11][9] = 0.093181; 
		Qij_AA[11][10] = 0.201204; Qij_AA[11][11] = 0.000000; Qij_AA[11][12] = 0.096474; Qij_AA[11][13] = 0.038261; Qij_AA[11][14] = 0.212302; 
		Qij_AA[11][15] = 0.400072; Qij_AA[11][16] = 0.446646; Qij_AA[11][17] = 0.023321; Qij_AA[11][18] = 0.068689; Qij_AA[11][19] = 0.144587; 
		Qij_AA[12][0] = 0.211550; Qij_AA[12][1] = 0.087930; Qij_AA[12][2] = 0.057420; Qij_AA[12][3] = 0.012182; Qij_AA[12][4] = 0.023690; 
		Qij_AA[12][5] = 0.120801; Qij_AA[12][6] = 0.058643; Qij_AA[12][7] = 0.046560; Qij_AA[12][8] = 0.021157; Qij_AA[12][9] = 0.493845; 
		Qij_AA[12][10] = 1.105667; Qij_AA[12][11] = 0.096474; Qij_AA[12][12] = 0.000000; Qij_AA[12][13] = 0.173052; Qij_AA[12][14] = 0.010363; 
		Qij_AA[12][15] = 0.090515; Qij_AA[12][16] = 0.184609; Qij_AA[12][17] = 0.022019; Qij_AA[12][18] = 0.073223; Qij_AA[12][19] = 0.307309; 
		Qij_AA[13][0] = 0.116646; Qij_AA[13][1] = 0.042569; Qij_AA[13][2] = 0.039769; Qij_AA[13][3] = 0.016577; Qij_AA[13][4] = 0.051127; 
		Qij_AA[13][5] = 0.026235; Qij_AA[13][6] = 0.028168; Qij_AA[13][7] = 0.050143; Qij_AA[13][8] = 0.079807; Qij_AA[13][9] = 0.321020; 
		Qij_AA[13][10] = 0.946499; Qij_AA[13][11] = 0.038261; Qij_AA[13][12] = 0.173052; Qij_AA[13][13] = 0.000000; Qij_AA[13][14] = 0.042564; 
		Qij_AA[13][15] = 0.138119; Qij_AA[13][16] = 0.085870; Qij_AA[13][17] = 0.128050; Qij_AA[13][18] = 0.898663; Qij_AA[13][19] = 0.247329; 
		Qij_AA[14][0] = 0.399143; Qij_AA[14][1] = 0.128480; Qij_AA[14][2] = 0.083956; Qij_AA[14][3] = 0.160063; Qij_AA[14][4] = 0.011137; 
		Qij_AA[14][5] = 0.156570; Qij_AA[14][6] = 0.205134; Qij_AA[14][7] = 0.124492; Qij_AA[14][8] = 0.078892; Qij_AA[14][9] = 0.054797; 
		Qij_AA[14][10] = 0.169784; Qij_AA[14][11] = 0.212302; Qij_AA[14][12] = 0.010363; Qij_AA[14][13] = 0.042564; Qij_AA[14][14] = 0.000000; 
		Qij_AA[14][15] = 0.430431; Qij_AA[14][16] = 0.207143; Qij_AA[14][17] = 0.014584; Qij_AA[14][18] = 0.032043; Qij_AA[14][19] = 0.129315; 
		Qij_AA[15][0] = 1.817198; Qij_AA[15][1] = 0.292327; Qij_AA[15][2] = 0.847049; Qij_AA[15][3] = 0.461519; Qij_AA[15][4] = 0.175270; 
		Qij_AA[15][5] = 0.358017; Qij_AA[15][6] = 0.406035; Qij_AA[15][7] = 0.612843; Qij_AA[15][8] = 0.167406; Qij_AA[15][9] = 0.081567; 
		Qij_AA[15][10] = 0.214977; Qij_AA[15][11] = 0.400072; Qij_AA[15][12] = 0.090515; Qij_AA[15][13] = 0.138119; Qij_AA[15][14] = 0.430431; 
		Qij_AA[15][15] = 0.000000; Qij_AA[15][16] = 1.767766; Qij_AA[15][17] = 0.035933; Qij_AA[15][18] = 0.121979; Qij_AA[15][19] = 0.127700; 
		Qij_AA[16][0] = 0.877877; Qij_AA[16][1] = 0.204109; Qij_AA[16][2] = 0.471268; Qij_AA[16][3] = 0.178197; Qij_AA[16][4] = 0.079511; 
		Qij_AA[16][5] = 0.248992; Qij_AA[16][6] = 0.321028; Qij_AA[16][7] = 0.136266; Qij_AA[16][8] = 0.101117; Qij_AA[16][9] = 0.376588; 
		Qij_AA[16][10] = 0.243227; Qij_AA[16][11] = 0.446646; Qij_AA[16][12] = 0.184609; Qij_AA[16][13] = 0.085870; Qij_AA[16][14] = 0.207143; 
		Qij_AA[16][15] = 1.767766; Qij_AA[16][16] = 0.000000; Qij_AA[16][17] = 0.020437; Qij_AA[16][18] = 0.094617; Qij_AA[16][19] = 0.740372; 
		Qij_AA[17][0] = 0.030309; Qij_AA[17][1] = 0.046417; Qij_AA[17][2] = 0.010459; Qij_AA[17][3] = 0.011393; Qij_AA[17][4] = 0.007732; 
		Qij_AA[17][5] = 0.021248; Qij_AA[17][6] = 0.018844; Qij_AA[17][7] = 0.023990; Qij_AA[17][8] = 0.020009; Qij_AA[17][9] = 0.034954; 
		Qij_AA[17][10] = 0.083439; Qij_AA[17][11] = 0.023321; Qij_AA[17][12] = 0.022019; Qij_AA[17][13] = 0.128050; Qij_AA[17][14] = 0.014584; 
		Qij_AA[17][15] = 0.035933; Qij_AA[17][16] = 0.020437; Qij_AA[17][17] = 0.000000; Qij_AA[17][18] = 0.124746; Qij_AA[17][19] = 0.022134; 
		Qij_AA[18][0] = 0.087061; Qij_AA[18][1] = 0.097010; Qij_AA[18][2] = 0.093268; Qij_AA[18][3] = 0.051664; Qij_AA[18][4] = 0.042823; 
		Qij_AA[18][5] = 0.062544; Qij_AA[18][6] = 0.055200; Qij_AA[18][7] = 0.037568; Qij_AA[18][8] = 0.286027; Qij_AA[18][9] = 0.086237; 
		Qij_AA[18][10] = 0.189842; Qij_AA[18][11] = 0.068689; Qij_AA[18][12] = 0.073223; Qij_AA[18][13] = 0.898663; Qij_AA[18][14] = 0.032043; 
		Qij_AA[18][15] = 0.121979; Qij_AA[18][16] = 0.094617; Qij_AA[18][17] = 0.124746; Qij_AA[18][18] = 0.000000; Qij_AA[18][19] = 0.125733; 
		Qij_AA[19][0] = 1.230985; Qij_AA[19][1] = 0.113146; Qij_AA[19][2] = 0.049824; Qij_AA[19][3] = 0.048769; Qij_AA[19][4] = 0.163831; 
		Qij_AA[19][5] = 0.112027; Qij_AA[19][6] = 0.205868; Qij_AA[19][7] = 0.082579; Qij_AA[19][8] = 0.068575; Qij_AA[19][9] = 3.654430; 
		Qij_AA[19][10] = 1.337571; Qij_AA[19][11] = 0.144587; Qij_AA[19][12] = 0.307309; Qij_AA[19][13] = 0.247329; Qij_AA[19][14] = 0.129315; 
		Qij_AA[19][15] = 0.127700; Qij_AA[19][16] = 0.740372; Qij_AA[19][17] = 0.022134; Qij_AA[19][18] = 0.125733; Qij_AA[19][19] = 0.000000; 

	
		AA_EM_Pi[0] = 0.078837;
		AA_EM_Pi[1] = 0.051238;
		AA_EM_Pi[2] = 0.042313;
		AA_EM_Pi[3] = 0.053066;
		AA_EM_Pi[4] = 0.015175;
		AA_EM_Pi[5] = 0.036713;
		AA_EM_Pi[6] = 0.061924;
		AA_EM_Pi[7] = 0.070852;
		AA_EM_Pi[8] = 0.023082;
		AA_EM_Pi[9] = 0.062056;
		AA_EM_Pi[10] = 0.096371;
		AA_EM_Pi[11] = 0.057324;
		AA_EM_Pi[12] = 0.023771;
		AA_EM_Pi[13] = 0.043296;
		AA_EM_Pi[14] = 0.043911;
		AA_EM_Pi[15] = 0.063403;
		AA_EM_Pi[16] = 0.055897;
		AA_EM_Pi[17] = 0.013272;
		AA_EM_Pi[18] = 0.034399;
		AA_EM_Pi[19] = 0.073101;
		}
	else if (doWAG == YES) 
		{
		Qij_AA[0][0] = 0.0000000; Qij_AA[1][0] = 0.5515710; Qij_AA[2][0] = 0.5098480; Qij_AA[3][0] = 0.7389980; Qij_AA[4][0] = 1.0270400; 
		Qij_AA[5][0] = 0.9085980; Qij_AA[6][0] = 1.5828500; Qij_AA[7][0] = 1.4167200; Qij_AA[8][0] = 0.3169540; Qij_AA[9][0] = 0.1933350; 
		Qij_AA[10][0] = 0.3979150; Qij_AA[11][0] = 0.9062650; Qij_AA[12][0] = 0.8934960; Qij_AA[13][0] = 0.2104940; Qij_AA[14][0] = 1.4385500; 
		Qij_AA[15][0] = 3.3707900; Qij_AA[16][0] = 2.1211100; Qij_AA[17][0] = 0.1131330; Qij_AA[18][0] = 0.2407350; Qij_AA[19][0] = 2.0060100;
		Qij_AA[0][1] = 0.5515710; Qij_AA[1][1] = 0.0000000; Qij_AA[2][1] = 0.6353460; Qij_AA[3][1] = 0.1473040; Qij_AA[4][1] = 0.5281910;  
		Qij_AA[5][1] = 3.0355000; Qij_AA[6][1] = 0.4391570; Qij_AA[7][1] = 0.5846650; Qij_AA[8][1] = 2.1371500; Qij_AA[9][1] = 0.1869790;  
		Qij_AA[10][1] = 0.4976710; Qij_AA[11][1] = 5.3514200; Qij_AA[12][1] = 0.6831620; Qij_AA[13][1] = 0.1027110; Qij_AA[14][1] = 0.6794890;  
		Qij_AA[15][1] = 1.2241900; Qij_AA[16][1] = 0.5544130; Qij_AA[17][1] = 1.1639200; Qij_AA[18][1] = 0.3815330; Qij_AA[19][1] = 0.2518490;
		Qij_AA[0][2] = 0.5098480; Qij_AA[1][2] = 0.6353460; Qij_AA[2][2] = 0.0000000; Qij_AA[3][2] = 5.4294200; Qij_AA[4][2] = 0.2652560;  
		Qij_AA[5][2] = 1.5436400; Qij_AA[6][2] = 0.9471980; Qij_AA[7][2] = 1.1255600; Qij_AA[8][2] = 3.9562900; Qij_AA[9][2] = 0.5542360;  
		Qij_AA[10][2] = 0.1315280; Qij_AA[11][2] = 3.0120100; Qij_AA[12][2] = 0.1982210; Qij_AA[13][2] = 0.0961621; Qij_AA[14][2] = 0.1950810;  
		Qij_AA[15][2] = 3.9742300; Qij_AA[16][2] = 2.0300600; Qij_AA[17][2] = 0.0719167; Qij_AA[18][2] = 1.0860000; Qij_AA[19][2] = 0.1962460;
		Qij_AA[0][3] = 0.7389980; Qij_AA[1][3] = 0.1473040; Qij_AA[2][3] = 5.4294200; Qij_AA[3][3] = 0.0000000; Qij_AA[4][3] = 0.0302949;  
		Qij_AA[5][3] = 0.6167830; Qij_AA[6][3] = 6.1741600; Qij_AA[7][3] = 0.8655840; Qij_AA[8][3] = 0.9306760; Qij_AA[9][3] = 0.0394370;  
		Qij_AA[10][3] = 0.0848047; Qij_AA[11][3] = 0.4798550; Qij_AA[12][3] = 0.1037540; Qij_AA[13][3] = 0.0467304; Qij_AA[14][3] = 0.4239840;  
		Qij_AA[15][3] = 1.0717600; Qij_AA[16][3] = 0.3748660; Qij_AA[17][3] = 0.1297670; Qij_AA[18][3] = 0.3257110; Qij_AA[19][3] = 0.1523350;
		Qij_AA[0][4] = 1.0270400; Qij_AA[1][4] = 0.5281910; Qij_AA[2][4] = 0.2652560; Qij_AA[3][4] = 0.0302949; Qij_AA[4][4] = 0.0000000;  
		Qij_AA[5][4] = 0.0988179; Qij_AA[6][4] = 0.0213520; Qij_AA[7][4] = 0.3066740; Qij_AA[8][4] = 0.2489720; Qij_AA[9][4] = 0.1701350;  
		Qij_AA[10][4] = 0.3842870; Qij_AA[11][4] = 0.0740339; Qij_AA[12][4] = 0.3904820; Qij_AA[13][4] = 0.3980200; Qij_AA[14][4] = 0.1094040;  
		Qij_AA[15][4] = 1.4076600; Qij_AA[16][4] = 0.5129840; Qij_AA[17][4] = 0.7170700; Qij_AA[18][4] = 0.5438330; Qij_AA[19][4] = 1.0021400;
		Qij_AA[0][5] = 0.9085980; Qij_AA[1][5] = 3.0355000; Qij_AA[2][5] = 1.5436400; Qij_AA[3][5] = 0.6167830; Qij_AA[4][5] = 0.0988179;  
		Qij_AA[5][5] = 0.0000000; Qij_AA[6][5] = 5.4694700; Qij_AA[7][5] = 0.3300520; Qij_AA[8][5] = 4.2941100; Qij_AA[9][5] = 0.1139170;  
		Qij_AA[10][5] = 0.8694890; Qij_AA[11][5] = 3.8949000; Qij_AA[12][5] = 1.5452600; Qij_AA[13][5] = 0.0999208; Qij_AA[14][5] = 0.9333720;  
		Qij_AA[15][5] = 1.0288700; Qij_AA[16][5] = 0.8579280; Qij_AA[17][5] = 0.2157370; Qij_AA[18][5] = 0.2277100; Qij_AA[19][5] = 0.3012810;
		Qij_AA[0][6] = 1.5828500; Qij_AA[1][6] = 0.4391570; Qij_AA[2][6] = 0.9471980; Qij_AA[3][6] = 6.1741600; Qij_AA[4][6] = 0.0213520;  
		Qij_AA[5][6] = 5.4694700; Qij_AA[6][6] = 0.0000000; Qij_AA[7][6] = 0.5677170; Qij_AA[8][6] = 0.5700250; Qij_AA[9][6] = 0.1273950;  
		Qij_AA[10][6] = 0.1542630; Qij_AA[11][6] = 2.5844300; Qij_AA[12][6] = 0.3151240; Qij_AA[13][6] = 0.0811339; Qij_AA[14][6] = 0.6823550;  
		Qij_AA[15][6] = 0.7049390; Qij_AA[16][6] = 0.8227650; Qij_AA[17][6] = 0.1565570; Qij_AA[18][6] = 0.1963030; Qij_AA[19][6] = 0.5887310;
		Qij_AA[0][7] = 1.4167200; Qij_AA[1][7] = 0.5846650; Qij_AA[2][7] = 1.1255600; Qij_AA[3][7] = 0.8655840; Qij_AA[4][7] = 0.3066740;  
		Qij_AA[5][7] = 0.3300520; Qij_AA[6][7] = 0.5677170; Qij_AA[7][7] = 0.0000000; Qij_AA[8][7] = 0.2494100; Qij_AA[9][7] = 0.0304501;  
		Qij_AA[10][7] = 0.0613037; Qij_AA[11][7] = 0.3735580; Qij_AA[12][7] = 0.1741000; Qij_AA[13][7] = 0.0499310; Qij_AA[14][7] = 0.2435700;  
		Qij_AA[15][7] = 1.3418200; Qij_AA[16][7] = 0.2258330; Qij_AA[17][7] = 0.3369830; Qij_AA[18][7] = 0.1036040; Qij_AA[19][7] = 0.1872470;
		Qij_AA[0][8] = 0.3169540; Qij_AA[1][8] = 2.1371500; Qij_AA[2][8] = 3.9562900; Qij_AA[3][8] = 0.9306760; Qij_AA[4][8] = 0.2489720;  
		Qij_AA[5][8] = 4.2941100; Qij_AA[6][8] = 0.5700250; Qij_AA[7][8] = 0.2494100; Qij_AA[8][8] = 0.0000000; Qij_AA[9][8] = 0.1381900;  
		Qij_AA[10][8] = 0.4994620; Qij_AA[11][8] = 0.8904320; Qij_AA[12][8] = 0.4041410; Qij_AA[13][8] = 0.6793710; Qij_AA[14][8] = 0.6961980;  
		Qij_AA[15][8] = 0.7401690; Qij_AA[16][8] = 0.4733070; Qij_AA[17][8] = 0.2625690; Qij_AA[18][8] = 3.8734400; Qij_AA[19][8] = 0.1183580;
		Qij_AA[0][9] = 0.1933350; Qij_AA[1][9] = 0.1869790; Qij_AA[2][9] = 0.5542360; Qij_AA[3][9] = 0.0394370; Qij_AA[4][9] = 0.1701350;  
		Qij_AA[5][9] = 0.1139170; Qij_AA[6][9] = 0.1273950; Qij_AA[7][9] = 0.0304501; Qij_AA[8][9] = 0.1381900; Qij_AA[9][9] = 0.0000000;  
		Qij_AA[10][9] = 3.1709700; Qij_AA[11][9] = 0.3238320; Qij_AA[12][9] = 4.2574600; Qij_AA[13][9] = 1.0594700; Qij_AA[14][9] = 0.0999288;  
		Qij_AA[15][9] = 0.3194400; Qij_AA[16][9] = 1.4581600; Qij_AA[17][9] = 0.2124830; Qij_AA[18][9] = 0.4201700; Qij_AA[19][9] = 7.8213000;
		Qij_AA[0][10] = 0.3979150; Qij_AA[1][10] = 0.4976710; Qij_AA[2][10] = 0.1315280; Qij_AA[3][10] = 0.0848047; Qij_AA[4][10] = 0.3842870;  
		Qij_AA[5][10] = 0.8694890; Qij_AA[6][10] = 0.1542630; Qij_AA[7][10] = 0.0613037; Qij_AA[8][10] = 0.4994620; Qij_AA[9][10] = 3.1709700;  
		Qij_AA[10][10] = 0.0000000; Qij_AA[11][10] = 0.2575550; Qij_AA[12][10] = 4.8540200; Qij_AA[13][10] = 2.1151700; Qij_AA[14][10] = 0.4158440;  
		Qij_AA[15][10] = 0.3447390; Qij_AA[16][10] = 0.3266220; Qij_AA[17][10] = 0.6653090; Qij_AA[18][10] = 0.3986180; Qij_AA[19][10] = 1.8003400;
		Qij_AA[0][11] = 0.9062650; Qij_AA[1][11] = 5.3514200; Qij_AA[2][11] = 3.0120100; Qij_AA[3][11] = 0.4798550; Qij_AA[4][11] = 0.0740339;  
		Qij_AA[5][11] = 3.8949000; Qij_AA[6][11] = 2.5844300; Qij_AA[7][11] = 0.3735580; Qij_AA[8][11] = 0.8904320; Qij_AA[9][11] = 0.3238320;  
		Qij_AA[10][11] = 0.2575550; Qij_AA[11][11] = 0.0000000; Qij_AA[12][11] = 0.9342760; Qij_AA[13][11] = 0.0888360; Qij_AA[14][11] = 0.5568960;  
		Qij_AA[15][11] = 0.9671300; Qij_AA[16][11] = 1.3869800; Qij_AA[17][11] = 0.1375050; Qij_AA[18][11] = 0.1332640; Qij_AA[19][11] = 0.3054340;
		Qij_AA[0][12] = 0.8934960; Qij_AA[1][12] = 0.6831620; Qij_AA[2][12] = 0.1982210; Qij_AA[3][12] = 0.1037540; Qij_AA[4][12] = 0.3904820;  
		Qij_AA[5][12] = 1.5452600; Qij_AA[6][12] = 0.3151240; Qij_AA[7][12] = 0.1741000; Qij_AA[8][12] = 0.4041410; Qij_AA[9][12] = 4.2574600;  
		Qij_AA[10][12] = 4.8540200; Qij_AA[11][12] = 0.9342760; Qij_AA[12][12] = 0.0000000; Qij_AA[13][12] = 1.1906300; Qij_AA[14][12] = 0.1713290;  
		Qij_AA[15][12] = 0.4939050; Qij_AA[16][12] = 1.5161200; Qij_AA[17][12] = 0.5157060; Qij_AA[18][12] = 0.4284370; Qij_AA[19][12] = 2.0584500;
		Qij_AA[0][13] = 0.2104940; Qij_AA[1][13] = 0.1027110; Qij_AA[2][13] = 0.0961621; Qij_AA[3][13] = 0.0467304; Qij_AA[4][13] = 0.3980200;  
		Qij_AA[5][13] = 0.0999208; Qij_AA[6][13] = 0.0811339; Qij_AA[7][13] = 0.0499310; Qij_AA[8][13] = 0.6793710; Qij_AA[9][13] = 1.0594700;  
		Qij_AA[10][13] = 2.1151700; Qij_AA[11][13] = 0.0888360; Qij_AA[12][13] = 1.1906300; Qij_AA[13][13] = 0.0000000; Qij_AA[14][13] = 0.1614440;  
		Qij_AA[15][13] = 0.5459310; Qij_AA[16][13] = 0.1719030; Qij_AA[17][13] = 1.5296400; Qij_AA[18][13] = 6.4542800; Qij_AA[19][13] = 0.6498920;
		Qij_AA[0][14] = 1.4385500; Qij_AA[1][14] = 0.6794890; Qij_AA[2][14] = 0.1950810; Qij_AA[3][14] = 0.4239840; Qij_AA[4][14] = 0.1094040;  
		Qij_AA[5][14] = 0.9333720; Qij_AA[6][14] = 0.6823550; Qij_AA[7][14] = 0.2435700; Qij_AA[8][14] = 0.6961980; Qij_AA[9][14] = 0.0999288;  
		Qij_AA[10][14] = 0.4158440; Qij_AA[11][14] = 0.5568960; Qij_AA[12][14] = 0.1713290; Qij_AA[13][14] = 0.1614440; Qij_AA[14][14] = 0.0000000;  
		Qij_AA[15][14] = 1.6132800; Qij_AA[16][14] = 0.7953840; Qij_AA[17][14] = 0.1394050; Qij_AA[18][14] = 0.2160460; Qij_AA[19][14] = 0.3148870;
		Qij_AA[0][15] = 3.3707900; Qij_AA[1][15] = 1.2241900; Qij_AA[2][15] = 3.9742300; Qij_AA[3][15] = 1.0717600; Qij_AA[4][15] = 1.4076600;  
		Qij_AA[5][15] = 1.0288700; Qij_AA[6][15] = 0.7049390; Qij_AA[7][15] = 1.3418200; Qij_AA[8][15] = 0.7401690; Qij_AA[9][15] = 0.3194400;  
		Qij_AA[10][15] = 0.3447390; Qij_AA[11][15] = 0.9671300; Qij_AA[12][15] = 0.4939050; Qij_AA[13][15] = 0.5459310; Qij_AA[14][15] = 1.6132800;  
		Qij_AA[15][15] = 0.0000000; Qij_AA[16][15] = 4.3780200; Qij_AA[17][15] = 0.5237420; Qij_AA[18][15] = 0.7869930; Qij_AA[19][15] = 0.2327390;
		Qij_AA[0][16] = 2.1211100; Qij_AA[1][16] = 0.5544130; Qij_AA[2][16] = 2.0300600; Qij_AA[3][16] = 0.3748660; Qij_AA[4][16] = 0.5129840;  
		Qij_AA[5][16] = 0.8579280; Qij_AA[6][16] = 0.8227650; Qij_AA[7][16] = 0.2258330; Qij_AA[8][16] = 0.4733070; Qij_AA[9][16] = 1.4581600;  
		Qij_AA[10][16] = 0.3266220; Qij_AA[11][16] = 1.3869800; Qij_AA[12][16] = 1.5161200; Qij_AA[13][16] = 0.1719030; Qij_AA[14][16] = 0.7953840;  
		Qij_AA[15][16] = 4.3780200; Qij_AA[16][16] = 0.0000000; Qij_AA[17][16] = 0.1108640; Qij_AA[18][16] = 0.2911480; Qij_AA[19][16] = 1.3882300;
		Qij_AA[0][17] = 0.1131330; Qij_AA[1][17] = 1.1639200; Qij_AA[2][17] = 0.0719167; Qij_AA[3][17] = 0.1297670; Qij_AA[4][17] = 0.7170700;  
		Qij_AA[5][17] = 0.2157370; Qij_AA[6][17] = 0.1565570; Qij_AA[7][17] = 0.3369830; Qij_AA[8][17] = 0.2625690; Qij_AA[9][17] = 0.2124830;  
		Qij_AA[10][17] = 0.6653090; Qij_AA[11][17] = 0.1375050; Qij_AA[12][17] = 0.5157060; Qij_AA[13][17] = 1.5296400; Qij_AA[14][17] = 0.1394050;  
		Qij_AA[15][17] = 0.5237420; Qij_AA[16][17] = 0.1108640; Qij_AA[17][17] = 0.0000000; Qij_AA[18][17] = 2.4853900; Qij_AA[19][17] = 0.3653690;
		Qij_AA[0][18] = 0.2407350; Qij_AA[1][18] = 0.3815330; Qij_AA[2][18] = 1.0860000; Qij_AA[3][18] = 0.3257110; Qij_AA[4][18] = 0.5438330;  
		Qij_AA[5][18] = 0.2277100; Qij_AA[6][18] = 0.1963030; Qij_AA[7][18] = 0.1036040; Qij_AA[8][18] = 3.8734400; Qij_AA[9][18] = 0.4201700;  
		Qij_AA[10][18] = 0.3986180; Qij_AA[11][18] = 0.1332640; Qij_AA[12][18] = 0.4284370; Qij_AA[13][18] = 6.4542800; Qij_AA[14][18] = 0.2160460;  
		Qij_AA[15][18] = 0.7869930; Qij_AA[16][18] = 0.2911480; Qij_AA[17][18] = 2.4853900; Qij_AA[18][18] = 0.0000000; Qij_AA[19][18] = 0.3147300;
		Qij_AA[0][19] = 2.0060100; Qij_AA[1][19] = 0.2518490; Qij_AA[2][19] = 0.1962460; Qij_AA[3][19] = 0.1523350; Qij_AA[4][19] = 1.0021400;  
		Qij_AA[5][19] = 0.3012810; Qij_AA[6][19] = 0.5887310; Qij_AA[7][19] = 0.1872470; Qij_AA[8][19] = 0.1183580; Qij_AA[9][19] = 7.8213000;  
		Qij_AA[10][19] = 1.8003400; Qij_AA[11][19] = 0.3054340; Qij_AA[12][19] = 2.0584500; Qij_AA[13][19] = 0.6498920; Qij_AA[14][19] = 0.3148870;  
		Qij_AA[15][19] = 0.2327390; Qij_AA[16][19] = 1.3882300; Qij_AA[17][19] = 0.3653690; Qij_AA[18][19] = 0.3147300; Qij_AA[19][19] = 0.0000000;


		AA_EM_Pi[0] = 0.08662790;
		AA_EM_Pi[1] = 0.04397200;
		AA_EM_Pi[2] = 0.03908940;
		AA_EM_Pi[3] = 0.05704510;
		AA_EM_Pi[4] = 0.01930780;
		AA_EM_Pi[5] = 0.03672810;
		AA_EM_Pi[6] = 0.05805890;
		AA_EM_Pi[7] = 0.08325180;
		AA_EM_Pi[8] = 0.02443130;
		AA_EM_Pi[9] = 0.04846600;
		AA_EM_Pi[10] = 0.08620970;
		AA_EM_Pi[11] = 0.06202860;
		AA_EM_Pi[12] = 0.01950273;
		AA_EM_Pi[13] = 0.03843190;
		AA_EM_Pi[14] = 0.04576310;
		AA_EM_Pi[15] = 0.06951790;
		AA_EM_Pi[16] = 0.06101270;
		AA_EM_Pi[17] = 0.01438590;
		AA_EM_Pi[18] = 0.03527420;
		AA_EM_Pi[19] = 0.07089560;
		}
	else if (doEAAMUser == YES)
		{
		for (i = 0; i < NUMAA; i++)
			for (j = 0; j < NUMAA; j++)
				{
				Qij_AA[i][j] = Qij_AAuser[i][j];
				}
		for (j = 0; j < NUMAA; j++)
			AA_EM_Pi[j] = FreqsAAUser[j];

		/* Qij_AAuser[NUMAA][NUMAA], FreqsAAUser[NUMAA]; */
		}
	else
		{
		fprintf (fpmpi, "\nWarning in Empirical_AA_model function: The Empirical model was not detected");		
		exit(-1);
		}

	/* fprintf (stderr, "\n In Empirical_AA_model function: OK \n"); */
		
	}





/****************************** Empirical_Codon_model *******************************/
/*Empirical codon models*/
 static void Empirical_Codon_model ()
	{
	int i, j, a, b;
	double Qij_ECM_Init[NUMCOD][NUMCOD], Freq_ECM_Init[NUMCOD];
	
	/*fprintf (stderr,"\n\n In Empirical_Codon_model \n\n");*/	
		/* initiallity */
	a = b = 0;

	for (i = 0; i < NUMCOD; i++)
		{
		for (j = 0; j < NUMCOD; j++)
			Qij_ECM_Init[i][j] = -1;
		}
	for (i = 0; i < NUMCOD; i++)
		Freq_ECM_Init[i] = -1;



	if (doECMrest == YES) /* Kosiol et al */
		{
		/*fprintf (stderr,"     Model: ECMrest \n\n");*/	
		

		/*  Original matrix */
		/* TTT TTC TTA TTG TCT TCC TCA TCG TAT TAC TGT TGC TGG CTT CTC CTA CTG CCT CCC CCA 
		CCG CAT CAC CAA CAG CGT CGC CGA CGG ATT ATC ATA ATG ACT ACC ACA ACG AAT AAC AAA 
		AAG AGT AGC AGA AGG GTT GTC GTA GTG GCT GCC GCA GCG GAT GAC GAA GAG GGT GGC GGA 
		GGG */
			
		Qij_ECM_Init[1][0] = 11.192024; 
		Qij_ECM_Init[2][0] = 1.315610; Qij_ECM_Init[2][1] = 0.010896; 
		Qij_ECM_Init[3][0] = 5.427076; Qij_ECM_Init[3][1] = 4.756288; Qij_ECM_Init[3][2] = 24.748755; 
		Qij_ECM_Init[4][0] = 1.658051; Qij_ECM_Init[4][1] = 0.000000; Qij_ECM_Init[4][2] = 0.000000; Qij_ECM_Init[4][3] = 0.000000; 
		Qij_ECM_Init[5][0] = 0.000000; Qij_ECM_Init[5][1] = 1.913571; Qij_ECM_Init[5][2] = 0.000000; Qij_ECM_Init[5][3] = 0.000000; Qij_ECM_Init[5][4] = 13.889102; 
		Qij_ECM_Init[6][0] = 0.000000; Qij_ECM_Init[6][1] = 0.000000; Qij_ECM_Init[6][2] = 2.952332; Qij_ECM_Init[6][3] = 0.000000; Qij_ECM_Init[6][4] = 44.407955; Qij_ECM_Init[6][5] = 13.681751; 
		Qij_ECM_Init[7][0] = 0.000000; Qij_ECM_Init[7][1] = 0.000000; Qij_ECM_Init[7][2] = 0.000000; Qij_ECM_Init[7][3] = 8.126914; Qij_ECM_Init[7][4] = 17.057443; Qij_ECM_Init[7][5] = 65.097021; Qij_ECM_Init[7][6] = 12.991861; 
		Qij_ECM_Init[8][0] = 6.610894; Qij_ECM_Init[8][1] = 0.000000; Qij_ECM_Init[8][2] = 0.000000; Qij_ECM_Init[8][3] = 0.000000; Qij_ECM_Init[8][4] = 2.206054; Qij_ECM_Init[8][5] = 0.000000; Qij_ECM_Init[8][6] = 0.000000; Qij_ECM_Init[8][7] = 0.000000; 
		Qij_ECM_Init[9][0] = 0.000000; Qij_ECM_Init[9][1] = 5.177930; Qij_ECM_Init[9][2] = 0.000000; Qij_ECM_Init[9][3] = 0.000000; Qij_ECM_Init[9][4] = 0.000000; Qij_ECM_Init[9][5] = 5.615472; Qij_ECM_Init[9][6] = 0.000000; Qij_ECM_Init[9][7] = 0.000000; Qij_ECM_Init[9][8] = 19.942818; 
		Qij_ECM_Init[10][0] = 3.347364; Qij_ECM_Init[10][1] = 0.000000; Qij_ECM_Init[10][2] = 0.000000; Qij_ECM_Init[10][3] = 0.000000; Qij_ECM_Init[10][4] = 6.191481; Qij_ECM_Init[10][5] = 0.000000; Qij_ECM_Init[10][6] = 0.000000; Qij_ECM_Init[10][7] = 0.000000; Qij_ECM_Init[10][8] = 0.582084; Qij_ECM_Init[10][9] = 0.000000; 
		Qij_ECM_Init[11][0] = 0.000000; Qij_ECM_Init[11][1] = 1.558523; Qij_ECM_Init[11][2] = 0.000000; Qij_ECM_Init[11][3] = 0.000000; Qij_ECM_Init[11][4] = 0.000000; Qij_ECM_Init[11][5] = 9.339206; Qij_ECM_Init[11][6] = 0.000000; Qij_ECM_Init[11][7] = 0.000000; Qij_ECM_Init[11][8] = 0.000000; Qij_ECM_Init[11][9] = 0.144278; Qij_ECM_Init[11][10] = 44.777964; 
		Qij_ECM_Init[12][0] = 0.000000; Qij_ECM_Init[12][1] = 0.000000; Qij_ECM_Init[12][2] = 0.000000; Qij_ECM_Init[12][3] = 5.369644; Qij_ECM_Init[12][4] = 0.000000; Qij_ECM_Init[12][5] = 0.000000; Qij_ECM_Init[12][6] = 0.000000; Qij_ECM_Init[12][7] = 4.662001; Qij_ECM_Init[12][8] = 0.000000; Qij_ECM_Init[12][9] = 0.000000; Qij_ECM_Init[12][10] = 0.677177; Qij_ECM_Init[12][11] = 0.073268; 
		Qij_ECM_Init[13][0] = 2.090751; Qij_ECM_Init[13][1] = 0.000000; Qij_ECM_Init[13][2] = 0.000000; Qij_ECM_Init[13][3] = 0.000000; Qij_ECM_Init[13][4] = 0.000000; Qij_ECM_Init[13][5] = 0.000000; Qij_ECM_Init[13][6] = 0.000000; Qij_ECM_Init[13][7] = 0.000000; Qij_ECM_Init[13][8] = 0.000000; Qij_ECM_Init[13][9] = 0.000000; Qij_ECM_Init[13][10] = 0.000000; Qij_ECM_Init[13][11] = 0.000000; Qij_ECM_Init[13][12] = 0.000000; 
		Qij_ECM_Init[14][0] = 0.000000; Qij_ECM_Init[14][1] = 2.266373; Qij_ECM_Init[14][2] = 0.000000; Qij_ECM_Init[14][3] = 0.000000; Qij_ECM_Init[14][4] = 0.000000; Qij_ECM_Init[14][5] = 0.000000; Qij_ECM_Init[14][6] = 0.000000; Qij_ECM_Init[14][7] = 0.000000; Qij_ECM_Init[14][8] = 0.000000; Qij_ECM_Init[14][9] = 0.000000; Qij_ECM_Init[14][10] = 0.000000; Qij_ECM_Init[14][11] = 0.000000; Qij_ECM_Init[14][12] = 0.000000; Qij_ECM_Init[14][13] = 8.905484; 
		Qij_ECM_Init[15][0] = 0.000000; Qij_ECM_Init[15][1] = 0.000000; Qij_ECM_Init[15][2] = 75.752638; Qij_ECM_Init[15][3] = 0.000000; Qij_ECM_Init[15][4] = 0.000000; Qij_ECM_Init[15][5] = 0.000000; Qij_ECM_Init[15][6] = 0.000000; Qij_ECM_Init[15][7] = 0.000000; Qij_ECM_Init[15][8] = 0.000000; Qij_ECM_Init[15][9] = 0.000000; Qij_ECM_Init[15][10] = 0.000000; Qij_ECM_Init[15][11] = 0.000000; Qij_ECM_Init[15][12] = 0.000000; Qij_ECM_Init[15][13] = 56.803876; Qij_ECM_Init[15][14] = 7.811205; 
		Qij_ECM_Init[16][0] = 0.000000; Qij_ECM_Init[16][1] = 0.000000; Qij_ECM_Init[16][2] = 0.000000; Qij_ECM_Init[16][3] = 20.877218; Qij_ECM_Init[16][4] = 0.000000; Qij_ECM_Init[16][5] = 0.000000; Qij_ECM_Init[16][6] = 0.000000; Qij_ECM_Init[16][7] = 0.000000; Qij_ECM_Init[16][8] = 0.000000; Qij_ECM_Init[16][9] = 0.000000; Qij_ECM_Init[16][10] = 0.000000; Qij_ECM_Init[16][11] = 0.000000; Qij_ECM_Init[16][12] = 0.000000; Qij_ECM_Init[16][13] = 8.432339; Qij_ECM_Init[16][14] = 22.078564; Qij_ECM_Init[16][15] = 5.650116; 
		Qij_ECM_Init[17][0] = 0.000000; Qij_ECM_Init[17][1] = 0.000000; Qij_ECM_Init[17][2] = 0.000000; Qij_ECM_Init[17][3] = 0.000000; Qij_ECM_Init[17][4] = 1.769355; Qij_ECM_Init[17][5] = 0.000000; Qij_ECM_Init[17][6] = 0.000000; Qij_ECM_Init[17][7] = 0.000000; Qij_ECM_Init[17][8] = 0.000000; Qij_ECM_Init[17][9] = 0.000000; Qij_ECM_Init[17][10] = 0.000000; Qij_ECM_Init[17][11] = 0.000000; Qij_ECM_Init[17][12] = 0.000000; Qij_ECM_Init[17][13] = 1.263838; Qij_ECM_Init[17][14] = 0.000000; Qij_ECM_Init[17][15] = 0.000000; Qij_ECM_Init[17][16] = 0.000000; 
		Qij_ECM_Init[18][0] = 0.000000; Qij_ECM_Init[18][1] = 0.000000; Qij_ECM_Init[18][2] = 0.000000; Qij_ECM_Init[18][3] = 0.000000; Qij_ECM_Init[18][4] = 0.000000; Qij_ECM_Init[18][5] = 2.704601; Qij_ECM_Init[18][6] = 0.000000; Qij_ECM_Init[18][7] = 0.000000; Qij_ECM_Init[18][8] = 0.000000; Qij_ECM_Init[18][9] = 0.000000; Qij_ECM_Init[18][10] = 0.000000; Qij_ECM_Init[18][11] = 0.000000; Qij_ECM_Init[18][12] = 0.000000; Qij_ECM_Init[18][13] = 0.000000; Qij_ECM_Init[18][14] = 1.389735; Qij_ECM_Init[18][15] = 0.000000; Qij_ECM_Init[18][16] = 0.000000; Qij_ECM_Init[18][17] = 17.461627; 
		Qij_ECM_Init[19][0] = 0.000000; Qij_ECM_Init[19][1] = 0.000000; Qij_ECM_Init[19][2] = 0.000000; Qij_ECM_Init[19][3] = 0.000000; Qij_ECM_Init[19][4] = 0.000000; Qij_ECM_Init[19][5] = 0.000000; Qij_ECM_Init[19][6] = 3.312811; Qij_ECM_Init[19][7] = 0.000000; Qij_ECM_Init[19][8] = 0.000000; Qij_ECM_Init[19][9] = 0.000000; Qij_ECM_Init[19][10] = 0.000000; Qij_ECM_Init[19][11] = 0.000000; Qij_ECM_Init[19][12] = 0.000000; Qij_ECM_Init[19][13] = 0.000000; Qij_ECM_Init[19][14] = 0.000000; Qij_ECM_Init[19][15] = 1.393680; Qij_ECM_Init[19][16] = 0.000000; Qij_ECM_Init[19][17] = 35.480963; Qij_ECM_Init[19][18] = 12.053827; 
		Qij_ECM_Init[20][0] = 0.000000; Qij_ECM_Init[20][1] = 0.000000; Qij_ECM_Init[20][2] = 0.000000; Qij_ECM_Init[20][3] = 0.000000; Qij_ECM_Init[20][4] = 0.000000; Qij_ECM_Init[20][5] = 0.000000; Qij_ECM_Init[20][6] = 0.000000; Qij_ECM_Init[20][7] = 1.303480; Qij_ECM_Init[20][8] = 0.000000; Qij_ECM_Init[20][9] = 0.000000; Qij_ECM_Init[20][10] = 0.000000; Qij_ECM_Init[20][11] = 0.000000; Qij_ECM_Init[20][12] = 0.000000; Qij_ECM_Init[20][13] = 0.000000; Qij_ECM_Init[20][14] = 0.000000; Qij_ECM_Init[20][15] = 0.000000; Qij_ECM_Init[20][16] = 0.477616; Qij_ECM_Init[20][17] = 8.407091; Qij_ECM_Init[20][18] = 28.557939; Qij_ECM_Init[20][19] = 11.295213; 
		Qij_ECM_Init[21][0] = 0.000000; Qij_ECM_Init[21][1] = 0.000000; Qij_ECM_Init[21][2] = 0.000000; Qij_ECM_Init[21][3] = 0.000000; Qij_ECM_Init[21][4] = 0.000000; Qij_ECM_Init[21][5] = 0.000000; Qij_ECM_Init[21][6] = 0.000000; Qij_ECM_Init[21][7] = 0.000000; Qij_ECM_Init[21][8] = 3.444964; Qij_ECM_Init[21][9] = 0.000000; Qij_ECM_Init[21][10] = 0.000000; Qij_ECM_Init[21][11] = 0.000000; Qij_ECM_Init[21][12] = 0.000000; Qij_ECM_Init[21][13] = 1.583116; Qij_ECM_Init[21][14] = 0.000000; Qij_ECM_Init[21][15] = 0.000000; Qij_ECM_Init[21][16] = 0.000000; Qij_ECM_Init[21][17] = 1.021682; Qij_ECM_Init[21][18] = 0.000000; Qij_ECM_Init[21][19] = 0.000000; Qij_ECM_Init[21][20] = 0.000000; 
		Qij_ECM_Init[22][0] = 0.000000; Qij_ECM_Init[22][1] = 0.000000; Qij_ECM_Init[22][2] = 0.000000; Qij_ECM_Init[22][3] = 0.000000; Qij_ECM_Init[22][4] = 0.000000; Qij_ECM_Init[22][5] = 0.000000; Qij_ECM_Init[22][6] = 0.000000; Qij_ECM_Init[22][7] = 0.000000; Qij_ECM_Init[22][8] = 0.000000; Qij_ECM_Init[22][9] = 7.087801; Qij_ECM_Init[22][10] = 0.000000; Qij_ECM_Init[22][11] = 0.000000; Qij_ECM_Init[22][12] = 0.000000; Qij_ECM_Init[22][13] = 0.000000; Qij_ECM_Init[22][14] = 3.230751; Qij_ECM_Init[22][15] = 0.000000; Qij_ECM_Init[22][16] = 0.000000; Qij_ECM_Init[22][17] = 0.000000; Qij_ECM_Init[22][18] = 3.774544; Qij_ECM_Init[22][19] = 0.000000; Qij_ECM_Init[22][20] = 0.000000; Qij_ECM_Init[22][21] = 28.086160; 
		Qij_ECM_Init[23][0] = 0.000000; Qij_ECM_Init[23][1] = 0.000000; Qij_ECM_Init[23][2] = 0.000000; Qij_ECM_Init[23][3] = 0.000000; Qij_ECM_Init[23][4] = 0.000000; Qij_ECM_Init[23][5] = 0.000000; Qij_ECM_Init[23][6] = 0.000000; Qij_ECM_Init[23][7] = 0.000000; Qij_ECM_Init[23][8] = 0.000000; Qij_ECM_Init[23][9] = 0.000000; Qij_ECM_Init[23][10] = 0.000000; Qij_ECM_Init[23][11] = 0.000000; Qij_ECM_Init[23][12] = 0.000000; Qij_ECM_Init[23][13] = 0.000000; Qij_ECM_Init[23][14] = 0.000000; Qij_ECM_Init[23][15] = 7.419058; Qij_ECM_Init[23][16] = 0.000000; Qij_ECM_Init[23][17] = 0.000000; Qij_ECM_Init[23][18] = 0.000000; Qij_ECM_Init[23][19] = 5.381868; Qij_ECM_Init[23][20] = 0.000000; Qij_ECM_Init[23][21] = 3.440380; Qij_ECM_Init[23][22] = 1.918904; 
		Qij_ECM_Init[24][0] = 0.000000; Qij_ECM_Init[24][1] = 0.000000; Qij_ECM_Init[24][2] = 0.000000; Qij_ECM_Init[24][3] = 0.000000; Qij_ECM_Init[24][4] = 0.000000; Qij_ECM_Init[24][5] = 0.000000; Qij_ECM_Init[24][6] = 0.000000; Qij_ECM_Init[24][7] = 0.000000; Qij_ECM_Init[24][8] = 0.000000; Qij_ECM_Init[24][9] = 0.000000; Qij_ECM_Init[24][10] = 0.000000; Qij_ECM_Init[24][11] = 0.000000; Qij_ECM_Init[24][12] = 0.000000; Qij_ECM_Init[24][13] = 0.000000; Qij_ECM_Init[24][14] = 0.000000; Qij_ECM_Init[24][15] = 0.000000; Qij_ECM_Init[24][16] = 1.812540; Qij_ECM_Init[24][17] = 0.000000; Qij_ECM_Init[24][18] = 0.000000; Qij_ECM_Init[24][19] = 0.000000; Qij_ECM_Init[24][20] = 1.794388; Qij_ECM_Init[24][21] = 1.086327; Qij_ECM_Init[24][22] = 5.369463; Qij_ECM_Init[24][23] = 14.959151; 
		Qij_ECM_Init[25][0] = 0.000000; Qij_ECM_Init[25][1] = 0.000000; Qij_ECM_Init[25][2] = 0.000000; Qij_ECM_Init[25][3] = 0.000000; Qij_ECM_Init[25][4] = 0.000000; Qij_ECM_Init[25][5] = 0.000000; Qij_ECM_Init[25][6] = 0.000000; Qij_ECM_Init[25][7] = 0.000000; Qij_ECM_Init[25][8] = 0.000000; Qij_ECM_Init[25][9] = 0.000000; Qij_ECM_Init[25][10] = 1.617091; Qij_ECM_Init[25][11] = 0.000000; Qij_ECM_Init[25][12] = 0.000000; Qij_ECM_Init[25][13] = 0.779565; Qij_ECM_Init[25][14] = 0.000000; Qij_ECM_Init[25][15] = 0.000000; Qij_ECM_Init[25][16] = 0.000000; Qij_ECM_Init[25][17] = 0.334165; Qij_ECM_Init[25][18] = 0.000000; Qij_ECM_Init[25][19] = 0.000000; Qij_ECM_Init[25][20] = 0.000000; Qij_ECM_Init[25][21] = 3.019726; Qij_ECM_Init[25][22] = 0.000000; Qij_ECM_Init[25][23] = 0.000000; Qij_ECM_Init[25][24] = 0.000000; 
		Qij_ECM_Init[26][0] = 0.000000; Qij_ECM_Init[26][1] = 0.000000; Qij_ECM_Init[26][2] = 0.000000; Qij_ECM_Init[26][3] = 0.000000; Qij_ECM_Init[26][4] = 0.000000; Qij_ECM_Init[26][5] = 0.000000; Qij_ECM_Init[26][6] = 0.000000; Qij_ECM_Init[26][7] = 0.000000; Qij_ECM_Init[26][8] = 0.000000; Qij_ECM_Init[26][9] = 0.000000; Qij_ECM_Init[26][10] = 0.000000; Qij_ECM_Init[26][11] = 1.632945; Qij_ECM_Init[26][12] = 0.000000; Qij_ECM_Init[26][13] = 0.000000; Qij_ECM_Init[26][14] = 2.250770; Qij_ECM_Init[26][15] = 0.000000; Qij_ECM_Init[26][16] = 0.000000; Qij_ECM_Init[26][17] = 0.000000; Qij_ECM_Init[26][18] = 1.699302; Qij_ECM_Init[26][19] = 0.000000; Qij_ECM_Init[26][20] = 0.000000; Qij_ECM_Init[26][21] = 0.000000; Qij_ECM_Init[26][22] = 7.016899; Qij_ECM_Init[26][23] = 0.000000; Qij_ECM_Init[26][24] = 0.000000; Qij_ECM_Init[26][25] = 14.603857; 
		Qij_ECM_Init[27][0] = 0.000000; Qij_ECM_Init[27][1] = 0.000000; Qij_ECM_Init[27][2] = 0.000000; Qij_ECM_Init[27][3] = 0.000000; Qij_ECM_Init[27][4] = 0.000000; Qij_ECM_Init[27][5] = 0.000000; Qij_ECM_Init[27][6] = 0.000000; Qij_ECM_Init[27][7] = 0.000000; Qij_ECM_Init[27][8] = 0.000000; Qij_ECM_Init[27][9] = 0.000000; Qij_ECM_Init[27][10] = 0.000000; Qij_ECM_Init[27][11] = 0.000000; Qij_ECM_Init[27][12] = 0.000000; Qij_ECM_Init[27][13] = 0.000000; Qij_ECM_Init[27][14] = 0.000000; Qij_ECM_Init[27][15] = 3.023939; Qij_ECM_Init[27][16] = 0.000000; Qij_ECM_Init[27][17] = 0.000000; Qij_ECM_Init[27][18] = 0.000000; Qij_ECM_Init[27][19] = 1.693662; Qij_ECM_Init[27][20] = 0.000000; Qij_ECM_Init[27][21] = 0.000000; Qij_ECM_Init[27][22] = 0.000000; Qij_ECM_Init[27][23] = 6.415757; Qij_ECM_Init[27][24] = 0.000000; Qij_ECM_Init[27][25] = 99.459951; Qij_ECM_Init[27][26] = 14.930266; 
		Qij_ECM_Init[28][0] = 0.000000; Qij_ECM_Init[28][1] = 0.000000; Qij_ECM_Init[28][2] = 0.000000; Qij_ECM_Init[28][3] = 0.000000; Qij_ECM_Init[28][4] = 0.000000; Qij_ECM_Init[28][5] = 0.000000; Qij_ECM_Init[28][6] = 0.000000; Qij_ECM_Init[28][7] = 0.000000; Qij_ECM_Init[28][8] = 0.000000; Qij_ECM_Init[28][9] = 0.000000; Qij_ECM_Init[28][10] = 0.000000; Qij_ECM_Init[28][11] = 0.000000; Qij_ECM_Init[28][12] = 3.026086; Qij_ECM_Init[28][13] = 0.000000; Qij_ECM_Init[28][14] = 0.000000; Qij_ECM_Init[28][15] = 0.000000; Qij_ECM_Init[28][16] = 1.462945; Qij_ECM_Init[28][17] = 0.000000; Qij_ECM_Init[28][18] = 0.000000; Qij_ECM_Init[28][19] = 0.000000; Qij_ECM_Init[28][20] = 3.144296; Qij_ECM_Init[28][21] = 0.000000; Qij_ECM_Init[28][22] = 0.000000; Qij_ECM_Init[28][23] = 0.000000; Qij_ECM_Init[28][24] = 19.920977; Qij_ECM_Init[28][25] = 30.80475; Qij_ECM_Init[28][26] = 79.483730; Qij_ECM_Init[28][27] = 13.919752; 
		Qij_ECM_Init[29][0] = 1.682029; Qij_ECM_Init[29][1] = 0.000000; Qij_ECM_Init[29][2] = 0.000000; Qij_ECM_Init[29][3] = 0.000000; Qij_ECM_Init[29][4] = 0.000000; Qij_ECM_Init[29][5] = 0.000000; Qij_ECM_Init[29][6] = 0.000000; Qij_ECM_Init[29][7] = 0.000000; Qij_ECM_Init[29][8] = 0.000000; Qij_ECM_Init[29][9] = 0.000000; Qij_ECM_Init[29][10] = 0.000000; Qij_ECM_Init[29][11] = 0.000000; Qij_ECM_Init[29][12] = 0.000000; Qij_ECM_Init[29][13] = 4.301225; Qij_ECM_Init[29][14] = 0.000000; Qij_ECM_Init[29][15] = 0.000000; Qij_ECM_Init[29][16] = 0.000000; Qij_ECM_Init[29][17] = 0.000000; Qij_ECM_Init[29][18] = 0.000000; Qij_ECM_Init[29][19] = 0.000000; Qij_ECM_Init[29][20] = 0.000000; Qij_ECM_Init[29][21] = 0.000000; Qij_ECM_Init[29][22] = 0.000000; Qij_ECM_Init[29][23] = 0.000000; Qij_ECM_Init[29][24] = 0.000000; Qij_ECM_Init[29][25] = 0.000000; Qij_ECM_Init[29][26] = 0.000000; Qij_ECM_Init[29][27] = 0.000000; Qij_ECM_Init[29][28] = 0.000000; 
		Qij_ECM_Init[30][0] = 0.000000; Qij_ECM_Init[30][1] = 0.786043; Qij_ECM_Init[30][2] = 0.000000; Qij_ECM_Init[30][3] = 0.000000; Qij_ECM_Init[30][4] = 0.000000; Qij_ECM_Init[30][5] = 0.000000; Qij_ECM_Init[30][6] = 0.000000; Qij_ECM_Init[30][7] = 0.000000; Qij_ECM_Init[30][8] = 0.000000; Qij_ECM_Init[30][9] = 0.000000; Qij_ECM_Init[30][10] = 0.000000; Qij_ECM_Init[30][11] = 0.000000; Qij_ECM_Init[30][12] = 0.000000; Qij_ECM_Init[30][13] = 0.000000; Qij_ECM_Init[30][14] = 6.381841; Qij_ECM_Init[30][15] = 0.000000; Qij_ECM_Init[30][16] = 0.000000; Qij_ECM_Init[30][17] = 0.000000; Qij_ECM_Init[30][18] = 0.000000; Qij_ECM_Init[30][19] = 0.000000; Qij_ECM_Init[30][20] = 0.000000; Qij_ECM_Init[30][21] = 0.000000; Qij_ECM_Init[30][22] = 0.000000; Qij_ECM_Init[30][23] = 0.000000; Qij_ECM_Init[30][24] = 0.000000; Qij_ECM_Init[30][25] = 0.000000; Qij_ECM_Init[30][26] = 0.000000; Qij_ECM_Init[30][27] = 0.000000; Qij_ECM_Init[30][28] = 0.000000; Qij_ECM_Init[30][29] = 10.140728; 
		Qij_ECM_Init[31][0] = 0.000000; Qij_ECM_Init[31][1] = 0.000000; Qij_ECM_Init[31][2] = 10.116588; Qij_ECM_Init[31][3] = 0.000000; Qij_ECM_Init[31][4] = 0.000000; Qij_ECM_Init[31][5] = 0.000000; Qij_ECM_Init[31][6] = 0.000000; Qij_ECM_Init[31][7] = 0.000000; Qij_ECM_Init[31][8] = 0.000000; Qij_ECM_Init[31][9] = 0.000000; Qij_ECM_Init[31][10] = 0.000000; Qij_ECM_Init[31][11] = 0.000000; Qij_ECM_Init[31][12] = 0.000000; Qij_ECM_Init[31][13] = 0.000000; Qij_ECM_Init[31][14] = 0.000000; Qij_ECM_Init[31][15] = 5.134459; Qij_ECM_Init[31][16] = 0.000000; Qij_ECM_Init[31][17] = 0.000000; Qij_ECM_Init[31][18] = 0.000000; Qij_ECM_Init[31][19] = 0.000000; Qij_ECM_Init[31][20] = 0.000000; Qij_ECM_Init[31][21] = 0.000000; Qij_ECM_Init[31][22] = 0.000000; Qij_ECM_Init[31][23] = 0.000000; Qij_ECM_Init[31][24] = 0.000000; Qij_ECM_Init[31][25] = 0.000000; Qij_ECM_Init[31][26] = 0.000000; Qij_ECM_Init[31][27] = 0.000000; Qij_ECM_Init[31][28] = 0.000000; Qij_ECM_Init[31][29] = 18.298900; Qij_ECM_Init[31][30] = 4.623936; 
		Qij_ECM_Init[32][0] = 0.000000; Qij_ECM_Init[32][1] = 0.000000; Qij_ECM_Init[32][2] = 0.000000; Qij_ECM_Init[32][3] = 7.911096; Qij_ECM_Init[32][4] = 0.000000; Qij_ECM_Init[32][5] = 0.000000; Qij_ECM_Init[32][6] = 0.000000; Qij_ECM_Init[32][7] = 0.000000; Qij_ECM_Init[32][8] = 0.000000; Qij_ECM_Init[32][9] = 0.000000; Qij_ECM_Init[32][10] = 0.000000; Qij_ECM_Init[32][11] = 0.000000; Qij_ECM_Init[32][12] = 0.000000; Qij_ECM_Init[32][13] = 0.000000; Qij_ECM_Init[32][14] = 0.000000; Qij_ECM_Init[32][15] = 0.000000; Qij_ECM_Init[32][16] = 2.570123; Qij_ECM_Init[32][17] = 0.000000; Qij_ECM_Init[32][18] = 0.000000; Qij_ECM_Init[32][19] = 0.000000; Qij_ECM_Init[32][20] = 0.000000; Qij_ECM_Init[32][21] = 0.000000; Qij_ECM_Init[32][22] = 0.000000; Qij_ECM_Init[32][23] = 0.000000; Qij_ECM_Init[32][24] = 0.000000; Qij_ECM_Init[32][25] = 0.000000; Qij_ECM_Init[32][26] = 0.000000; Qij_ECM_Init[32][27] = 0.000000; Qij_ECM_Init[32][28] = 0.000000; Qij_ECM_Init[32][29] = 1.281784; Qij_ECM_Init[32][30] = 1.303951; Qij_ECM_Init[32][31] = 2.082128; 
		Qij_ECM_Init[33][0] = 0.000000; Qij_ECM_Init[33][1] = 0.000000; Qij_ECM_Init[33][2] = 0.000000; Qij_ECM_Init[33][3] = 0.000000; Qij_ECM_Init[33][4] = 38.229100; Qij_ECM_Init[33][5] = 0.000000; Qij_ECM_Init[33][6] = 0.000000; Qij_ECM_Init[33][7] = 0.000000; Qij_ECM_Init[33][8] = 0.000000; Qij_ECM_Init[33][9] = 0.000000; Qij_ECM_Init[33][10] = 0.000000; Qij_ECM_Init[33][11] = 0.000000; Qij_ECM_Init[33][12] = 0.000000; Qij_ECM_Init[33][13] = 0.000000; Qij_ECM_Init[33][14] = 0.000000; Qij_ECM_Init[33][15] = 0.000000; Qij_ECM_Init[33][16] = 0.000000; Qij_ECM_Init[33][17] = 6.578976; Qij_ECM_Init[33][18] = 0.000000; Qij_ECM_Init[33][19] = 0.000000; Qij_ECM_Init[33][20] = 0.000000; Qij_ECM_Init[33][21] = 0.000000; Qij_ECM_Init[33][22] = 0.000000; Qij_ECM_Init[33][23] = 0.000000; Qij_ECM_Init[33][24] = 0.000000; Qij_ECM_Init[33][25] = 0.000000; Qij_ECM_Init[33][26] = 0.000000; Qij_ECM_Init[33][27] = 0.000000; Qij_ECM_Init[33][28] = 0.000000; Qij_ECM_Init[33][29] = 2.801564; Qij_ECM_Init[33][30] = 0.000000; Qij_ECM_Init[33][31] = 0.000000; Qij_ECM_Init[33][32] = 0.000000; 
		Qij_ECM_Init[34][0] = 0.000000; Qij_ECM_Init[34][1] = 0.000000; Qij_ECM_Init[34][2] = 0.000000; Qij_ECM_Init[34][3] = 0.000000; Qij_ECM_Init[34][4] = 0.000000; Qij_ECM_Init[34][5] = 15.793595; Qij_ECM_Init[34][6] = 0.000000; Qij_ECM_Init[34][7] = 0.000000; Qij_ECM_Init[34][8] = 0.000000; Qij_ECM_Init[34][9] = 0.000000; Qij_ECM_Init[34][10] = 0.000000; Qij_ECM_Init[34][11] = 0.000000; Qij_ECM_Init[34][12] = 0.000000; Qij_ECM_Init[34][13] = 0.000000; Qij_ECM_Init[34][14] = 0.000000; Qij_ECM_Init[34][15] = 0.000000; Qij_ECM_Init[34][16] = 0.000000; Qij_ECM_Init[34][17] = 0.000000; Qij_ECM_Init[34][18] = 1.434550; Qij_ECM_Init[34][19] = 0.000000; Qij_ECM_Init[34][20] = 0.000000; Qij_ECM_Init[34][21] = 0.000000; Qij_ECM_Init[34][22] = 0.000000; Qij_ECM_Init[34][23] = 0.000000; Qij_ECM_Init[34][24] = 0.000000; Qij_ECM_Init[34][25] = 0.000000; Qij_ECM_Init[34][26] = 0.000000; Qij_ECM_Init[34][27] = 0.000000; Qij_ECM_Init[34][28] = 0.000000; Qij_ECM_Init[34][29] = 0.000000; Qij_ECM_Init[34][30] = 2.231468; Qij_ECM_Init[34][31] = 0.000000; Qij_ECM_Init[34][32] = 0.000000; Qij_ECM_Init[34][33] = 6.035740; 
		Qij_ECM_Init[35][0] = 0.000000; Qij_ECM_Init[35][1] = 0.000000; Qij_ECM_Init[35][2] = 0.000000; Qij_ECM_Init[35][3] = 0.000000; Qij_ECM_Init[35][4] = 0.000000; Qij_ECM_Init[35][5] = 0.000000; Qij_ECM_Init[35][6] = 6.033932; Qij_ECM_Init[35][7] = 0.000000; Qij_ECM_Init[35][8] = 0.000000; Qij_ECM_Init[35][9] = 0.000000; Qij_ECM_Init[35][10] = 0.000000; Qij_ECM_Init[35][11] = 0.000000; Qij_ECM_Init[35][12] = 0.000000; Qij_ECM_Init[35][13] = 0.000000; Qij_ECM_Init[35][14] = 0.000000; Qij_ECM_Init[35][15] = 0.000000; Qij_ECM_Init[35][16] = 0.000000; Qij_ECM_Init[35][17] = 0.000000; Qij_ECM_Init[35][18] = 0.000000; Qij_ECM_Init[35][19] = 0.925575; Qij_ECM_Init[35][20] = 0.000000; Qij_ECM_Init[35][21] = 0.000000; Qij_ECM_Init[35][22] = 0.000000; Qij_ECM_Init[35][23] = 0.000000; Qij_ECM_Init[35][24] = 0.000000; Qij_ECM_Init[35][25] = 0.000000; Qij_ECM_Init[35][26] = 0.000000; Qij_ECM_Init[35][27] = 0.000000; Qij_ECM_Init[35][28] = 0.000000; Qij_ECM_Init[35][29] = 0.000000; Qij_ECM_Init[35][30] = 0.000000; Qij_ECM_Init[35][31] = 4.962350; Qij_ECM_Init[35][32] = 0.000000; Qij_ECM_Init[35][33] = 28.307876; Qij_ECM_Init[35][34] = 6.967655; 
		Qij_ECM_Init[36][0] = 0.000000; Qij_ECM_Init[36][1] = 0.000000; Qij_ECM_Init[36][2] = 0.000000; Qij_ECM_Init[36][3] = 0.000000; Qij_ECM_Init[36][4] = 0.000000; Qij_ECM_Init[36][5] = 0.000000; Qij_ECM_Init[36][6] = 0.000000; Qij_ECM_Init[36][7] = 17.103904; Qij_ECM_Init[36][8] = 0.000000; Qij_ECM_Init[36][9] = 0.000000; Qij_ECM_Init[36][10] = 0.000000; Qij_ECM_Init[36][11] = 0.000000; Qij_ECM_Init[36][12] = 0.000000; Qij_ECM_Init[36][13] = 0.000000; Qij_ECM_Init[36][14] = 0.000000; Qij_ECM_Init[36][15] = 0.000000; Qij_ECM_Init[36][16] = 0.000000; Qij_ECM_Init[36][17] = 0.000000; Qij_ECM_Init[36][18] = 0.000000; Qij_ECM_Init[36][19] = 0.000000; Qij_ECM_Init[36][20] = 1.238450; Qij_ECM_Init[36][21] = 0.000000; Qij_ECM_Init[36][22] = 0.000000; Qij_ECM_Init[36][23] = 0.000000; Qij_ECM_Init[36][24] = 0.000000; Qij_ECM_Init[36][25] = 0.000000; Qij_ECM_Init[36][26] = 0.000000; Qij_ECM_Init[36][27] = 0.000000; Qij_ECM_Init[36][28] = 0.000000; Qij_ECM_Init[36][29] = 0.000000; Qij_ECM_Init[36][30] = 0.000000; Qij_ECM_Init[36][31] = 0.000000; Qij_ECM_Init[36][32] = 8.155285; Qij_ECM_Init[36][33] = 19.578982; Qij_ECM_Init[36][34] = 38.414969; Qij_ECM_Init[36][35] = 12.678802; 
		Qij_ECM_Init[37][0] = 0.000000; Qij_ECM_Init[37][1] = 0.000000; Qij_ECM_Init[37][2] = 0.000000; Qij_ECM_Init[37][3] = 0.000000; Qij_ECM_Init[37][4] = 0.000000; Qij_ECM_Init[37][5] = 0.000000; Qij_ECM_Init[37][6] = 0.000000; Qij_ECM_Init[37][7] = 0.000000; Qij_ECM_Init[37][8] = 2.245405; Qij_ECM_Init[37][9] = 0.000000; Qij_ECM_Init[37][10] = 0.000000; Qij_ECM_Init[37][11] = 0.000000; Qij_ECM_Init[37][12] = 0.000000; Qij_ECM_Init[37][13] = 0.000000; Qij_ECM_Init[37][14] = 0.000000; Qij_ECM_Init[37][15] = 0.000000; Qij_ECM_Init[37][16] = 0.000000; Qij_ECM_Init[37][17] = 0.000000; Qij_ECM_Init[37][18] = 0.000000; Qij_ECM_Init[37][19] = 0.000000; Qij_ECM_Init[37][20] = 0.000000; Qij_ECM_Init[37][21] = 5.004762; Qij_ECM_Init[37][22] = 0.000000; Qij_ECM_Init[37][23] = 0.000000; Qij_ECM_Init[37][24] = 0.000000; Qij_ECM_Init[37][25] = 0.000000; Qij_ECM_Init[37][26] = 0.000000; Qij_ECM_Init[37][27] = 0.000000; Qij_ECM_Init[37][28] = 0.000000; Qij_ECM_Init[37][29] = 0.501054; Qij_ECM_Init[37][30] = 0.000000; Qij_ECM_Init[37][31] = 0.000000; Qij_ECM_Init[37][32] = 0.000000; Qij_ECM_Init[37][33] = 11.715476; Qij_ECM_Init[37][34] = 0.000000; Qij_ECM_Init[37][35] = 0.000000; Qij_ECM_Init[37][36] = 0.000000; 
		Qij_ECM_Init[38][0] = 0.000000; Qij_ECM_Init[38][1] = 0.000000; Qij_ECM_Init[38][2] = 0.000000; Qij_ECM_Init[38][3] = 0.000000; Qij_ECM_Init[38][4] = 0.000000; Qij_ECM_Init[38][5] = 0.000000; Qij_ECM_Init[38][6] = 0.000000; Qij_ECM_Init[38][7] = 0.000000; Qij_ECM_Init[38][8] = 0.000000; Qij_ECM_Init[38][9] = 0.228361; Qij_ECM_Init[38][10] = 0.000000; Qij_ECM_Init[38][11] = 0.000000; Qij_ECM_Init[38][12] = 0.000000; Qij_ECM_Init[38][13] = 0.000000; Qij_ECM_Init[38][14] = 0.000000; Qij_ECM_Init[38][15] = 0.000000; Qij_ECM_Init[38][16] = 0.000000; Qij_ECM_Init[38][17] = 0.000000; Qij_ECM_Init[38][18] = 0.000000; Qij_ECM_Init[38][19] = 0.000000; Qij_ECM_Init[38][20] = 0.000000; Qij_ECM_Init[38][21] = 0.000000; Qij_ECM_Init[38][22] = 4.105602; Qij_ECM_Init[38][23] = 0.000000; Qij_ECM_Init[38][24] = 0.000000; Qij_ECM_Init[38][25] = 0.000000; Qij_ECM_Init[38][26] = 0.000000; Qij_ECM_Init[38][27] = 0.000000; Qij_ECM_Init[38][28] = 0.000000; Qij_ECM_Init[38][29] = 0.000000; Qij_ECM_Init[38][30] = 0.292691; Qij_ECM_Init[38][31] = 0.000000; Qij_ECM_Init[38][32] = 0.000000; Qij_ECM_Init[38][33] = 0.000000; Qij_ECM_Init[38][34] = 2.134740; Qij_ECM_Init[38][35] = 0.000000; Qij_ECM_Init[38][36] = 0.000000; Qij_ECM_Init[38][37] = 13.863648; 
		Qij_ECM_Init[39][0] = 0.000000; Qij_ECM_Init[39][1] = 0.000000; Qij_ECM_Init[39][2] = 0.000000; Qij_ECM_Init[39][3] = 0.000000; Qij_ECM_Init[39][4] = 0.000000; Qij_ECM_Init[39][5] = 0.000000; Qij_ECM_Init[39][6] = 0.000000; Qij_ECM_Init[39][7] = 0.000000; Qij_ECM_Init[39][8] = 0.000000; Qij_ECM_Init[39][9] = 0.000000; Qij_ECM_Init[39][10] = 0.000000; Qij_ECM_Init[39][11] = 0.000000; Qij_ECM_Init[39][12] = 0.000000; Qij_ECM_Init[39][13] = 0.000000; Qij_ECM_Init[39][14] = 0.000000; Qij_ECM_Init[39][15] = 0.000000; Qij_ECM_Init[39][16] = 0.000000; Qij_ECM_Init[39][17] = 0.000000; Qij_ECM_Init[39][18] = 0.000000; Qij_ECM_Init[39][19] = 0.000000; Qij_ECM_Init[39][20] = 0.000000; Qij_ECM_Init[39][21] = 0.000000; Qij_ECM_Init[39][22] = 0.000000; Qij_ECM_Init[39][23] = 6.404436; Qij_ECM_Init[39][24] = 0.000000; Qij_ECM_Init[39][25] = 0.000000; Qij_ECM_Init[39][26] = 0.000000; Qij_ECM_Init[39][27] = 0.000000; Qij_ECM_Init[39][28] = 0.000000; Qij_ECM_Init[39][29] = 0.000000; Qij_ECM_Init[39][30] = 0.000000; Qij_ECM_Init[39][31] = 2.647620; Qij_ECM_Init[39][32] = 0.000000; Qij_ECM_Init[39][33] = 0.000000; Qij_ECM_Init[39][34] = 0.000000; Qij_ECM_Init[39][35] = 3.919360; Qij_ECM_Init[39][36] = 0.000000; Qij_ECM_Init[39][37] = 4.929483; Qij_ECM_Init[39][38] = 0.366267; 
		Qij_ECM_Init[40][0] = 0.000000; Qij_ECM_Init[40][1] = 0.000000; Qij_ECM_Init[40][2] = 0.000000; Qij_ECM_Init[40][3] = 0.000000; Qij_ECM_Init[40][4] = 0.000000; Qij_ECM_Init[40][5] = 0.000000; Qij_ECM_Init[40][6] = 0.000000; Qij_ECM_Init[40][7] = 0.000000; Qij_ECM_Init[40][8] = 0.000000; Qij_ECM_Init[40][9] = 0.000000; Qij_ECM_Init[40][10] = 0.000000; Qij_ECM_Init[40][11] = 0.000000; Qij_ECM_Init[40][12] = 0.000000; Qij_ECM_Init[40][13] = 0.000000; Qij_ECM_Init[40][14] = 0.000000; Qij_ECM_Init[40][15] = 0.000000; Qij_ECM_Init[40][16] = 0.000000; Qij_ECM_Init[40][17] = 0.000000; Qij_ECM_Init[40][18] = 0.000000; Qij_ECM_Init[40][19] = 0.000000; Qij_ECM_Init[40][20] = 0.000000; Qij_ECM_Init[40][21] = 0.000000; Qij_ECM_Init[40][22] = 0.000000; Qij_ECM_Init[40][23] = 0.000000; Qij_ECM_Init[40][24] = 2.715692; Qij_ECM_Init[40][25] = 0.000000; Qij_ECM_Init[40][26] = 0.000000; Qij_ECM_Init[40][27] = 0.000000; Qij_ECM_Init[40][28] = 0.000000; Qij_ECM_Init[40][29] = 0.000000; Qij_ECM_Init[40][30] = 0.000000; Qij_ECM_Init[40][31] = 0.000000; Qij_ECM_Init[40][32] = 0.975074; Qij_ECM_Init[40][33] = 0.000000; Qij_ECM_Init[40][34] = 0.000000; Qij_ECM_Init[40][35] = 0.000000; Qij_ECM_Init[40][36] = 5.869857; Qij_ECM_Init[40][37] = 1.010212; Qij_ECM_Init[40][38] = 0.982893; Qij_ECM_Init[40][39] = 10.762877; 
		Qij_ECM_Init[41][0] = 0.000000; Qij_ECM_Init[41][1] = 0.000000; Qij_ECM_Init[41][2] = 0.000000; Qij_ECM_Init[41][3] = 0.000000; Qij_ECM_Init[41][4] = 0.000000; Qij_ECM_Init[41][5] = 0.000000; Qij_ECM_Init[41][6] = 0.000000; Qij_ECM_Init[41][7] = 0.000000; Qij_ECM_Init[41][8] = 0.000000; Qij_ECM_Init[41][9] = 0.000000; Qij_ECM_Init[41][10] = 4.719489; Qij_ECM_Init[41][11] = 0.000000; Qij_ECM_Init[41][12] = 0.000000; Qij_ECM_Init[41][13] = 0.000000; Qij_ECM_Init[41][14] = 0.000000; Qij_ECM_Init[41][15] = 0.000000; Qij_ECM_Init[41][16] = 0.000000; Qij_ECM_Init[41][17] = 0.000000; Qij_ECM_Init[41][18] = 0.000000; Qij_ECM_Init[41][19] = 0.000000; Qij_ECM_Init[41][20] = 0.000000; Qij_ECM_Init[41][21] = 0.000000; Qij_ECM_Init[41][22] = 0.000000; Qij_ECM_Init[41][23] = 0.000000; Qij_ECM_Init[41][24] = 0.000000; Qij_ECM_Init[41][25] = 3.834666; Qij_ECM_Init[41][26] = 0.000000; Qij_ECM_Init[41][27] = 0.000000; Qij_ECM_Init[41][28] = 0.000000; Qij_ECM_Init[41][29] = 0.578118; Qij_ECM_Init[41][30] = 0.000000; Qij_ECM_Init[41][31] = 0.000000; Qij_ECM_Init[41][32] = 0.000000; Qij_ECM_Init[41][33] = 39.399322; Qij_ECM_Init[41][34] = 0.000000; Qij_ECM_Init[41][35] = 0.000000; Qij_ECM_Init[41][36] = 0.000000; Qij_ECM_Init[41][37] = 16.623529; Qij_ECM_Init[41][38] = 0.000000; Qij_ECM_Init[41][39] = 0.000000; Qij_ECM_Init[41][40] = 0.000000; 
		Qij_ECM_Init[42][0] = 0.000000; Qij_ECM_Init[42][1] = 0.000000; Qij_ECM_Init[42][2] = 0.000000; Qij_ECM_Init[42][3] = 0.000000; Qij_ECM_Init[42][4] = 0.000000; Qij_ECM_Init[42][5] = 0.000000; Qij_ECM_Init[42][6] = 0.000000; Qij_ECM_Init[42][7] = 0.000000; Qij_ECM_Init[42][8] = 0.000000; Qij_ECM_Init[42][9] = 0.000000; Qij_ECM_Init[42][10] = 0.000000; Qij_ECM_Init[42][11] = 2.047654; Qij_ECM_Init[42][12] = 0.000000; Qij_ECM_Init[42][13] = 0.000000; Qij_ECM_Init[42][14] = 0.000000; Qij_ECM_Init[42][15] = 0.000000; Qij_ECM_Init[42][16] = 0.000000; Qij_ECM_Init[42][17] = 0.000000; Qij_ECM_Init[42][18] = 0.000000; Qij_ECM_Init[42][19] = 0.000000; Qij_ECM_Init[42][20] = 0.000000; Qij_ECM_Init[42][21] = 0.000000; Qij_ECM_Init[42][22] = 0.000000; Qij_ECM_Init[42][23] = 0.000000; Qij_ECM_Init[42][24] = 0.000000; Qij_ECM_Init[42][25] = 0.000000; Qij_ECM_Init[42][26] = 5.033630; Qij_ECM_Init[42][27] = 0.000000; Qij_ECM_Init[42][28] = 0.000000; Qij_ECM_Init[42][29] = 0.000000; Qij_ECM_Init[42][30] = 0.437779; Qij_ECM_Init[42][31] = 0.000000; Qij_ECM_Init[42][32] = 0.000000; Qij_ECM_Init[42][33] = 0.000000; Qij_ECM_Init[42][34] = 21.337943; Qij_ECM_Init[42][35] = 0.000000; Qij_ECM_Init[42][36] = 0.000000; Qij_ECM_Init[42][37] = 0.000000; Qij_ECM_Init[42][38] = 7.784768; Qij_ECM_Init[42][39] = 0.000000; Qij_ECM_Init[42][40] = 0.000000; Qij_ECM_Init[42][41] = 26.637668; 
		Qij_ECM_Init[43][0] = 0.000000; Qij_ECM_Init[43][1] = 0.000000; Qij_ECM_Init[43][2] = 0.000000; Qij_ECM_Init[43][3] = 0.000000; Qij_ECM_Init[43][4] = 0.000000; Qij_ECM_Init[43][5] = 0.000000; Qij_ECM_Init[43][6] = 0.000000; Qij_ECM_Init[43][7] = 0.000000; Qij_ECM_Init[43][8] = 0.000000; Qij_ECM_Init[43][9] = 0.000000; Qij_ECM_Init[43][10] = 0.000000; Qij_ECM_Init[43][11] = 0.000000; Qij_ECM_Init[43][12] = 0.000000; Qij_ECM_Init[43][13] = 0.000000; Qij_ECM_Init[43][14] = 0.000000; Qij_ECM_Init[43][15] = 0.000000; Qij_ECM_Init[43][16] = 0.000000; Qij_ECM_Init[43][17] = 0.000000; Qij_ECM_Init[43][18] = 0.000000; Qij_ECM_Init[43][19] = 0.000000; Qij_ECM_Init[43][20] = 0.000000; Qij_ECM_Init[43][21] = 0.000000; Qij_ECM_Init[43][22] = 0.000000; Qij_ECM_Init[43][23] = 0.000000; Qij_ECM_Init[43][24] = 0.000000; Qij_ECM_Init[43][25] = 0.000000; Qij_ECM_Init[43][26] = 0.000000; Qij_ECM_Init[43][27] = 92.372238; Qij_ECM_Init[43][28] = 0.000000; Qij_ECM_Init[43][29] = 0.000000; Qij_ECM_Init[43][30] = 0.000000; Qij_ECM_Init[43][31] = 1.903175; Qij_ECM_Init[43][32] = 0.000000; Qij_ECM_Init[43][33] = 0.000000; Qij_ECM_Init[43][34] = 0.000000; Qij_ECM_Init[43][35] = 0.754055; Qij_ECM_Init[43][36] = 0.000000; Qij_ECM_Init[43][37] = 0.000000; Qij_ECM_Init[43][38] = 0.000000; Qij_ECM_Init[43][39] = 8.423762; Qij_ECM_Init[43][40] = 0.000000; Qij_ECM_Init[43][41] = 1.792245; Qij_ECM_Init[43][42] = 0.120900; 
		Qij_ECM_Init[44][0] = 0.000000; Qij_ECM_Init[44][1] = 0.000000; Qij_ECM_Init[44][2] = 0.000000; Qij_ECM_Init[44][3] = 0.000000; Qij_ECM_Init[44][4] = 0.000000; Qij_ECM_Init[44][5] = 0.000000; Qij_ECM_Init[44][6] = 0.000000; Qij_ECM_Init[44][7] = 0.000000; Qij_ECM_Init[44][8] = 0.000000; Qij_ECM_Init[44][9] = 0.000000; Qij_ECM_Init[44][10] = 0.000000; Qij_ECM_Init[44][11] = 0.000000; Qij_ECM_Init[44][12] = 0.825082; Qij_ECM_Init[44][13] = 0.000000; Qij_ECM_Init[44][14] = 0.000000; Qij_ECM_Init[44][15] = 0.000000; Qij_ECM_Init[44][16] = 0.000000; Qij_ECM_Init[44][17] = 0.000000; Qij_ECM_Init[44][18] = 0.000000; Qij_ECM_Init[44][19] = 0.000000; Qij_ECM_Init[44][20] = 0.000000; Qij_ECM_Init[44][21] = 0.000000; Qij_ECM_Init[44][22] = 0.000000; Qij_ECM_Init[44][23] = 0.000000; Qij_ECM_Init[44][24] = 0.000000; Qij_ECM_Init[44][25] = 0.000000; Qij_ECM_Init[44][26] = 0.000000; Qij_ECM_Init[44][27] = 0.000000; Qij_ECM_Init[44][28] = 133.296291; Qij_ECM_Init[44][29] = 0.000000; Qij_ECM_Init[44][30] = 0.000000; Qij_ECM_Init[44][31] = 0.000000; Qij_ECM_Init[44][32] = 2.231662; Qij_ECM_Init[44][33] = 0.000000; Qij_ECM_Init[44][34] = 0.000000; Qij_ECM_Init[44][35] = 0.000000; Qij_ECM_Init[44][36] = 22.577271; Qij_ECM_Init[44][37] = 0.000000; Qij_ECM_Init[44][38] = 0.000000; Qij_ECM_Init[44][39] = 0.000000; Qij_ECM_Init[44][40] = 21.000358; Qij_ECM_Init[44][41] = 3.324581; Qij_ECM_Init[44][42] = 6.011970; Qij_ECM_Init[44][43] = 36.292705; 
		Qij_ECM_Init[45][0] = 2.261813; Qij_ECM_Init[45][1] = 0.000000; Qij_ECM_Init[45][2] = 0.000000; Qij_ECM_Init[45][3] = 0.000000; Qij_ECM_Init[45][4] = 0.000000; Qij_ECM_Init[45][5] = 0.000000; Qij_ECM_Init[45][6] = 0.000000; Qij_ECM_Init[45][7] = 0.000000; Qij_ECM_Init[45][8] = 0.000000; Qij_ECM_Init[45][9] = 0.000000; Qij_ECM_Init[45][10] = 0.000000; Qij_ECM_Init[45][11] = 0.000000; Qij_ECM_Init[45][12] = 0.000000; Qij_ECM_Init[45][13] = 2.473623; Qij_ECM_Init[45][14] = 0.000000; Qij_ECM_Init[45][15] = 0.000000; Qij_ECM_Init[45][16] = 0.000000; Qij_ECM_Init[45][17] = 0.000000; Qij_ECM_Init[45][18] = 0.000000; Qij_ECM_Init[45][19] = 0.000000; Qij_ECM_Init[45][20] = 0.000000; Qij_ECM_Init[45][21] = 0.000000; Qij_ECM_Init[45][22] = 0.000000; Qij_ECM_Init[45][23] = 0.000000; Qij_ECM_Init[45][24] = 0.000000; Qij_ECM_Init[45][25] = 0.000000; Qij_ECM_Init[45][26] = 0.000000; Qij_ECM_Init[45][27] = 0.000000; Qij_ECM_Init[45][28] = 0.000000; Qij_ECM_Init[45][29] = 7.096281; Qij_ECM_Init[45][30] = 0.000000; Qij_ECM_Init[45][31] = 0.000000; Qij_ECM_Init[45][32] = 0.000000; Qij_ECM_Init[45][33] = 0.000000; Qij_ECM_Init[45][34] = 0.000000; Qij_ECM_Init[45][35] = 0.000000; Qij_ECM_Init[45][36] = 0.000000; Qij_ECM_Init[45][37] = 0.000000; Qij_ECM_Init[45][38] = 0.000000; Qij_ECM_Init[45][39] = 0.000000; Qij_ECM_Init[45][40] = 0.000000; Qij_ECM_Init[45][41] = 0.000000; Qij_ECM_Init[45][42] = 0.000000; Qij_ECM_Init[45][43] = 0.000000; Qij_ECM_Init[45][44] = 0.000000; 
		Qij_ECM_Init[46][0] = 0.000000; Qij_ECM_Init[46][1] = 1.923392; Qij_ECM_Init[46][2] = 0.000000; Qij_ECM_Init[46][3] = 0.000000; Qij_ECM_Init[46][4] = 0.000000; Qij_ECM_Init[46][5] = 0.000000; Qij_ECM_Init[46][6] = 0.000000; Qij_ECM_Init[46][7] = 0.000000; Qij_ECM_Init[46][8] = 0.000000; Qij_ECM_Init[46][9] = 0.000000; Qij_ECM_Init[46][10] = 0.000000; Qij_ECM_Init[46][11] = 0.000000; Qij_ECM_Init[46][12] = 0.000000; Qij_ECM_Init[46][13] = 0.000000; Qij_ECM_Init[46][14] = 5.914972; Qij_ECM_Init[46][15] = 0.000000; Qij_ECM_Init[46][16] = 0.000000; Qij_ECM_Init[46][17] = 0.000000; Qij_ECM_Init[46][18] = 0.000000; Qij_ECM_Init[46][19] = 0.000000; Qij_ECM_Init[46][20] = 0.000000; Qij_ECM_Init[46][21] = 0.000000; Qij_ECM_Init[46][22] = 0.000000; Qij_ECM_Init[46][23] = 0.000000; Qij_ECM_Init[46][24] = 0.000000; Qij_ECM_Init[46][25] = 0.000000; Qij_ECM_Init[46][26] = 0.000000; Qij_ECM_Init[46][27] = 0.000000; Qij_ECM_Init[46][28] = 0.000000; Qij_ECM_Init[46][29] = 0.000000; Qij_ECM_Init[46][30] = 10.137337; Qij_ECM_Init[46][31] = 0.000000; Qij_ECM_Init[46][32] = 0.000000; Qij_ECM_Init[46][33] = 0.000000; Qij_ECM_Init[46][34] = 0.000000; Qij_ECM_Init[46][35] = 0.000000; Qij_ECM_Init[46][36] = 0.000000; Qij_ECM_Init[46][37] = 0.000000; Qij_ECM_Init[46][38] = 0.000000; Qij_ECM_Init[46][39] = 0.000000; Qij_ECM_Init[46][40] = 0.000000; Qij_ECM_Init[46][41] = 0.000000; Qij_ECM_Init[46][42] = 0.000000; Qij_ECM_Init[46][43] = 0.000000; Qij_ECM_Init[46][44] = 0.000000; Qij_ECM_Init[46][45] = 6.669955; 
		Qij_ECM_Init[47][0] = 0.000000; Qij_ECM_Init[47][1] = 0.000000; Qij_ECM_Init[47][2] = 2.362720; Qij_ECM_Init[47][3] = 0.000000; Qij_ECM_Init[47][4] = 0.000000; Qij_ECM_Init[47][5] = 0.000000; Qij_ECM_Init[47][6] = 0.000000; Qij_ECM_Init[47][7] = 0.000000; Qij_ECM_Init[47][8] = 0.000000; Qij_ECM_Init[47][9] = 0.000000; Qij_ECM_Init[47][10] = 0.000000; Qij_ECM_Init[47][11] = 0.000000; Qij_ECM_Init[47][12] = 0.000000; Qij_ECM_Init[47][13] = 0.000000; Qij_ECM_Init[47][14] = 0.000000; Qij_ECM_Init[47][15] = 3.737489; Qij_ECM_Init[47][16] = 0.000000; Qij_ECM_Init[47][17] = 0.000000; Qij_ECM_Init[47][18] = 0.000000; Qij_ECM_Init[47][19] = 0.000000; Qij_ECM_Init[47][20] = 0.000000; Qij_ECM_Init[47][21] = 0.000000; Qij_ECM_Init[47][22] = 0.000000; Qij_ECM_Init[47][23] = 0.000000; Qij_ECM_Init[47][24] = 0.000000; Qij_ECM_Init[47][25] = 0.000000; Qij_ECM_Init[47][26] = 0.000000; Qij_ECM_Init[47][27] = 0.000000; Qij_ECM_Init[47][28] = 0.000000; Qij_ECM_Init[47][29] = 0.000000; Qij_ECM_Init[47][30] = 0.000000; Qij_ECM_Init[47][31] = 25.294298; Qij_ECM_Init[47][32] = 0.000000; Qij_ECM_Init[47][33] = 0.000000; Qij_ECM_Init[47][34] = 0.000000; Qij_ECM_Init[47][35] = 0.000000; Qij_ECM_Init[47][36] = 0.000000; Qij_ECM_Init[47][37] = 0.000000; Qij_ECM_Init[47][38] = 0.000000; Qij_ECM_Init[47][39] = 0.000000; Qij_ECM_Init[47][40] = 0.000000; Qij_ECM_Init[47][41] = 0.000000; Qij_ECM_Init[47][42] = 0.000000; Qij_ECM_Init[47][43] = 0.000000; Qij_ECM_Init[47][44] = 0.000000; Qij_ECM_Init[47][45] = 26.045078; Qij_ECM_Init[47][46] = 3.531461; 
		Qij_ECM_Init[48][0] = 0.000000; Qij_ECM_Init[48][1] = 0.000000; Qij_ECM_Init[48][2] = 0.000000; Qij_ECM_Init[48][3] = 2.022101; Qij_ECM_Init[48][4] = 0.000000; Qij_ECM_Init[48][5] = 0.000000; Qij_ECM_Init[48][6] = 0.000000; Qij_ECM_Init[48][7] = 0.000000; Qij_ECM_Init[48][8] = 0.000000; Qij_ECM_Init[48][9] = 0.000000; Qij_ECM_Init[48][10] = 0.000000; Qij_ECM_Init[48][11] = 0.000000; Qij_ECM_Init[48][12] = 0.000000; Qij_ECM_Init[48][13] = 0.000000; Qij_ECM_Init[48][14] = 0.000000; Qij_ECM_Init[48][15] = 0.000000; Qij_ECM_Init[48][16] = 2.164805; Qij_ECM_Init[48][17] = 0.000000; Qij_ECM_Init[48][18] = 0.000000; Qij_ECM_Init[48][19] = 0.000000; Qij_ECM_Init[48][20] = 0.000000; Qij_ECM_Init[48][21] = 0.000000; Qij_ECM_Init[48][22] = 0.000000; Qij_ECM_Init[48][23] = 0.000000; Qij_ECM_Init[48][24] = 0.000000; Qij_ECM_Init[48][25] = 0.000000; Qij_ECM_Init[48][26] = 0.000000; Qij_ECM_Init[48][27] = 0.000000; Qij_ECM_Init[48][28] = 0.000000; Qij_ECM_Init[48][29] = 0.000000; Qij_ECM_Init[48][30] = 0.000000; Qij_ECM_Init[48][31] = 0.000000; Qij_ECM_Init[48][32] = 2.078444; Qij_ECM_Init[48][33] = 0.000000; Qij_ECM_Init[48][34] = 0.000000; Qij_ECM_Init[48][35] = 0.000000; Qij_ECM_Init[48][36] = 0.000000; Qij_ECM_Init[48][37] = 0.000000; Qij_ECM_Init[48][38] = 0.000000; Qij_ECM_Init[48][39] = 0.000000; Qij_ECM_Init[48][40] = 0.000000; Qij_ECM_Init[48][41] = 0.000000; Qij_ECM_Init[48][42] = 0.000000; Qij_ECM_Init[48][43] = 0.000000; Qij_ECM_Init[48][44] = 0.000000; Qij_ECM_Init[48][45] = 8.901167; Qij_ECM_Init[48][46] = 21.657664; Qij_ECM_Init[48][47] = 11.898141; 
		Qij_ECM_Init[49][0] = 0.000000; Qij_ECM_Init[49][1] = 0.000000; Qij_ECM_Init[49][2] = 0.000000; Qij_ECM_Init[49][3] = 0.000000; Qij_ECM_Init[49][4] = 5.540052; Qij_ECM_Init[49][5] = 0.000000; Qij_ECM_Init[49][6] = 0.000000; Qij_ECM_Init[49][7] = 0.000000; Qij_ECM_Init[49][8] = 0.000000; Qij_ECM_Init[49][9] = 0.000000; Qij_ECM_Init[49][10] = 0.000000; Qij_ECM_Init[49][11] = 0.000000; Qij_ECM_Init[49][12] = 0.000000; Qij_ECM_Init[49][13] = 0.000000; Qij_ECM_Init[49][14] = 0.000000; Qij_ECM_Init[49][15] = 0.000000; Qij_ECM_Init[49][16] = 0.000000; Qij_ECM_Init[49][17] = 1.159185; Qij_ECM_Init[49][18] = 0.000000; Qij_ECM_Init[49][19] = 0.000000; Qij_ECM_Init[49][20] = 0.000000; Qij_ECM_Init[49][21] = 0.000000; Qij_ECM_Init[49][22] = 0.000000; Qij_ECM_Init[49][23] = 0.000000; Qij_ECM_Init[49][24] = 0.000000; Qij_ECM_Init[49][25] = 0.000000; Qij_ECM_Init[49][26] = 0.000000; Qij_ECM_Init[49][27] = 0.000000; Qij_ECM_Init[49][28] = 0.000000; Qij_ECM_Init[49][29] = 0.000000; Qij_ECM_Init[49][30] = 0.000000; Qij_ECM_Init[49][31] = 0.000000; Qij_ECM_Init[49][32] = 0.000000; Qij_ECM_Init[49][33] = 5.107629; Qij_ECM_Init[49][34] = 0.000000; Qij_ECM_Init[49][35] = 0.000000; Qij_ECM_Init[49][36] = 0.000000; Qij_ECM_Init[49][37] = 0.000000; Qij_ECM_Init[49][38] = 0.000000; Qij_ECM_Init[49][39] = 0.000000; Qij_ECM_Init[49][40] = 0.000000; Qij_ECM_Init[49][41] = 0.000000; Qij_ECM_Init[49][42] = 0.000000; Qij_ECM_Init[49][43] = 0.000000; Qij_ECM_Init[49][44] = 0.000000; Qij_ECM_Init[49][45] = 3.682092; Qij_ECM_Init[49][46] = 0.000000; Qij_ECM_Init[49][47] = 0.000000; Qij_ECM_Init[49][48] = 0.000000; 
		Qij_ECM_Init[50][0] = 0.000000; Qij_ECM_Init[50][1] = 0.000000; Qij_ECM_Init[50][2] = 0.000000; Qij_ECM_Init[50][3] = 0.000000; Qij_ECM_Init[50][4] = 0.000000; Qij_ECM_Init[50][5] = 7.675838; Qij_ECM_Init[50][6] = 0.000000; Qij_ECM_Init[50][7] = 0.000000; Qij_ECM_Init[50][8] = 0.000000; Qij_ECM_Init[50][9] = 0.000000; Qij_ECM_Init[50][10] = 0.000000; Qij_ECM_Init[50][11] = 0.000000; Qij_ECM_Init[50][12] = 0.000000; Qij_ECM_Init[50][13] = 0.000000; Qij_ECM_Init[50][14] = 0.000000; Qij_ECM_Init[50][15] = 0.000000; Qij_ECM_Init[50][16] = 0.000000; Qij_ECM_Init[50][17] = 0.000000; Qij_ECM_Init[50][18] = 3.120189; Qij_ECM_Init[50][19] = 0.000000; Qij_ECM_Init[50][20] = 0.000000; Qij_ECM_Init[50][21] = 0.000000; Qij_ECM_Init[50][22] = 0.000000; Qij_ECM_Init[50][23] = 0.000000; Qij_ECM_Init[50][24] = 0.000000; Qij_ECM_Init[50][25] = 0.000000; Qij_ECM_Init[50][26] = 0.000000; Qij_ECM_Init[50][27] = 0.000000; Qij_ECM_Init[50][28] = 0.000000; Qij_ECM_Init[50][29] = 0.000000; Qij_ECM_Init[50][30] = 0.000000; Qij_ECM_Init[50][31] = 0.000000; Qij_ECM_Init[50][32] = 0.000000; Qij_ECM_Init[50][33] = 0.000000; Qij_ECM_Init[50][34] = 2.312255; Qij_ECM_Init[50][35] = 0.000000; Qij_ECM_Init[50][36] = 0.000000; Qij_ECM_Init[50][37] = 0.000000; Qij_ECM_Init[50][38] = 0.000000; Qij_ECM_Init[50][39] = 0.000000; Qij_ECM_Init[50][40] = 0.000000; Qij_ECM_Init[50][41] = 0.000000; Qij_ECM_Init[50][42] = 0.000000; Qij_ECM_Init[50][43] = 0.000000; Qij_ECM_Init[50][44] = 0.000000; Qij_ECM_Init[50][45] = 0.000000; Qij_ECM_Init[50][46] = 4.308415; Qij_ECM_Init[50][47] = 0.000000; Qij_ECM_Init[50][48] = 0.000000; Qij_ECM_Init[50][49] = 6.516319; 
		Qij_ECM_Init[51][0] = 0.000000; Qij_ECM_Init[51][1] = 0.000000; Qij_ECM_Init[51][2] = 0.000000; Qij_ECM_Init[51][3] = 0.000000; Qij_ECM_Init[51][4] = 0.000000; Qij_ECM_Init[51][5] = 0.000000; Qij_ECM_Init[51][6] = 9.880382; Qij_ECM_Init[51][7] = 0.000000; Qij_ECM_Init[51][8] = 0.000000; Qij_ECM_Init[51][9] = 0.000000; Qij_ECM_Init[51][10] = 0.000000; Qij_ECM_Init[51][11] = 0.000000; Qij_ECM_Init[51][12] = 0.000000; Qij_ECM_Init[51][13] = 0.000000; Qij_ECM_Init[51][14] = 0.000000; Qij_ECM_Init[51][15] = 0.000000; Qij_ECM_Init[51][16] = 0.000000; Qij_ECM_Init[51][17] = 0.000000; Qij_ECM_Init[51][18] = 0.000000; Qij_ECM_Init[51][19] = 2.923972; Qij_ECM_Init[51][20] = 0.000000; Qij_ECM_Init[51][21] = 0.000000; Qij_ECM_Init[51][22] = 0.000000; Qij_ECM_Init[51][23] = 0.000000; Qij_ECM_Init[51][24] = 0.000000; Qij_ECM_Init[51][25] = 0.000000; Qij_ECM_Init[51][26] = 0.000000; Qij_ECM_Init[51][27] = 0.000000; Qij_ECM_Init[51][28] = 0.000000; Qij_ECM_Init[51][29] = 0.000000; Qij_ECM_Init[51][30] = 0.000000; Qij_ECM_Init[51][31] = 0.000000; Qij_ECM_Init[51][32] = 0.000000; Qij_ECM_Init[51][33] = 0.000000; Qij_ECM_Init[51][34] = 0.000000; Qij_ECM_Init[51][35] = 3.064069; Qij_ECM_Init[51][36] = 0.000000; Qij_ECM_Init[51][37] = 0.000000; Qij_ECM_Init[51][38] = 0.000000; Qij_ECM_Init[51][39] = 0.000000; Qij_ECM_Init[51][40] = 0.000000; Qij_ECM_Init[51][41] = 0.000000; Qij_ECM_Init[51][42] = 0.000000; Qij_ECM_Init[51][43] = 0.000000; Qij_ECM_Init[51][44] = 0.000000; Qij_ECM_Init[51][45] = 0.000000; Qij_ECM_Init[51][46] = 0.000000; Qij_ECM_Init[51][47] = 6.291148; Qij_ECM_Init[51][48] = 0.000000; Qij_ECM_Init[51][49] = 21.910225; Qij_ECM_Init[51][50] = 5.090423; 
		Qij_ECM_Init[52][0] = 0.000000; Qij_ECM_Init[52][1] = 0.000000; Qij_ECM_Init[52][2] = 0.000000; Qij_ECM_Init[52][3] = 0.000000; Qij_ECM_Init[52][4] = 0.000000; Qij_ECM_Init[52][5] = 0.000000; Qij_ECM_Init[52][6] = 0.000000; Qij_ECM_Init[52][7] = 21.863158; Qij_ECM_Init[52][8] = 0.000000; Qij_ECM_Init[52][9] = 0.000000; Qij_ECM_Init[52][10] = 0.000000; Qij_ECM_Init[52][11] = 0.000000; Qij_ECM_Init[52][12] = 0.000000; Qij_ECM_Init[52][13] = 0.000000; Qij_ECM_Init[52][14] = 0.000000; Qij_ECM_Init[52][15] = 0.000000; Qij_ECM_Init[52][16] = 0.000000; Qij_ECM_Init[52][17] = 0.000000; Qij_ECM_Init[52][18] = 0.000000; Qij_ECM_Init[52][19] = 0.000000; Qij_ECM_Init[52][20] = 6.034856; Qij_ECM_Init[52][21] = 0.000000; Qij_ECM_Init[52][22] = 0.000000; Qij_ECM_Init[52][23] = 0.000000; Qij_ECM_Init[52][24] = 0.000000; Qij_ECM_Init[52][25] = 0.000000; Qij_ECM_Init[52][26] = 0.000000; Qij_ECM_Init[52][27] = 0.000000; Qij_ECM_Init[52][28] = 0.000000; Qij_ECM_Init[52][29] = 0.000000; Qij_ECM_Init[52][30] = 0.000000; Qij_ECM_Init[52][31] = 0.000000; Qij_ECM_Init[52][32] = 0.000000; Qij_ECM_Init[52][33] = 0.000000; Qij_ECM_Init[52][34] = 0.000000; Qij_ECM_Init[52][35] = 0.000000; Qij_ECM_Init[52][36] = 25.461549; Qij_ECM_Init[52][37] = 0.000000; Qij_ECM_Init[52][38] = 0.000000; Qij_ECM_Init[52][39] = 0.000000; Qij_ECM_Init[52][40] = 0.000000; Qij_ECM_Init[52][41] = 0.000000; Qij_ECM_Init[52][42] = 0.000000; Qij_ECM_Init[52][43] = 0.000000; Qij_ECM_Init[52][44] = 0.000000; Qij_ECM_Init[52][45] = 0.000000; Qij_ECM_Init[52][46] = 0.000000; Qij_ECM_Init[52][47] = 0.000000; Qij_ECM_Init[52][48] = 6.166554; Qij_ECM_Init[52][49] = 5.512586; Qij_ECM_Init[52][50] = 20.715347; Qij_ECM_Init[52][51] = 9.529141; 
		Qij_ECM_Init[53][0] = 0.000000; Qij_ECM_Init[53][1] = 0.000000; Qij_ECM_Init[53][2] = 0.000000; Qij_ECM_Init[53][3] = 0.000000; Qij_ECM_Init[53][4] = 0.000000; Qij_ECM_Init[53][5] = 0.000000; Qij_ECM_Init[53][6] = 0.000000; Qij_ECM_Init[53][7] = 0.000000; Qij_ECM_Init[53][8] = 0.367553; Qij_ECM_Init[53][9] = 0.000000; Qij_ECM_Init[53][10] = 0.000000; Qij_ECM_Init[53][11] = 0.000000; Qij_ECM_Init[53][12] = 0.000000; Qij_ECM_Init[53][13] = 0.000000; Qij_ECM_Init[53][14] = 0.000000; Qij_ECM_Init[53][15] = 0.000000; Qij_ECM_Init[53][16] = 0.000000; Qij_ECM_Init[53][17] = 0.000000; Qij_ECM_Init[53][18] = 0.000000; Qij_ECM_Init[53][19] = 0.000000; Qij_ECM_Init[53][20] = 0.000000; Qij_ECM_Init[53][21] = 0.383706; Qij_ECM_Init[53][22] = 0.000000; Qij_ECM_Init[53][23] = 0.000000; Qij_ECM_Init[53][24] = 0.000000; Qij_ECM_Init[53][25] = 0.000000; Qij_ECM_Init[53][26] = 0.000000; Qij_ECM_Init[53][27] = 0.000000; Qij_ECM_Init[53][28] = 0.000000; Qij_ECM_Init[53][29] = 0.000000; Qij_ECM_Init[53][30] = 0.000000; Qij_ECM_Init[53][31] = 0.000000; Qij_ECM_Init[53][32] = 0.000000; Qij_ECM_Init[53][33] = 0.000000; Qij_ECM_Init[53][34] = 0.000000; Qij_ECM_Init[53][35] = 0.000000; Qij_ECM_Init[53][36] = 0.000000; Qij_ECM_Init[53][37] = 6.091654; Qij_ECM_Init[53][38] = 0.000000; Qij_ECM_Init[53][39] = 0.000000; Qij_ECM_Init[53][40] = 0.000000; Qij_ECM_Init[53][41] = 0.000000; Qij_ECM_Init[53][42] = 0.000000; Qij_ECM_Init[53][43] = 0.000000; Qij_ECM_Init[53][44] = 0.000000; Qij_ECM_Init[53][45] = 0.352915; Qij_ECM_Init[53][46] = 0.000000; Qij_ECM_Init[53][47] = 0.000000; Qij_ECM_Init[53][48] = 0.000000; Qij_ECM_Init[53][49] = 0.693026; Qij_ECM_Init[53][50] = 0.000000; Qij_ECM_Init[53][51] = 0.000000; Qij_ECM_Init[53][52] = 0.000000; 
		Qij_ECM_Init[54][0] = 0.000000; Qij_ECM_Init[54][1] = 0.000000; Qij_ECM_Init[54][2] = 0.000000; Qij_ECM_Init[54][3] = 0.000000; Qij_ECM_Init[54][4] = 0.000000; Qij_ECM_Init[54][5] = 0.000000; Qij_ECM_Init[54][6] = 0.000000; Qij_ECM_Init[54][7] = 0.000000; Qij_ECM_Init[54][8] = 0.000000; Qij_ECM_Init[54][9] = 0.294702; Qij_ECM_Init[54][10] = 0.000000; Qij_ECM_Init[54][11] = 0.000000; Qij_ECM_Init[54][12] = 0.000000; Qij_ECM_Init[54][13] = 0.000000; Qij_ECM_Init[54][14] = 0.000000; Qij_ECM_Init[54][15] = 0.000000; Qij_ECM_Init[54][16] = 0.000000; Qij_ECM_Init[54][17] = 0.000000; Qij_ECM_Init[54][18] = 0.000000; Qij_ECM_Init[54][19] = 0.000000; Qij_ECM_Init[54][20] = 0.000000; Qij_ECM_Init[54][21] = 0.000000; Qij_ECM_Init[54][22] = 3.006827; Qij_ECM_Init[54][23] = 0.000000; Qij_ECM_Init[54][24] = 0.000000; Qij_ECM_Init[54][25] = 0.000000; Qij_ECM_Init[54][26] = 0.000000; Qij_ECM_Init[54][27] = 0.000000; Qij_ECM_Init[54][28] = 0.000000; Qij_ECM_Init[54][29] = 0.000000; Qij_ECM_Init[54][30] = 0.000000; Qij_ECM_Init[54][31] = 0.000000; Qij_ECM_Init[54][32] = 0.000000; Qij_ECM_Init[54][33] = 0.000000; Qij_ECM_Init[54][34] = 0.000000; Qij_ECM_Init[54][35] = 0.000000; Qij_ECM_Init[54][36] = 0.000000; Qij_ECM_Init[54][37] = 0.000000; Qij_ECM_Init[54][38] = 3.686074; Qij_ECM_Init[54][39] = 0.000000; Qij_ECM_Init[54][40] = 0.000000; Qij_ECM_Init[54][41] = 0.000000; Qij_ECM_Init[54][42] = 0.000000; Qij_ECM_Init[54][43] = 0.000000; Qij_ECM_Init[54][44] = 0.000000; Qij_ECM_Init[54][45] = 0.000000; Qij_ECM_Init[54][46] = 0.208522; Qij_ECM_Init[54][47] = 0.000000; Qij_ECM_Init[54][48] = 0.000000; Qij_ECM_Init[54][49] = 0.000000; Qij_ECM_Init[54][50] = 1.866565; Qij_ECM_Init[54][51] = 0.000000; Qij_ECM_Init[54][52] = 0.000000; Qij_ECM_Init[54][53] = 10.605899; 
		Qij_ECM_Init[55][0] = 0.000000; Qij_ECM_Init[55][1] = 0.000000; Qij_ECM_Init[55][2] = 0.000000; Qij_ECM_Init[55][3] = 0.000000; Qij_ECM_Init[55][4] = 0.000000; Qij_ECM_Init[55][5] = 0.000000; Qij_ECM_Init[55][6] = 0.000000; Qij_ECM_Init[55][7] = 0.000000; Qij_ECM_Init[55][8] = 0.000000; Qij_ECM_Init[55][9] = 0.000000; Qij_ECM_Init[55][10] = 0.000000; Qij_ECM_Init[55][11] = 0.000000; Qij_ECM_Init[55][12] = 0.000000; Qij_ECM_Init[55][13] = 0.000000; Qij_ECM_Init[55][14] = 0.000000; Qij_ECM_Init[55][15] = 0.000000; Qij_ECM_Init[55][16] = 0.000000; Qij_ECM_Init[55][17] = 0.000000; Qij_ECM_Init[55][18] = 0.000000; Qij_ECM_Init[55][19] = 0.000000; Qij_ECM_Init[55][20] = 0.000000; Qij_ECM_Init[55][21] = 0.000000; Qij_ECM_Init[55][22] = 0.000000; Qij_ECM_Init[55][23] = 4.485369; Qij_ECM_Init[55][24] = 0.000000; Qij_ECM_Init[55][25] = 0.000000; Qij_ECM_Init[55][26] = 0.000000; Qij_ECM_Init[55][27] = 0.000000; Qij_ECM_Init[55][28] = 0.000000; Qij_ECM_Init[55][29] = 0.000000; Qij_ECM_Init[55][30] = 0.000000; Qij_ECM_Init[55][31] = 0.000000; Qij_ECM_Init[55][32] = 0.000000; Qij_ECM_Init[55][33] = 0.000000; Qij_ECM_Init[55][34] = 0.000000; Qij_ECM_Init[55][35] = 0.000000; Qij_ECM_Init[55][36] = 0.000000; Qij_ECM_Init[55][37] = 0.000000; Qij_ECM_Init[55][38] = 0.000000; Qij_ECM_Init[55][39] = 2.811398; Qij_ECM_Init[55][40] = 0.000000; Qij_ECM_Init[55][41] = 0.000000; Qij_ECM_Init[55][42] = 0.000000; Qij_ECM_Init[55][43] = 0.000000; Qij_ECM_Init[55][44] = 0.000000; Qij_ECM_Init[55][45] = 0.000000; Qij_ECM_Init[55][46] = 0.000000; Qij_ECM_Init[55][47] = 1.277861; Qij_ECM_Init[55][48] = 0.000000; Qij_ECM_Init[55][49] = 0.000000; Qij_ECM_Init[55][50] = 0.000000; Qij_ECM_Init[55][51] = 2.774445; Qij_ECM_Init[55][52] = 0.000000; Qij_ECM_Init[55][53] = 2.710610; Qij_ECM_Init[55][54] = 0.650088; 
		Qij_ECM_Init[56][0] = 0.000000; Qij_ECM_Init[56][1] = 0.000000; Qij_ECM_Init[56][2] = 0.000000; Qij_ECM_Init[56][3] = 0.000000; Qij_ECM_Init[56][4] = 0.000000; Qij_ECM_Init[56][5] = 0.000000; Qij_ECM_Init[56][6] = 0.000000; Qij_ECM_Init[56][7] = 0.000000; Qij_ECM_Init[56][8] = 0.000000; Qij_ECM_Init[56][9] = 0.000000; Qij_ECM_Init[56][10] = 0.000000; Qij_ECM_Init[56][11] = 0.000000; Qij_ECM_Init[56][12] = 0.000000; Qij_ECM_Init[56][13] = 0.000000; Qij_ECM_Init[56][14] = 0.000000; Qij_ECM_Init[56][15] = 0.000000; Qij_ECM_Init[56][16] = 0.000000; Qij_ECM_Init[56][17] = 0.000000; Qij_ECM_Init[56][18] = 0.000000; Qij_ECM_Init[56][19] = 0.000000; Qij_ECM_Init[56][20] = 0.000000; Qij_ECM_Init[56][21] = 0.000000; Qij_ECM_Init[56][22] = 0.000000; Qij_ECM_Init[56][23] = 0.000000; Qij_ECM_Init[56][24] = 7.686782; Qij_ECM_Init[56][25] = 0.000000; Qij_ECM_Init[56][26] = 0.000000; Qij_ECM_Init[56][27] = 0.000000; Qij_ECM_Init[56][28] = 0.000000; Qij_ECM_Init[56][29] = 0.000000; Qij_ECM_Init[56][30] = 0.000000; Qij_ECM_Init[56][31] = 0.000000; Qij_ECM_Init[56][32] = 0.000000; Qij_ECM_Init[56][33] = 0.000000; Qij_ECM_Init[56][34] = 0.000000; Qij_ECM_Init[56][35] = 0.000000; Qij_ECM_Init[56][36] = 0.000000; Qij_ECM_Init[56][37] = 0.000000; Qij_ECM_Init[56][38] = 0.000000; Qij_ECM_Init[56][39] = 0.000000; Qij_ECM_Init[56][40] = 2.090641; Qij_ECM_Init[56][41] = 0.000000; Qij_ECM_Init[56][42] = 0.000000; Qij_ECM_Init[56][43] = 0.000000; Qij_ECM_Init[56][44] = 0.000000; Qij_ECM_Init[56][45] = 0.000000; Qij_ECM_Init[56][46] = 0.000000; Qij_ECM_Init[56][47] = 0.000000; Qij_ECM_Init[56][48] = 0.476105; Qij_ECM_Init[56][49] = 0.000000; Qij_ECM_Init[56][50] = 0.000000; Qij_ECM_Init[56][51] = 0.000000; Qij_ECM_Init[56][52] = 9.441919; Qij_ECM_Init[56][53] = 1.296294; Qij_ECM_Init[56][54] = 3.779053; Qij_ECM_Init[56][55] = 10.153570; 
		Qij_ECM_Init[57][0] = 0.000000; Qij_ECM_Init[57][1] = 0.000000; Qij_ECM_Init[57][2] = 0.000000; Qij_ECM_Init[57][3] = 0.000000; Qij_ECM_Init[57][4] = 0.000000; Qij_ECM_Init[57][5] = 0.000000; Qij_ECM_Init[57][6] = 0.000000; Qij_ECM_Init[57][7] = 0.000000; Qij_ECM_Init[57][8] = 0.000000; Qij_ECM_Init[57][9] = 0.000000; Qij_ECM_Init[57][10] = 1.104727; Qij_ECM_Init[57][11] = 0.000000; Qij_ECM_Init[57][12] = 0.000000; Qij_ECM_Init[57][13] = 0.000000; Qij_ECM_Init[57][14] = 0.000000; Qij_ECM_Init[57][15] = 0.000000; Qij_ECM_Init[57][16] = 0.000000; Qij_ECM_Init[57][17] = 0.000000; Qij_ECM_Init[57][18] = 0.000000; Qij_ECM_Init[57][19] = 0.000000; Qij_ECM_Init[57][20] = 0.000000; Qij_ECM_Init[57][21] = 0.000000; Qij_ECM_Init[57][22] = 0.000000; Qij_ECM_Init[57][23] = 0.000000; Qij_ECM_Init[57][24] = 0.000000; Qij_ECM_Init[57][25] = 0.041150; Qij_ECM_Init[57][26] = 0.000000; Qij_ECM_Init[57][27] = 0.000000; Qij_ECM_Init[57][28] = 0.000000; Qij_ECM_Init[57][29] = 0.000000; Qij_ECM_Init[57][30] = 0.000000; Qij_ECM_Init[57][31] = 0.000000; Qij_ECM_Init[57][32] = 0.000000; Qij_ECM_Init[57][33] = 0.000000; Qij_ECM_Init[57][34] = 0.000000; Qij_ECM_Init[57][35] = 0.000000; Qij_ECM_Init[57][36] = 0.000000; Qij_ECM_Init[57][37] = 0.000000; Qij_ECM_Init[57][38] = 0.000000; Qij_ECM_Init[57][39] = 0.000000; Qij_ECM_Init[57][40] = 0.000000; Qij_ECM_Init[57][41] = 10.590780; Qij_ECM_Init[57][42] = 0.000000; Qij_ECM_Init[57][43] = 0.000000; Qij_ECM_Init[57][44] = 0.000000; Qij_ECM_Init[57][45] = 0.503385; Qij_ECM_Init[57][46] = 0.000000; Qij_ECM_Init[57][47] = 0.000000; Qij_ECM_Init[57][48] = 0.000000; Qij_ECM_Init[57][49] = 1.541379; Qij_ECM_Init[57][50] = 0.000000; Qij_ECM_Init[57][51] = 0.000000; Qij_ECM_Init[57][52] = 0.000000; Qij_ECM_Init[57][53] = 1.042624; Qij_ECM_Init[57][54] = 0.000000; Qij_ECM_Init[57][55] = 0.000000; Qij_ECM_Init[57][56] = 0.000000; 
		Qij_ECM_Init[58][0] = 0.000000; Qij_ECM_Init[58][1] = 0.000000; Qij_ECM_Init[58][2] = 0.000000; Qij_ECM_Init[58][3] = 0.000000; Qij_ECM_Init[58][4] = 0.000000; Qij_ECM_Init[58][5] = 0.000000; Qij_ECM_Init[58][6] = 0.000000; Qij_ECM_Init[58][7] = 0.000000; Qij_ECM_Init[58][8] = 0.000000; Qij_ECM_Init[58][9] = 0.000000; Qij_ECM_Init[58][10] = 0.000000; Qij_ECM_Init[58][11] = 0.552851; Qij_ECM_Init[58][12] = 0.000000; Qij_ECM_Init[58][13] = 0.000000; Qij_ECM_Init[58][14] = 0.000000; Qij_ECM_Init[58][15] = 0.000000; Qij_ECM_Init[58][16] = 0.000000; Qij_ECM_Init[58][17] = 0.000000; Qij_ECM_Init[58][18] = 0.000000; Qij_ECM_Init[58][19] = 0.000000; Qij_ECM_Init[58][20] = 0.000000; Qij_ECM_Init[58][21] = 0.000000; Qij_ECM_Init[58][22] = 0.000000; Qij_ECM_Init[58][23] = 0.000000; Qij_ECM_Init[58][24] = 0.000000; Qij_ECM_Init[58][25] = 0.000000; Qij_ECM_Init[58][26] = 1.252470; Qij_ECM_Init[58][27] = 0.000000; Qij_ECM_Init[58][28] = 0.000000; Qij_ECM_Init[58][29] = 0.000000; Qij_ECM_Init[58][30] = 0.000000; Qij_ECM_Init[58][31] = 0.000000; Qij_ECM_Init[58][32] = 0.000000; Qij_ECM_Init[58][33] = 0.000000; Qij_ECM_Init[58][34] = 0.000000; Qij_ECM_Init[58][35] = 0.000000; Qij_ECM_Init[58][36] = 0.000000; Qij_ECM_Init[58][37] = 0.000000; Qij_ECM_Init[58][38] = 0.000000; Qij_ECM_Init[58][39] = 0.000000; Qij_ECM_Init[58][40] = 0.000000; Qij_ECM_Init[58][41] = 0.000000; Qij_ECM_Init[58][42] = 4.285543; Qij_ECM_Init[58][43] = 0.000000; Qij_ECM_Init[58][44] = 0.000000; Qij_ECM_Init[58][45] = 0.000000; Qij_ECM_Init[58][46] = 0.542717; Qij_ECM_Init[58][47] = 0.000000; Qij_ECM_Init[58][48] = 0.000000; Qij_ECM_Init[58][49] = 0.000000; Qij_ECM_Init[58][50] = 2.303487; Qij_ECM_Init[58][51] = 0.000000; Qij_ECM_Init[58][52] = 0.000000; Qij_ECM_Init[58][53] = 0.000000; Qij_ECM_Init[58][54] = 1.561629; Qij_ECM_Init[58][55] = 0.000000; Qij_ECM_Init[58][56] = 0.000000; Qij_ECM_Init[58][57] = 9.488520; 
		Qij_ECM_Init[59][0] = 0.000000; Qij_ECM_Init[59][1] = 0.000000; Qij_ECM_Init[59][2] = 0.000000; Qij_ECM_Init[59][3] = 0.000000; Qij_ECM_Init[59][4] = 0.000000; Qij_ECM_Init[59][5] = 0.000000; Qij_ECM_Init[59][6] = 0.000000; Qij_ECM_Init[59][7] = 0.000000; Qij_ECM_Init[59][8] = 0.000000; Qij_ECM_Init[59][9] = 0.000000; Qij_ECM_Init[59][10] = 0.000000; Qij_ECM_Init[59][11] = 0.000000; Qij_ECM_Init[59][12] = 0.000000; Qij_ECM_Init[59][13] = 0.000000; Qij_ECM_Init[59][14] = 0.000000; Qij_ECM_Init[59][15] = 0.000000; Qij_ECM_Init[59][16] = 0.000000; Qij_ECM_Init[59][17] = 0.000000; Qij_ECM_Init[59][18] = 0.000000; Qij_ECM_Init[59][19] = 0.000000; Qij_ECM_Init[59][20] = 0.000000; Qij_ECM_Init[59][21] = 0.000000; Qij_ECM_Init[59][22] = 0.000000; Qij_ECM_Init[59][23] = 0.000000; Qij_ECM_Init[59][24] = 0.000000; Qij_ECM_Init[59][25] = 0.000000; Qij_ECM_Init[59][26] = 0.000000; Qij_ECM_Init[59][27] = 0.091041; Qij_ECM_Init[59][28] = 0.000000; Qij_ECM_Init[59][29] = 0.000000; Qij_ECM_Init[59][30] = 0.000000; Qij_ECM_Init[59][31] = 0.000000; Qij_ECM_Init[59][32] = 0.000000; Qij_ECM_Init[59][33] = 0.000000; Qij_ECM_Init[59][34] = 0.000000; Qij_ECM_Init[59][35] = 0.000000; Qij_ECM_Init[59][36] = 0.000000; Qij_ECM_Init[59][37] = 0.000000; Qij_ECM_Init[59][38] = 0.000000; Qij_ECM_Init[59][39] = 0.000000; Qij_ECM_Init[59][40] = 0.000000; Qij_ECM_Init[59][41] = 0.000000; Qij_ECM_Init[59][42] = 0.000000; Qij_ECM_Init[59][43] = 1.432410; Qij_ECM_Init[59][44] = 0.000000; Qij_ECM_Init[59][45] = 0.000000; Qij_ECM_Init[59][46] = 0.000000; Qij_ECM_Init[59][47] = 0.702411; Qij_ECM_Init[59][48] = 0.000000; Qij_ECM_Init[59][49] = 0.000000; Qij_ECM_Init[59][50] = 0.000000; Qij_ECM_Init[59][51] = 2.985093; Qij_ECM_Init[59][52] = 0.000000; Qij_ECM_Init[59][53] = 0.000000; Qij_ECM_Init[59][54] = 0.000000; Qij_ECM_Init[59][55] = 0.874000; Qij_ECM_Init[59][56] = 0.000000; Qij_ECM_Init[59][57] = 20.518100; Qij_ECM_Init[59][58] = 4.120953; 
		Qij_ECM_Init[60][0] = 0.000000; Qij_ECM_Init[60][1] = 0.000000; Qij_ECM_Init[60][2] = 0.000000; Qij_ECM_Init[60][3] = 0.000000; Qij_ECM_Init[60][4] = 0.000000; Qij_ECM_Init[60][5] = 0.000000; Qij_ECM_Init[60][6] = 0.000000; Qij_ECM_Init[60][7] = 0.000000; Qij_ECM_Init[60][8] = 0.000000; Qij_ECM_Init[60][9] = 0.000000; Qij_ECM_Init[60][10] = 0.000000; Qij_ECM_Init[60][11] = 0.000000; Qij_ECM_Init[60][12] = 0.810856; Qij_ECM_Init[60][13] = 0.000000; Qij_ECM_Init[60][14] = 0.000000; Qij_ECM_Init[60][15] = 0.000000; Qij_ECM_Init[60][16] = 0.000000; Qij_ECM_Init[60][17] = 0.000000; Qij_ECM_Init[60][18] = 0.000000; Qij_ECM_Init[60][19] = 0.000000; Qij_ECM_Init[60][20] = 0.000000; Qij_ECM_Init[60][21] = 0.000000; Qij_ECM_Init[60][22] = 0.000000; Qij_ECM_Init[60][23] = 0.000000; Qij_ECM_Init[60][24] = 0.000000; Qij_ECM_Init[60][25] = 0.000000; Qij_ECM_Init[60][26] = 0.000000; Qij_ECM_Init[60][27] = 0.000000; Qij_ECM_Init[60][28] = 4.803738; Qij_ECM_Init[60][29] = 0.000000; Qij_ECM_Init[60][30] = 0.000000; Qij_ECM_Init[60][31] = 0.000000; Qij_ECM_Init[60][32] = 0.000000; Qij_ECM_Init[60][33] = 0.000000; Qij_ECM_Init[60][34] = 0.000000; Qij_ECM_Init[60][35] = 0.000000; Qij_ECM_Init[60][36] = 0.000000; Qij_ECM_Init[60][37] = 0.000000; Qij_ECM_Init[60][38] = 0.000000; Qij_ECM_Init[60][39] = 0.000000; Qij_ECM_Init[60][40] = 0.000000; Qij_ECM_Init[60][41] = 0.000000; Qij_ECM_Init[60][42] = 0.000000; Qij_ECM_Init[60][43] = 0.000000; Qij_ECM_Init[60][44] = 5.388514; Qij_ECM_Init[60][45] = 0.000000; Qij_ECM_Init[60][46] = 0.000000; Qij_ECM_Init[60][47] = 0.000000; Qij_ECM_Init[60][48] = 0.302501; Qij_ECM_Init[60][49] = 0.000000; Qij_ECM_Init[60][50] = 0.000000; Qij_ECM_Init[60][51] = 0.000000; Qij_ECM_Init[60][52] = 6.644971; Qij_ECM_Init[60][53] = 0.000000; Qij_ECM_Init[60][54] = 0.000000; Qij_ECM_Init[60][55] = 0.000000; Qij_ECM_Init[60][56] = 1.393810; Qij_ECM_Init[60][57] = 13.246936; Qij_ECM_Init[60][58] = 18.064826; Qij_ECM_Init[60][59] = 19.084271; 

		Freq_ECM_Init[0] = 0.022103; Freq_ECM_Init[1] = 0.021383; Freq_ECM_Init[2] = 0.016387; Freq_ECM_Init[3] = 0.015425; Freq_ECM_Init[4] = 0.011880; Freq_ECM_Init[5] = 0.011131; Freq_ECM_Init[6] = 0.009750; Freq_ECM_Init[7] = 0.008956; Freq_ECM_Init[8] = 0.015965; Freq_ECM_Init[9] = 0.015782; Freq_ECM_Init[10] = 0.006025; Freq_ECM_Init[11] = 0.007029; Freq_ECM_Init[12] = 0.011880; Freq_ECM_Init[13] = 0.014467; Freq_ECM_Init[14] = 0.017386; Freq_ECM_Init[15] = 0.007600; Freq_ECM_Init[16] = 0.028839; Freq_ECM_Init[17] = 0.010007; Freq_ECM_Init[18] = 0.010100; Freq_ECM_Init[19] = 0.010642; Freq_ECM_Init[20] = 0.011843; Freq_ECM_Init[21] = 0.011097; Freq_ECM_Init[22] = 0.011703; Freq_ECM_Init[23] = 0.016076; Freq_ECM_Init[24] = 0.020211; Freq_ECM_Init[25] = 0.008311; Freq_ECM_Init[26] = 0.014148; Freq_ECM_Init[27] = 0.004800; Freq_ECM_Init[28] = 0.007837; Freq_ECM_Init[29] = 0.025576; Freq_ECM_Init[30] = 0.023441; Freq_ECM_Init[31] = 0.013551; Freq_ECM_Init[32] = 0.020102; Freq_ECM_Init[33] = 0.013424; Freq_ECM_Init[34] = 0.020201; Freq_ECM_Init[35] = 0.015528; Freq_ECM_Init[36] = 0.012142; Freq_ECM_Init[37] = 0.023006; Freq_ECM_Init[38] = 0.020171; Freq_ECM_Init[39] = 0.030001; Freq_ECM_Init[40] = 0.026344; Freq_ECM_Init[41] = 0.010142; Freq_ECM_Init[42] = 0.011679; Freq_ECM_Init[43] = 0.010372; Freq_ECM_Init[44] = 0.008195; Freq_ECM_Init[45] = 0.019047; Freq_ECM_Init[46] = 0.018938; Freq_ECM_Init[47] = 0.010901; Freq_ECM_Init[48] = 0.022747; Freq_ECM_Init[49] = 0.019005; Freq_ECM_Init[50] = 0.028307; Freq_ECM_Init[51] = 0.015908; Freq_ECM_Init[52] = 0.018853; Freq_ECM_Init[53] = 0.028198; Freq_ECM_Init[54] = 0.024532; Freq_ECM_Init[55] = 0.033223; Freq_ECM_Init[56] = 0.031878; Freq_ECM_Init[57] = 0.016852; Freq_ECM_Init[58] = 0.022982; Freq_ECM_Init[59] = 0.015796; Freq_ECM_Init[60] = 0.010191; 



		/* complete the matrix */			
		for (i = 0; i < NUMCOD; i++)
			{
			for (j = 0; j < NUMCOD; j++)
				{
				if (i == j)
					Qij_ECM_Init[i][j] = 0; /* main diagonal */
				if (i != j) 
					{
					if (Qij_ECM_Init[i][j] == -1 && Qij_ECM_Init[j][i] >= 0)
						Qij_ECM_Init[i][j] = Qij_ECM_Init[j][i]; /* symetric matrix */
					if (Qij_ECM_Init[j][i] == -1 && Qij_ECM_Init[i][j] >= 0)
						Qij_ECM_Init[j][i] = Qij_ECM_Init[i][j]; /* symetric matrix */
					} 
				}		
			}


		/* check if the matrix is symmetric: [0][1] = [1][0] */
		/*for (i = 0; i < NUMCOD; i++)
			for (j = 0; j < NUMCOD; j++)
				{
				if (i == j) 
					{
					if (Qij_ECM_Init[i][j] > 0.00000000001 || Qij_ECM_Init[i][j] < -0.00000000001)
						{
						if (noisy > 2)
							fprintf (stderr, "\n\n> ECM1: Warning in the emperical codon matrix. Main diagonal is different to 0: Q[%d][%d] = %lf \n\n", i, j, Qij_ECM_Init[i][j]);
						}
					}
				else 
					{
					if (Qij_ECM_Init[i][j] != Qij_ECM_Init[j][i])
						{
						if (noisy > 2)
							fprintf (stderr, "\n\n> ECM1: Warning in the emperical codon matrix. Matrix is not symmetric: Q[%d][%d] (%lf) = Q[%d][%d] (%lf) \n\n", i, j, Qij_ECM_Init[i][j], j, i, Qij_ECM_Init[j][i]);
						}

					}			
				}*/



		/* adapt matrix to our codon order */

		/* Kosiol et al: TTT TTC TTA TTG TCT TCC TCA TCG TAT TAC TGT TGC TGG CTT CTC CTA CTG CCT CCC CCA 
		CCG CAT CAC CAA CAG CGT CGC CGA CGG ATT ATC ATA ATG ACT ACC ACA ACG AAT AAC AAA 
		AAG AGT AGC AGA AGG GTT GTC GTA GTG GCT GCC GCA GCG GAT GAC GAA GAG GGT GGC GGA 
		GGG */

		/* our matrix: AAA AAC AAG AAT ACA ACC ACG ACT AGA AGC AGG AGT ATA ATC ATG ATT CAA CAC CAG CAT 
		CCA CCC CCG CCT CGA CGC CGG CGT CTA CTC CTG CTT GAA GAC GAG GAT GCA GCC GCG GCT 
		GGA GGC GGG GGT GTA GTC GTG GTT TAC TAT TCA TCC TCG TCT TGC TGG TGT TTA TTC TTG TTT */

		/* our matrix - Kosiol et al */
		/*
		0 39
		1 38
		2 40
		3 37
		4 35
		5 34
		6 36
		7 33
		8 43
		9 42
		10 44
		11 41
		12 31
		13 30
		14 32
		15 29
		16 23
		17 22
		18 24
		19 21
		20 19
		21 18
		22 20
		23 17
		24 27
		25 26
		26 28
		27 25
		28 15
		29 14
		30 16
		31 13
		32 55
		33 54
		34 56
		35 53
		36 51
		37 50
		38 52
		39 49
		40 59
		41 58
		42 60
		43 57
		44 47
		45 46
		46 48
		47 45
		48 9
		49 8
		50 6
		51 5
		52 7
		53 4
		54 11
		55 12
		56 10
		57 2
		58 1
		59 3
		60 0
		*/

		
		for (i = 0; i < NUMCOD; i++)
			{
			for (j = 0; j < NUMCOD; j++)
				{
				if (i == j)
					{
					Qij_C[i][j] = 0; /* main diagonal */
					Qij_ECM_Init[i][j] = 0;
					}
				else
					{
					if (i == 39)
						a = 0;
					if (i == 38)
						a = 1;
					if (i == 40)
						a = 2;
					if (i == 37)
						a = 3;
					if (i == 35)
						a = 4;
					if (i == 34)
						a = 5;
					if (i == 36)
						a = 6;
					if (i == 33)
						a = 7;
					if (i == 43)
						a = 8;
					if (i == 42)
						a = 9;
					if (i == 44)
						a = 10;
					if (i == 41)
						a = 11;
					if (i == 31)
						a = 12;
					if (i == 30)
						a = 13;
					if (i == 32)
						a = 14;
					if (i == 29)
						a = 15;
					if (i == 23)
						a = 16;
					if (i == 22)
						a = 17;
					if (i == 24)
						a = 18;
					if (i == 21)
						a = 19;
					if (i == 19)
						a = 20;
					if (i == 18)
						a = 21;
					if (i == 20)
						a = 22;
					if (i == 17)
						a = 23;
					if (i == 27)
						a = 24;
					if (i == 26)
						a = 25;
					if (i == 28)
						a = 26;
					if (i == 25)
						a = 27;
					if (i == 15)
						a = 28;
					if (i == 14)
						a = 29;
					if (i == 16)
						a = 30;
					if (i == 13)
						a = 31;
					if (i == 55)
						a = 32;
					if (i == 54)
						a = 33;
					if (i == 56)
						a = 34;
					if (i == 53)
						a = 35;
					if (i == 51)
						a = 36;
					if (i == 50)
						a = 37;
					if (i == 52)
						a = 38;
					if (i == 49)
						a = 39;
					if (i == 59)
						a = 40;
					if (i == 58)
						a = 41;
					if (i == 60)
						a = 42;
					if (i == 57)
						a = 43;
					if (i == 47)
						a = 44;
					if (i == 46)
						a = 45;
					if (i == 48)
						a = 46;
					if (i == 45)
						a = 47;
					if (i == 9)
						a = 48;
					if (i == 8)
						a = 49;
					if (i == 6)
						a = 50;
					if (i == 5)
						a = 51;
					if (i == 7)
						a = 52;
					if (i == 4)
						a = 53;
					if (i == 11)
						a = 54;
					if (i == 12)
						a = 55;
					if (i == 10)
						a = 56;
					if (i == 2)
						a = 57;
					if (i == 1)
						a = 58;
					if (i == 3)
						a = 59;
					if (i == 0)
						a = 60;


					if (j == 39)
						b = 0;
					if (j == 38)
						b = 1;
					if (j == 40)
						b = 2;
					if (j == 37)
						b = 3;
					if (j == 35)
						b = 4;
					if (j == 34)
						b = 5;
					if (j == 36)
						b = 6;
					if (j == 33)
						b = 7;
					if (j == 43)
						b = 8;
					if (j == 42)
						b = 9;
					if (j == 44)
						b = 10;
					if (j == 41)
						b = 11;
					if (j == 31)
						b = 12;
					if (j == 30)
						b = 13;
					if (j == 32)
						b = 14;
					if (j == 29)
						b = 15;
					if (j == 23)
						b = 16;
					if (j == 22)
						b = 17;
					if (j == 24)
						b = 18;
					if (j == 21)
						b = 19;
					if (j == 19)
						b = 20;
					if (j == 18)
						b = 21;
					if (j == 20)
						b = 22;
					if (j == 17)
						b = 23;
					if (j == 27)
						b = 24;
					if (j == 26)
						b = 25;
					if (j == 28)
						b = 26;
					if (j == 25)
						b = 27;
					if (j == 15)
						b = 28;
					if (j == 14)
						b = 29;
					if (j == 16)
						b = 30;
					if (j == 13)
						b = 31;
					if (j == 55)
						b = 32;
					if (j == 54)
						b = 33;
					if (j == 56)
						b = 34;
					if (j == 53)
						b = 35;
					if (j == 51)
						b = 36;
					if (j == 50)
						b = 37;
					if (j == 52)
						b = 38;
					if (j == 49)
						b = 39;
					if (j == 59)
						b = 40;
					if (j == 58)
						b = 41;
					if (j == 60)
						b = 42;
					if (j == 57)
						b = 43;
					if (j == 47)
						b = 44;
					if (j == 46)
						b = 45;
					if (j == 48)
						b = 46;
					if (j == 45)
						b = 47;
					if (j == 9)
						b = 48;
					if (j == 8)
						b = 49;
					if (j == 6)
						b = 50;
					if (j == 5)
						b = 51;
					if (j == 7)
						b = 52;
					if (j == 4)
						b = 53;
					if (j == 11)
						b = 54;
					if (j == 12)
						b = 55;
					if (j == 10)
						b = 56;
					if (j == 2)
						b = 57;
					if (j == 1)
						b = 58;
					if (j == 3)
						b = 59;
					if (j == 0)
						b = 60;

					Qij_C[a][b] = Qij_ECM_Init[i][j];
					

					if (i == 0) /* Freqs */
						{
						Qij_CF[b] = Freq_ECM_Init[j];
						Qij_CF[60] = Freq_ECM_Init[0]; /* because i==j is not considered here */
						}
					}

				}		
			}


		/* check if the matrix is symmetric: [0][1] = [1][0] */
		/*for (i = 0; i < NUMCOD; i++)
			for (j = 0; j < NUMCOD; j++)
				{
				if (i == j) 
					{
					if (Qij_C[i][j] > 0.00000000001 || Qij_C[i][j] < -0.00000000001)
						{
						if (noisy > 2)
							fprintf (stderr, "\n\n> ECM2: Warning in the emperical codon matrix. Main diagonal is different to 0: Q[%d][%d] = %lf \n\n", i, j, Qij_C[i][j]);
						}
					}
				else 
					{
					if (Qij_C[i][j] != Qij_C[j][i])
						{
						if (noisy > 2)
							fprintf (stderr, "\n\n> ECM2: Warning in the emperical codon matrix. Matrix is not symmetric: Q[%d][%d] (%lf) = Q[%d][%d] (%lf) \n\n", i, j, Qij_C[i][j], j, i, Qij_C[j][i]);
						}

					}			
				}*/


		}
	else if (doECMunrest == YES) /* Kosiol et al (Empirical codon model* -unrestricted, allowing for multiple nucleotide changes-) */
		{
		/*fprintf (stderr,"     Model: ECMunrest \n\n");*/

		/*  Original matrix */
		/* TTT TTC TTA TTG TCT TCC TCA TCG TAT TAC TGT TGC TGG CTT CTC CTA CTG CCT CCC CCA 
		CCG CAT CAC CAA CAG CGT CGC CGA CGG ATT ATC ATA ATG ACT ACC ACA ACG AAT AAC AAA 
		AAG AGT AGC AGA AGG GTT GTC GTA GTG GCT GCC GCA GCG GAT GAC GAA GAG GGT GGC GGA 
		GGG */

		Qij_ECM_Init[1][0] = 16.011531; 
		Qij_ECM_Init[2][0] = 2.395822; Qij_ECM_Init[2][1] = 0.151858; 
		Qij_ECM_Init[3][0] = 1.204356; Qij_ECM_Init[3][1] = 0.675537; Qij_ECM_Init[3][2] = 18.541946; 
		Qij_ECM_Init[4][0] = 0.773935; Qij_ECM_Init[4][1] = 0.052602; Qij_ECM_Init[4][2] = 0.249707; Qij_ECM_Init[4][3] = 0.274990; 
		Qij_ECM_Init[5][0] = 0.030074; Qij_ECM_Init[5][1] = 0.656004; Qij_ECM_Init[5][2] = 0.011609; Qij_ECM_Init[5][3] = 0.158873; Qij_ECM_Init[5][4] = 23.655090; 
		Qij_ECM_Init[6][0] = 0.278090; Qij_ECM_Init[6][1] = 0.056677; Qij_ECM_Init[6][2] = 1.184813; Qij_ECM_Init[6][3] = 0.611887; Qij_ECM_Init[6][4] = 35.921779; Qij_ECM_Init[6][5] = 15.982573; 
		Qij_ECM_Init[7][0] = 0.034137; Qij_ECM_Init[7][1] = 0.198277; Qij_ECM_Init[7][2] = 0.010188; Qij_ECM_Init[7][3] = 0.694091; Qij_ECM_Init[7][4] = 11.510965; Qij_ECM_Init[7][5] = 35.359077; Qij_ECM_Init[7][6] = 17.424222; 
		Qij_ECM_Init[8][0] = 4.317981; Qij_ECM_Init[8][1] = 0.503397; Qij_ECM_Init[8][2] = 0.798582; Qij_ECM_Init[8][3] = 0.337279; Qij_ECM_Init[8][4] = 0.688169; Qij_ECM_Init[8][5] = 0.047115; Qij_ECM_Init[8][6] = 0.341791; Qij_ECM_Init[8][7] = 0.058136; 
		Qij_ECM_Init[9][0] = 0.481042; Qij_ECM_Init[9][1] = 4.483501; Qij_ECM_Init[9][2] = 0.033529; Qij_ECM_Init[9][3] = 0.177833; Qij_ECM_Init[9][4] = 0.069588; Qij_ECM_Init[9][5] = 0.524116; Qij_ECM_Init[9][6] = 0.070809; Qij_ECM_Init[9][7] = 0.213967; Qij_ECM_Init[9][8] = 24.177765; 
		Qij_ECM_Init[10][0] = 0.733587; Qij_ECM_Init[10][1] = 0.076912; Qij_ECM_Init[10][2] = 0.645571; Qij_ECM_Init[10][3] = 0.395942; Qij_ECM_Init[10][4] = 1.811753; Qij_ECM_Init[10][5] = 0.343463; Qij_ECM_Init[10][6] = 0.751980; Qij_ECM_Init[10][7] = 0.143447; Qij_ECM_Init[10][8] = 0.822999; Qij_ECM_Init[10][9] = 0.054860; 
		Qij_ECM_Init[11][0] = 0.045951; Qij_ECM_Init[11][1] = 0.561620; Qij_ECM_Init[11][2] = 0.040012; Qij_ECM_Init[11][3] = 0.240632; Qij_ECM_Init[11][4] = 0.138244; Qij_ECM_Init[11][5] = 1.323765; Qij_ECM_Init[11][6] = 0.121937; Qij_ECM_Init[11][7] = 0.493179; Qij_ECM_Init[11][8] = 0.068342; Qij_ECM_Init[11][9] = 0.628438; Qij_ECM_Init[11][10] = 56.838378; 
		Qij_ECM_Init[12][0] = 0.786871; Qij_ECM_Init[12][1] = 1.183337; Qij_ECM_Init[12][2] = 0.271072; Qij_ECM_Init[12][3] = 0.632947; Qij_ECM_Init[12][4] = 0.069758; Qij_ECM_Init[12][5] = 0.081312; Qij_ECM_Init[12][6] = 0.195833; Qij_ECM_Init[12][7] = 0.410046; Qij_ECM_Init[12][8] = 1.140051; Qij_ECM_Init[12][9] = 1.421996; Qij_ECM_Init[12][10] = 0.264556; Qij_ECM_Init[12][11] = 0.210115; 
		Qij_ECM_Init[13][0] = 2.016257; Qij_ECM_Init[13][1] = 0.207692; Qij_ECM_Init[13][2] = 12.035723; Qij_ECM_Init[13][3] = 11.161511; Qij_ECM_Init[13][4] = 0.277929; Qij_ECM_Init[13][5] = 0.000186; Qij_ECM_Init[13][6] = 0.000289; Qij_ECM_Init[13][7] = 0.000000; Qij_ECM_Init[13][8] = 0.485469; Qij_ECM_Init[13][9] = 0.000299; Qij_ECM_Init[13][10] = 0.543240; Qij_ECM_Init[13][11] = 0.000674; Qij_ECM_Init[13][12] = 0.010122; 
		Qij_ECM_Init[14][0] = 0.083684; Qij_ECM_Init[14][1] = 2.306110; Qij_ECM_Init[14][2] = 1.373823; Qij_ECM_Init[14][3] = 5.651603; Qij_ECM_Init[14][4] = 0.000085; Qij_ECM_Init[14][5] = 0.342813; Qij_ECM_Init[14][6] = 0.000096; Qij_ECM_Init[14][7] = 0.000344; Qij_ECM_Init[14][8] = 0.000116; Qij_ECM_Init[14][9] = 0.622089; Qij_ECM_Init[14][10] = 0.000466; Qij_ECM_Init[14][11] = 0.674176; Qij_ECM_Init[14][12] = 0.113701; Qij_ECM_Init[14][13] = 15.874441; 
		Qij_ECM_Init[15][0] = 1.036474; Qij_ECM_Init[15][1] = 0.198558; Qij_ECM_Init[15][2] = 27.219895; Qij_ECM_Init[15][3] = 16.560966; Qij_ECM_Init[15][4] = 0.000678; Qij_ECM_Init[15][5] = 0.000186; Qij_ECM_Init[15][6] = 0.496046; Qij_ECM_Init[15][7] = 0.000115; Qij_ECM_Init[15][8] = 0.016650; Qij_ECM_Init[15][9] = 0.011978; Qij_ECM_Init[15][10] = 0.020649; Qij_ECM_Init[15][11] = 0.021578; Qij_ECM_Init[15][12] = 0.017106; Qij_ECM_Init[15][13] = 21.437257; Qij_ECM_Init[15][14] = 8.808275; 
		Qij_ECM_Init[16][0] = 0.073550; Qij_ECM_Init[16][1] = 1.341144; Qij_ECM_Init[16][2] = 1.045943; Qij_ECM_Init[16][3] = 12.455337; Qij_ECM_Init[16][4] = 0.000000; Qij_ECM_Init[16][5] = 0.001022; Qij_ECM_Init[16][6] = 0.000000; Qij_ECM_Init[16][7] = 0.266943; Qij_ECM_Init[16][8] = 0.004815; Qij_ECM_Init[16][9] = 0.308859; Qij_ECM_Init[16][10] = 0.002639; Qij_ECM_Init[16][11] = 0.265948; Qij_ECM_Init[16][12] = 0.504866; Qij_ECM_Init[16][13] = 4.802017; Qij_ECM_Init[16][14] = 15.484088; Qij_ECM_Init[16][15] = 8.319767; 
		Qij_ECM_Init[17][0] = 0.324368; Qij_ECM_Init[17][1] = 0.000141; Qij_ECM_Init[17][2] = 0.001358; Qij_ECM_Init[17][3] = 0.003499; Qij_ECM_Init[17][4] = 2.846677; Qij_ECM_Init[17][5] = 0.196358; Qij_ECM_Init[17][6] = 0.544474; Qij_ECM_Init[17][7] = 0.078776; Qij_ECM_Init[17][8] = 0.337879; Qij_ECM_Init[17][9] = 0.000479; Qij_ECM_Init[17][10] = 0.239715; Qij_ECM_Init[17][11] = 0.000270; Qij_ECM_Init[17][12] = 0.061833; Qij_ECM_Init[17][13] = 0.822643; Qij_ECM_Init[17][14] = 0.036254; Qij_ECM_Init[17][15] = 0.181411; Qij_ECM_Init[17][16] = 0.014388; 
		Qij_ECM_Init[18][0] = 0.000140; Qij_ECM_Init[18][1] = 0.285635; Qij_ECM_Init[18][2] = 0.000000; Qij_ECM_Init[18][3] = 0.000382; Qij_ECM_Init[18][4] = 0.101204; Qij_ECM_Init[18][5] = 2.487136; Qij_ECM_Init[18][6] = 0.072352; Qij_ECM_Init[18][7] = 0.432520; Qij_ECM_Init[18][8] = 0.000116; Qij_ECM_Init[18][9] = 0.310416; Qij_ECM_Init[18][10] = 0.000000; Qij_ECM_Init[18][11] = 0.215779; Qij_ECM_Init[18][12] = 0.032564; Qij_ECM_Init[18][13] = 0.026571; Qij_ECM_Init[18][14] = 0.648769; Qij_ECM_Init[18][15] = 0.040087; Qij_ECM_Init[18][16] = 0.149771; Qij_ECM_Init[18][17] = 23.496083; 
		Qij_ECM_Init[19][0] = 0.025217; Qij_ECM_Init[19][1] = 0.006558; Qij_ECM_Init[19][2] = 0.261069; Qij_ECM_Init[19][3] = 0.005535; Qij_ECM_Init[19][4] = 0.487542; Qij_ECM_Init[19][5] = 0.138742; Qij_ECM_Init[19][6] = 3.121656; Qij_ECM_Init[19][7] = 0.151589; Qij_ECM_Init[19][8] = 0.032140; Qij_ECM_Init[19][9] = 0.025873; Qij_ECM_Init[19][10] = 0.002795; Qij_ECM_Init[19][11] = 0.010250; Qij_ECM_Init[19][12] = 0.070308; Qij_ECM_Init[19][13] = 0.065669; Qij_ECM_Init[19][14] = 0.016609; Qij_ECM_Init[19][15] = 1.073790; Qij_ECM_Init[19][16] = 0.040917; Qij_ECM_Init[19][17] = 40.922701; Qij_ECM_Init[19][18] = 15.426733; 
		Qij_ECM_Init[20][0] = 0.004063; Qij_ECM_Init[20][1] = 0.079161; Qij_ECM_Init[20][2] = 0.000000; Qij_ECM_Init[20][3] = 0.112999; Qij_ECM_Init[20][4] = 0.021444; Qij_ECM_Init[20][5] = 0.371063; Qij_ECM_Init[20][6] = 0.064924; Qij_ECM_Init[20][7] = 2.075226; Qij_ECM_Init[20][8] = 0.004177; Qij_ECM_Init[20][9] = 0.037372; Qij_ECM_Init[20][10] = 0.000155; Qij_ECM_Init[20][11] = 0.004585; Qij_ECM_Init[20][12] = 0.215788; Qij_ECM_Init[20][13] = 0.007978; Qij_ECM_Init[20][14] = 0.118229; Qij_ECM_Init[20][15] = 0.016442; Qij_ECM_Init[20][16] = 0.495176; Qij_ECM_Init[20][17] = 10.291826; Qij_ECM_Init[20][18] = 33.453780; Qij_ECM_Init[20][19] = 15.127582; 
		Qij_ECM_Init[21][0] = 0.638696; Qij_ECM_Init[21][1] = 0.001312; Qij_ECM_Init[21][2] = 0.026551; Qij_ECM_Init[21][3] = 0.040275; Qij_ECM_Init[21][4] = 1.253945; Qij_ECM_Init[21][5] = 0.002137; Qij_ECM_Init[21][6] = 0.128111; Qij_ECM_Init[21][7] = 0.073730; Qij_ECM_Init[21][8] = 3.088481; Qij_ECM_Init[21][9] = 0.340541; Qij_ECM_Init[21][10] = 0.634065; Qij_ECM_Init[21][11] = 0.001483; Qij_ECM_Init[21][12] = 0.195073; Qij_ECM_Init[21][13] = 0.664866; Qij_ECM_Init[21][14] = 0.057328; Qij_ECM_Init[21][15] = 0.438648; Qij_ECM_Init[21][16] = 0.044742; Qij_ECM_Init[21][17] = 0.775254; Qij_ECM_Init[21][18] = 0.091276; Qij_ECM_Init[21][19] = 0.286252; Qij_ECM_Init[21][20] = 0.054021; 
		Qij_ECM_Init[22][0] = 0.000467; Qij_ECM_Init[22][1] = 0.761771; Qij_ECM_Init[22][2] = 0.000123; Qij_ECM_Init[22][3] = 0.002163; Qij_ECM_Init[22][4] = 0.000593; Qij_ECM_Init[22][5] = 1.144692; Qij_ECM_Init[22][6] = 0.014470; Qij_ECM_Init[22][7] = 0.114551; Qij_ECM_Init[22][8] = 0.265766; Qij_ECM_Init[22][9] = 3.193996; Qij_ECM_Init[22][10] = 0.000155; Qij_ECM_Init[22][11] = 0.483076; Qij_ECM_Init[22][12] = 0.369273; Qij_ECM_Init[22][13] = 0.058614; Qij_ECM_Init[22][14] = 0.617694; Qij_ECM_Init[22][15] = 0.059927; Qij_ECM_Init[22][16] = 0.330036; Qij_ECM_Init[22][17] = 0.061583; Qij_ECM_Init[22][18] = 0.730306; Qij_ECM_Init[22][19] = 0.089835; Qij_ECM_Init[22][20] = 0.364129; Qij_ECM_Init[22][21] = 38.685701; 
		Qij_ECM_Init[23][0] = 0.126320; Qij_ECM_Init[23][1] = 0.016628; Qij_ECM_Init[23][2] = 0.576476; Qij_ECM_Init[23][3] = 0.007508; Qij_ECM_Init[23][4] = 0.508308; Qij_ECM_Init[23][5] = 0.080383; Qij_ECM_Init[23][6] = 2.066955; Qij_ECM_Init[23][7] = 0.002179; Qij_ECM_Init[23][8] = 0.486281; Qij_ECM_Init[23][9] = 0.079236; Qij_ECM_Init[23][10] = 0.163174; Qij_ECM_Init[23][11] = 0.032232; Qij_ECM_Init[23][12] = 0.055163; Qij_ECM_Init[23][13] = 0.529045; Qij_ECM_Init[23][14] = 0.071794; Qij_ECM_Init[23][15] = 1.205738; Qij_ECM_Init[23][16] = 0.033372; Qij_ECM_Init[23][17] = 0.435109; Qij_ECM_Init[23][18] = 0.074846; Qij_ECM_Init[23][19] = 1.052040; Qij_ECM_Init[23][20] = 0.063366; Qij_ECM_Init[23][21] = 2.473439; Qij_ECM_Init[23][22] = 0.751904; 
		Qij_ECM_Init[24][0] = 0.009760; Qij_ECM_Init[24][1] = 0.107218; Qij_ECM_Init[24][2] = 0.000000; Qij_ECM_Init[24][3] = 0.250748; Qij_ECM_Init[24][4] = 0.049246; Qij_ECM_Init[24][5] = 0.423382; Qij_ECM_Init[24][6] = 0.002122; Qij_ECM_Init[24][7] = 1.519211; Qij_ECM_Init[24][8] = 0.092070; Qij_ECM_Init[24][9] = 0.332396; Qij_ECM_Init[24][10] = 0.057910; Qij_ECM_Init[24][11] = 0.105597; Qij_ECM_Init[24][12] = 0.247490; Qij_ECM_Init[24][13] = 0.079119; Qij_ECM_Init[24][14] = 0.422671; Qij_ECM_Init[24][15] = 0.105449; Qij_ECM_Init[24][16] = 0.703795; Qij_ECM_Init[24][17] = 0.107434; Qij_ECM_Init[24][18] = 0.529594; Qij_ECM_Init[24][19] = 0.184327; Qij_ECM_Init[24][20] = 0.715716; Qij_ECM_Init[24][21] = 1.106179; Qij_ECM_Init[24][22] = 2.503268; Qij_ECM_Init[24][23] = 17.923045; 
		Qij_ECM_Init[25][0] = 0.143832; Qij_ECM_Init[25][1] = 0.000094; Qij_ECM_Init[25][2] = 0.000741; Qij_ECM_Init[25][3] = 0.003054; Qij_ECM_Init[25][4] = 0.660622; Qij_ECM_Init[25][5] = 0.001208; Qij_ECM_Init[25][6] = 0.000579; Qij_ECM_Init[25][7] = 0.001720; Qij_ECM_Init[25][8] = 0.534375; Qij_ECM_Init[25][9] = 0.001377; Qij_ECM_Init[25][10] = 0.726908; Qij_ECM_Init[25][11] = 0.077815; Qij_ECM_Init[25][12] = 0.019696; Qij_ECM_Init[25][13] = 0.663877; Qij_ECM_Init[25][14] = 0.068758; Qij_ECM_Init[25][15] = 0.134394; Qij_ECM_Init[25][16] = 0.015019; Qij_ECM_Init[25][17] = 0.500433; Qij_ECM_Init[25][18] = 0.124232; Qij_ECM_Init[25][19] = 0.063413; Qij_ECM_Init[25][20] = 0.044676; Qij_ECM_Init[25][21] = 2.460976; Qij_ECM_Init[25][22] = 0.277265; Qij_ECM_Init[25][23] = 1.164262; Qij_ECM_Init[25][24] = 0.340811; 
		Qij_ECM_Init[26][0] = 0.000000; Qij_ECM_Init[26][1] = 0.200806; Qij_ECM_Init[26][2] = 0.000000; Qij_ECM_Init[26][3] = 0.000064; Qij_ECM_Init[26][4] = 0.000000; Qij_ECM_Init[26][5] = 0.685812; Qij_ECM_Init[26][6] = 0.000000; Qij_ECM_Init[26][7] = 0.032106; Qij_ECM_Init[26][8] = 0.000116; Qij_ECM_Init[26][9] = 0.604541; Qij_ECM_Init[26][10] = 0.012886; Qij_ECM_Init[26][11] = 0.516927; Qij_ECM_Init[26][12] = 0.176476; Qij_ECM_Init[26][13] = 0.016022; Qij_ECM_Init[26][14] = 0.544828; Qij_ECM_Init[26][15] = 0.005436; Qij_ECM_Init[26][16] = 0.563956; Qij_ECM_Init[26][17] = 0.002398; Qij_ECM_Init[26][18] = 0.563799; Qij_ECM_Init[26][19] = 0.001702; Qij_ECM_Init[26][20] = 0.798346; Qij_ECM_Init[26][21] = 0.170088; Qij_ECM_Init[26][22] = 2.478358; Qij_ECM_Init[26][23] = 0.148940; Qij_ECM_Init[26][24] = 2.029914; Qij_ECM_Init[26][25] = 27.244097; 
		Qij_ECM_Init[27][0] = 0.030121; Qij_ECM_Init[27][1] = 0.016020; Qij_ECM_Init[27][2] = 0.136647; Qij_ECM_Init[27][3] = 0.001527; Qij_ECM_Init[27][4] = 0.006103; Qij_ECM_Init[27][5] = 0.004089; Qij_ECM_Init[27][6] = 0.557015; Qij_ECM_Init[27][7] = 0.003211; Qij_ECM_Init[27][8] = 0.043917; Qij_ECM_Init[27][9] = 0.051686; Qij_ECM_Init[27][10] = 0.232728; Qij_ECM_Init[27][11] = 0.166150; Qij_ECM_Init[27][12] = 0.146501; Qij_ECM_Init[27][13] = 0.424607; Qij_ECM_Init[27][14] = 0.112395; Qij_ECM_Init[27][15] = 0.918198; Qij_ECM_Init[27][16] = 0.041969; Qij_ECM_Init[27][17] = 0.352807; Qij_ECM_Init[27][18] = 0.154017; Qij_ECM_Init[27][19] = 0.626603; Qij_ECM_Init[27][20] = 0.091073; Qij_ECM_Init[27][21] = 1.353860; Qij_ECM_Init[27][22] = 0.526904; Qij_ECM_Init[27][23] = 4.725840; Qij_ECM_Init[27][24] = 0.617320; Qij_ECM_Init[27][25] = 39.595443; Qij_ECM_Init[27][26] = 12.677657; 
		Qij_ECM_Init[28][0] = 0.000934; Qij_ECM_Init[28][1] = 0.027355; Qij_ECM_Init[28][2] = 0.000000; Qij_ECM_Init[28][3] = 0.127696; Qij_ECM_Init[28][4] = 0.000085; Qij_ECM_Init[28][5] = 0.004832; Qij_ECM_Init[28][6] = 0.000000; Qij_ECM_Init[28][7] = 1.903571; Qij_ECM_Init[28][8] = 0.003713; Qij_ECM_Init[28][9] = 0.081931; Qij_ECM_Init[28][10] = 0.023909; Qij_ECM_Init[28][11] = 0.183143; Qij_ECM_Init[28][12] = 1.135910; Qij_ECM_Init[28][13] = 0.039428; Qij_ECM_Init[28][14] = 0.640495; Qij_ECM_Init[28][15] = 0.040902; Qij_ECM_Init[28][16] = 0.794366; Qij_ECM_Init[28][17] = 0.009880; Qij_ECM_Init[28][18] = 0.897101; Qij_ECM_Init[28][19] = 0.010300; Qij_ECM_Init[28][20] = 1.164525; Qij_ECM_Init[28][21] = 0.316372; Qij_ECM_Init[28][22] = 2.208430; Qij_ECM_Init[28][23] = 0.299978; Qij_ECM_Init[28][24] = 4.718199; Qij_ECM_Init[28][25] = 12.868484; Qij_ECM_Init[28][26] = 35.563093; Qij_ECM_Init[28][27] = 30.574631; 
		Qij_ECM_Init[29][0] = 1.119411; Qij_ECM_Init[29][1] = 0.059956; Qij_ECM_Init[29][2] = 2.130663; Qij_ECM_Init[29][3] = 1.292935; Qij_ECM_Init[29][4] = 0.172403; Qij_ECM_Init[29][5] = 0.000000; Qij_ECM_Init[29][6] = 0.000386; Qij_ECM_Init[29][7] = 0.000000; Qij_ECM_Init[29][8] = 0.352731; Qij_ECM_Init[29][9] = 0.000180; Qij_ECM_Init[29][10] = 0.431456; Qij_ECM_Init[29][11] = 0.000405; Qij_ECM_Init[29][12] = 0.078312; Qij_ECM_Init[29][13] = 3.330793; Qij_ECM_Init[29][14] = 0.184010; Qij_ECM_Init[29][15] = 1.328581; Qij_ECM_Init[29][16] = 0.089308; Qij_ECM_Init[29][17] = 0.292855; Qij_ECM_Init[29][18] = 0.000096; Qij_ECM_Init[29][19] = 0.002597; Qij_ECM_Init[29][20] = 0.000246; Qij_ECM_Init[29][21] = 0.193328; Qij_ECM_Init[29][22] = 0.000000; Qij_ECM_Init[29][23] = 0.078926; Qij_ECM_Init[29][24] = 0.003859; Qij_ECM_Init[29][25] = 0.076434; Qij_ECM_Init[29][26] = 0.000000; Qij_ECM_Init[29][27] = 0.000416; Qij_ECM_Init[29][28] = 0.000000; 
		Qij_ECM_Init[30][0] = 0.056038; Qij_ECM_Init[30][1] = 1.006045; Qij_ECM_Init[30][2] = 0.042112; Qij_ECM_Init[30][3] = 0.478019; Qij_ECM_Init[30][4] = 0.000000; Qij_ECM_Init[30][5] = 0.115975; Qij_ECM_Init[30][6] = 0.000096; Qij_ECM_Init[30][7] = 0.000344; Qij_ECM_Init[30][8] = 0.000116; Qij_ECM_Init[30][9] = 0.255975; Qij_ECM_Init[30][10] = 0.000311; Qij_ECM_Init[30][11] = 0.309643; Qij_ECM_Init[30][12] = 0.136849; Qij_ECM_Init[30][13] = 0.390190; Qij_ECM_Init[30][14] = 3.765697; Qij_ECM_Init[30][15] = 0.203017; Qij_ECM_Init[30][16] = 2.469249; Qij_ECM_Init[30][17] = 0.000096; Qij_ECM_Init[30][18] = 0.270274; Qij_ECM_Init[30][19] = 0.000448; Qij_ECM_Init[30][20] = 0.021723; Qij_ECM_Init[30][21] = 0.000469; Qij_ECM_Init[30][22] = 0.127899; Qij_ECM_Init[30][23] = 0.010543; Qij_ECM_Init[30][24] = 0.105885; Qij_ECM_Init[30][25] = 0.000118; Qij_ECM_Init[30][26] = 0.238839; Qij_ECM_Init[30][27] = 0.001248; Qij_ECM_Init[30][28] = 0.003064; Qij_ECM_Init[30][29] = 13.609310; 
		Qij_ECM_Init[31][0] = 1.075187; Qij_ECM_Init[31][1] = 0.064968; Qij_ECM_Init[31][2] = 5.159075; Qij_ECM_Init[31][3] = 1.065537; Qij_ECM_Init[31][4] = 0.000424; Qij_ECM_Init[31][5] = 0.000000; Qij_ECM_Init[31][6] = 0.403435; Qij_ECM_Init[31][7] = 0.000000; Qij_ECM_Init[31][8] = 0.573013; Qij_ECM_Init[31][9] = 0.025454; Qij_ECM_Init[31][10] = 0.069555; Qij_ECM_Init[31][11] = 0.012138; Qij_ECM_Init[31][12] = 0.170041; Qij_ECM_Init[31][13] = 1.260239; Qij_ECM_Init[31][14] = 0.136148; Qij_ECM_Init[31][15] = 4.400610; Qij_ECM_Init[31][16] = 0.048882; Qij_ECM_Init[31][17] = 0.002014; Qij_ECM_Init[31][18] = 0.000000; Qij_ECM_Init[31][19] = 0.480521; Qij_ECM_Init[31][20] = 0.000000; Qij_ECM_Init[31][21] = 0.040109; Qij_ECM_Init[31][22] = 0.000272; Qij_ECM_Init[31][23] = 0.390087; Qij_ECM_Init[31][24] = 0.000048; Qij_ECM_Init[31][25] = 0.000000; Qij_ECM_Init[31][26] = 0.000000; Qij_ECM_Init[31][27] = 0.121855; Qij_ECM_Init[31][28] = 0.000000; Qij_ECM_Init[31][29] = 16.415611; Qij_ECM_Init[31][30] = 5.784672; 
		Qij_ECM_Init[32][0] = 0.679370; Qij_ECM_Init[32][1] = 0.800602; Qij_ECM_Init[32][2] = 1.418466; Qij_ECM_Init[32][3] = 3.062807; Qij_ECM_Init[32][4] = 0.093491; Qij_ECM_Init[32][5] = 0.042282; Qij_ECM_Init[32][6] = 0.246094; Qij_ECM_Init[32][7] = 0.527005; Qij_ECM_Init[32][8] = 0.294368; Qij_ECM_Init[32][9] = 0.300354; Qij_ECM_Init[32][10] = 0.298091; Qij_ECM_Init[32][11] = 0.324613; Qij_ECM_Init[32][12] = 0.321642; Qij_ECM_Init[32][13] = 1.220020; Qij_ECM_Init[32][14] = 1.434579; Qij_ECM_Init[32][15] = 1.635281; Qij_ECM_Init[32][16] = 2.236557; Qij_ECM_Init[32][17] = 0.081631; Qij_ECM_Init[32][18] = 0.008455; Qij_ECM_Init[32][19] = 0.042006; Qij_ECM_Init[32][20] = 0.193459; Qij_ECM_Init[32][21] = 0.323588; Qij_ECM_Init[32][22] = 0.163406; Qij_ECM_Init[32][23] = 0.443617; Qij_ECM_Init[32][24] = 0.834976; Qij_ECM_Init[32][25] = 0.028736; Qij_ECM_Init[32][26] = 0.029786; Qij_ECM_Init[32][27] = 0.015596; Qij_ECM_Init[32][28] = 0.408680; Qij_ECM_Init[32][29] = 1.155098; Qij_ECM_Init[32][30] = 1.428293; Qij_ECM_Init[32][31] = 2.230691; 
		Qij_ECM_Init[33][0] = 0.497293; Qij_ECM_Init[33][1] = 0.000141; Qij_ECM_Init[33][2] = 0.012473; Qij_ECM_Init[33][3] = 0.015652; Qij_ECM_Init[33][4] = 4.693944; Qij_ECM_Init[33][5] = 0.487317; Qij_ECM_Init[33][6] = 2.297807; Qij_ECM_Init[33][7] = 0.199748; Qij_ECM_Init[33][8] = 0.599932; Qij_ECM_Init[33][9] = 0.000599; Qij_ECM_Init[33][10] = 1.089585; Qij_ECM_Init[33][11] = 0.001483; Qij_ECM_Init[33][12] = 0.035939; Qij_ECM_Init[33][13] = 0.831215; Qij_ECM_Init[33][14] = 0.000060; Qij_ECM_Init[33][15] = 0.004348; Qij_ECM_Init[33][16] = 0.000070; Qij_ECM_Init[33][17] = 1.050363; Qij_ECM_Init[33][18] = 0.053805; Qij_ECM_Init[33][19] = 0.345545; Qij_ECM_Init[33][20] = 0.011476; Qij_ECM_Init[33][21] = 0.898794; Qij_ECM_Init[33][22] = 0.000272; Qij_ECM_Init[33][23] = 0.374419; Qij_ECM_Init[33][24] = 0.029088; Qij_ECM_Init[33][25] = 0.344601; Qij_ECM_Init[33][26] = 0.000000; Qij_ECM_Init[33][27] = 0.001040; Qij_ECM_Init[33][28] = 0.000000; Qij_ECM_Init[33][29] = 1.266654; Qij_ECM_Init[33][30] = 0.075878; Qij_ECM_Init[33][31] = 0.351882; Qij_ECM_Init[33][32] = 0.419831; 
		Qij_ECM_Init[34][0] = 0.000093; Qij_ECM_Init[34][1] = 0.371541; Qij_ECM_Init[34][2] = 0.000062; Qij_ECM_Init[34][3] = 0.002990; Qij_ECM_Init[34][4] = 0.196983; Qij_ECM_Init[34][5] = 3.829580; Qij_ECM_Init[34][6] = 0.150107; Qij_ECM_Init[34][7] = 2.395833; Qij_ECM_Init[34][8] = 0.000116; Qij_ECM_Init[34][9] = 0.393545; Qij_ECM_Init[34][10] = 0.000776; Qij_ECM_Init[34][11] = 0.806071; Qij_ECM_Init[34][12] = 0.037822; Qij_ECM_Init[34][13] = 0.000396; Qij_ECM_Init[34][14] = 0.897490; Qij_ECM_Init[34][15] = 0.000679; Qij_ECM_Init[34][16] = 0.073657; Qij_ECM_Init[34][17] = 0.044125; Qij_ECM_Init[34][18] = 0.870967; Qij_ECM_Init[34][19] = 0.027138; Qij_ECM_Init[34][20] = 0.527094; Qij_ECM_Init[34][21] = 0.001125; Qij_ECM_Init[34][22] = 0.969387; Qij_ECM_Init[34][23] = 0.066519; Qij_ECM_Init[34][24] = 0.617464; Qij_ECM_Init[34][25] = 0.001060; Qij_ECM_Init[34][26] = 1.481721; Qij_ECM_Init[34][27] = 0.002079; Qij_ECM_Init[34][28] = 0.017774; Qij_ECM_Init[34][29] = 0.034573; Qij_ECM_Init[34][30] = 1.066285; Qij_ECM_Init[34][31] = 0.016701; Qij_ECM_Init[34][32] = 0.433759; Qij_ECM_Init[34][33] = 13.991583; 
		Qij_ECM_Init[35][0] = 0.079948; Qij_ECM_Init[35][1] = 0.010539; Qij_ECM_Init[35][2] = 0.871568; Qij_ECM_Init[35][3] = 0.011134; Qij_ECM_Init[35][4] = 2.018483; Qij_ECM_Init[35][5] = 0.409721; Qij_ECM_Init[35][6] = 5.709933; Qij_ECM_Init[35][7] = 0.349846; Qij_ECM_Init[35][8] = 0.208041; Qij_ECM_Init[35][9] = 0.053363; Qij_ECM_Init[35][10] = 0.415775; Qij_ECM_Init[35][11] = 0.061227; Qij_ECM_Init[35][12] = 0.060421; Qij_ECM_Init[35][13] = 0.000857; Qij_ECM_Init[35][14] = 0.000119; Qij_ECM_Init[35][15] = 0.944560; Qij_ECM_Init[35][16] = 0.000070; Qij_ECM_Init[35][17] = 0.368538; Qij_ECM_Init[35][18] = 0.026230; Qij_ECM_Init[35][19] = 1.018005; Qij_ECM_Init[35][20] = 0.015001; Qij_ECM_Init[35][21] = 0.082373; Qij_ECM_Init[35][22] = 0.021920; Qij_ECM_Init[35][23] = 1.660885; Qij_ECM_Init[35][24] = 0.001302; Qij_ECM_Init[35][25] = 0.000589; Qij_ECM_Init[35][26] = 0.000000; Qij_ECM_Init[35][27] = 0.360575; Qij_ECM_Init[35][28] = 0.000000; Qij_ECM_Init[35][29] = 0.296014; Qij_ECM_Init[35][30] = 0.048902; Qij_ECM_Init[35][31] = 2.260424; Qij_ECM_Init[35][32] = 0.853779; Qij_ECM_Init[35][33] = 31.915858; Qij_ECM_Init[35][34] = 8.373639; 
		Qij_ECM_Init[36][0] = 0.008032; Qij_ECM_Init[36][1] = 0.036489; Qij_ECM_Init[36][2] = 0.000062; Qij_ECM_Init[36][3] = 0.586818; Qij_ECM_Init[36][4] = 0.361164; Qij_ECM_Init[36][5] = 1.562591; Qij_ECM_Init[36][6] = 0.516594; Qij_ECM_Init[36][7] = 4.919174; Qij_ECM_Init[36][8] = 0.042119; Qij_ECM_Init[36][9] = 0.177757; Qij_ECM_Init[36][10] = 0.053874; Qij_ECM_Init[36][11] = 0.173298; Qij_ECM_Init[36][12] = 0.362681; Qij_ECM_Init[36][13] = 0.000264; Qij_ECM_Init[36][14] = 0.000595; Qij_ECM_Init[36][15] = 0.000408; Qij_ECM_Init[36][16] = 0.733202; Qij_ECM_Init[36][17] = 0.079712; Qij_ECM_Init[36][18] = 0.435243; Qij_ECM_Init[36][19] = 0.083475; Qij_ECM_Init[36][20] = 0.962295; Qij_ECM_Init[36][21] = 0.076938; Qij_ECM_Init[36][22] = 0.103080; Qij_ECM_Init[36][23] = 0.002854; Qij_ECM_Init[36][24] = 1.766961; Qij_ECM_Init[36][25] = 0.004593; Qij_ECM_Init[36][26] = 0.014243; Qij_ECM_Init[36][27] = 0.002911; Qij_ECM_Init[36][28] = 2.985421; Qij_ECM_Init[36][29] = 0.090674; Qij_ECM_Init[36][30] = 0.311759; Qij_ECM_Init[36][31] = 0.154441; Qij_ECM_Init[36][32] = 1.376727; Qij_ECM_Init[36][33] = 12.116657; Qij_ECM_Init[36][34] = 28.470047; Qij_ECM_Init[36][35] = 19.459275; 
		Qij_ECM_Init[37][0] = 0.263567; Qij_ECM_Init[37][1] = 0.000094; Qij_ECM_Init[37][2] = 0.271628; Qij_ECM_Init[37][3] = 0.077878; Qij_ECM_Init[37][4] = 1.773102; Qij_ECM_Init[37][5] = 0.000929; Qij_ECM_Init[37][6] = 0.872084; Qij_ECM_Init[37][7] = 0.040706; Qij_ECM_Init[37][8] = 0.747870; Qij_ECM_Init[37][9] = 0.042762; Qij_ECM_Init[37][10] = 0.360038; Qij_ECM_Init[37][11] = 0.000135; Qij_ECM_Init[37][12] = 0.074859; Qij_ECM_Init[37][13] = 0.259380; Qij_ECM_Init[37][14] = 0.000000; Qij_ECM_Init[37][15] = 0.019568; Qij_ECM_Init[37][16] = 0.000140; Qij_ECM_Init[37][17] = 0.787340; Qij_ECM_Init[37][18] = 0.000192; Qij_ECM_Init[37][19] = 0.096104; Qij_ECM_Init[37][20] = 0.002705; Qij_ECM_Init[37][21] = 2.691226; Qij_ECM_Init[37][22] = 0.188587; Qij_ECM_Init[37][23] = 1.759732; Qij_ECM_Init[37][24] = 0.206851; Qij_ECM_Init[37][25] = 0.682254; Qij_ECM_Init[37][26] = 0.000068; Qij_ECM_Init[37][27] = 0.009981; Qij_ECM_Init[37][28] = 0.000981; Qij_ECM_Init[37][29] = 0.239388; Qij_ECM_Init[37][30] = 0.014351; Qij_ECM_Init[37][31] = 0.256283; Qij_ECM_Init[37][32] = 0.208924; Qij_ECM_Init[37][33] = 2.057449; Qij_ECM_Init[37][34] = 0.067554; Qij_ECM_Init[37][35] = 1.243753; Qij_ECM_Init[37][36] = 0.224397; 
		Qij_ECM_Init[38][0] = 0.000093; Qij_ECM_Init[38][1] = 0.143614; Qij_ECM_Init[38][2] = 0.002840; Qij_ECM_Init[38][3] = 0.060699; Qij_ECM_Init[38][4] = 0.003390; Qij_ECM_Init[38][5] = 1.118208; Qij_ECM_Init[38][6] = 0.187826; Qij_ECM_Init[38][7] = 0.725836; Qij_ECM_Init[38][8] = 0.046586; Qij_ECM_Init[38][9] = 0.487814; Qij_ECM_Init[38][10] = 0.000932; Qij_ECM_Init[38][11] = 0.325422; Qij_ECM_Init[38][12] = 0.053908; Qij_ECM_Init[38][13] = 0.000330; Qij_ECM_Init[38][14] = 0.187880; Qij_ECM_Init[38][15] = 0.014540; Qij_ECM_Init[38][16] = 0.034916; Qij_ECM_Init[38][17] = 0.000959; Qij_ECM_Init[38][18] = 0.532092; Qij_ECM_Init[38][19] = 0.074161; Qij_ECM_Init[38][20] = 0.095418; Qij_ECM_Init[38][21] = 0.460970; Qij_ECM_Init[38][22] = 2.203539; Qij_ECM_Init[38][23] = 0.377447; Qij_ECM_Init[38][24] = 0.985145; Qij_ECM_Init[38][25] = 0.003180; Qij_ECM_Init[38][26] = 0.863191; Qij_ECM_Init[38][27] = 0.016636; Qij_ECM_Init[38][28] = 0.065212; Qij_ECM_Init[38][29] = 0.025405; Qij_ECM_Init[38][30] = 0.175491; Qij_ECM_Init[38][31] = 0.020837; Qij_ECM_Init[38][32] = 0.219170; Qij_ECM_Init[38][33] = 0.296066; Qij_ECM_Init[38][34] = 1.346385; Qij_ECM_Init[38][35] = 0.259909; Qij_ECM_Init[38][36] = 0.822133; Qij_ECM_Init[38][37] = 17.634677; 
		Qij_ECM_Init[39][0] = 0.148268; Qij_ECM_Init[39][1] = 0.005996; Qij_ECM_Init[39][2] = 0.612660; Qij_ECM_Init[39][3] = 0.004963; Qij_ECM_Init[39][4] = 0.340991; Qij_ECM_Init[39][5] = 0.020909; Qij_ECM_Init[39][6] = 1.496628; Qij_ECM_Init[39][7] = 0.000459; Qij_ECM_Init[39][8] = 0.467136; Qij_ECM_Init[39][9] = 0.042942; Qij_ECM_Init[39][10] = 0.099519; Qij_ECM_Init[39][11] = 0.004316; Qij_ECM_Init[39][12] = 0.051005; Qij_ECM_Init[39][13] = 0.060922; Qij_ECM_Init[39][14] = 0.002143; Qij_ECM_Init[39][15] = 0.433620; Qij_ECM_Init[39][16] = 0.000035; Qij_ECM_Init[39][17] = 0.247195; Qij_ECM_Init[39][18] = 0.012394; Qij_ECM_Init[39][19] = 1.042457; Qij_ECM_Init[39][20] = 0.000410; Qij_ECM_Init[39][21] = 0.899262; Qij_ECM_Init[39][22] = 0.143479; Qij_ECM_Init[39][23] = 3.215817; Qij_ECM_Init[39][24] = 0.285384; Qij_ECM_Init[39][25] = 1.769879; Qij_ECM_Init[39][26] = 0.296358; Qij_ECM_Init[39][27] = 3.065510; Qij_ECM_Init[39][28] = 0.011032; Qij_ECM_Init[39][29] = 0.221536; Qij_ECM_Init[39][30] = 0.023020; Qij_ECM_Init[39][31] = 0.667397; Qij_ECM_Init[39][32] = 0.275355; Qij_ECM_Init[39][33] = 0.878163; Qij_ECM_Init[39][34] = 0.089476; Qij_ECM_Init[39][35] = 1.523251; Qij_ECM_Init[39][36] = 0.199589; Qij_ECM_Init[39][37] = 2.075154; Qij_ECM_Init[39][38] = 0.413957; 
		Qij_ECM_Init[40][0] = 0.013122; Qij_ECM_Init[40][1] = 0.043609; Qij_ECM_Init[40][2] = 0.000062; Qij_ECM_Init[40][3] = 0.333780; Qij_ECM_Init[40][4] = 0.156468; Qij_ECM_Init[40][5] = 0.251650; Qij_ECM_Init[40][6] = 0.004438; Qij_ECM_Init[40][7] = 0.768607; Qij_ECM_Init[40][8] = 0.072867; Qij_ECM_Init[40][9] = 0.140864; Qij_ECM_Init[40][10] = 0.011489; Qij_ECM_Init[40][11] = 0.034794; Qij_ECM_Init[40][12] = 0.105226; Qij_ECM_Init[40][13] = 0.039362; Qij_ECM_Init[40][14] = 0.022384; Qij_ECM_Init[40][15] = 0.000679; Qij_ECM_Init[40][16] = 0.133032; Qij_ECM_Init[40][17] = 0.220816; Qij_ECM_Init[40][18] = 0.303613; Qij_ECM_Init[40][19] = 0.012002; Qij_ECM_Init[40][20] = 0.561523; Qij_ECM_Init[40][21] = 0.324525; Qij_ECM_Init[40][22] = 0.571469; Qij_ECM_Init[40][23] = 0.461383; Qij_ECM_Init[40][24] = 2.285052; Qij_ECM_Init[40][25] = 0.560831; Qij_ECM_Init[40][26] = 2.721043; Qij_ECM_Init[40][27] = 0.034519; Qij_ECM_Init[40][28] = 3.832200; Qij_ECM_Init[40][29] = 0.041440; Qij_ECM_Init[40][30] = 0.116405; Qij_ECM_Init[40][31] = 0.056267; Qij_ECM_Init[40][32] = 0.497593; Qij_ECM_Init[40][33] = 0.291009; Qij_ECM_Init[40][34] = 0.623366; Qij_ECM_Init[40][35] = 0.256174; Qij_ECM_Init[40][36] = 1.144639; Qij_ECM_Init[40][37] = 0.524647; Qij_ECM_Init[40][38] = 1.038682; Qij_ECM_Init[40][39] = 12.931524; 
		Qij_ECM_Init[41][0] = 0.225554; Qij_ECM_Init[41][1] = 0.000047; Qij_ECM_Init[41][2] = 0.010929; Qij_ECM_Init[41][3] = 0.009289; Qij_ECM_Init[41][4] = 12.169045; Qij_ECM_Init[41][5] = 0.083636; Qij_ECM_Init[41][6] = 5.964323; Qij_ECM_Init[41][7] = 0.681575; Qij_ECM_Init[41][8] = 0.506470; Qij_ECM_Init[41][9] = 0.000180; Qij_ECM_Init[41][10] = 2.007768; Qij_ECM_Init[41][11] = 0.181794; Qij_ECM_Init[41][12] = 0.139046; Qij_ECM_Init[41][13] = 0.322807; Qij_ECM_Init[41][14] = 0.000060; Qij_ECM_Init[41][15] = 0.009512; Qij_ECM_Init[41][16] = 0.000105; Qij_ECM_Init[41][17] = 1.035015; Qij_ECM_Init[41][18] = 0.000288; Qij_ECM_Init[41][19] = 0.021048; Qij_ECM_Init[41][20] = 0.001066; Qij_ECM_Init[41][21] = 1.293228; Qij_ECM_Init[41][22] = 0.000453; Qij_ECM_Init[41][23] = 1.177718; Qij_ECM_Init[41][24] = 0.083261; Qij_ECM_Init[41][25] = 0.772349; Qij_ECM_Init[41][26] = 0.018146; Qij_ECM_Init[41][27] = 0.530881; Qij_ECM_Init[41][28] = 0.025006; Qij_ECM_Init[41][29] = 0.359183; Qij_ECM_Init[41][30] = 0.018727; Qij_ECM_Init[41][31] = 0.269862; Qij_ECM_Init[41][32] = 0.306375; Qij_ECM_Init[41][33] = 4.943439; Qij_ECM_Init[41][34] = 0.275865; Qij_ECM_Init[41][35] = 2.397415; Qij_ECM_Init[41][36] = 0.563566; Qij_ECM_Init[41][37] = 4.971507; Qij_ECM_Init[41][38] = 0.586685; Qij_ECM_Init[41][39] = 1.293860; Qij_ECM_Init[41][40] = 0.389004; 
		Qij_ECM_Init[42][0] = 0.000093; Qij_ECM_Init[42][1] = 0.166706; Qij_ECM_Init[42][2] = 0.000432; Qij_ECM_Init[42][3] = 0.005790; Qij_ECM_Init[42][4] = 0.094762; Qij_ECM_Init[42][5] = 10.892976; Qij_ECM_Init[42][6] = 1.049877; Qij_ECM_Init[42][7] = 9.818281; Qij_ECM_Init[42][8] = 0.000116; Qij_ECM_Init[42][9] = 0.346890; Qij_ECM_Init[42][10] = 0.248099; Qij_ECM_Init[42][11] = 1.372357; Qij_ECM_Init[42][12] = 0.167138; Qij_ECM_Init[42][13] = 0.000330; Qij_ECM_Init[42][14] = 0.300513; Qij_ECM_Init[42][15] = 0.002718; Qij_ECM_Init[42][16] = 0.017300; Qij_ECM_Init[42][17] = 0.001247; Qij_ECM_Init[42][18] = 1.337629; Qij_ECM_Init[42][19] = 0.005195; Qij_ECM_Init[42][20] = 0.104681; Qij_ECM_Init[42][21] = 0.005060; Qij_ECM_Init[42][22] = 1.282522; Qij_ECM_Init[42][23] = 0.232701; Qij_ECM_Init[42][24] = 1.418383; Qij_ECM_Init[42][25] = 0.387941; Qij_ECM_Init[42][26] = 1.320875; Qij_ECM_Init[42][27] = 0.354545; Qij_ECM_Init[42][28] = 1.360141; Qij_ECM_Init[42][29] = 0.031140; Qij_ECM_Init[42][30] = 0.238533; Qij_ECM_Init[42][31] = 0.021539; Qij_ECM_Init[42][32] = 0.304581; Qij_ECM_Init[42][33] = 0.622868; Qij_ECM_Init[42][34] = 4.699375; Qij_ECM_Init[42][35] = 0.441084; Qij_ECM_Init[42][36] = 2.871848; Qij_ECM_Init[42][37] = 0.643789; Qij_ECM_Init[42][38] = 4.127466; Qij_ECM_Init[42][39] = 0.334224; Qij_ECM_Init[42][40] = 0.928876; Qij_ECM_Init[42][41] = 28.579806; 
		Qij_ECM_Init[43][0] = 0.140516; Qij_ECM_Init[43][1] = 0.012600; Qij_ECM_Init[43][2] = 0.423774; Qij_ECM_Init[43][3] = 0.001718; Qij_ECM_Init[43][4] = 0.047890; Qij_ECM_Init[43][5] = 0.002044; Qij_ECM_Init[43][6] = 1.094736; Qij_ECM_Init[43][7] = 0.000115; Qij_ECM_Init[43][8] = 0.424321; Qij_ECM_Init[43][9] = 0.060909; Qij_ECM_Init[43][10] = 0.144388; Qij_ECM_Init[43][11] = 0.030883; Qij_ECM_Init[43][12] = 0.145245; Qij_ECM_Init[43][13] = 0.004747; Qij_ECM_Init[43][14] = 0.000060; Qij_ECM_Init[43][15] = 0.409432; Qij_ECM_Init[43][16] = 0.000000; Qij_ECM_Init[43][17] = 0.011511; Qij_ECM_Init[43][18] = 0.000384; Qij_ECM_Init[43][19] = 0.493508; Qij_ECM_Init[43][20] = 0.000000; Qij_ECM_Init[43][21] = 0.411115; Qij_ECM_Init[43][22] = 0.025544; Qij_ECM_Init[43][23] = 1.242140; Qij_ECM_Init[43][24] = 0.000289; Qij_ECM_Init[43][25] = 17.450524; Qij_ECM_Init[43][26] = 1.113671; Qij_ECM_Init[43][27] = 31.949764; Qij_ECM_Init[43][28] = 2.418859; Qij_ECM_Init[43][29] = 0.116039; Qij_ECM_Init[43][30] = 0.012331; Qij_ECM_Init[43][31] = 0.780008; Qij_ECM_Init[43][32] = 0.305714; Qij_ECM_Init[43][33] = 0.432918; Qij_ECM_Init[43][34] = 0.021698; Qij_ECM_Init[43][35] = 1.316696; Qij_ECM_Init[43][36] = 0.087905; Qij_ECM_Init[43][37] = 0.936840; Qij_ECM_Init[43][38] = 0.273855; Qij_ECM_Init[43][39] = 5.815294; Qij_ECM_Init[43][40] = 1.197614; Qij_ECM_Init[43][41] = 1.644621; Qij_ECM_Init[43][42] = 0.403913; 
		Qij_ECM_Init[44][0] = 0.083310; Qij_ECM_Init[44][1] = 0.056771; Qij_ECM_Init[44][2] = 0.000247; Qij_ECM_Init[44][3] = 0.506841; Qij_ECM_Init[44][4] = 0.063994; Qij_ECM_Init[44][5] = 0.028715; Qij_ECM_Init[44][6] = 0.009261; Qij_ECM_Init[44][7] = 0.514392; Qij_ECM_Init[44][8] = 0.200499; Qij_ECM_Init[44][9] = 0.269510; Qij_ECM_Init[44][10] = 0.122186; Qij_ECM_Init[44][11] = 0.070533; Qij_ECM_Init[44][12] = 0.496706; Qij_ECM_Init[44][13] = 0.009560; Qij_ECM_Init[44][14] = 0.000952; Qij_ECM_Init[44][15] = 0.000951; Qij_ECM_Init[44][16] = 0.040320; Qij_ECM_Init[44][17] = 0.060432; Qij_ECM_Init[44][18] = 0.033244; Qij_ECM_Init[44][19] = 0.009225; Qij_ECM_Init[44][20] = 0.273876; Qij_ECM_Init[44][21] = 0.140943; Qij_ECM_Init[44][22] = 0.169022; Qij_ECM_Init[44][23] = 0.003786; Qij_ECM_Init[44][24] = 1.148387; Qij_ECM_Init[44][25] = 6.798629; Qij_ECM_Init[44][26] = 4.087042; Qij_ECM_Init[44][27] = 15.287419; Qij_ECM_Init[44][28] = 18.531553; Qij_ECM_Init[44][29] = 0.093542; Qij_ECM_Init[44][30] = 0.062369; Qij_ECM_Init[44][31] = 0.317466; Qij_ECM_Init[44][32] = 0.905810; Qij_ECM_Init[44][33] = 0.309656; Qij_ECM_Init[44][34] = 0.140701; Qij_ECM_Init[44][35] = 0.511968; Qij_ECM_Init[44][36] = 0.765495; Qij_ECM_Init[44][37] = 0.454347; Qij_ECM_Init[44][38] = 0.600415; Qij_ECM_Init[44][39] = 1.868194; Qij_ECM_Init[44][40] = 7.316623; Qij_ECM_Init[44][41] = 1.477696; Qij_ECM_Init[44][42] = 1.286990; Qij_ECM_Init[44][43] = 43.916187; 
		Qij_ECM_Init[45][0] = 0.863970; Qij_ECM_Init[45][1] = 0.065905; Qij_ECM_Init[45][2] = 0.748196; Qij_ECM_Init[45][3] = 0.529619; Qij_ECM_Init[45][4] = 0.563995; Qij_ECM_Init[45][5] = 0.000186; Qij_ECM_Init[45][6] = 0.002219; Qij_ECM_Init[45][7] = 0.000115; Qij_ECM_Init[45][8] = 0.571505; Qij_ECM_Init[45][9] = 0.000359; Qij_ECM_Init[45][10] = 1.598824; Qij_ECM_Init[45][11] = 0.004316; Qij_ECM_Init[45][12] = 0.038763; Qij_ECM_Init[45][13] = 1.897150; Qij_ECM_Init[45][14] = 0.072866; Qij_ECM_Init[45][15] = 0.555104; Qij_ECM_Init[45][16] = 0.011580; Qij_ECM_Init[45][17] = 0.708395; Qij_ECM_Init[45][18] = 0.000192; Qij_ECM_Init[45][19] = 0.009225; Qij_ECM_Init[45][20] = 0.000246; Qij_ECM_Init[45][21] = 0.338207; Qij_ECM_Init[45][22] = 0.000091; Qij_ECM_Init[45][23] = 0.150804; Qij_ECM_Init[45][24] = 0.009600; Qij_ECM_Init[45][25] = 0.336828; Qij_ECM_Init[45][26] = 0.000000; Qij_ECM_Init[45][27] = 0.003743; Qij_ECM_Init[45][28] = 0.000000; Qij_ECM_Init[45][29] = 6.546163; Qij_ECM_Init[45][30] = 0.575921; Qij_ECM_Init[45][31] = 2.577578; Qij_ECM_Init[45][32] = 0.430124; Qij_ECM_Init[45][33] = 2.898791; Qij_ECM_Init[45][34] = 0.003020; Qij_ECM_Init[45][35] = 0.056250; Qij_ECM_Init[45][36] = 0.004868; Qij_ECM_Init[45][37] = 0.318595; Qij_ECM_Init[45][38] = 0.000295; Qij_ECM_Init[45][39] = 0.201480; Qij_ECM_Init[45][40] = 0.072138; Qij_ECM_Init[45][41] = 0.501456; Qij_ECM_Init[45][42] = 0.000219; Qij_ECM_Init[45][43] = 0.032116; Qij_ECM_Init[45][44] = 0.051709; 
		Qij_ECM_Init[46][0] = 0.026338; Qij_ECM_Init[46][1] = 0.946136; Qij_ECM_Init[46][2] = 0.005990; Qij_ECM_Init[46][3] = 0.140867; Qij_ECM_Init[46][4] = 0.000085; Qij_ECM_Init[46][5] = 0.396897; Qij_ECM_Init[46][6] = 0.000096; Qij_ECM_Init[46][7] = 0.001261; Qij_ECM_Init[46][8] = 0.000116; Qij_ECM_Init[46][9] = 0.582801; Qij_ECM_Init[46][10] = 0.001087; Qij_ECM_Init[46][11] = 1.273908; Qij_ECM_Init[46][12] = 0.092044; Qij_ECM_Init[46][13] = 0.105361; Qij_ECM_Init[46][14] = 2.720153; Qij_ECM_Init[46][15] = 0.043756; Qij_ECM_Init[46][16] = 1.085170; Qij_ECM_Init[46][17] = 0.000192; Qij_ECM_Init[46][18] = 0.760090; Qij_ECM_Init[46][19] = 0.000537; Qij_ECM_Init[46][20] = 0.031642; Qij_ECM_Init[46][21] = 0.000375; Qij_ECM_Init[46][22] = 0.491034; Qij_ECM_Init[46][23] = 0.006757; Qij_ECM_Init[46][24] = 0.069320; Qij_ECM_Init[46][25] = 0.000589; Qij_ECM_Init[46][26] = 0.648523; Qij_ECM_Init[46][27] = 0.001871; Qij_ECM_Init[46][28] = 0.005026; Qij_ECM_Init[46][29] = 0.458622; Qij_ECM_Init[46][30] = 7.487816; Qij_ECM_Init[46][31] = 0.154207; Qij_ECM_Init[46][32] = 0.350473; Qij_ECM_Init[46][33] = 0.001027; Qij_ECM_Init[46][34] = 2.862216; Qij_ECM_Init[46][35] = 0.002515; Qij_ECM_Init[46][36] = 0.010298; Qij_ECM_Init[46][37] = 0.000000; Qij_ECM_Init[46][38] = 0.215492; Qij_ECM_Init[46][39] = 0.001930; Qij_ECM_Init[46][40] = 0.056145; Qij_ECM_Init[46][41] = 0.000097; Qij_ECM_Init[46][42] = 0.381287; Qij_ECM_Init[46][43] = 0.000205; Qij_ECM_Init[46][44] = 0.002062; Qij_ECM_Init[46][45] = 10.956917; 
		Qij_ECM_Init[47][0] = 0.565566; Qij_ECM_Init[47][1] = 0.047403; Qij_ECM_Init[47][2] = 2.299543; Qij_ECM_Init[47][3] = 0.762425; Qij_ECM_Init[47][4] = 0.001356; Qij_ECM_Init[47][5] = 0.000279; Qij_ECM_Init[47][6] = 0.813720; Qij_ECM_Init[47][7] = 0.000115; Qij_ECM_Init[47][8] = 0.236179; Qij_ECM_Init[47][9] = 0.060430; Qij_ECM_Init[47][10] = 0.754233; Qij_ECM_Init[47][11] = 0.086986; Qij_ECM_Init[47][12] = 0.058616; Qij_ECM_Init[47][13] = 0.509595; Qij_ECM_Init[47][14] = 0.031730; Qij_ECM_Init[47][15] = 2.047159; Qij_ECM_Init[47][16] = 0.020529; Qij_ECM_Init[47][17] = 0.001151; Qij_ECM_Init[47][18] = 0.000192; Qij_ECM_Init[47][19] = 0.732111; Qij_ECM_Init[47][20] = 0.000082; Qij_ECM_Init[47][21] = 0.019586; Qij_ECM_Init[47][22] = 0.002808; Qij_ECM_Init[47][23] = 0.606945; Qij_ECM_Init[47][24] = 0.000145; Qij_ECM_Init[47][25] = 0.000353; Qij_ECM_Init[47][26] = 0.000000; Qij_ECM_Init[47][27] = 0.255147; Qij_ECM_Init[47][28] = 0.000000; Qij_ECM_Init[47][29] = 2.581654; Qij_ECM_Init[47][30] = 0.313779; Qij_ECM_Init[47][31] = 11.271062; Qij_ECM_Init[47][32] = 0.569076; Qij_ECM_Init[47][33] = 0.009008; Qij_ECM_Init[47][34] = 0.001957; Qij_ECM_Init[47][35] = 3.879355; Qij_ECM_Init[47][36] = 0.002528; Qij_ECM_Init[47][37] = 0.008844; Qij_ECM_Init[47][38] = 0.002362; Qij_ECM_Init[47][39] = 0.708204; Qij_ECM_Init[47][40] = 0.000524; Qij_ECM_Init[47][41] = 0.006305; Qij_ECM_Init[47][42] = 0.000657; Qij_ECM_Init[47][43] = 0.560642; Qij_ECM_Init[47][44] = 0.002062; Qij_ECM_Init[47][45] = 25.313949; Qij_ECM_Init[47][46] = 5.637509; 
		Qij_ECM_Init[48][0] = 0.068927; Qij_ECM_Init[48][1] = 0.371072; Qij_ECM_Init[48][2] = 0.024699; Qij_ECM_Init[48][3] = 1.108802; Qij_ECM_Init[48][4] = 0.000254; Qij_ECM_Init[48][5] = 0.001394; Qij_ECM_Init[48][6] = 0.000772; Qij_ECM_Init[48][7] = 0.451899; Qij_ECM_Init[48][8] = 0.009630; Qij_ECM_Init[48][9] = 0.116309; Qij_ECM_Init[48][10] = 0.126844; Qij_ECM_Init[48][11] = 0.530278; Qij_ECM_Init[48][12] = 0.277072; Qij_ECM_Init[48][13] = 0.091844; Qij_ECM_Init[48][14] = 0.477439; Qij_ECM_Init[48][15] = 0.173122; Qij_ECM_Init[48][16] = 2.262490; Qij_ECM_Init[48][17] = 0.000384; Qij_ECM_Init[48][18] = 0.001537; Qij_ECM_Init[48][19] = 0.000717; Qij_ECM_Init[48][20] = 0.602428; Qij_ECM_Init[48][21] = 0.032237; Qij_ECM_Init[48][22] = 0.044112; Qij_ECM_Init[48][23] = 0.000466; Qij_ECM_Init[48][24] = 0.475496; Qij_ECM_Init[48][25] = 0.001413; Qij_ECM_Init[48][26] = 0.003287; Qij_ECM_Init[48][27] = 0.000832; Qij_ECM_Init[48][28] = 0.701399; Qij_ECM_Init[48][29] = 0.953353; Qij_ECM_Init[48][30] = 3.487342; Qij_ECM_Init[48][31] = 0.911193; Qij_ECM_Init[48][32] = 1.399673; Qij_ECM_Init[48][33] = 0.003635; Qij_ECM_Init[48][34] = 0.089643; Qij_ECM_Init[48][35] = 0.011433; Qij_ECM_Init[48][36] = 3.092500; Qij_ECM_Init[48][37] = 0.000628; Qij_ECM_Init[48][38] = 0.013582; Qij_ECM_Init[48][39] = 0.000193; Qij_ECM_Init[48][40] = 0.311885; Qij_ECM_Init[48][41] = 0.001358; Qij_ECM_Init[48][42] = 0.004160; Qij_ECM_Init[48][43] = 0.000103; Qij_ECM_Init[48][44] = 0.314379; Qij_ECM_Init[48][45] = 8.832621; Qij_ECM_Init[48][46] = 18.744445; Qij_ECM_Init[48][47] = 13.945647; 
		Qij_ECM_Init[49][0] = 0.483563; Qij_ECM_Init[49][1] = 0.000234; Qij_ECM_Init[49][2] = 0.008892; Qij_ECM_Init[49][3] = 0.035630; Qij_ECM_Init[49][4] = 3.994417; Qij_ECM_Init[49][5] = 0.771771; Qij_ECM_Init[49][6] = 1.825878; Qij_ECM_Init[49][7] = 0.250545; Qij_ECM_Init[49][8] = 0.370309; Qij_ECM_Init[49][9] = 0.000419; Qij_ECM_Init[49][10] = 1.899865; Qij_ECM_Init[49][11] = 0.011733; Qij_ECM_Init[49][12] = 0.035860; Qij_ECM_Init[49][13] = 0.879741; Qij_ECM_Init[49][14] = 0.000417; Qij_ECM_Init[49][15] = 0.004077; Qij_ECM_Init[49][16] = 0.000772; Qij_ECM_Init[49][17] = 1.272426; Qij_ECM_Init[49][18] = 0.073021; Qij_ECM_Init[49][19] = 0.346978; Qij_ECM_Init[49][20] = 0.013526; Qij_ECM_Init[49][21] = 0.420580; Qij_ECM_Init[49][22] = 0.000091; Qij_ECM_Init[49][23] = 0.272950; Qij_ECM_Init[49][24] = 0.040907; Qij_ECM_Init[49][25] = 0.324227; Qij_ECM_Init[49][26] = 0.000000; Qij_ECM_Init[49][27] = 0.001871; Qij_ECM_Init[49][28] = 0.000000; Qij_ECM_Init[49][29] = 0.536332; Qij_ECM_Init[49][30] = 0.000253; Qij_ECM_Init[49][31] = 0.001795; Qij_ECM_Init[49][32] = 0.451134; Qij_ECM_Init[49][33] = 2.359362; Qij_ECM_Init[49][34] = 0.120121; Qij_ECM_Init[49][35] = 0.324162; Qij_ECM_Init[49][36] = 0.108501; Qij_ECM_Init[49][37] = 0.643160; Qij_ECM_Init[49][38] = 0.001329; Qij_ECM_Init[49][39] = 0.216244; Qij_ECM_Init[49][40] = 0.268662; Qij_ECM_Init[49][41] = 2.323091; Qij_ECM_Init[49][42] = 0.005328; Qij_ECM_Init[49][43] = 0.013852; Qij_ECM_Init[49][44] = 0.045374; Qij_ECM_Init[49][45] = 2.600428; Qij_ECM_Init[49][46] = 0.131929; Qij_ECM_Init[49][47] = 0.662578; Qij_ECM_Init[49][48] = 0.152215; 
		Qij_ECM_Init[50][0] = 0.000093; Qij_ECM_Init[50][1] = 0.512203; Qij_ECM_Init[50][2] = 0.000000; Qij_ECM_Init[50][3] = 0.001654; Qij_ECM_Init[50][4] = 0.111968; Qij_ECM_Init[50][5] = 3.452570; Qij_ECM_Init[50][6] = 0.084218; Qij_ECM_Init[50][7] = 1.978448; Qij_ECM_Init[50][8] = 0.000058; Qij_ECM_Init[50][9] = 0.380788; Qij_ECM_Init[50][10] = 0.000466; Qij_ECM_Init[50][11] = 1.514097; Qij_ECM_Init[50][12] = 0.044178; Qij_ECM_Init[50][13] = 0.000132; Qij_ECM_Init[50][14] = 1.191514; Qij_ECM_Init[50][15] = 0.000136; Qij_ECM_Init[50][16] = 0.103766; Qij_ECM_Init[50][17] = 0.022062; Qij_ECM_Init[50][18] = 1.394892; Qij_ECM_Init[50][19] = 0.013077; Qij_ECM_Init[50][20] = 0.971148; Qij_ECM_Init[50][21] = 0.000562; Qij_ECM_Init[50][22] = 0.696016; Qij_ECM_Init[50][23] = 0.018814; Qij_ECM_Init[50][24] = 0.634927; Qij_ECM_Init[50][25] = 0.000236; Qij_ECM_Init[50][26] = 1.610248; Qij_ECM_Init[50][27] = 0.000416; Qij_ECM_Init[50][28] = 0.020471; Qij_ECM_Init[50][29] = 0.000040; Qij_ECM_Init[50][30] = 0.536362; Qij_ECM_Init[50][31] = 0.000000; Qij_ECM_Init[50][32] = 0.169264; Qij_ECM_Init[50][33] = 0.038559; Qij_ECM_Init[50][34] = 2.159328; Qij_ECM_Init[50][35] = 0.019665; Qij_ECM_Init[50][36] = 0.498504; Qij_ECM_Init[50][37] = 0.000045; Qij_ECM_Init[50][38] = 0.565968; Qij_ECM_Init[50][39] = 0.005500; Qij_ECM_Init[50][40] = 0.373948; Qij_ECM_Init[50][41] = 0.000485; Qij_ECM_Init[50][42] = 2.214735; Qij_ECM_Init[50][43] = 0.000000; Qij_ECM_Init[50][44] = 0.001768; Qij_ECM_Init[50][45] = 0.046583; Qij_ECM_Init[50][46] = 2.620833; Qij_ECM_Init[50][47] = 0.028569; Qij_ECM_Init[50][48] = 0.682579; Qij_ECM_Init[50][49] = 9.612709; 
		Qij_ECM_Init[51][0] = 0.109975; Qij_ECM_Init[51][1] = 0.016535; Qij_ECM_Init[51][2] = 1.041312; Qij_ECM_Init[51][3] = 0.019406; Qij_ECM_Init[51][4] = 1.931350; Qij_ECM_Init[51][5] = 0.558500; Qij_ECM_Init[51][6] = 4.380679; Qij_ECM_Init[51][7] = 0.505677; Qij_ECM_Init[51][8] = 0.176829; Qij_ECM_Init[51][9] = 0.034737; Qij_ECM_Init[51][10] = 0.806554; Qij_ECM_Init[51][11] = 0.297371; Qij_ECM_Init[51][12] = 0.031466; Qij_ECM_Init[51][13] = 0.002374; Qij_ECM_Init[51][14] = 0.000357; Qij_ECM_Init[51][15] = 0.741135; Qij_ECM_Init[51][16] = 0.000351; Qij_ECM_Init[51][17] = 0.335924; Qij_ECM_Init[51][18] = 0.069754; Qij_ECM_Init[51][19] = 1.236457; Qij_ECM_Init[51][20] = 0.087384; Qij_ECM_Init[51][21] = 0.039265; Qij_ECM_Init[51][22] = 0.004982; Qij_ECM_Init[51][23] = 1.274118; Qij_ECM_Init[51][24] = 0.002219; Qij_ECM_Init[51][25] = 0.000589; Qij_ECM_Init[51][26] = 0.000068; Qij_ECM_Init[51][27] = 0.286547; Qij_ECM_Init[51][28] = 0.000123; Qij_ECM_Init[51][29] = 0.002262; Qij_ECM_Init[51][30] = 0.000589; Qij_ECM_Init[51][31] = 0.983926; Qij_ECM_Init[51][32] = 0.517896; Qij_ECM_Init[51][33] = 0.381796; Qij_ECM_Init[51][34] = 0.077341; Qij_ECM_Init[51][35] = 2.735831; Qij_ECM_Init[51][36] = 0.318574; Qij_ECM_Init[51][37] = 0.084620; Qij_ECM_Init[51][38] = 0.041435; Qij_ECM_Init[51][39] = 0.923644; Qij_ECM_Init[51][40] = 0.004382; Qij_ECM_Init[51][41] = 0.126382; Qij_ECM_Init[51][42] = 0.063353; Qij_ECM_Init[51][43] = 0.461729; Qij_ECM_Init[51][44] = 0.004420; Qij_ECM_Init[51][45] = 0.718719; Qij_ECM_Init[51][46] = 0.092405; Qij_ECM_Init[51][47] = 3.415722; Qij_ECM_Init[51][48] = 0.415718; Qij_ECM_Init[51][49] = 24.400553; Qij_ECM_Init[51][50] = 6.746560; 
		Qij_ECM_Init[52][0] = 0.005884; Qij_ECM_Init[52][1] = 0.074851; Qij_ECM_Init[52][2] = 0.000000; Qij_ECM_Init[52][3] = 0.220908; Qij_ECM_Init[52][4] = 0.103323; Qij_ECM_Init[52][5] = 1.262618; Qij_ECM_Init[52][6] = 0.150589; Qij_ECM_Init[52][7] = 4.658653; Qij_ECM_Init[52][8] = 0.027035; Qij_ECM_Init[52][9] = 0.106187; Qij_ECM_Init[52][10] = 0.028567; Qij_ECM_Init[52][11] = 0.586111; Qij_ECM_Init[52][12] = 0.446015; Qij_ECM_Init[52][13] = 0.000066; Qij_ECM_Init[52][14] = 0.000893; Qij_ECM_Init[52][15] = 0.000000; Qij_ECM_Init[52][16] = 1.524024; Qij_ECM_Init[52][17] = 0.014101; Qij_ECM_Init[52][18] = 0.417565; Qij_ECM_Init[52][19] = 0.017824; Qij_ECM_Init[52][20] = 1.950083; Qij_ECM_Init[52][21] = 0.080124; Qij_ECM_Init[52][22] = 0.190037; Qij_ECM_Init[52][23] = 0.001165; Qij_ECM_Init[52][24] = 1.544626; Qij_ECM_Init[52][25] = 0.001531; Qij_ECM_Init[52][26] = 0.083744; Qij_ECM_Init[52][27] = 0.000624; Qij_ECM_Init[52][28] = 3.409178; Qij_ECM_Init[52][29] = 0.000081; Qij_ECM_Init[52][30] = 0.004629; Qij_ECM_Init[52][31] = 0.000078; Qij_ECM_Init[52][32] = 0.837302; Qij_ECM_Init[52][33] = 0.023862; Qij_ECM_Init[52][34] = 0.728891; Qij_ECM_Init[52][35] = 0.049848; Qij_ECM_Init[52][36] = 2.866325; Qij_ECM_Init[52][37] = 0.003771; Qij_ECM_Init[52][38] = 0.068501; Qij_ECM_Init[52][39] = 0.000482; Qij_ECM_Init[52][40] = 0.759132; Qij_ECM_Init[52][41] = 0.006402; Qij_ECM_Init[52][42] = 0.200205; Qij_ECM_Init[52][43] = 0.000000; Qij_ECM_Init[52][44] = 0.187832; Qij_ECM_Init[52][45] = 0.054049; Qij_ECM_Init[52][46] = 0.968351; Qij_ECM_Init[52][47] = 0.081861; Qij_ECM_Init[52][48] = 2.211488; Qij_ECM_Init[52][49] = 5.140068; Qij_ECM_Init[52][50] = 19.373137; Qij_ECM_Init[52][51] = 11.561124; 
		Qij_ECM_Init[53][0] = 0.064397; Qij_ECM_Init[53][1] = 0.000000; Qij_ECM_Init[53][2] = 0.042112; Qij_ECM_Init[53][3] = 0.038557; Qij_ECM_Init[53][4] = 1.120532; Qij_ECM_Init[53][5] = 0.003717; Qij_ECM_Init[53][6] = 0.348448; Qij_ECM_Init[53][7] = 0.117533; Qij_ECM_Init[53][8] = 0.223763; Qij_ECM_Init[53][9] = 0.015452; Qij_ECM_Init[53][10] = 0.099985; Qij_ECM_Init[53][11] = 0.000135; Qij_ECM_Init[53][12] = 0.028249; Qij_ECM_Init[53][13] = 0.129492; Qij_ECM_Init[53][14] = 0.000000; Qij_ECM_Init[53][15] = 0.012366; Qij_ECM_Init[53][16] = 0.000491; Qij_ECM_Init[53][17] = 0.661776; Qij_ECM_Init[53][18] = 0.000769; Qij_ECM_Init[53][19] = 0.147873; Qij_ECM_Init[53][20] = 0.031560; Qij_ECM_Init[53][21] = 0.746792; Qij_ECM_Init[53][22] = 0.046739; Qij_ECM_Init[53][23] = 0.706782; Qij_ECM_Init[53][24] = 0.130873; Qij_ECM_Init[53][25] = 0.162525; Qij_ECM_Init[53][26] = 0.000000; Qij_ECM_Init[53][27] = 0.007070; Qij_ECM_Init[53][28] = 0.000368; Qij_ECM_Init[53][29] = 0.066966; Qij_ECM_Init[53][30] = 0.000042; Qij_ECM_Init[53][31] = 0.001171; Qij_ECM_Init[53][32] = 0.059065; Qij_ECM_Init[53][33] = 0.928969; Qij_ECM_Init[53][34] = 0.000559; Qij_ECM_Init[53][35] = 0.092988; Qij_ECM_Init[53][36] = 0.042595; Qij_ECM_Init[53][37] = 3.529593; Qij_ECM_Init[53][38] = 0.371685; Qij_ECM_Init[53][39] = 0.604859; Qij_ECM_Init[53][40] = 0.188097; Qij_ECM_Init[53][41] = 1.702817; Qij_ECM_Init[53][42] = 0.012481; Qij_ECM_Init[53][43] = 0.030474; Qij_ECM_Init[53][44] = 0.015763; Qij_ECM_Init[53][45] = 0.153418; Qij_ECM_Init[53][46] = 0.007112; Qij_ECM_Init[53][47] = 0.078381; Qij_ECM_Init[53][48] = 0.011491; Qij_ECM_Init[53][49] = 0.396521; Qij_ECM_Init[53][50] = 0.015140; Qij_ECM_Init[53][51] = 0.189090; Qij_ECM_Init[53][52] = 0.043198; 
		Qij_ECM_Init[54][0] = 0.000000; Qij_ECM_Init[54][1] = 0.055366; Qij_ECM_Init[54][2] = 0.000062; Qij_ECM_Init[54][3] = 0.006808; Qij_ECM_Init[54][4] = 0.000254; Qij_ECM_Init[54][5] = 1.023142; Qij_ECM_Init[54][6] = 0.007428; Qij_ECM_Init[54][7] = 0.670108; Qij_ECM_Init[54][8] = 0.010037; Qij_ECM_Init[54][9] = 0.184704; Qij_ECM_Init[54][10] = 0.000000; Qij_ECM_Init[54][11] = 0.071612; Qij_ECM_Init[54][12] = 0.066384; Qij_ECM_Init[54][13] = 0.000066; Qij_ECM_Init[54][14] = 0.135255; Qij_ECM_Init[54][15] = 0.001359; Qij_ECM_Init[54][16] = 0.015686; Qij_ECM_Init[54][17] = 0.000096; Qij_ECM_Init[54][18] = 0.976175; Qij_ECM_Init[54][19] = 0.003672; Qij_ECM_Init[54][20] = 0.644235; Qij_ECM_Init[54][21] = 0.100928; Qij_ECM_Init[54][22] = 0.975727; Qij_ECM_Init[54][23] = 0.121389; Qij_ECM_Init[54][24] = 0.928319; Qij_ECM_Init[54][25] = 0.000236; Qij_ECM_Init[54][26] = 0.915505; Qij_ECM_Init[54][27] = 0.009981; Qij_ECM_Init[54][28] = 0.150527; Qij_ECM_Init[54][29] = 0.000000; Qij_ECM_Init[54][30] = 0.032447; Qij_ECM_Init[54][31] = 0.000000; Qij_ECM_Init[54][32] = 0.011379; Qij_ECM_Init[54][33] = 0.000158; Qij_ECM_Init[54][34] = 1.013424; Qij_ECM_Init[54][35] = 0.003354; Qij_ECM_Init[54][36] = 0.095207; Qij_ECM_Init[54][37] = 0.167041; Qij_ECM_Init[54][38] = 2.729647; Qij_ECM_Init[54][39] = 0.053168; Qij_ECM_Init[54][40] = 0.426684; Qij_ECM_Init[54][41] = 0.000388; Qij_ECM_Init[54][42] = 2.005334; Qij_ECM_Init[54][43] = 0.000718; Qij_ECM_Init[54][44] = 0.008986; Qij_ECM_Init[54][45] = 0.004101; Qij_ECM_Init[54][46] = 0.119062; Qij_ECM_Init[54][47] = 0.006776; Qij_ECM_Init[54][48] = 0.041280; Qij_ECM_Init[54][49] = 0.018617; Qij_ECM_Init[54][50] = 0.802516; Qij_ECM_Init[54][51] = 0.027912; Qij_ECM_Init[54][52] = 0.702594; Qij_ECM_Init[54][53] = 14.214694; 
		Qij_ECM_Init[55][0] = 0.084945; Qij_ECM_Init[55][1] = 0.006464; Qij_ECM_Init[55][2] = 0.287373; Qij_ECM_Init[55][3] = 0.005472; Qij_ECM_Init[55][4] = 0.330481; Qij_ECM_Init[55][5] = 0.085680; Qij_ECM_Init[55][6] = 1.265487; Qij_ECM_Init[55][7] = 0.002179; Qij_ECM_Init[55][8] = 0.257122; Qij_ECM_Init[55][9] = 0.043721; Qij_ECM_Init[55][10] = 0.028878; Qij_ECM_Init[55][11] = 0.003641; Qij_ECM_Init[55][12] = 0.009966; Qij_ECM_Init[55][13] = 0.039560; Qij_ECM_Init[55][14] = 0.002679; Qij_ECM_Init[55][15] = 0.313495; Qij_ECM_Init[55][16] = 0.000140; Qij_ECM_Init[55][17] = 0.184749; Qij_ECM_Init[55][18] = 0.105112; Qij_ECM_Init[55][19] = 0.890822; Qij_ECM_Init[55][20] = 0.005410; Qij_ECM_Init[55][21] = 0.452442; Qij_ECM_Init[55][22] = 0.106069; Qij_ECM_Init[55][23] = 3.081614; Qij_ECM_Init[55][24] = 0.536567; Qij_ECM_Init[55][25] = 0.034978; Qij_ECM_Init[55][26] = 0.025678; Qij_ECM_Init[55][27] = 0.440217; Qij_ECM_Init[55][28] = 0.000858; Qij_ECM_Init[55][29] = 0.038612; Qij_ECM_Init[55][30] = 0.009174; Qij_ECM_Init[55][31] = 0.361403; Qij_ECM_Init[55][32] = 0.033994; Qij_ECM_Init[55][33] = 0.251423; Qij_ECM_Init[55][34] = 0.109664; Qij_ECM_Init[55][35] = 1.164866; Qij_ECM_Init[55][36] = 0.003464; Qij_ECM_Init[55][37] = 0.975582; Qij_ECM_Init[55][38] = 0.193544; Qij_ECM_Init[55][39] = 2.258321; Qij_ECM_Init[55][40] = 0.308851; Qij_ECM_Init[55][41] = 0.832592; Qij_ECM_Init[55][42] = 0.308372; Qij_ECM_Init[55][43] = 0.668173; Qij_ECM_Init[55][44] = 0.004420; Qij_ECM_Init[55][45] = 0.276499; Qij_ECM_Init[55][46] = 0.042565; Qij_ECM_Init[55][47] = 0.469281; Qij_ECM_Init[55][48] = 0.055025; Qij_ECM_Init[55][49] = 0.502355; Qij_ECM_Init[55][50] = 0.140546; Qij_ECM_Init[55][51] = 0.905488; Qij_ECM_Init[55][52] = 0.227527; Qij_ECM_Init[55][53] = 2.738552; Qij_ECM_Init[55][54] = 0.892903; 
		Qij_ECM_Init[56][0] = 0.010974; Qij_ECM_Init[56][1] = 0.034428; Qij_ECM_Init[56][2] = 0.000000; Qij_ECM_Init[56][3] = 0.159955; Qij_ECM_Init[56][4] = 0.042380; Qij_ECM_Init[56][5] = 0.283432; Qij_ECM_Init[56][6] = 0.001061; Qij_ECM_Init[56][7] = 1.029128; Qij_ECM_Init[56][8] = 0.042815; Qij_ECM_Init[56][9] = 0.136432; Qij_ECM_Init[56][10] = 0.014439; Qij_ECM_Init[56][11] = 0.013216; Qij_ECM_Init[56][12] = 0.137634; Qij_ECM_Init[56][13] = 0.004220; Qij_ECM_Init[56][14] = 0.010061; Qij_ECM_Init[56][15] = 0.000136; Qij_ECM_Init[56][16] = 0.176300; Qij_ECM_Init[56][17] = 0.034437; Qij_ECM_Init[56][18] = 0.294294; Qij_ECM_Init[56][19] = 0.001791; Qij_ECM_Init[56][20] = 0.990330; Qij_ECM_Init[56][21] = 0.159217; Qij_ECM_Init[56][22] = 0.566034; Qij_ECM_Init[56][23] = 0.343314; Qij_ECM_Init[56][24] = 3.036767; Qij_ECM_Init[56][25] = 0.007891; Qij_ECM_Init[56][26] = 0.528692; Qij_ECM_Init[56][27] = 0.001040; Qij_ECM_Init[56][28] = 2.171984; Qij_ECM_Init[56][29] = 0.003312; Qij_ECM_Init[56][30] = 0.031984; Qij_ECM_Init[56][31] = 0.000078; Qij_ECM_Init[56][32] = 0.262465; Qij_ECM_Init[56][33] = 0.033581; Qij_ECM_Init[56][34] = 0.360196; Qij_ECM_Init[56][35] = 0.000838; Qij_ECM_Init[56][36] = 1.447392; Qij_ECM_Init[56][37] = 0.149578; Qij_ECM_Init[56][38] = 0.372719; Qij_ECM_Init[56][39] = 0.159248; Qij_ECM_Init[56][40] = 1.563846; Qij_ECM_Init[56][41] = 0.129098; Qij_ECM_Init[56][42] = 0.822643; Qij_ECM_Init[56][43] = 0.000410; Qij_ECM_Init[56][44] = 1.195790; Qij_ECM_Init[56][45] = 0.049842; Qij_ECM_Init[56][46] = 0.245019; Qij_ECM_Init[56][47] = 0.053017; Qij_ECM_Init[56][48] = 0.362328; Qij_ECM_Init[56][49] = 0.106257; Qij_ECM_Init[56][50] = 0.938586; Qij_ECM_Init[56][51] = 0.157605; Qij_ECM_Init[56][52] = 1.251589; Qij_ECM_Init[56][53] = 1.091224; Qij_ECM_Init[56][54] = 3.195698; Qij_ECM_Init[56][55] = 12.984714; 
		Qij_ECM_Init[57][0] = 0.164659; Qij_ECM_Init[57][1] = 0.000141; Qij_ECM_Init[57][2] = 0.000741; Qij_ECM_Init[57][3] = 0.003881; Qij_ECM_Init[57][4] = 0.976185; Qij_ECM_Init[57][5] = 0.001951; Qij_ECM_Init[57][6] = 0.011673; Qij_ECM_Init[57][7] = 0.007109; Qij_ECM_Init[57][8] = 0.130940; Qij_ECM_Init[57][9] = 0.000120; Qij_ECM_Init[57][10] = 0.420899; Qij_ECM_Init[57][11] = 0.045044; Qij_ECM_Init[57][12] = 0.039313; Qij_ECM_Init[57][13] = 0.169777; Qij_ECM_Init[57][14] = 0.000060; Qij_ECM_Init[57][15] = 0.000272; Qij_ECM_Init[57][16] = 0.000175; Qij_ECM_Init[57][17] = 0.418802; Qij_ECM_Init[57][18] = 0.000288; Qij_ECM_Init[57][19] = 0.002508; Qij_ECM_Init[57][20] = 0.001312; Qij_ECM_Init[57][21] = 0.388156; Qij_ECM_Init[57][22] = 0.000091; Qij_ECM_Init[57][23] = 0.042812; Qij_ECM_Init[57][24] = 0.003377; Qij_ECM_Init[57][25] = 0.241197; Qij_ECM_Init[57][26] = 0.004656; Qij_ECM_Init[57][27] = 0.042005; Qij_ECM_Init[57][28] = 0.011768; Qij_ECM_Init[57][29] = 0.069995; Qij_ECM_Init[57][30] = 0.000000; Qij_ECM_Init[57][31] = 0.000156; Qij_ECM_Init[57][32] = 0.027479; Qij_ECM_Init[57][33] = 0.380374; Qij_ECM_Init[57][34] = 0.000112; Qij_ECM_Init[57][35] = 0.000534; Qij_ECM_Init[57][36] = 0.000374; Qij_ECM_Init[57][37] = 1.322234; Qij_ECM_Init[57][38] = 0.005905; Qij_ECM_Init[57][39] = 0.048730; Qij_ECM_Init[57][40] = 0.021649; Qij_ECM_Init[57][41] = 2.382451; Qij_ECM_Init[57][42] = 0.326035; Qij_ECM_Init[57][43] = 0.037657; Qij_ECM_Init[57][44] = 0.047437; Qij_ECM_Init[57][45] = 0.164143; Qij_ECM_Init[57][46] = 0.016776; Qij_ECM_Init[57][47] = 0.072521; Qij_ECM_Init[57][48] = 0.024883; Qij_ECM_Init[57][49] = 1.572808; Qij_ECM_Init[57][50] = 0.086923; Qij_ECM_Init[57][51] = 0.585071; Qij_ECM_Init[57][52] = 0.083552; Qij_ECM_Init[57][53] = 0.629243; Qij_ECM_Init[57][54] = 0.035120; Qij_ECM_Init[57][55] = 0.089148; Qij_ECM_Init[57][56] = 0.030223; 
		Qij_ECM_Init[58][0] = 0.000000; Qij_ECM_Init[58][1] = 0.172889; Qij_ECM_Init[58][2] = 0.000000; Qij_ECM_Init[58][3] = 0.000191; Qij_ECM_Init[58][4] = 0.000085; Qij_ECM_Init[58][5] = 0.880032; Qij_ECM_Init[58][6] = 0.000289; Qij_ECM_Init[58][7] = 0.356038; Qij_ECM_Init[58][8] = 0.000058; Qij_ECM_Init[58][9] = 0.127388; Qij_ECM_Init[58][10] = 0.007608; Qij_ECM_Init[58][11] = 0.309374; Qij_ECM_Init[58][12] = 0.105305; Qij_ECM_Init[58][13] = 0.000000; Qij_ECM_Init[58][14] = 0.240505; Qij_ECM_Init[58][15] = 0.000000; Qij_ECM_Init[58][16] = 0.047268; Qij_ECM_Init[58][17] = 0.000096; Qij_ECM_Init[58][18] = 0.636916; Qij_ECM_Init[58][19] = 0.000090; Qij_ECM_Init[58][20] = 0.395771; Qij_ECM_Init[58][21] = 0.000843; Qij_ECM_Init[58][22] = 0.566759; Qij_ECM_Init[58][23] = 0.016193; Qij_ECM_Init[58][24] = 0.336277; Qij_ECM_Init[58][25] = 0.021435; Qij_ECM_Init[58][26] = 0.676049; Qij_ECM_Init[58][27] = 0.008942; Qij_ECM_Init[58][28] = 0.703728; Qij_ECM_Init[58][29] = 0.000283; Qij_ECM_Init[58][30] = 0.055425; Qij_ECM_Init[58][31] = 0.000000; Qij_ECM_Init[58][32] = 0.018603; Qij_ECM_Init[58][33] = 0.000000; Qij_ECM_Init[58][34] = 0.518903; Qij_ECM_Init[58][35] = 0.000000; Qij_ECM_Init[58][36] = 0.006459; Qij_ECM_Init[58][37] = 0.001122; Qij_ECM_Init[58][38] = 1.110726; Qij_ECM_Init[58][39] = 0.002863; Qij_ECM_Init[58][40] = 0.176224; Qij_ECM_Init[58][41] = 0.054025; Qij_ECM_Init[58][42] = 2.392606; Qij_ECM_Init[58][43] = 0.000821; Qij_ECM_Init[58][44] = 0.012227; Qij_ECM_Init[58][45] = 0.002050; Qij_ECM_Init[58][46] = 0.201477; Qij_ECM_Init[58][47] = 0.001557; Qij_ECM_Init[58][48] = 0.051048; Qij_ECM_Init[58][49] = 0.022214; Qij_ECM_Init[58][50] = 1.797671; Qij_ECM_Init[58][51] = 0.027973; Qij_ECM_Init[58][52] = 1.398079; Qij_ECM_Init[58][53] = 0.037461; Qij_ECM_Init[58][54] = 1.228004; Qij_ECM_Init[58][55] = 0.030585; Qij_ECM_Init[58][56] = 0.239725; Qij_ECM_Init[58][57] = 13.935950; 
		Qij_ECM_Init[59][0] = 0.113991; Qij_ECM_Init[59][1] = 0.018315; Qij_ECM_Init[59][2] = 0.201112; Qij_ECM_Init[59][3] = 0.001082; Qij_ECM_Init[59][4] = 0.012121; Qij_ECM_Init[59][5] = 0.001951; Qij_ECM_Init[59][6] = 1.720919; Qij_ECM_Init[59][7] = 0.001720; Qij_ECM_Init[59][8] = 0.082323; Qij_ECM_Init[59][9] = 0.029826; Qij_ECM_Init[59][10] = 0.197641; Qij_ECM_Init[59][11] = 0.061497; Qij_ECM_Init[59][12] = 0.073682; Qij_ECM_Init[59][13] = 0.000330; Qij_ECM_Init[59][14] = 0.000060; Qij_ECM_Init[59][15] = 0.165784; Qij_ECM_Init[59][16] = 0.000070; Qij_ECM_Init[59][17] = 0.003549; Qij_ECM_Init[59][18] = 0.000384; Qij_ECM_Init[59][19] = 0.556204; Qij_ECM_Init[59][20] = 0.000164; Qij_ECM_Init[59][21] = 0.097554; Qij_ECM_Init[59][22] = 0.004982; Qij_ECM_Init[59][23] = 0.551493; Qij_ECM_Init[59][24] = 0.000289; Qij_ECM_Init[59][25] = 0.015310; Qij_ECM_Init[59][26] = 0.000753; Qij_ECM_Init[59][27] = 0.247245; Qij_ECM_Init[59][28] = 0.010419; Qij_ECM_Init[59][29] = 0.000283; Qij_ECM_Init[59][30] = 0.000084; Qij_ECM_Init[59][31] = 0.194319; Qij_ECM_Init[59][32] = 0.037724; Qij_ECM_Init[59][33] = 0.002449; Qij_ECM_Init[59][34] = 0.000112; Qij_ECM_Init[59][35] = 0.466770; Qij_ECM_Init[59][36] = 0.000187; Qij_ECM_Init[59][37] = 0.909861; Qij_ECM_Init[59][38] = 0.280400; Qij_ECM_Init[59][39] = 0.713961; Qij_ECM_Init[59][40] = 0.001760; Qij_ECM_Init[59][41] = 1.179053; Qij_ECM_Init[59][42] = 0.298738; Qij_ECM_Init[59][43] = 0.938439; Qij_ECM_Init[59][44] = 0.165587; Qij_ECM_Init[59][45] = 0.080337; Qij_ECM_Init[59][46] = 0.009773; Qij_ECM_Init[59][47] = 0.324696; Qij_ECM_Init[59][48] = 0.016839; Qij_ECM_Init[59][49] = 0.658541; Qij_ECM_Init[59][50] = 0.036022; Qij_ECM_Init[59][51] = 1.693998; Qij_ECM_Init[59][52] = 0.046588; Qij_ECM_Init[59][53] = 0.375097; Qij_ECM_Init[59][54] = 0.067431; Qij_ECM_Init[59][55] = 0.639125; Qij_ECM_Init[59][56] = 0.053748; Qij_ECM_Init[59][57] = 21.171295; Qij_ECM_Init[59][58] = 5.214689; 
		Qij_ECM_Init[60][0] = 0.018773; Qij_ECM_Init[60][1] = 0.032039; Qij_ECM_Init[60][2] = 0.000000; Qij_ECM_Init[60][3] = 0.175861; Qij_ECM_Init[60][4] = 0.002797; Qij_ECM_Init[60][5] = 0.002974; Qij_ECM_Init[60][6] = 0.003376; Qij_ECM_Init[60][7] = 2.163175; Qij_ECM_Init[60][8] = 0.007948; Qij_ECM_Init[60][9] = 0.014314; Qij_ECM_Init[60][10] = 0.105884; Qij_ECM_Init[60][11] = 0.183952; Qij_ECM_Init[60][12] = 0.381671; Qij_ECM_Init[60][13] = 0.000066; Qij_ECM_Init[60][14] = 0.000119; Qij_ECM_Init[60][15] = 0.000000; Qij_ECM_Init[60][16] = 0.185038; Qij_ECM_Init[60][17] = 0.001918; Qij_ECM_Init[60][18] = 0.001441; Qij_ECM_Init[60][19] = 0.001254; Qij_ECM_Init[60][20] = 0.703092; Qij_ECM_Init[60][21] = 0.084060; Qij_ECM_Init[60][22] = 0.053714; Qij_ECM_Init[60][23] = 0.003029; Qij_ECM_Init[60][24] = 0.634203; Qij_ECM_Init[60][25] = 0.043222; Qij_ECM_Init[60][26] = 0.097165; Qij_ECM_Init[60][27] = 0.143481; Qij_ECM_Init[60][28] = 0.590833; Qij_ECM_Init[60][29] = 0.000081; Qij_ECM_Init[60][30] = 0.000295; Qij_ECM_Init[60][31] = 0.000078; Qij_ECM_Init[60][32] = 0.410199; Qij_ECM_Init[60][33] = 0.000553; Qij_ECM_Init[60][34] = 0.000447; Qij_ECM_Init[60][35] = 0.000610; Qij_ECM_Init[60][36] = 0.716441; Qij_ECM_Init[60][37] = 0.194964; Qij_ECM_Init[60][38] = 0.293884; Qij_ECM_Init[60][39] = 0.001158; Qij_ECM_Init[60][40] = 0.744000; Qij_ECM_Init[60][41] = 0.684968; Qij_ECM_Init[60][42] = 1.149846; Qij_ECM_Init[60][43] = 0.069567; Qij_ECM_Init[60][44] = 1.558784; Qij_ECM_Init[60][45] = 0.032177; Qij_ECM_Init[60][46] = 0.064227; Qij_ECM_Init[60][47] = 0.074536; Qij_ECM_Init[60][48] = 0.276276; Qij_ECM_Init[60][49] = 0.238907; Qij_ECM_Init[60][50] = 0.496552; Qij_ECM_Init[60][51] = 0.672077; Qij_ECM_Init[60][52] = 1.526141; Qij_ECM_Init[60][53] = 0.235747; Qij_ECM_Init[60][54] = 0.403521; Qij_ECM_Init[60][55] = 0.136937; Qij_ECM_Init[60][56] = 0.968146; Qij_ECM_Init[60][57] = 13.981617; Qij_ECM_Init[60][58] = 18.675227; Qij_ECM_Init[60][59] = 25.640860; 

		Freq_ECM_Init[0] = 0.021414; Freq_ECM_Init[1] = 0.021349; Freq_ECM_Init[2] = 0.016195; Freq_ECM_Init[3] = 0.015717; Freq_ECM_Init[4] = 0.011798; Freq_ECM_Init[5] = 0.010761; Freq_ECM_Init[6] = 0.010366; Freq_ECM_Init[7] = 0.008721; Freq_ECM_Init[8] = 0.017237; Freq_ECM_Init[9] = 0.016697; Freq_ECM_Init[10] = 0.006441; Freq_ECM_Init[11] = 0.007415; Freq_ECM_Init[12] = 0.012744; Freq_ECM_Init[13] = 0.015167; Freq_ECM_Init[14] = 0.016798; Freq_ECM_Init[15] = 0.007359; Freq_ECM_Init[16] = 0.028497; Freq_ECM_Init[17] = 0.010425; Freq_ECM_Init[18] = 0.010408; Freq_ECM_Init[19] = 0.011165; Freq_ECM_Init[20] = 0.012199; Freq_ECM_Init[21] = 0.010671; Freq_ECM_Init[22] = 0.011040; Freq_ECM_Init[23] = 0.017168; Freq_ECM_Init[24] = 0.020730; Freq_ECM_Init[25] = 0.008491; Freq_ECM_Init[26] = 0.014604; Freq_ECM_Init[27] = 0.004809; Freq_ECM_Init[28] = 0.008158; Freq_ECM_Init[29] = 0.024759; Freq_ECM_Init[30] = 0.023762; Freq_ECM_Init[31] = 0.012814; Freq_ECM_Init[32] = 0.021180; Freq_ECM_Init[33] = 0.012656; Freq_ECM_Init[34] = 0.017882; Freq_ECM_Init[35] = 0.013120; Freq_ECM_Init[36] = 0.010682; Freq_ECM_Init[37] = 0.022276; Freq_ECM_Init[38] = 0.020321; Freq_ECM_Init[39] = 0.031090; Freq_ECM_Init[40] = 0.026699; Freq_ECM_Init[41] = 0.010310; Freq_ECM_Init[42] = 0.013701; Freq_ECM_Init[43] = 0.009746; Freq_ECM_Init[44] = 0.006788; Freq_ECM_Init[45] = 0.019020; Freq_ECM_Init[46] = 0.018419; Freq_ECM_Init[47] = 0.010921; Freq_ECM_Init[48] = 0.022626; Freq_ECM_Init[49] = 0.018907; Freq_ECM_Init[50] = 0.026817; Freq_ECM_Init[51] = 0.016516; Freq_ECM_Init[52] = 0.018288; Freq_ECM_Init[53] = 0.028590; Freq_ECM_Init[54] = 0.025285; Freq_ECM_Init[55] = 0.034527; Freq_ECM_Init[56] = 0.030606; Freq_ECM_Init[57] = 0.016883; Freq_ECM_Init[58] = 0.023659; Freq_ECM_Init[59] = 0.016386; Freq_ECM_Init[60] = 0.010223; 



		/* complete the matrix */			
		for (i = 0; i < NUMCOD; i++)
			{
			for (j = 0; j < NUMCOD; j++)
				{
				if (i == j)
					Qij_ECM_Init[i][j] = 0; /* main diagonal */
				if (i != j) 
					{
					if (Qij_ECM_Init[i][j] == -1 && Qij_ECM_Init[j][i] >= 0)
						Qij_ECM_Init[i][j] = Qij_ECM_Init[j][i]; /* symetric matrix */
					if (Qij_ECM_Init[j][i] == -1 && Qij_ECM_Init[i][j] >= 0)
						Qij_ECM_Init[j][i] = Qij_ECM_Init[i][j]; /* symetric matrix */
					} 
				}		
			}

		/* check if the matrix is symmetric: [0][1] = [1][0] */
		/*for (i = 0; i < NUMCOD; i++)
			for (j = 0; j < NUMCOD; j++)
				{
				if (i == j)
					{
					if (Qij_ECM_Init[i][j] > 0.00000000001 || Qij_ECM_Init[i][j] < -0.00000000001)
						{
						if (noisy > 2)
							fprintf (stderr, "\n\n> ECM1: Warning in the emperical codon matrix. Main diagonal is different to 0: Q[%d][%d] = %lf \n\n", i, j, Qij_ECM_Init[i][j]);
						}
					}
				else
					{
					if (Qij_ECM_Init[i][j] != Qij_ECM_Init[j][i])
						{
						if (noisy > 2)
							fprintf (stderr, "\n\n> ECM1: Warning in the emperical codon matrix. Matrix is not symmetric: Q[%d][%d] (%lf) = Q[%d][%d] (%lf) \n\n", i, j, Qij_ECM_Init[i][j], j, i, Qij_ECM_Init[j][i]);
						}

					}			
				}*/



		/* adapt matrix to our codon order */

		/* Kosiol et al: TTT TTC TTA TTG TCT TCC TCA TCG TAT TAC TGT TGC TGG CTT CTC CTA CTG CCT CCC CCA 
		CCG CAT CAC CAA CAG CGT CGC CGA CGG ATT ATC ATA ATG ACT ACC ACA ACG AAT AAC AAA 
		AAG AGT AGC AGA AGG GTT GTC GTA GTG GCT GCC GCA GCG GAT GAC GAA GAG GGT GGC GGA 
		GGG */

		/* our matrix: AAA AAC AAG AAT ACA ACC ACG ACT AGA AGC AGG AGT ATA ATC ATG ATT CAA CAC CAG CAT 
		CCA CCC CCG CCT CGA CGC CGG CGT CTA CTC CTG CTT GAA GAC GAG GAT GCA GCC GCG GCT 
		GGA GGC GGG GGT GTA GTC GTG GTT TAC TAT TCA TCC TCG TCT TGC TGG TGT TTA TTC TTG TTT */

		/* our matrix - Kosiol et al */
		/*
		0 39
		1 38
		2 40
		3 37
		4 35
		5 34
		6 36
		7 33
		8 43
		9 42
		10 44
		11 41
		12 31
		13 30
		14 32
		15 29
		16 23
		17 22
		18 24
		19 21
		20 19
		21 18
		22 20
		23 17
		24 27
		25 26
		26 28
		27 25
		28 15
		29 14
		30 16
		31 13
		32 55
		33 54
		34 56
		35 53
		36 51
		37 50
		38 52
		39 49
		40 59
		41 58
		42 60
		43 57
		44 47
		45 46
		46 48
		47 45
		48 9
		49 8
		50 6
		51 5
		52 7
		53 4
		54 11
		55 12
		56 10
		57 2
		58 1
		59 3
		60 0
		*/

		
		for (i = 0; i < NUMCOD; i++)
			{
			for (j = 0; j < NUMCOD; j++)
				{
				if (i == j)
					{
					Qij_C[i][j] = 0; /* main diagonal */
					Qij_ECM_Init[i][j] = 0;
					}
				else
					{
					if (i == 39)
						a = 0;
					if (i == 38)
						a = 1;
					if (i == 40)
						a = 2;
					if (i == 37)
						a = 3;
					if (i == 35)
						a = 4;
					if (i == 34)
						a = 5;
					if (i == 36)
						a = 6;
					if (i == 33)
						a = 7;
					if (i == 43)
						a = 8;
					if (i == 42)
						a = 9;
					if (i == 44)
						a = 10;
					if (i == 41)
						a = 11;
					if (i == 31)
						a = 12;
					if (i == 30)
						a = 13;
					if (i == 32)
						a = 14;
					if (i == 29)
						a = 15;
					if (i == 23)
						a = 16;
					if (i == 22)
						a = 17;
					if (i == 24)
						a = 18;
					if (i == 21)
						a = 19;
					if (i == 19)
						a = 20;
					if (i == 18)
						a = 21;
					if (i == 20)
						a = 22;
					if (i == 17)
						a = 23;
					if (i == 27)
						a = 24;
					if (i == 26)
						a = 25;
					if (i == 28)
						a = 26;
					if (i == 25)
						a = 27;
					if (i == 15)
						a = 28;
					if (i == 14)
						a = 29;
					if (i == 16)
						a = 30;
					if (i == 13)
						a = 31;
					if (i == 55)
						a = 32;
					if (i == 54)
						a = 33;
					if (i == 56)
						a = 34;
					if (i == 53)
						a = 35;
					if (i == 51)
						a = 36;
					if (i == 50)
						a = 37;
					if (i == 52)
						a = 38;
					if (i == 49)
						a = 39;
					if (i == 59)
						a = 40;
					if (i == 58)
						a = 41;
					if (i == 60)
						a = 42;
					if (i == 57)
						a = 43;
					if (i == 47)
						a = 44;
					if (i == 46)
						a = 45;
					if (i == 48)
						a = 46;
					if (i == 45)
						a = 47;
					if (i == 9)
						a = 48;
					if (i == 8)
						a = 49;
					if (i == 6)
						a = 50;
					if (i == 5)
						a = 51;
					if (i == 7)
						a = 52;
					if (i == 4)
						a = 53;
					if (i == 11)
						a = 54;
					if (i == 12)
						a = 55;
					if (i == 10)
						a = 56;
					if (i == 2)
						a = 57;
					if (i == 1)
						a = 58;
					if (i == 3)
						a = 59;
					if (i == 0)
						a = 60;


					if (j == 39)
						b = 0;
					if (j == 38)
						b = 1;
					if (j == 40)
						b = 2;
					if (j == 37)
						b = 3;
					if (j == 35)
						b = 4;
					if (j == 34)
						b = 5;
					if (j == 36)
						b = 6;
					if (j == 33)
						b = 7;
					if (j == 43)
						b = 8;
					if (j == 42)
						b = 9;
					if (j == 44)
						b = 10;
					if (j == 41)
						b = 11;
					if (j == 31)
						b = 12;
					if (j == 30)
						b = 13;
					if (j == 32)
						b = 14;
					if (j == 29)
						b = 15;
					if (j == 23)
						b = 16;
					if (j == 22)
						b = 17;
					if (j == 24)
						b = 18;
					if (j == 21)
						b = 19;
					if (j == 19)
						b = 20;
					if (j == 18)
						b = 21;
					if (j == 20)
						b = 22;
					if (j == 17)
						b = 23;
					if (j == 27)
						b = 24;
					if (j == 26)
						b = 25;
					if (j == 28)
						b = 26;
					if (j == 25)
						b = 27;
					if (j == 15)
						b = 28;
					if (j == 14)
						b = 29;
					if (j == 16)
						b = 30;
					if (j == 13)
						b = 31;
					if (j == 55)
						b = 32;
					if (j == 54)
						b = 33;
					if (j == 56)
						b = 34;
					if (j == 53)
						b = 35;
					if (j == 51)
						b = 36;
					if (j == 50)
						b = 37;
					if (j == 52)
						b = 38;
					if (j == 49)
						b = 39;
					if (j == 59)
						b = 40;
					if (j == 58)
						b = 41;
					if (j == 60)
						b = 42;
					if (j == 57)
						b = 43;
					if (j == 47)
						b = 44;
					if (j == 46)
						b = 45;
					if (j == 48)
						b = 46;
					if (j == 45)
						b = 47;
					if (j == 9)
						b = 48;
					if (j == 8)
						b = 49;
					if (j == 6)
						b = 50;
					if (j == 5)
						b = 51;
					if (j == 7)
						b = 52;
					if (j == 4)
						b = 53;
					if (j == 11)
						b = 54;
					if (j == 12)
						b = 55;
					if (j == 10)
						b = 56;
					if (j == 2)
						b = 57;
					if (j == 1)
						b = 58;
					if (j == 3)
						b = 59;
					if (j == 0)
						b = 60;

					Qij_C[a][b] = Qij_ECM_Init[i][j];
					
					if (i == 0) /* Freqs */
						{
						Qij_CF[b] = Freq_ECM_Init[j];
						Qij_CF[60] = Freq_ECM_Init[0]; /* because i==j is not considered here */
						}
					}

				}		
			}

		/* check if the matrix is symmetric: [0][1] = [1][0] */
		/*for (i = 0; i < NUMCOD; i++)
			for (j = 0; j < NUMCOD; j++)
				{
				if (i == j)
					{
					if (Qij_C[i][j] > 0.00000000001 || Qij_C[i][j] < -0.00000000001)
						{
						if (noisy > 2)
							fprintf (stderr, "\n\n> ECM2: Warning in the emperical codon matrix. Main diagonal is different to 0: Q[%d][%d] = %lf \n\n", i, j, Qij_C[i][j]);
						}
					}
				else
					{
					if (Qij_C[i][j] != Qij_C[j][i])
						{
						if (noisy > 2)
							fprintf (stderr, "\n\n> ECM2: Warning in the emperical codon matrix. Matrix is not symmetric: Q[%d][%d] (%lf) = Q[%d][%d] (%lf) \n\n", i, j, Qij_C[i][j], j, i, Qij_C[j][i]);
						}

					}			
				}*/

		}
	else if (doECMSchn == YES) /* Empirical codon model: Empirical codon substitution matrix. Schneider, Cannarozzi* and Gonnet. BMC bioinformatics 2005 */
		{
		/*fprintf (stderr, "\n\n In the ECMSchn emperical codon matrix\n");*/

		Qij_C[0][0] = 0;		Qij_C[0][1] = 305;		Qij_C[0][2] = 12057; 	Qij_C[0][3] = 580;  	Qij_C[0][4] = 650;  	Qij_C[0][5] = 54;    Qij_C[0][6] = 0;  	Qij_C[0][7] = 114; 	Qij_C[0][8] = 4144;  	Qij_C[0][9] = 158;  		Qij_C[0][10] = 572;  		Qij_C[0][11] = 245;  	Qij_C[0][12] = 292;   	Qij_C[0][13] = 0;   		Qij_C[0][14] = 80;   Qij_C[0][15] = 16; Qij_C[0][16] = 1364;   Qij_C[0][17] = 94;  Qij_C[0][18] = 137;  Qij_C[0][19] = 169;   Qij_C[0][20] = 91;   Qij_C[0][21] = 18;   Qij_C[0][22] = 39;   Qij_C[0][23] = 26;  Qij_C[0][24] = 908;  Qij_C[0][25] = 337;  Qij_C[0][26] = 410;  Qij_C[0][27] = 334;  Qij_C[0][28] = 100;   Qij_C[0][29] = 17;    Qij_C[0][30] = 0;   Qij_C[0][31] = 30;  Qij_C[0][32] = 626;   Qij_C[0][33] = 58;    Qij_C[0][34] = 0;   Qij_C[0][35] = 56;  Qij_C[0][36] = 216;   Qij_C[0][37] = 13;   Qij_C[0][38] = 62;   Qij_C[0][39] = 43;  Qij_C[0][40] = 137;   Qij_C[0][41] = 13;   Qij_C[0][42] = 13;   Qij_C[0][43] = 44;  Qij_C[0][44] = 153;   Qij_C[0][45] = 13;   Qij_C[0][46] = 10;   Qij_C[0][47] = 37;    Qij_C[0][48] = 8;    Qij_C[0][49] = 16;  Qij_C[0][50] = 133;   Qij_C[0][51] = 24;   Qij_C[0][52] = 53;   Qij_C[0][53] = 54;   Qij_C[0][54] = 15;    Qij_C[0][55] = 9;   Qij_C[0][56] = 20;   Qij_C[0][57] = 59;    Qij_C[0][58] = 6;   Qij_C[0][59] = 28;    Qij_C[0][60] = 4;
		Qij_C[1][0] = 305;   	Qij_C[1][1] = 0;  		Qij_C[1][2] = 269;		Qij_C[1][3] = 17900; 	Qij_C[1][4] = 165;  	Qij_C[1][5] = 984;   Qij_C[1][6] = 67;  	Qij_C[1][7] = 122;  	Qij_C[1][8] = 142; 		Qij_C[1][9] = 3430;  	Qij_C[1][10] = 139;   	Qij_C[1][11] = 0;   	Qij_C[1][12] = 21;  		Qij_C[1][13] = 145;   	Qij_C[1][14] = 42;    Qij_C[1][15] = 0;  Qij_C[1][16] = 148; Qij_C[1][17] = 1196;  Qij_C[1][18] = 142;    Qij_C[1][19] = 9;   Qij_C[1][20] = 17;   Qij_C[1][21] = 98;   Qij_C[1][22] = 47;   Qij_C[1][23] = 14;    Qij_C[1][24] = 0;  Qij_C[1][25] = 264;   Qij_C[1][26] = 58;    Qij_C[1][27] = 0;   Qij_C[1][28] = 19;   Qij_C[1][29] = 64;    Qij_C[1][30] = 7;    Qij_C[1][31] = 0;   Qij_C[1][32] = 74; Qij_C[1][33] = 1249;   Qij_C[1][34] = 80;    Qij_C[1][35] = 4;   Qij_C[1][36] = 28;  Qij_C[1][37] = 224;  Qij_C[1][38] = 161;   Qij_C[1][39] = 38;   Qij_C[1][40] = 31;  Qij_C[1][41] = 589;  Qij_C[1][42] = 171;   Qij_C[1][43] = 98;   Qij_C[1][44] = 26;   Qij_C[1][45] = 86;   Qij_C[1][46] = 12;   Qij_C[1][47] = 20;  Qij_C[1][48] = 196;    Qij_C[1][49] = 0;   Qij_C[1][50] = 79;  Qij_C[1][51] = 277;   Qij_C[1][52] = 40;   Qij_C[1][53] = 87;  Qij_C[1][54] = 116;    Qij_C[1][55] = 7;    Qij_C[1][56] = 4;    Qij_C[1][57] = 4;   Qij_C[1][58] = 34;   Qij_C[1][59] = 22;    Qij_C[1][60] = 8;
		Qij_C[2][0] = 12057; 	Qij_C[2][1] = 269;   	Qij_C[2][2] = 0;  		Qij_C[2][3] = 298;   	Qij_C[2][4] = 94;   	Qij_C[2][5] = 85;  	Qij_C[2][6] = 795;   Qij_C[2][7] = 27;  	Qij_C[2][8] = 390;  		Qij_C[2][9] = 131; 		Qij_C[2][10] = 3644;  	Qij_C[2][11] = 146;   Qij_C[2][12] = 22;   		Qij_C[2][13] = 21;  		Qij_C[2][14] = 189;   Qij_C[2][15] = 20;   Qij_C[2][16] = 33;  Qij_C[2][17] = 110;  Qij_C[2][18] = 727;   Qij_C[2][19] = 84;   Qij_C[2][20] = 28;   Qij_C[2][21] = 14;  Qij_C[2][22] = 105;   Qij_C[2][23] = 14;  Qij_C[2][24] = 299;  Qij_C[2][25] = 569; Qij_C[2][26] = 1249;  Qij_C[2][27] = 353;    Qij_C[2][28] = 0;    Qij_C[2][29] = 3;   Qij_C[2][30] = 36;    Qij_C[2][31] = 7;    Qij_C[2][32] = 0;   Qij_C[2][33] = 35;  Qij_C[2][34] = 429;   Qij_C[2][35] = 44;   Qij_C[2][36] = 48;   Qij_C[2][37] = 45;  Qij_C[2][38] = 171;   Qij_C[2][39] = 31;   Qij_C[2][40] = 11;   Qij_C[2][41] = 28;  Qij_C[2][42] = 144;   Qij_C[2][43] = 32;   Qij_C[2][44] = 16;   Qij_C[2][45] = 11;   Qij_C[2][46] = 54;    Qij_C[2][47] = 3;   Qij_C[2][48] = 11;    Qij_C[2][49] = 11;   Qij_C[2][50] = 52;   Qij_C[2][51] = 24;   Qij_C[2][52] = 70;   Qij_C[2][53] = 26;   Qij_C[2][54] = 16;   Qij_C[2][55] = 24;   Qij_C[2][56] = 13;    Qij_C[2][57] = 4;    Qij_C[2][58] = 0;   Qij_C[2][59] = 39;    Qij_C[2][60] = 6;
		Qij_C[3][0] = 580;		Qij_C[3][1] = 17900; 	Qij_C[3][2] = 298;   	Qij_C[3][3] = 0;  		Qij_C[3][4] = 237;  	Qij_C[3][5] = 16;  	Qij_C[3][6] = 182; 	Qij_C[3][7] = 1425;  Qij_C[3][8] = 178;  		Qij_C[3][9] = 178;  		Qij_C[3][10] = 145; 		Qij_C[3][11] = 4830;  Qij_C[3][12] = 50;    	Qij_C[3][13] = 0;   		Qij_C[3][14] = 68;  Qij_C[3][15] = 202;  Qij_C[3][16] = 311;   Qij_C[3][17] = 55;  Qij_C[3][18] = 168; Qij_C[3][19] = 1623;   Qij_C[3][20] = 55;   Qij_C[3][21] = 34;   Qij_C[3][22] = 46;  Qij_C[3][23] = 115;   Qij_C[3][24] = 45;    Qij_C[3][25] = 0;   Qij_C[3][26] = 27;  Qij_C[3][27] = 429;   Qij_C[3][28] = 22;    Qij_C[3][29] = 0;    Qij_C[3][30] = 0;  Qij_C[3][31] = 110;  Qij_C[3][32] = 187;   Qij_C[3][33] = 33;  Qij_C[3][34] = 106; Qij_C[3][35] = 1636;  Qij_C[3][36] = 149;   Qij_C[3][37] = 25;   Qij_C[3][38] = 81;  Qij_C[3][39] = 252;  Qij_C[3][40] = 121;   Qij_C[3][41] = 91;   Qij_C[3][42] = 67;  Qij_C[3][43] = 829;   Qij_C[3][44] = 55;   Qij_C[3][45] = 21;   Qij_C[3][46] = 12;  Qij_C[3][47] = 100;    Qij_C[3][48] = 0;    Qij_C[3][49] = 316;  Qij_C[3][50] = 139;   Qij_C[3][51] = 32;   Qij_C[3][52] = 78;  Qij_C[3][53] = 289;    Qij_C[3][54] = 0;   Qij_C[3][55] = 11;  Qij_C[3][56] = 191;   Qij_C[3][57] = 48;    Qij_C[3][58] = 0;   Qij_C[3][59] = 36;   Qij_C[3][60] = 41;
		Qij_C[4][0] = 650;  	Qij_C[4][1] = 165;  	Qij_C[4][2] = 94;  		Qij_C[4][3] = 237;   	Qij_C[4][4] = 0;		Qij_C[4][5] = 10306;	Qij_C[4][6] = 34110;	Qij_C[4][7] = 16829; Qij_C[4][8] = 743;  		Qij_C[4][9] = 343;   	Qij_C[4][10] = 49;  		Qij_C[4][11] = 402; 	Qij_C[4][12] = 2434;  	Qij_C[4][13] = 0;  		Qij_C[4][14] = 714;    Qij_C[4][15] = 0;  Qij_C[4][16] = 341;   Qij_C[4][17] = 27;   Qij_C[4][18] = 96;   Qij_C[4][19] = 93; Qij_C[4][20] = 1015;    Qij_C[4][21] = 0;   Qij_C[4][22] = 88;   Qij_C[4][23] = 64;    Qij_C[4][24] = 0;    Qij_C[4][25] = 0;   Qij_C[4][26] = 26;   Qij_C[4][27] = 39;  Qij_C[4][28] = 288;    Qij_C[4][29] = 0;   Qij_C[4][30] = 46;    Qij_C[4][31] = 4;  Qij_C[4][32] = 196;    Qij_C[4][33] = 0;   Qij_C[4][34] = 76;   Qij_C[4][35] = 83; Qij_C[4][36] = 3718;    Qij_C[4][37] = 0;    Qij_C[4][38] = 0;    Qij_C[4][39] = 0;  Qij_C[4][40] = 214;    Qij_C[4][41] = 6;   Qij_C[4][42] = 84;   Qij_C[4][43] = 46; Qij_C[4][44] = 1694;    Qij_C[4][45] = 1;  Qij_C[4][46] = 206;   Qij_C[4][47] = 65;    Qij_C[4][48] = 0;    Qij_C[4][49] = 12; Qij_C[4][50] = 3129;   Qij_C[4][51] = 81;  Qij_C[4][52] = 578;  Qij_C[4][53] = 567;   Qij_C[4][54] = 22;   Qij_C[4][55] = 19;   Qij_C[4][56] = 75;  Qij_C[4][57] = 295;   Qij_C[4][58] = 11;   Qij_C[4][59] = 92;   Qij_C[4][60] = 23;
		Qij_C[5][0] = 54; 		Qij_C[5][1] = 984;  	Qij_C[5][2] = 85;  		Qij_C[5][3] = 16;		Qij_C[5][4] = 10306; 	Qij_C[5][5] = 0;		Qij_C[5][6] = 19942;	Qij_C[5][7] = 16316; Qij_C[5][8] = 31; 		Qij_C[5][9] = 2248;  	Qij_C[5][10] = 59;    	Qij_C[5][11] = 0;    	Qij_C[5][12] = 0; 		Qij_C[5][13] = 1028;  	Qij_C[5][14] = 176;    Qij_C[5][15] = 0;   Qij_C[5][16] = 37;  Qij_C[5][17] = 171;   Qij_C[5][18] = 61;   Qij_C[5][19] = 15;    Qij_C[5][20] = 0;  Qij_C[5][21] = 817;    Qij_C[5][22] = 0;   Qij_C[5][23] = 76;   Qij_C[5][24] = 71;  Qij_C[5][25] = 118;   Qij_C[5][26] = 33;   Qij_C[5][27] = 14;    Qij_C[5][28] = 0;  Qij_C[5][29] = 186;   Qij_C[5][30] = 44;    Qij_C[5][31] = 0;   Qij_C[5][32] = 36;  Qij_C[5][33] = 124;   Qij_C[5][34] = 35;    Qij_C[5][35] = 2;    Qij_C[5][36] = 0; Qij_C[5][37] = 2888;  Qij_C[5][38] = 193;    Qij_C[5][39] = 0;   Qij_C[5][40] = 12;  Qij_C[5][41] = 250;    Qij_C[5][42] = 0;   Qij_C[5][43] = 91;   Qij_C[5][44] = 20; Qij_C[5][45] = 1080;   Qij_C[5][46] = 66;   Qij_C[5][47] = 72;   Qij_C[5][48] = 33;    Qij_C[5][49] = 21;  Qij_C[5][50] = 113; Qij_C[5][51] = 2315;    Qij_C[5][52] = 0;  Qij_C[5][53] = 279;  Qij_C[5][54] = 153;    Qij_C[5][55] = 9;   Qij_C[5][56] = 10;    Qij_C[5][57] = 3;   Qij_C[5][58] = 74;   Qij_C[5][59] = 39;    Qij_C[5][60] = 7;
		Qij_C[6][0] = 0;   		Qij_C[6][1] = 67; 		Qij_C[6][2] = 795;  	Qij_C[6][3] = 182;		Qij_C[6][4] = 34110;	Qij_C[6][5] = 19942; Qij_C[6][6] = 0;		Qij_C[6][7] = 20814; Qij_C[6][8] = 0;  		Qij_C[6][9] = 618;  		Qij_C[6][10] = 927;  		Qij_C[6][11] = 387;   Qij_C[6][12] = 0;  		Qij_C[6][13] = 134; 		Qij_C[6][14] = 1616;  Qij_C[6][15] = 166;    Qij_C[6][16] = 0;   Qij_C[6][17] = 35;  Qij_C[6][18] = 307;    Qij_C[6][19] = 0;    Qij_C[6][20] = 0;  Qij_C[6][21] = 170; Qij_C[6][22] = 1953;    Qij_C[6][23] = 0;  Qij_C[6][24] = 322;  Qij_C[6][25] = 116;  Qij_C[6][26] = 172;    Qij_C[6][27] = 0;    Qij_C[6][28] = 0;   Qij_C[6][29] = 28;  Qij_C[6][30] = 181;   Qij_C[6][31] = 55;    Qij_C[6][32] = 0;   Qij_C[6][33] = 77;  Qij_C[6][34] = 199;    Qij_C[6][35] = 0;    Qij_C[6][36] = 0;   Qij_C[6][37] = 36; Qij_C[6][38] = 7718;    Qij_C[6][39] = 0;   Qij_C[6][40] = 51;   Qij_C[6][41] = 62;  Qij_C[6][42] = 405;    Qij_C[6][43] = 0;   Qij_C[6][44] = 36;    Qij_C[6][45] = 0;  Qij_C[6][46] = 995;  Qij_C[6][47] = 141;    Qij_C[6][48] = 9;    Qij_C[6][49] = 52;  Qij_C[6][50] = 232;  Qij_C[6][51] = 682; Qij_C[6][52] = 6944;    Qij_C[6][53] = 0;    Qij_C[6][54] = 0;   Qij_C[6][55] = 44;  Qij_C[6][56] = 134;   Qij_C[6][57] = 49;    Qij_C[6][58] = 5;  Qij_C[6][59] = 306;   Qij_C[6][60] = 51;
		Qij_C[7][0] = 114;  	Qij_C[7][1] = 122;		Qij_C[7][2] = 27; 		Qij_C[7][3] = 1425;		Qij_C[7][4] = 16829;	Qij_C[7][5] = 16316;	Qij_C[7][6] = 20814; Qij_C[7][7] = 0;   	Qij_C[7][8] = 11;  		Qij_C[7][9] = 421;   	Qij_C[7][10] = 40; 		Qij_C[7][11] = 2941;  Qij_C[7][12] = 0;    		Qij_C[7][13] = 0;  		Qij_C[7][14] = 262; Qij_C[7][15] = 1552;  Qij_C[7][16] = 166;    Qij_C[7][17] = 6;   Qij_C[7][18] = 30;  Qij_C[7][19] = 212;    Qij_C[7][20] = 0;   Qij_C[7][21] = 52;   Qij_C[7][22] = 15;  Qij_C[7][23] = 990;    Qij_C[7][24] = 0;   Qij_C[7][25] = 42;    Qij_C[7][26] = 0;  Qij_C[7][27] = 318;    Qij_C[7][28] = 0;    Qij_C[7][29] = 0;   Qij_C[7][30] = 25;  Qij_C[7][31] = 233;   Qij_C[7][32] = 38;   Qij_C[7][33] = 54;   Qij_C[7][34] = 52;  Qij_C[7][35] = 149;    Qij_C[7][36] = 0;    Qij_C[7][37] = 0;    Qij_C[7][38] = 0; Qij_C[7][39] = 3490;    Qij_C[7][40] = 3;   Qij_C[7][41] = 50;   Qij_C[7][42] = 77;  Qij_C[7][43] = 349;    Qij_C[7][44] = 0;  Qij_C[7][45] = 148;  Qij_C[7][46] = 155; Qij_C[7][47] = 1227;   Qij_C[7][48] = 17;    Qij_C[7][49] = 61;  Qij_C[7][50] = 489;  Qij_C[7][51] = 170;  Qij_C[7][52] = 362; Qij_C[7][53] = 2679;   Qij_C[7][54] = 41;    Qij_C[7][55] = 0;  Qij_C[7][56] = 194;   Qij_C[7][57] = 67;   Qij_C[7][58] = 23;   Qij_C[7][59] = 79;   Qij_C[7][60] = 82;
		Qij_C[8][0] = 4144;  	Qij_C[8][1] = 142;  	Qij_C[8][2] = 390;  	Qij_C[8][3] = 178;  	Qij_C[8][4] = 743;   	Qij_C[8][5] = 31;    Qij_C[8][6] = 0;   	Qij_C[8][7] = 11;    Qij_C[8][8] = 0;  		Qij_C[8][9] = 339;		Qij_C[8][10] = 25118; 	Qij_C[8][11] = 638;  	Qij_C[8][12] = 415;  		Qij_C[8][13] = 0;   		Qij_C[8][14] = 93;    Qij_C[8][15] = 0;  Qij_C[8][16] = 623;   Qij_C[8][17] = 55;   Qij_C[8][18] = 32;  Qij_C[8][19] = 118;    Qij_C[8][20] = 0;   Qij_C[8][21] = 17;   Qij_C[8][22] = 45;    Qij_C[8][23] = 5; Qij_C[8][24] = 22415; Qij_C[8][25] = 2803; Qij_C[8][26] = 6405; Qij_C[8][27] = 6203;    Qij_C[8][28] = 9;    Qij_C[8][29] = 0;   Qij_C[8][30] = 13;   Qij_C[8][31] = 32;  Qij_C[8][32] = 213;   Qij_C[8][33] = 22;    Qij_C[8][34] = 0;   Qij_C[8][35] = 27;  Qij_C[8][36] = 108;   Qij_C[8][37] = 24;   Qij_C[8][38] = 49;   Qij_C[8][39] = 47; Qij_C[8][40] = 1071;   Qij_C[8][41] = 25;    Qij_C[8][42] = 0;    Qij_C[8][43] = 0;  Qij_C[8][44] = 249;    Qij_C[8][45] = 5;    Qij_C[8][46] = 0;   Qij_C[8][47] = 31;   Qij_C[8][48] = 20;    Qij_C[8][49] = 0;   Qij_C[8][50] = 79;   Qij_C[8][51] = 26;   Qij_C[8][52] = 12;   Qij_C[8][53] = 54;    Qij_C[8][54] = 7;   Qij_C[8][55] = 23;   Qij_C[8][56] = 52;   Qij_C[8][57] = 87;    Qij_C[8][58] = 2;   Qij_C[8][59] = 13;   Qij_C[8][60] = 10;
		Qij_C[9][0] = 158; 		Qij_C[9][1] = 3430;  	Qij_C[9][2] = 131;  	Qij_C[9][3] = 178;  	Qij_C[9][4] = 343; 		Qij_C[9][5] = 2248;  Qij_C[9][6] = 618;  	Qij_C[9][7] = 421;  	Qij_C[9][8] = 339;   	Qij_C[9][9] = 0;  		Qij_C[9][10] = 444;		Qij_C[9][11] = 21641; Qij_C[9][12] = 27;  		Qij_C[9][13] = 228;   	Qij_C[9][14] = 67;    Qij_C[9][15] = 0;  Qij_C[9][16] = 133;  Qij_C[9][17] = 454;  Qij_C[9][18] = 123;   Qij_C[9][19] = 41;   Qij_C[9][20] = 25;  Qij_C[9][21] = 213;   Qij_C[9][22] = 88;   Qij_C[9][23] = 15;   Qij_C[9][24] = 72;  Qij_C[9][25] = 740;   Qij_C[9][26] = 22;    Qij_C[9][27] = 0;    Qij_C[9][28] = 0;   Qij_C[9][29] = 68;   Qij_C[9][30] = 21;   Qij_C[9][31] = 23;   Qij_C[9][32] = 82;  Qij_C[9][33] = 395;   Qij_C[9][34] = 86;   Qij_C[9][35] = 30;  Qij_C[9][36] = 106;  Qij_C[9][37] = 608;  Qij_C[9][38] = 258;  Qij_C[9][39] = 101;  Qij_C[9][40] = 134; Qij_C[9][41] = 2627;  Qij_C[9][42] = 328;    Qij_C[9][43] = 6;   Qij_C[9][44] = 87;  Qij_C[9][45] = 170;   Qij_C[9][46] = 10;   Qij_C[9][47] = 69;   Qij_C[9][48] = 79;    Qij_C[9][49] = 10;  Qij_C[9][50] = 214;  Qij_C[9][51] = 983;  Qij_C[9][52] = 697;  Qij_C[9][53] = 312;  Qij_C[9][54] = 792;   Qij_C[9][55] = 19;  Qij_C[9][56] = 169;   Qij_C[9][57] = 33;   Qij_C[9][58] = 34;    Qij_C[9][59] = 0;   Qij_C[9][60] = 10;
		Qij_C[10][0] = 572;  	Qij_C[10][1] = 139; 	Qij_C[10][2] = 3644; 	Qij_C[10][3] = 145;  	Qij_C[10][4] = 49;  	Qij_C[10][5] = 59;  	Qij_C[10][6] = 927;  Qij_C[10][7] = 40;	Qij_C[10][8] = 25118;  	Qij_C[10][9] = 444;  	Qij_C[10][10] = 0;  		Qij_C[10][11] = 544;  Qij_C[10][12] = 106;  	Qij_C[10][13] = 15;  		Qij_C[10][14] = 258;   Qij_C[10][15] = 29;   Qij_C[10][16] = 60;   Qij_C[10][17] = 95;  Qij_C[10][18] = 271;   Qij_C[10][19] = 62;   Qij_C[10][20] = 39;    Qij_C[10][21] = 0;    Qij_C[10][22] = 5;   Qij_C[10][23] = 17; Qij_C[10][24] = 6064; Qij_C[10][25] = 5913; Qij_C[10][26] = 18118; Qij_C[10][27] = 2885;    Qij_C[10][28] = 0;   Qij_C[10][29] = 20;   Qij_C[10][30] = 22;    Qij_C[10][31] = 0;    Qij_C[10][32] = 0;   Qij_C[10][33] = 11;  Qij_C[10][34] = 162;   Qij_C[10][35] = 19;   Qij_C[10][36] = 88;   Qij_C[10][37] = 51;  Qij_C[10][38] = 171;    Qij_C[10][39] = 0;    Qij_C[10][40] = 0;    Qij_C[10][41] = 0; Qij_C[10][42] = 1567;    Qij_C[10][43] = 0;    Qij_C[10][44] = 0;   Qij_C[10][45] = 38;  Qij_C[10][46] = 106;    Qij_C[10][47] = 0;    Qij_C[10][48] = 0;    Qij_C[10][49] = 31;    Qij_C[10][50] = 4;   Qij_C[10][51] = 12;   Qij_C[10][52] = 72;   Qij_C[10][53] = 33;   Qij_C[10][54] = 20;  Qij_C[10][55] = 264;   Qij_C[10][56] = 36;   Qij_C[10][57] = 51;    Qij_C[10][58] = 0;   Qij_C[10][59] = 36;   Qij_C[10][60] = 12;
		Qij_C[11][0] = 245;  	Qij_C[11][1] = 0; 		Qij_C[11][2] = 146; 	Qij_C[11][3] = 4830; 	Qij_C[11][4] = 402;  	Qij_C[11][5] = 0;  	Qij_C[11][6] = 387; 	Qij_C[11][7] = 2941; Qij_C[11][8] = 638;		Qij_C[11][9] = 21641;  	Qij_C[11][10] = 544;  	Qij_C[11][11] = 0;   	Qij_C[11][12] = 91;   	Qij_C[11][13] = 0;   		Qij_C[11][14] = 78;  Qij_C[11][15] = 345;  Qij_C[11][16] = 198;    Qij_C[11][17] = 0;   Qij_C[11][18] = 84;  Qij_C[11][19] = 605;   Qij_C[11][20] = 76;    Qij_C[11][21] = 0;   Qij_C[11][22] = 37;  Qij_C[11][23] = 178;    Qij_C[11][24] = 0;    Qij_C[11][25] = 0;   Qij_C[11][26] = 44; Qij_C[11][27] = 1145;   Qij_C[11][28] = 26;    Qij_C[11][29] = 0;    Qij_C[11][30] = 4;   Qij_C[11][31] = 71;  Qij_C[11][32] = 114;   Qij_C[11][33] = 38;  Qij_C[11][34] = 101;  Qij_C[11][35] = 488;  Qij_C[11][36] = 268;    Qij_C[11][37] = 0;  Qij_C[11][38] = 178;  Qij_C[11][39] = 628;  Qij_C[11][40] = 151;    Qij_C[11][41] = 0;  Qij_C[11][42] = 398; Qij_C[11][43] = 3432;   Qij_C[11][44] = 31;   Qij_C[11][45] = 16;   Qij_C[11][46] = 28;  Qij_C[11][47] = 233;    Qij_C[11][48] = 0;    Qij_C[11][49] = 157;  Qij_C[11][50] = 528;   Qij_C[11][51] = 51;  Qij_C[11][52] = 366;  Qij_C[11][53] = 938;  Qij_C[11][54] = 105;   Qij_C[11][55] = 27;  Qij_C[11][56] = 981;    Qij_C[11][57] = 0;    Qij_C[11][58] = 0;   Qij_C[11][59] = 47;   Qij_C[11][60] = 49;
		Qij_C[12][0] = 292;  	Qij_C[12][1] = 21;   	Qij_C[12][2] = 22;  	Qij_C[12][3] = 50; 		Qij_C[12][4] = 2434; 	Qij_C[12][5] = 0;    Qij_C[12][6] = 0;    Qij_C[12][7] = 0;  	Qij_C[12][8] = 415;   	Qij_C[12][9] = 27;  		Qij_C[12][10] = 106;  	Qij_C[12][11] = 91;   Qij_C[12][12] = 0;		Qij_C[12][13] = 13126;	Qij_C[12][14] = 2443; Qij_C[12][15] = 15113;   Qij_C[12][16] = 93;    Qij_C[12][17] = 4;   Qij_C[12][18] = 20;   Qij_C[12][19] = 51;   Qij_C[12][20] = 97;   Qij_C[12][21] = 13;   Qij_C[12][22] = 79;   Qij_C[12][23] = 49;    Qij_C[12][24] = 5;    Qij_C[12][25] = 3;    Qij_C[12][26] = 0;   Qij_C[12][27] = 43; Qij_C[12][28] = 3786;  Qij_C[12][29] = 176;  Qij_C[12][30] = 421;  Qij_C[12][31] = 134;   Qij_C[12][32] = 95;    Qij_C[12][33] = 0;   Qij_C[12][34] = 17;   Qij_C[12][35] = 19;  Qij_C[12][36] = 484;    Qij_C[12][37] = 0;  Qij_C[12][38] = 315;   Qij_C[12][39] = 42;   Qij_C[12][40] = 85;   Qij_C[12][41] = 18;   Qij_C[12][42] = 14;    Qij_C[12][43] = 0; Qij_C[12][44] = 11512;  Qij_C[12][45] = 158; Qij_C[12][46] = 1567;  Qij_C[12][47] = 389;    Qij_C[12][48] = 1;    Qij_C[12][49] = 29;  Qij_C[12][50] = 209;   Qij_C[12][51] = 54;   Qij_C[12][52] = 88;    Qij_C[12][53] = 0;   Qij_C[12][54] = 16;   Qij_C[12][55] = 14;   Qij_C[12][56] = 14; Qij_C[12][57] = 3243;   Qij_C[12][58] = 33;  Qij_C[12][59] = 833;  Qij_C[12][60] = 157;
		Qij_C[13][0] = 0;  		Qij_C[13][1] = 145; 	Qij_C[13][2] = 21;   	Qij_C[13][3] = 0;    	Qij_C[13][4] = 0; 		Qij_C[13][5] = 1028; Qij_C[13][6] = 134;  Qij_C[13][7] = 0;    Qij_C[13][8] = 0;  		Qij_C[13][9] = 228;  	Qij_C[13][10] = 15;   	Qij_C[13][11] = 0;	Qij_C[13][12] = 13126;	Qij_C[13][13] = 0;  		Qij_C[13][14] = 495; Qij_C[13][15] = 16920;   Qij_C[13][16] = 24;   Qij_C[13][17] = 36;    Qij_C[13][18] = 7;    Qij_C[13][19] = 0;    Qij_C[13][20] = 0;   Qij_C[13][21] = 55;   Qij_C[13][22] = 29;    Qij_C[13][23] = 0;    Qij_C[13][24] = 0;   Qij_C[13][25] = 20;   Qij_C[13][26] = 15;   Qij_C[13][27] = 17;    Qij_C[13][28] = 0; Qij_C[13][29] = 1745;  Qij_C[13][30] = 351;  Qij_C[13][31] = 133;    Qij_C[13][32] = 5;   Qij_C[13][33] = 20;    Qij_C[13][34] = 1;    Qij_C[13][35] = 0;    Qij_C[13][36] = 0;  Qij_C[13][37] = 217;   Qij_C[13][38] = 77;   Qij_C[13][39] = 32;    Qij_C[13][40] = 0;   Qij_C[13][41] = 42;   Qij_C[13][42] = 22;    Qij_C[13][43] = 0;    Qij_C[13][44] = 0; Qij_C[13][45] = 6084;  Qij_C[13][46] = 928;   Qij_C[13][47] = 53;   Qij_C[13][48] = 42;    Qij_C[13][49] = 7;    Qij_C[13][50] = 6;   Qij_C[13][51] = 35;   Qij_C[13][52] = 15;   Qij_C[13][53] = 15;   Qij_C[13][54] = 62;    Qij_C[13][55] = 7;   Qij_C[13][56] = 10;  Qij_C[13][57] = 111;  Qij_C[13][58] = 356;   Qij_C[13][59] = 27;   Qij_C[13][60] = 23;
		Qij_C[14][0] = 80;   	Qij_C[14][1] = 42;  	Qij_C[14][2] = 189;  	Qij_C[14][3] = 68;  	Qij_C[14][4] = 714;  	Qij_C[14][5] = 176; 	Qij_C[14][6] = 1616; Qij_C[14][7] = 262;  Qij_C[14][8] = 93;   	Qij_C[14][9] = 67;  		Qij_C[14][10] = 258;  	Qij_C[14][11] = 78; 	Qij_C[14][12] = 2443;  	Qij_C[14][13] = 495;    	Qij_C[14][14] = 0;  Qij_C[14][15] = 781;   Qij_C[14][16] = 96;   Qij_C[14][17] = 20;  Qij_C[14][18] = 116;   Qij_C[14][19] = 61;   Qij_C[14][20] = 55;   Qij_C[14][21] = 27;   Qij_C[14][22] = 92;   Qij_C[14][23] = 34;    Qij_C[14][24] = 0;   Qij_C[14][25] = 23;   Qij_C[14][26] = 50;   Qij_C[14][27] = 29;  Qij_C[14][28] = 726;  Qij_C[14][29] = 369; Qij_C[14][30] = 1104;  Qij_C[14][31] = 346;   Qij_C[14][32] = 22;    Qij_C[14][33] = 9;   Qij_C[14][34] = 63;    Qij_C[14][35] = 8;  Qij_C[14][36] = 282;  Qij_C[14][37] = 115;  Qij_C[14][38] = 392;  Qij_C[14][39] = 108;   Qij_C[14][40] = 31;   Qij_C[14][41] = 16;  Qij_C[14][42] = 116;   Qij_C[14][43] = 23;  Qij_C[14][44] = 626;  Qij_C[14][45] = 190; Qij_C[14][46] = 1219;  Qij_C[14][47] = 259;   Qij_C[14][48] = 21;    Qij_C[14][49] = 32;  Qij_C[14][50] = 153;   Qij_C[14][51] = 39;  Qij_C[14][52] = 229;   Qij_C[14][53] = 75;   Qij_C[14][54] = 22;   Qij_C[14][55] = 45;   Qij_C[14][56] = 29;  Qij_C[14][57] = 536;   Qij_C[14][58] = 89; Qij_C[14][59] = 1607;  Qij_C[14][60] = 126;
		Qij_C[15][0] = 16; 		Qij_C[15][1] = 0;   	Qij_C[15][2] = 20;  	Qij_C[15][3] = 202;  	Qij_C[15][4] = 0;    	Qij_C[15][5] = 0;  	Qij_C[15][6] = 166; 	Qij_C[15][7] = 1552; Qij_C[15][8] = 0;   	 	Qij_C[15][9] = 0;   		Qij_C[15][10] = 29;  		Qij_C[15][11] = 345;	Qij_C[15][12] = 15113;	Qij_C[15][13] = 16920;  	Qij_C[15][14] = 781;    Qij_C[15][15] = 0;    Qij_C[15][16] = 0;    Qij_C[15][17] = 4;   Qij_C[15][18] = 20;   Qij_C[15][19] = 84;   Qij_C[15][20] = 24;   Qij_C[15][21] = 10;    Qij_C[15][22] = 0;   Qij_C[15][23] = 68;   Qij_C[15][24] = 64;    Qij_C[15][25] = 0;    Qij_C[15][26] = 0;   Qij_C[15][27] = 27;  Qij_C[15][28] = 185;  Qij_C[15][29] = 131;  Qij_C[15][30] = 283; Qij_C[15][31] = 1848;    Qij_C[15][32] = 0;    Qij_C[15][33] = 0;   Qij_C[15][34] = 21;   Qij_C[15][35] = 36;   Qij_C[15][36] = 73;    Qij_C[15][37] = 0;    Qij_C[15][38] = 0;  Qij_C[15][39] = 233;   Qij_C[15][40] = 16;   Qij_C[15][41] = 10;    Qij_C[15][42] = 0;   Qij_C[15][43] = 46;  Qij_C[15][44] = 125;   Qij_C[15][45] = 79;  Qij_C[15][46] = 743; Qij_C[15][47] = 6623;    Qij_C[15][48] = 1;   Qij_C[15][49] = 64;    Qij_C[15][50] = 0;   Qij_C[15][51] = 30;   Qij_C[15][52] = 18;   Qij_C[15][53] = 72;    Qij_C[15][54] = 1;   Qij_C[15][55] = 10;   Qij_C[15][56] = 90;  Qij_C[15][57] = 201;   Qij_C[15][58] = 29;  Qij_C[15][59] = 399;  Qij_C[15][60] = 437;
		Qij_C[16][0] = 1364; 	Qij_C[16][1] = 148;  	Qij_C[16][2] = 33;  	Qij_C[16][3] = 311;  	Qij_C[16][4] = 341;  	Qij_C[16][5] = 37;   Qij_C[16][6] = 0;  	Qij_C[16][7] = 166;  Qij_C[16][8] = 623;  	Qij_C[16][9] = 133;   	Qij_C[16][10] = 60;  		Qij_C[16][11] = 198;  Qij_C[16][12] = 93;   	Qij_C[16][13] = 24;   	Qij_C[16][14] = 96;    Qij_C[16][15] = 0;    Qij_C[16][16] = 0; Qij_C[16][17] = 1176; Qij_C[16][18] = 15317; Qij_C[16][19] = 1995; Qij_C[16][20] = 1405;   Qij_C[16][21] = 99;  Qij_C[16][22] = 296;  Qij_C[16][23] = 126; Qij_C[16][24] = 3956;  Qij_C[16][25] = 217;    Qij_C[16][26] = 0;  Qij_C[16][27] = 646; Qij_C[16][28] = 1166;   Qij_C[16][29] = 38;   Qij_C[16][30] = 51;  Qij_C[16][31] = 168; Qij_C[16][32] = 1246;   Qij_C[16][33] = 76;   Qij_C[16][34] = 66;  Qij_C[16][35] = 132;  Qij_C[16][36] = 307;   Qij_C[16][37] = 22;  Qij_C[16][38] = 182;   Qij_C[16][39] = 60;  Qij_C[16][40] = 225;   Qij_C[16][41] = 15;   Qij_C[16][42] = 53;    Qij_C[16][43] = 0;  Qij_C[16][44] = 276;   Qij_C[16][45] = 29;   Qij_C[16][46] = 10;   Qij_C[16][47] = 82;   Qij_C[16][48] = 56;    Qij_C[16][49] = 122;    Qij_C[16][50] = 403;   Qij_C[16][51] = 90;    Qij_C[16][52] = 0;  Qij_C[16][53] = 143;   Qij_C[16][54] = 60;   Qij_C[16][55] = 38;   Qij_C[16][56] = 70;   Qij_C[16][57] = 93;   Qij_C[16][58] = 18;   Qij_C[16][59] = 63;   Qij_C[16][60] = 35;
		Qij_C[17][0] = 94;		Qij_C[17][1] = 1196; 	Qij_C[17][2] = 110; 	Qij_C[17][3] = 55;   	Qij_C[17][4] = 27;  	Qij_C[17][5] = 171;  Qij_C[17][6] = 35;   Qij_C[17][7] = 6;   	Qij_C[17][8] = 55;  		Qij_C[17][9] = 454;   	Qij_C[17][10] = 95;   	Qij_C[17][11] = 0;    Qij_C[17][12] = 4;   		Qij_C[17][13] = 36;   	Qij_C[17][14] = 20;    Qij_C[17][15] = 4; Qij_C[17][16] = 1176;    Qij_C[17][17] = 0; Qij_C[17][18] = 1057; Qij_C[17][19] = 30148;   Qij_C[17][20] = 97;  Qij_C[17][21] = 617;  Qij_C[17][22] = 246;    Qij_C[17][23] = 0;  Qij_C[17][24] = 261; Qij_C[17][25] = 2689;  Qij_C[17][26] = 317;    Qij_C[17][27] = 0;   Qij_C[17][28] = 96;  Qij_C[17][29] = 390;   Qij_C[17][30] = 40;    Qij_C[17][31] = 0;   Qij_C[17][32] = 28;  Qij_C[17][33] = 311;   Qij_C[17][34] = 71;    Qij_C[17][35] = 0;   Qij_C[17][36] = 20;  Qij_C[17][37] = 119;   Qij_C[17][38] = 45;    Qij_C[17][39] = 5;   Qij_C[17][40] = 16;  Qij_C[17][41] = 165;   Qij_C[17][42] = 31;    Qij_C[17][43] = 0;   Qij_C[17][44] = 36;   Qij_C[17][45] = 75;   Qij_C[17][46] = 18;    Qij_C[17][47] = 1; Qij_C[17][48] = 1624;  Qij_C[17][49] = 137;   Qij_C[17][50] = 53;  Qij_C[17][51] = 211;  Qij_C[17][52] = 112;   Qij_C[17][53] = 43;  Qij_C[17][54] = 276;   Qij_C[17][55] = 20;   Qij_C[17][56] = 21;    Qij_C[17][57] = 5;  Qij_C[17][58] = 166;   Qij_C[17][59] = 20;   Qij_C[17][60] = 36;
		Qij_C[18][0] = 137;  	Qij_C[18][1] = 142;  	Qij_C[18][2] = 727;  	Qij_C[18][3] = 168;  	Qij_C[18][4] = 96;   	Qij_C[18][5] = 61;  	Qij_C[18][6] = 307;  Qij_C[18][7] = 30;   Qij_C[18][8] = 32;  		Qij_C[18][9] = 123;  	Qij_C[18][10] = 271;  	Qij_C[18][11] = 84;   Qij_C[18][12] = 20;    	Qij_C[18][13] = 7;  		Qij_C[18][14] = 116;   Qij_C[18][15] = 20; Qij_C[18][16] = 15317; Qij_C[18][17] = 1057;    Qij_C[18][18] = 0; Qij_C[18][19] = 1086;  Qij_C[18][20] = 235;  Qij_C[18][21] = 161; Qij_C[18][22] = 1234;   Qij_C[18][23] = 88;    Qij_C[18][24] = 0;  Qij_C[18][25] = 355; Qij_C[18][26] = 2408;  Qij_C[18][27] = 232;   Qij_C[18][28] = 46;   Qij_C[18][29] = 92;  Qij_C[18][30] = 290;   Qij_C[18][31] = 77;  Qij_C[18][32] = 112;   Qij_C[18][33] = 72;  Qij_C[18][34] = 739;   Qij_C[18][35] = 54;   Qij_C[18][36] = 61;   Qij_C[18][37] = 88;  Qij_C[18][38] = 246;   Qij_C[18][39] = 52;    Qij_C[18][40] = 8;   Qij_C[18][41] = 40;  Qij_C[18][42] = 148;   Qij_C[18][43] = 43;   Qij_C[18][44] = 31;   Qij_C[18][45] = 25;   Qij_C[18][46] = 62;   Qij_C[18][47] = 28;   Qij_C[18][48] = 58;     Qij_C[18][49] = 42;  Qij_C[18][50] = 109;   Qij_C[18][51] = 80;  Qij_C[18][52] = 288;   Qij_C[18][53] = 55;   Qij_C[18][54] = 35;   Qij_C[18][55] = 97;   Qij_C[18][56] = 43;   Qij_C[18][57] = 50;   Qij_C[18][58] = 13;   Qij_C[18][59] = 95;   Qij_C[18][60] = 11;
		Qij_C[19][0] = 169;  	Qij_C[19][1] = 9;   	Qij_C[19][2] = 84; 		Qij_C[19][3] = 1623; 	Qij_C[19][4] = 93;   	Qij_C[19][5] = 15;   Qij_C[19][6] = 0;  	Qij_C[19][7] = 212;  Qij_C[19][8] = 118;   	Qij_C[19][9] = 41;   	Qij_C[19][10] = 62;  		Qij_C[19][11] = 605;  Qij_C[19][12] = 51;    	Qij_C[19][13] = 0;   		Qij_C[19][14] = 61;   Qij_C[19][15] = 84; Qij_C[19][16] = 1995; Qij_C[19][17] = 30148; Qij_C[19][18] = 1086;    Qij_C[19][19] = 0;   Qij_C[19][20] = 56;   Qij_C[19][21] = 38;  Qij_C[19][22] = 173;  Qij_C[19][23] = 756;  Qij_C[19][24] = 133;    Qij_C[19][25] = 0;  Qij_C[19][26] = 191; Qij_C[19][27] = 4390;    Qij_C[19][28] = 0;   Qij_C[19][29] = 55;   Qij_C[19][30] = 43;  Qij_C[19][31] = 676;  Qij_C[19][32] = 123;   Qij_C[19][33] = 22;   Qij_C[19][34] = 69;  Qij_C[19][35] = 378;   Qij_C[19][36] = 70;    Qij_C[19][37] = 0;  Qij_C[19][38] = 109;  Qij_C[19][39] = 111;   Qij_C[19][40] = 26;   Qij_C[19][41] = 12;   Qij_C[19][42] = 29;  Qij_C[19][43] = 266;   Qij_C[19][44] = 23;   Qij_C[19][45] = 15;   Qij_C[19][46] = 23;   Qij_C[19][47] = 68;    Qij_C[19][48] = 0; Qij_C[19][49] = 2184;   Qij_C[19][50] = 76;   Qij_C[19][51] = 22;    Qij_C[19][52] = 0;  Qij_C[19][53] = 315;    Qij_C[19][54] = 6;   Qij_C[19][55] = 63;  Qij_C[19][56] = 475;   Qij_C[19][57] = 80;   Qij_C[19][58] = 22;   Qij_C[19][59] = 27;  Qij_C[19][60] = 172;
		Qij_C[20][0] = 91;   	Qij_C[20][1] = 17;   	Qij_C[20][2] = 28;   	Qij_C[20][3] = 55; 		Qij_C[20][4] = 1015; 	Qij_C[20][5] = 0;    Qij_C[20][6] = 0;    Qij_C[20][7] = 0;    Qij_C[20][8] = 0;   		Qij_C[20][9] = 25;   	Qij_C[20][10] = 39;   	Qij_C[20][11] = 76;   Qij_C[20][12] = 97;    	Qij_C[20][13] = 0;   		Qij_C[20][14] = 55;   Qij_C[20][15] = 24; Qij_C[20][16] = 1405;   Qij_C[20][17] = 97;  Qij_C[20][18] = 235;   Qij_C[20][19] = 56;    Qij_C[20][20] = 0; Qij_C[20][21] = 10490; Qij_C[20][22] = 27394; Qij_C[20][23] = 15604;  Qij_C[20][24] = 393;    Qij_C[20][25] = 8;   Qij_C[20][26] = 57;    Qij_C[20][27] = 0; Qij_C[20][28] = 1474;    Qij_C[20][29] = 0;  Qij_C[20][30] = 137;    Qij_C[20][31] = 0;   Qij_C[20][32] = 71;    Qij_C[20][33] = 6;   Qij_C[20][34] = 51;   Qij_C[20][35] = 28; Qij_C[20][36] = 1186;    Qij_C[20][37] = 7;    Qij_C[20][38] = 0;   Qij_C[20][39] = 28;   Qij_C[20][40] = 78;   Qij_C[20][41] = 31;   Qij_C[20][42] = 36;   Qij_C[20][43] = 29;  Qij_C[20][44] = 394;   Qij_C[20][45] = 36;   Qij_C[20][46] = 58;    Qij_C[20][47] = 0;    Qij_C[20][48] = 0;    Qij_C[20][49] = 7; Qij_C[20][50] = 2829;    Qij_C[20][51] = 0;  Qij_C[20][52] = 131;    Qij_C[20][53] = 0;    Qij_C[20][54] = 0;   Qij_C[20][55] = 14;   Qij_C[20][56] = 11;   Qij_C[20][57] = 99;   Qij_C[20][58] = 12;   Qij_C[20][59] = 87;    Qij_C[20][60] = 0;
		Qij_C[21][0] = 18;   	Qij_C[21][1] = 98;   	Qij_C[21][2] = 14;   	Qij_C[21][3] = 34;   	Qij_C[21][4] = 0;  		Qij_C[21][5] = 817;  Qij_C[21][6] = 170;  Qij_C[21][7] = 52;   Qij_C[21][8] = 17;  		Qij_C[21][9] = 213;    	Qij_C[21][10] = 0;    	Qij_C[21][11] = 0;   	Qij_C[21][12] = 13;   	Qij_C[21][13] = 55;   	Qij_C[21][14] = 27;   Qij_C[21][15] = 10;   Qij_C[21][16] = 99;  Qij_C[21][17] = 617;  Qij_C[21][18] = 161;   Qij_C[21][19] = 38; Qij_C[21][20] = 10490;    Qij_C[21][21] = 0; Qij_C[21][22] = 21512; Qij_C[21][23] = 16327;   Qij_C[21][24] = 23;  Qij_C[21][25] = 404;    Qij_C[21][26] = 0;    Qij_C[21][27] = 0;    Qij_C[21][28] = 0;  Qij_C[21][29] = 706;    Qij_C[21][30] = 0;    Qij_C[21][31] = 0;   Qij_C[21][32] = 17;   Qij_C[21][33] = 72;   Qij_C[21][34] = 40;    Qij_C[21][35] = 7;   Qij_C[21][36] = 19;  Qij_C[21][37] = 965;  Qij_C[21][38] = 206;   Qij_C[21][39] = 63;   Qij_C[21][40] = 11;  Qij_C[21][41] = 114;   Qij_C[21][42] = 55;   Qij_C[21][43] = 16;   Qij_C[21][44] = 63;  Qij_C[21][45] = 199;   Qij_C[21][46] = 21;    Qij_C[21][47] = 0;   Qij_C[21][48] = 47;    Qij_C[21][49] = 0;    Qij_C[21][50] = 0; Qij_C[21][51] = 2535;    Qij_C[21][52] = 0;   Qij_C[21][53] = 65;   Qij_C[21][54] = 49;    Qij_C[21][55] = 0;    Qij_C[21][56] = 0;   Qij_C[21][57] = 18;   Qij_C[21][58] = 82;    Qij_C[21][59] = 3;    Qij_C[21][60] = 0;
		Qij_C[22][0] = 39;   	Qij_C[22][1] = 47;  	Qij_C[22][2] = 105;  	Qij_C[22][3] = 46;   	Qij_C[22][4] = 88;   	Qij_C[22][5] = 0; 	Qij_C[22][6] = 1953; Qij_C[22][7] = 15;   Qij_C[22][8] = 45;   	Qij_C[22][9] = 88;    	Qij_C[22][10] = 5;   		Qij_C[22][11] = 37;   Qij_C[22][12] = 79;   	Qij_C[22][13] = 29;   	Qij_C[22][14] = 92;    Qij_C[22][15] = 0;  Qij_C[22][16] = 296;  Qij_C[22][17] = 246; Qij_C[22][18] = 1234;  Qij_C[22][19] = 173; Qij_C[22][20] = 27394; Qij_C[22][21] = 21512;    Qij_C[22][22] = 0; Qij_C[22][23] = 15588;    Qij_C[22][24] = 0;  Qij_C[22][25] = 121; Qij_C[22][26] = 1276;    Qij_C[22][27] = 0;    Qij_C[22][28] = 0;    Qij_C[22][29] = 0;  Qij_C[22][30] = 935;    Qij_C[22][31] = 0;   Qij_C[22][32] = 35;   Qij_C[22][33] = 40;   Qij_C[22][34] = 81;   Qij_C[22][35] = 37;  Qij_C[22][36] = 101;  Qij_C[22][37] = 145; Qij_C[22][38] = 4882;    Qij_C[22][39] = 0;   Qij_C[22][40] = 26;  Qij_C[22][41] = 129;  Qij_C[22][42] = 251;    Qij_C[22][43] = 0;    Qij_C[22][44] = 0;   Qij_C[22][45] = 69;  Qij_C[22][46] = 154;   Qij_C[22][47] = 65;   Qij_C[22][48] = 22;    Qij_C[22][49] = 4;  Qij_C[22][50] = 244;    Qij_C[22][51] = 0; Qij_C[22][52] = 5851;    Qij_C[22][53] = 0;   Qij_C[22][54] = 31;   Qij_C[22][55] = 68;   Qij_C[22][56] = 44;   Qij_C[22][57] = 11;    Qij_C[22][58] = 3;  Qij_C[22][59] = 109;   Qij_C[22][60] = 26;
		Qij_C[23][0] = 26;   	Qij_C[23][1] = 14;   	Qij_C[23][2] = 14;  	Qij_C[23][3] = 115;  	Qij_C[23][4] = 64;   	Qij_C[23][5] = 76;   Qij_C[23][6] = 0;  	Qij_C[23][7] = 990;  Qij_C[23][8] = 5;   		Qij_C[23][9] = 15;   	Qij_C[23][10] = 17;  		Qij_C[23][11] = 178;  Qij_C[23][12] = 49;    	Qij_C[23][13] = 0;   		Qij_C[23][14] = 34;   Qij_C[23][15] = 68;  Qij_C[23][16] = 126;    Qij_C[23][17] = 0;   Qij_C[23][18] = 88;  Qij_C[23][19] = 756; Qij_C[23][20] = 15604; Qij_C[23][21] = 16327; Qij_C[23][22] = 15588;    Qij_C[23][23] = 0;    Qij_C[23][24] = 0;    Qij_C[23][25] = 0;    Qij_C[23][26] = 0;  Qij_C[23][27] = 712;    Qij_C[23][28] = 0;   Qij_C[23][29] = 34;    Qij_C[23][30] = 0;  Qij_C[23][31] = 937;   Qij_C[23][32] = 29;    Qij_C[23][33] = 8;   Qij_C[23][34] = 19;   Qij_C[23][35] = 44;   Qij_C[23][36] = 91;   Qij_C[23][37] = 79;    Qij_C[23][38] = 0; Qij_C[23][39] = 1111;   Qij_C[23][40] = 16;   Qij_C[23][41] = 14;    Qij_C[23][42] = 9;  Qij_C[23][43] = 161;    Qij_C[23][44] = 0;    Qij_C[23][45] = 0;   Qij_C[23][46] = 27;  Qij_C[23][47] = 258;    Qij_C[23][48] = 3;   Qij_C[23][49] = 43;    Qij_C[23][50] = 0;    Qij_C[23][51] = 0;    Qij_C[23][52] = 0; Qij_C[23][53] = 2744;   Qij_C[23][54] = 12;    Qij_C[23][55] = 0;  Qij_C[23][56] = 101;    Qij_C[23][57] = 7;    Qij_C[23][58] = 0;   Qij_C[23][59] = 72;   Qij_C[23][60] = 97;
		Qij_C[24][0] = 908;  	Qij_C[24][1] = 0;  		Qij_C[24][2] = 299;  	Qij_C[24][3] = 45;   	Qij_C[24][4] = 0;   	Qij_C[24][5] = 71;  	Qij_C[24][6] = 322;  Qij_C[24][7] = 0;	Qij_C[24][8] = 22415;   	Qij_C[24][9] = 72; 		Qij_C[24][10] = 6064; 	Qij_C[24][11] = 0;    Qij_C[24][12] = 5;    	Qij_C[24][13] = 0;    	Qij_C[24][14] = 0;   Qij_C[24][15] = 64; Qij_C[24][16] = 3956;  Qij_C[24][17] = 261;    Qij_C[24][18] = 0;  Qij_C[24][19] = 133;  Qij_C[24][20] = 393;   Qij_C[24][21] = 23;    Qij_C[24][22] = 0;    Qij_C[24][23] = 0;    Qij_C[24][24] = 0; Qij_C[24][25] = 19396; Qij_C[24][26] = 39593; Qij_C[24][27] = 40836;  Qij_C[24][28] = 966;   Qij_C[24][29] = 45;    Qij_C[24][30] = 0;    Qij_C[24][31] = 0;   Qij_C[24][32] = 24;    Qij_C[24][33] = 0;    Qij_C[24][34] = 0;    Qij_C[24][35] = 0;   Qij_C[24][36] = 72;   Qij_C[24][37] = 26;    Qij_C[24][38] = 0;    Qij_C[24][39] = 0;  Qij_C[24][40] = 176;    Qij_C[24][41] = 0;    Qij_C[24][42] = 0;  Qij_C[24][43] = 117;   Qij_C[24][44] = 86;    Qij_C[24][45] = 0;    Qij_C[24][46] = 0;    Qij_C[24][47] = 0;    Qij_C[24][48] = 0;   Qij_C[24][49] = 68;  Qij_C[24][50] = 163;    Qij_C[24][51] = 0;   Qij_C[24][52] = 53;    Qij_C[24][53] = 0;   Qij_C[24][54] = 53;  Qij_C[24][55] = 130;   Qij_C[24][56] = 51;    Qij_C[24][57] = 0;    Qij_C[24][58] = 0;   Qij_C[24][59] = 25;    Qij_C[24][60] = 8;
		Qij_C[25][0] = 337;  	Qij_C[25][1] = 264;  	Qij_C[25][2] = 569;  	Qij_C[25][3] = 0;    	Qij_C[25][4] = 0;  		Qij_C[25][5] = 118;  Qij_C[25][6] = 116;  Qij_C[25][7] = 42; 	Qij_C[25][8] = 2803;  	Qij_C[25][9] = 740; 		Qij_C[25][10] = 5913;    	Qij_C[25][11] = 0;    Qij_C[25][12] = 3;   		Qij_C[25][13] = 20;   	Qij_C[25][14] = 23;    Qij_C[25][15] = 0;  Qij_C[25][16] = 217; Qij_C[25][17] = 2689;  Qij_C[25][18] = 355;    Qij_C[25][19] = 0;    Qij_C[25][20] = 8;  Qij_C[25][21] = 404;  Qij_C[25][22] = 121;    Qij_C[25][23] = 0; Qij_C[25][24] = 19396;    Qij_C[25][25] = 0; Qij_C[25][26] = 19595; Qij_C[25][27] = 42123;    Qij_C[25][28] = 0;  Qij_C[25][29] = 486;   Qij_C[25][30] = 34;    Qij_C[25][31] = 1;    Qij_C[25][32] = 0;   Qij_C[25][33] = 57;   Qij_C[25][34] = 44;    Qij_C[25][35] = 8;    Qij_C[25][36] = 0;  Qij_C[25][37] = 133;   Qij_C[25][38] = 94;    Qij_C[25][39] = 0;    Qij_C[25][40] = 0;  Qij_C[25][41] = 452;    Qij_C[25][42] = 0;    Qij_C[25][43] = 0;    Qij_C[25][44] = 0;   Qij_C[25][45] = 52;   Qij_C[25][46] = 20;   Qij_C[25][47] = 15;  Qij_C[25][48] = 139;    Qij_C[25][49] = 4;    Qij_C[25][50] = 0;  Qij_C[25][51] = 177;  Qij_C[25][52] = 105;    Qij_C[25][53] = 0;  Qij_C[25][54] = 908;   Qij_C[25][55] = 40;    Qij_C[25][56] = 0;   Qij_C[25][57] = 40;   Qij_C[25][58] = 56;    Qij_C[25][59] = 0;    Qij_C[25][60] = 0;
		Qij_C[26][0] = 410;  	Qij_C[26][1] = 58; 		Qij_C[26][2] = 1249; 	Qij_C[26][3] = 27;   	Qij_C[26][4] = 26;   	Qij_C[26][5] = 33;  	Qij_C[26][6] = 172;  Qij_C[26][7] = 0; 	Qij_C[26][8] = 6405;   	Qij_C[26][9] = 22;		Qij_C[26][10] = 18118;	Qij_C[26][11] = 44;   Qij_C[26][12] = 0;   		Qij_C[26][13] = 15;   	Qij_C[26][14] = 50;    Qij_C[26][15] = 0;    Qij_C[26][16] = 0;  Qij_C[26][17] = 317; Qij_C[26][18] = 2408;  Qij_C[26][19] = 191;   Qij_C[26][20] = 57;    Qij_C[26][21] = 0; Qij_C[26][22] = 1276;    Qij_C[26][23] = 0; Qij_C[26][24] = 39593; Qij_C[26][25] = 19595;    Qij_C[26][26] = 0; Qij_C[26][27] = 25507;    Qij_C[26][28] = 7;    Qij_C[26][29] = 0;  Qij_C[26][30] = 340;   Qij_C[26][31] = 21;    Qij_C[26][32] = 0;   Qij_C[26][33] = 11;  Qij_C[26][34] = 104;   Qij_C[26][35] = 13;   Qij_C[26][36] = 23;    Qij_C[26][37] = 0;  Qij_C[26][38] = 379;   Qij_C[26][39] = 62;    Qij_C[26][40] = 0;   Qij_C[26][41] = 78;  Qij_C[26][42] = 515;    Qij_C[26][43] = 0;    Qij_C[26][44] = 0;   Qij_C[26][45] = 36;   Qij_C[26][46] = 58;    Qij_C[26][47] = 3;   Qij_C[26][48] = 17;    Qij_C[26][49] = 0;   Qij_C[26][50] = 31;   Qij_C[26][51] = 50;  Qij_C[26][52] = 385;    Qij_C[26][53] = 0;  Qij_C[26][54] = 109;  Qij_C[26][55] = 576;   Qij_C[26][56] = 50;    Qij_C[26][57] = 2;    Qij_C[26][58] = 8;   Qij_C[26][59] = 45;   Qij_C[26][60] = 10;
		Qij_C[27][0] = 334;  	Qij_C[27][1] = 0;  		Qij_C[27][2] = 353;  	Qij_C[27][3] = 429;  	Qij_C[27][4] = 39;   	Qij_C[27][5] = 14;   Qij_C[27][6] = 0;  	Qij_C[27][7] = 318; 	Qij_C[27][8] = 6203;    	Qij_C[27][9] = 0; 		Qij_C[27][10] = 2885; 	Qij_C[27][11] = 1145;	Qij_C[27][12] = 43;   	Qij_C[27][13] = 17;   	Qij_C[27][14] = 29;   Qij_C[27][15] = 27;  Qij_C[27][16] = 646;    Qij_C[27][17] = 0;  Qij_C[27][18] = 232; Qij_C[27][19] = 4390;    Qij_C[27][20] = 0;    Qij_C[27][21] = 0;    Qij_C[27][22] = 0;  Qij_C[27][23] = 712; Qij_C[27][24] = 40836; Qij_C[27][25] = 42123; Qij_C[27][26] = 25507;    Qij_C[27][27] = 0;    Qij_C[27][28] = 0;    Qij_C[27][29] = 0;    Qij_C[27][30] = 0;  Qij_C[27][31] = 685;   Qij_C[27][32] = 69;    Qij_C[27][33] = 1;    Qij_C[27][34] = 0;   Qij_C[27][35] = 66;   Qij_C[27][36] = 38;   Qij_C[27][37] = 29;    Qij_C[27][38] = 0;  Qij_C[27][39] = 121;    Qij_C[27][40] = 0;    Qij_C[27][41] = 1;    Qij_C[27][42] = 0;  Qij_C[27][43] = 688;    Qij_C[27][44] = 0;   Qij_C[27][45] = 18;   Qij_C[27][46] = 12;   Qij_C[27][47] = 96;    Qij_C[27][48] = 0;  Qij_C[27][49] = 362;    Qij_C[27][50] = 1;   Qij_C[27][51] = 11;    Qij_C[27][52] = 0;  Qij_C[27][53] = 326;    Qij_C[27][54] = 0;   Qij_C[27][55] = 14; Qij_C[27][56] = 1302;   Qij_C[27][57] = 49;    Qij_C[27][58] = 7;   Qij_C[27][59] = 98;   Qij_C[27][60] = 70;
		Qij_C[28][0] = 100;  	Qij_C[28][1] = 19;   	Qij_C[28][2] = 0;  		Qij_C[28][3] = 22;  	Qij_C[28][4] = 288;  	Qij_C[28][5] = 0;    Qij_C[28][6] = 0;    Qij_C[28][7] = 0;    Qij_C[28][8] = 9;    	Qij_C[28][9] = 0;    	Qij_C[28][10] = 0;   		Qij_C[28][11] = 26; 	Qij_C[28][12] = 3786;    	Qij_C[28][13] = 0;  		Qij_C[28][14] = 726;  Qij_C[28][15] = 185; Qij_C[28][16] = 1166;   Qij_C[28][17] = 96;   Qij_C[28][18] = 46;    Qij_C[28][19] = 0; Qij_C[28][20] = 1474;    Qij_C[28][21] = 0;    Qij_C[28][22] = 0;    Qij_C[28][23] = 0;  Qij_C[28][24] = 966;    Qij_C[28][25] = 0;    Qij_C[28][26] = 7;    Qij_C[28][27] = 0;    Qij_C[28][28] = 0; Qij_C[28][29] = 8429; Qij_C[28][30] = 16270; Qij_C[28][31] = 10903;   Qij_C[28][32] = 52;    Qij_C[28][33] = 0;    Qij_C[28][34] = 0;    Qij_C[28][35] = 5;  Qij_C[28][36] = 300;    Qij_C[28][37] = 0;    Qij_C[28][38] = 0;   Qij_C[28][39] = 14;   Qij_C[28][40] = 70;    Qij_C[28][41] = 0;    Qij_C[28][42] = 0;    Qij_C[28][43] = 9; Qij_C[28][44] = 2164;  Qij_C[28][45] = 120;   Qij_C[28][46] = 16;    Qij_C[28][47] = 0;    Qij_C[28][48] = 0;   Qij_C[28][49] = 68;  Qij_C[28][50] = 154;    Qij_C[28][51] = 0;  Qij_C[28][52] = 340;    Qij_C[28][53] = 0;    Qij_C[28][54] = 0;   Qij_C[28][55] = 36;   Qij_C[28][56] = 59; Qij_C[28][57] = 26307;  Qij_C[28][58] = 106; Qij_C[28][59] = 6745;  Qij_C[28][60] = 112;
		Qij_C[29][0] = 17;   	Qij_C[29][1] = 64;   	Qij_C[29][2] = 3;    	Qij_C[29][3] = 0;    	Qij_C[29][4] = 0;  		Qij_C[29][5] = 186;  Qij_C[29][6] = 28;   Qij_C[29][7] = 0;    Qij_C[29][8] = 0;   		Qij_C[29][9] = 68;   	Qij_C[29][10] = 20;    	Qij_C[29][11] = 0;  	Qij_C[29][12] = 176; 		Qij_C[29][13] = 1745;  	Qij_C[29][14] = 369;  Qij_C[29][15] = 131;   Qij_C[29][16] = 38;  Qij_C[29][17] = 390;   Qij_C[29][18] = 92;   Qij_C[29][19] = 55;    Qij_C[29][20] = 0;  Qij_C[29][21] = 706;    Qij_C[29][22] = 0;   Qij_C[29][23] = 34;   Qij_C[29][24] = 45;  Qij_C[29][25] = 486;    Qij_C[29][26] = 0;    Qij_C[29][27] = 0; Qij_C[29][28] = 8429;    Qij_C[29][29] = 0; Qij_C[29][30] = 7138; Qij_C[29][31] = 15530;    Qij_C[29][32] = 6;   Qij_C[29][33] = 20;   Qij_C[29][34] = 12;    Qij_C[29][35] = 0;    Qij_C[29][36] = 0;  Qij_C[29][37] = 160;   Qij_C[29][38] = 40;    Qij_C[29][39] = 8;   Qij_C[29][40] = 12;   Qij_C[29][41] = 38;    Qij_C[29][42] = 1;    Qij_C[29][43] = 0;    Qij_C[29][44] = 5; Qij_C[29][45] = 1603;   Qij_C[29][46] = 24;   Qij_C[29][47] = 28;  Qij_C[29][48] = 128;    Qij_C[29][49] = 1;    Qij_C[29][50] = 0;  Qij_C[29][51] = 214;    Qij_C[29][52] = 0;    Qij_C[29][53] = 0;  Qij_C[29][54] = 152;    Qij_C[29][55] = 9;    Qij_C[29][56] = 9; Qij_C[29][57] = 3595; Qij_C[29][58] = 1293; Qij_C[29][59] = 2691;    Qij_C[29][60] = 0;
		Qij_C[30][0] = 0;    	Qij_C[30][1] = 7;   	Qij_C[30][2] = 36;   	Qij_C[30][3] = 0;   	Qij_C[30][4] = 46;   	Qij_C[30][5] = 44;  	Qij_C[30][6] = 181;  Qij_C[30][7] = 25;   Qij_C[30][8] = 13;   	Qij_C[30][9] = 21;   	Qij_C[30][10] = 22;    	Qij_C[30][11] = 4;  	Qij_C[30][12] = 421;  	Qij_C[30][13] = 351; 		Qij_C[30][14] = 1104;  Qij_C[30][15] = 283;   Qij_C[30][16] = 51;   Qij_C[30][17] = 40;  Qij_C[30][18] = 290;   Qij_C[30][19] = 43;  Qij_C[30][20] = 137;    Qij_C[30][21] = 0;  Qij_C[30][22] = 935;    Qij_C[30][23] = 0;    Qij_C[30][24] = 0;   Qij_C[30][25] = 34;  Qij_C[30][26] = 340;    Qij_C[30][27] = 0; Qij_C[30][28] = 16270; Qij_C[30][29] = 7138;    Qij_C[30][30] = 0; Qij_C[30][31] = 7205;    Qij_C[30][32] = 0;    Qij_C[30][33] = 3;   Qij_C[30][34] = 27;    Qij_C[30][35] = 0;   Qij_C[30][36] = 46;   Qij_C[30][37] = 31;  Qij_C[30][38] = 261;   Qij_C[30][39] = 31;    Qij_C[30][40] = 0;    Qij_C[30][41] = 6;   Qij_C[30][42] = 39;    Qij_C[30][43] = 9;    Qij_C[30][44] = 7;   Qij_C[30][45] = 42;  Qij_C[30][46] = 827;   Qij_C[30][47] = 11;   Qij_C[30][48] = 14;   Qij_C[30][49] = 39;    Qij_C[30][50] = 0;   Qij_C[30][51] = 34;    Qij_C[30][52] = 0;   Qij_C[30][53] = 20;    Qij_C[30][54] = 9;   Qij_C[30][55] = 51;   Qij_C[30][56] = 17; Qij_C[30][57] = 4180;  Qij_C[30][58] = 136; Qij_C[30][59] = 13314;  Qij_C[30][60] = 186;
		Qij_C[31][0] = 30;   	Qij_C[31][1] = 0;    	Qij_C[31][2] = 7;  		Qij_C[31][3] = 110;  	Qij_C[31][4] = 4;    	Qij_C[31][5] = 0;   	Qij_C[31][6] = 55;  	Qij_C[31][7] = 233;  Qij_C[31][8] = 32;   	Qij_C[31][9] = 23;    	Qij_C[31][10] = 0;   		Qij_C[31][11] = 71;  	Qij_C[31][12] = 134;  	Qij_C[31][13] = 133;  	Qij_C[31][14] = 346; Qij_C[31][15] = 1848;  Qij_C[31][16] = 168;    Qij_C[31][17] = 0;   Qij_C[31][18] = 77;  Qij_C[31][19] = 676;    Qij_C[31][20] = 0;    Qij_C[31][21] = 0;    Qij_C[31][22] = 0;  Qij_C[31][23] = 937;    Qij_C[31][24] = 0;    Qij_C[31][25] = 1;   Qij_C[31][26] = 21;  Qij_C[31][27] = 685; Qij_C[31][28] = 10903; Qij_C[31][29] = 15530; Qij_C[31][30] = 7205;    Qij_C[31][31] = 0;   Qij_C[31][32] = 13;   Qij_C[31][33] = 10;    Qij_C[31][34] = 7;   Qij_C[31][35] = 21;   Qij_C[31][36] = 29;   Qij_C[31][37] = 30;   Qij_C[31][38] = 16;  Qij_C[31][39] = 183;   Qij_C[31][40] = 13;   Qij_C[31][41] = 14;    Qij_C[31][42] = 0;   Qij_C[31][43] = 50;  Qij_C[31][44] = 131;   Qij_C[31][45] = 18;    Qij_C[31][46] = 0; Qij_C[31][47] = 1661;   Qij_C[31][48] = 18;  Qij_C[31][49] = 138;    Qij_C[31][50] = 0;    Qij_C[31][51] = 0;    Qij_C[31][52] = 0;  Qij_C[31][53] = 278;   Qij_C[31][54] = 21;    Qij_C[31][55] = 9;  Qij_C[31][56] = 147; Qij_C[31][57] = 4065;    Qij_C[31][58] = 0; Qij_C[31][59] = 4641; Qij_C[31][60] = 1304;
		Qij_C[32][0] = 626;  	Qij_C[32][1] = 74;   	Qij_C[32][2] = 0;  		Qij_C[32][3] = 187;  	Qij_C[32][4] = 196;  	Qij_C[32][5] = 36;   Qij_C[32][6] = 0;   	Qij_C[32][7] = 38;  	Qij_C[32][8] = 213;   	Qij_C[32][9] = 82;    	Qij_C[32][10] = 0;  		Qij_C[32][11] = 114;  Qij_C[32][12] = 95;    	Qij_C[32][13] = 5;   		Qij_C[32][14] = 22;    Qij_C[32][15] = 0; Qij_C[32][16] = 1246;   Qij_C[32][17] = 28;  Qij_C[32][18] = 112;  Qij_C[32][19] = 123;   Qij_C[32][20] = 71;   Qij_C[32][21] = 17;   Qij_C[32][22] = 35;   Qij_C[32][23] = 29;   Qij_C[32][24] = 24;    Qij_C[32][25] = 0;    Qij_C[32][26] = 0;   Qij_C[32][27] = 69;   Qij_C[32][28] = 52;    Qij_C[32][29] = 6;    Qij_C[32][30] = 0;   Qij_C[32][31] = 13;    Qij_C[32][32] = 0; Qij_C[32][33] = 1114; Qij_C[32][34] = 11181; Qij_C[32][35] = 1758;  Qij_C[32][36] = 636;   Qij_C[32][37] = 41;    Qij_C[32][38] = 0;   Qij_C[32][39] = 64;  Qij_C[32][40] = 798;    Qij_C[32][41] = 0;    Qij_C[32][42] = 0;   Qij_C[32][43] = 28;  Qij_C[32][44] = 367;   Qij_C[32][45] = 24;   Qij_C[32][46] = 16;   Qij_C[32][47] = 62;    Qij_C[32][48] = 9;   Qij_C[32][49] = 16;  Qij_C[32][50] = 118;   Qij_C[32][51] = 14;   Qij_C[32][52] = 53;   Qij_C[32][53] = 42;    Qij_C[32][54] = 0;    Qij_C[32][55] = 5;   Qij_C[32][56] = 13;   Qij_C[32][57] = 32;    Qij_C[32][58] = 2;   Qij_C[32][59] = 46;    Qij_C[32][60] = 8;
		Qij_C[33][0] = 58; 		Qij_C[33][1] = 1249; 	Qij_C[33][2] = 35;   	Qij_C[33][3] = 33;   	Qij_C[33][4] = 0;  		Qij_C[33][5] = 124;  Qij_C[33][6] = 77;   Qij_C[33][7] = 54;   Qij_C[33][8] = 22;  		Qij_C[33][9] = 395;   	Qij_C[33][10] = 11;   	Qij_C[33][11] = 38;   Qij_C[33][12] = 0;   		Qij_C[33][13] = 20;    	Qij_C[33][14] = 9;    Qij_C[33][15] = 0;   Qij_C[33][16] = 76;  Qij_C[33][17] = 311;   Qij_C[33][18] = 72;   Qij_C[33][19] = 22;    Qij_C[33][20] = 6;   Qij_C[33][21] = 72;   Qij_C[33][22] = 40;    Qij_C[33][23] = 8;    Qij_C[33][24] = 0;   Qij_C[33][25] = 57;   Qij_C[33][26] = 11;    Qij_C[33][27] = 1;    Qij_C[33][28] = 0;   Qij_C[33][29] = 20;    Qij_C[33][30] = 3;   Qij_C[33][31] = 10; Qij_C[33][32] = 1114;    Qij_C[33][33] = 0; Qij_C[33][34] = 1466; Qij_C[33][35] = 13482;   Qij_C[33][36] = 39;  Qij_C[33][37] = 322;  Qij_C[33][38] = 182;    Qij_C[33][39] = 0;   Qij_C[33][40] = 86;  Qij_C[33][41] = 795;   Qij_C[33][42] = 32;    Qij_C[33][43] = 0;   Qij_C[33][44] = 19;  Qij_C[33][45] = 141;    Qij_C[33][46] = 0;    Qij_C[33][47] = 0;   Qij_C[33][48] = 76;    Qij_C[33][49] = 0;   Qij_C[33][50] = 35;  Qij_C[33][51] = 115;   Qij_C[33][52] = 76;    Qij_C[33][53] = 1;   Qij_C[33][54] = 24;    Qij_C[33][55] = 1;    Qij_C[33][56] = 9;   Qij_C[33][57] = 16;   Qij_C[33][58] = 13;    Qij_C[33][59] = 0;    Qij_C[33][60] = 0;
		Qij_C[34][0] = 0;   	Qij_C[34][1] = 80;  	Qij_C[34][2] = 429;  	Qij_C[34][3] = 106;  	Qij_C[34][4] = 76;   	Qij_C[34][5] = 35;  	Qij_C[34][6] = 199;  Qij_C[34][7] = 52;   Qij_C[34][8] = 0;   		Qij_C[34][9] = 86;  		Qij_C[34][10] = 162;  	Qij_C[34][11] = 101;  Qij_C[34][12] = 17;    	Qij_C[34][13] = 1;   		Qij_C[34][14] = 63;   Qij_C[34][15] = 21;   Qij_C[34][16] = 66;   Qij_C[34][17] = 71;  Qij_C[34][18] = 739;   Qij_C[34][19] = 69;   Qij_C[34][20] = 51;   Qij_C[34][21] = 40;   Qij_C[34][22] = 81;   Qij_C[34][23] = 19;    Qij_C[34][24] = 0;   Qij_C[34][25] = 44;  Qij_C[34][26] = 104;    Qij_C[34][27] = 0;    Qij_C[34][28] = 0;   Qij_C[34][29] = 12;   Qij_C[34][30] = 27;    Qij_C[34][31] = 7; Qij_C[34][32] = 11181; Qij_C[34][33] = 1466;    Qij_C[34][34] = 0; Qij_C[34][35] = 1216;  Qij_C[34][36] = 118;   Qij_C[34][37] = 91;  Qij_C[34][38] = 916;   Qij_C[34][39] = 70;    Qij_C[34][40] = 0;   Qij_C[34][41] = 50;  Qij_C[34][42] = 749;   Qij_C[34][43] = 30;   Qij_C[34][44] = 38;   Qij_C[34][45] = 26;  Qij_C[34][46] = 161;    Qij_C[34][47] = 4;    Qij_C[34][48] = 6;   Qij_C[34][49] = 16;   Qij_C[34][50] = 43;   Qij_C[34][51] = 42;   Qij_C[34][52] = 84;   Qij_C[34][53] = 36;   Qij_C[34][54] = 11;   Qij_C[34][55] = 13;    Qij_C[34][56] = 3;   Qij_C[34][57] = 20;    Qij_C[34][58] = 4;   Qij_C[34][59] = 18;    Qij_C[34][60] = 3;
		Qij_C[35][0] = 56;   	Qij_C[35][1] = 4;   	Qij_C[35][2] = 44; 		Qij_C[35][3] = 1636; 	Qij_C[35][4] = 83;   	Qij_C[35][5] = 2;    Qij_C[35][6] = 0;  	Qij_C[35][7] = 149;  Qij_C[35][8] = 27;   	Qij_C[35][9] = 30;   	Qij_C[35][10] = 19;  		Qij_C[35][11] = 488;  Qij_C[35][12] = 19;    	Qij_C[35][13] = 0;    	Qij_C[35][14] = 8;   Qij_C[35][15] = 36;  Qij_C[35][16] = 132;    Qij_C[35][17] = 0;   Qij_C[35][18] = 54;  Qij_C[35][19] = 378;   Qij_C[35][20] = 28;    Qij_C[35][21] = 7;   Qij_C[35][22] = 37;   Qij_C[35][23] = 44;    Qij_C[35][24] = 0;    Qij_C[35][25] = 8;   Qij_C[35][26] = 13;   Qij_C[35][27] = 66;    Qij_C[35][28] = 5;    Qij_C[35][29] = 0;    Qij_C[35][30] = 0;   Qij_C[35][31] = 21; Qij_C[35][32] = 1758; Qij_C[35][33] = 13482; Qij_C[35][34] = 1216;    Qij_C[35][35] = 0;   Qij_C[35][36] = 59;    Qij_C[35][37] = 0;   Qij_C[35][38] = 20;  Qij_C[35][39] = 384;   Qij_C[35][40] = 50;    Qij_C[35][41] = 0;   Qij_C[35][42] = 88; Qij_C[35][43] = 1058;   Qij_C[35][44] = 24;    Qij_C[35][45] = 0;    Qij_C[35][46] = 5;  Qij_C[35][47] = 187;    Qij_C[35][48] = 0;  Qij_C[35][49] = 122;   Qij_C[35][50] = 52;    Qij_C[35][51] = 0;   Qij_C[35][52] = 20;  Qij_C[35][53] = 138;    Qij_C[35][54] = 0;    Qij_C[35][55] = 3;   Qij_C[35][56] = 41;    Qij_C[35][57] = 0;    Qij_C[35][58] = 0;   Qij_C[35][59] = 16;   Qij_C[35][60] = 14;
		Qij_C[36][0] = 216;  	Qij_C[36][1] = 28;   	Qij_C[36][2] = 48;  	Qij_C[36][3] = 149; 	Qij_C[36][4] = 3718; 	Qij_C[36][5] = 0;    Qij_C[36][6] = 0;    Qij_C[36][7] = 0;  	Qij_C[36][8] = 108;  	Qij_C[36][9] = 106;   	Qij_C[36][10] = 88;  		Qij_C[36][11] = 268;  Qij_C[36][12] = 484;    	Qij_C[36][13] = 0;  		Qij_C[36][14] = 282;   Qij_C[36][15] = 73;  Qij_C[36][16] = 307;   Qij_C[36][17] = 20;   Qij_C[36][18] = 61;   Qij_C[36][19] = 70; Qij_C[36][20] = 1186;   Qij_C[36][21] = 19;  Qij_C[36][22] = 101;   Qij_C[36][23] = 91;   Qij_C[36][24] = 72;    Qij_C[36][25] = 0;   Qij_C[36][26] = 23;   Qij_C[36][27] = 38;  Qij_C[36][28] = 300;    Qij_C[36][29] = 0;   Qij_C[36][30] = 46;   Qij_C[36][31] = 29;  Qij_C[36][32] = 636;   Qij_C[36][33] = 39;  Qij_C[36][34] = 118;   Qij_C[36][35] = 59;    Qij_C[36][36] = 0; Qij_C[36][37] = 8169; Qij_C[36][38] = 22755; Qij_C[36][39] = 14816; Qij_C[36][40] = 1071;    Qij_C[36][41] = 0;  Qij_C[36][42] = 360;  Qij_C[36][43] = 171; Qij_C[36][44] = 3240;    Qij_C[36][45] = 0;  Qij_C[36][46] = 591;    Qij_C[36][47] = 0;    Qij_C[36][48] = 1;   Qij_C[36][49] = 19; Qij_C[36][50] = 3185;  Qij_C[36][51] = 127;  Qij_C[36][52] = 250;  Qij_C[36][53] = 303;   Qij_C[36][54] = 27;   Qij_C[36][55] = 17;   Qij_C[36][56] = 87;  Qij_C[36][57] = 293;    Qij_C[36][58] = 0;   Qij_C[36][59] = 82;   Qij_C[36][60] = 39;
		Qij_C[37][0] = 13;  	Qij_C[37][1] = 224;  	Qij_C[37][2] = 45;   	Qij_C[37][3] = 25;   	Qij_C[37][4] = 0; 		Qij_C[37][5] = 2888; Qij_C[37][6] = 36;   Qij_C[37][7] = 0;   	Qij_C[37][8] = 24;  		Qij_C[37][9] = 608;   	Qij_C[37][10] = 51;    	Qij_C[37][11] = 0;    Qij_C[37][12] = 0;  		Qij_C[37][13] = 217;  	Qij_C[37][14] = 115;    Qij_C[37][15] = 0;   Qij_C[37][16] = 22;  Qij_C[37][17] = 119;   Qij_C[37][18] = 88;    Qij_C[37][19] = 0;    Qij_C[37][20] = 7;  Qij_C[37][21] = 965;  Qij_C[37][22] = 145;   Qij_C[37][23] = 79;   Qij_C[37][24] = 26;  Qij_C[37][25] = 133;    Qij_C[37][26] = 0;   Qij_C[37][27] = 29;    Qij_C[37][28] = 0;  Qij_C[37][29] = 160;   Qij_C[37][30] = 31;   Qij_C[37][31] = 30;   Qij_C[37][32] = 41;  Qij_C[37][33] = 322;   Qij_C[37][34] = 91;    Qij_C[37][35] = 0; Qij_C[37][36] = 8169;    Qij_C[37][37] = 0; Qij_C[37][38] = 14245; Qij_C[37][39] = 12825;   Qij_C[37][40] = 44; Qij_C[37][41] = 1050;  Qij_C[37][42] = 151;    Qij_C[37][43] = 0;    Qij_C[37][44] = 0; Qij_C[37][45] = 2241;   Qij_C[37][46] = 80;    Qij_C[37][47] = 0;   Qij_C[37][48] = 28;   Qij_C[37][49] = 11;  Qij_C[37][50] = 201; Qij_C[37][51] = 2338;  Qij_C[37][52] = 324;  Qij_C[37][53] = 250;  Qij_C[37][54] = 197;   Qij_C[37][55] = 15;   Qij_C[37][56] = 22;   Qij_C[37][57] = 42;   Qij_C[37][58] = 78;   Qij_C[37][59] = 24;    Qij_C[37][60] = 1;
		Qij_C[38][0] = 62;  	Qij_C[38][1] = 161;  	Qij_C[38][2] = 171;  	Qij_C[38][3] = 81;   	Qij_C[38][4] = 0;  		Qij_C[38][5] = 193; 	Qij_C[38][6] = 7718; Qij_C[38][7] = 0;   	Qij_C[38][8] = 49;  		Qij_C[38][9] = 258;  	Qij_C[38][10] = 171;  	Qij_C[38][11] = 178;  Qij_C[38][12] = 315;   	Qij_C[38][13] = 77;  		Qij_C[38][14] = 392;    Qij_C[38][15] = 0;  Qij_C[38][16] = 182;   Qij_C[38][17] = 45;  Qij_C[38][18] = 246;  Qij_C[38][19] = 109;    Qij_C[38][20] = 0;  Qij_C[38][21] = 206; Qij_C[38][22] = 4882;    Qij_C[38][23] = 0;    Qij_C[38][24] = 0;   Qij_C[38][25] = 94;  Qij_C[38][26] = 379;    Qij_C[38][27] = 0;    Qij_C[38][28] = 0;   Qij_C[38][29] = 40;  Qij_C[38][30] = 261;   Qij_C[38][31] = 16;    Qij_C[38][32] = 0;  Qij_C[38][33] = 182;  Qij_C[38][34] = 916;   Qij_C[38][35] = 20; Qij_C[38][36] = 22755; Qij_C[38][37] = 14245;    Qij_C[38][38] = 0; Qij_C[38][39] = 13866;    Qij_C[38][40] = 0;  Qij_C[38][41] = 357; Qij_C[38][42] = 2466;    Qij_C[38][43] = 0;    Qij_C[38][44] = 0;    Qij_C[38][45] = 0; Qij_C[38][46] = 2849;    Qij_C[38][47] = 0;   Qij_C[38][48] = 68;    Qij_C[38][49] = 0;    Qij_C[38][50] = 0;  Qij_C[38][51] = 354; Qij_C[38][52] = 9766;  Qij_C[38][53] = 450;  Qij_C[38][54] = 134;   Qij_C[38][55] = 32;   Qij_C[38][56] = 96;    Qij_C[38][57] = 0;   Qij_C[38][58] = 59;  Qij_C[38][59] = 480;   Qij_C[38][60] = 19;
		Qij_C[39][0] = 43;   	Qij_C[39][1] = 38;   	Qij_C[39][2] = 31;  	Qij_C[39][3] = 252;  	Qij_C[39][4] = 0;    	Qij_C[39][5] = 0;    Qij_C[39][6] = 0; 	Qij_C[39][7] = 3490; Qij_C[39][8] = 47;  		Qij_C[39][9] = 101;    	Qij_C[39][10] = 0;  		Qij_C[39][11] = 628;  Qij_C[39][12] = 42;   	Qij_C[39][13] = 32;  		Qij_C[39][14] = 108;  Qij_C[39][15] = 233;   Qij_C[39][16] = 60;    Qij_C[39][17] = 5;   Qij_C[39][18] = 52;  Qij_C[39][19] = 111;   Qij_C[39][20] = 28;   Qij_C[39][21] = 63;    Qij_C[39][22] = 0; Qij_C[39][23] = 1111;    Qij_C[39][24] = 0;    Qij_C[39][25] = 0;   Qij_C[39][26] = 62;  Qij_C[39][27] = 121;   Qij_C[39][28] = 14;    Qij_C[39][29] = 8;   Qij_C[39][30] = 31;  Qij_C[39][31] = 183;   Qij_C[39][32] = 64;    Qij_C[39][33] = 0;   Qij_C[39][34] = 70;  Qij_C[39][35] = 384; Qij_C[39][36] = 14816; Qij_C[39][37] = 12825; Qij_C[39][38] = 13866;    Qij_C[39][39] = 0;  Qij_C[39][40] = 133;   Qij_C[39][41] = 72;   Qij_C[39][42] = 35; Qij_C[39][43] = 1264;   Qij_C[39][44] = 14;    Qij_C[39][45] = 0;   Qij_C[39][46] = 37; Qij_C[39][47] = 2567;   Qij_C[39][48] = 11;   Qij_C[39][49] = 54;  Qij_C[39][50] = 301;  Qij_C[39][51] = 180;    Qij_C[39][52] = 0; Qij_C[39][53] = 2454;   Qij_C[39][54] = 32;    Qij_C[39][55] = 0;  Qij_C[39][56] = 203;   Qij_C[39][57] = 43;   Qij_C[39][58] = 10;   Qij_C[39][59] = 68;   Qij_C[39][60] = 89;
		Qij_C[40][0] = 137;  	Qij_C[40][1] = 31;   	Qij_C[40][2] = 11;  	Qij_C[40][3] = 121;  	Qij_C[40][4] = 214;  	Qij_C[40][5] = 12;   Qij_C[40][6] = 51;   Qij_C[40][7] = 3; 	Qij_C[40][8] = 1071;  	Qij_C[40][9] = 134;    	Qij_C[40][10] = 0;  		Qij_C[40][11] = 151;  Qij_C[40][12] = 85;    	Qij_C[40][13] = 0;   		Qij_C[40][14] = 31;   Qij_C[40][15] = 16;  Qij_C[40][16] = 225;   Qij_C[40][17] = 16;    Qij_C[40][18] = 8;   Qij_C[40][19] = 26;   Qij_C[40][20] = 78;   Qij_C[40][21] = 11;   Qij_C[40][22] = 26;   Qij_C[40][23] = 16;  Qij_C[40][24] = 176;    Qij_C[40][25] = 0;    Qij_C[40][26] = 0;    Qij_C[40][27] = 0;   Qij_C[40][28] = 70;   Qij_C[40][29] = 12;    Qij_C[40][30] = 0;   Qij_C[40][31] = 13;  Qij_C[40][32] = 798;   Qij_C[40][33] = 86;    Qij_C[40][34] = 0;   Qij_C[40][35] = 50; Qij_C[40][36] = 1071;   Qij_C[40][37] = 44;    Qij_C[40][38] = 0;  Qij_C[40][39] = 133;    Qij_C[40][40] = 0; Qij_C[40][41] = 9267; Qij_C[40][42] = 21307; Qij_C[40][43] = 13656;  Qij_C[40][44] = 629;    Qij_C[40][45] = 0;    Qij_C[40][46] = 0;    Qij_C[40][47] = 0;    Qij_C[40][48] = 0;    Qij_C[40][49] = 9;  Qij_C[40][50] = 198;   Qij_C[40][51] = 59;    Qij_C[40][52] = 0;   Qij_C[40][53] = 80;    Qij_C[40][54] = 0;    Qij_C[40][55] = 4;   Qij_C[40][56] = 34;   Qij_C[40][57] = 23;    Qij_C[40][58] = 1;    Qij_C[40][59] = 0;   Qij_C[40][60] = 15;
		Qij_C[41][0] = 13;  	Qij_C[41][1] = 589;  	Qij_C[41][2] = 28;   	Qij_C[41][3] = 91;   	Qij_C[41][4] = 6;  		Qij_C[41][5] = 250;  Qij_C[41][6] = 62;   Qij_C[41][7] = 50;   Qij_C[41][8] = 25; 		Qij_C[41][9] = 2627;    	Qij_C[41][10] = 0;    	Qij_C[41][11] = 0;   	Qij_C[41][12] = 18;   	Qij_C[41][13] = 42;   	Qij_C[41][14] = 16;   Qij_C[41][15] = 10;   Qij_C[41][16] = 15;  Qij_C[41][17] = 165;   Qij_C[41][18] = 40;   Qij_C[41][19] = 12;   Qij_C[41][20] = 31;  Qij_C[41][21] = 114;  Qij_C[41][22] = 129;   Qij_C[41][23] = 14;    Qij_C[41][24] = 0;  Qij_C[41][25] = 452;   Qij_C[41][26] = 78;    Qij_C[41][27] = 1;    Qij_C[41][28] = 0;   Qij_C[41][29] = 38;    Qij_C[41][30] = 6;   Qij_C[41][31] = 14;    Qij_C[41][32] = 0;  Qij_C[41][33] = 795;   Qij_C[41][34] = 50;    Qij_C[41][35] = 0;    Qij_C[41][36] = 0; Qij_C[41][37] = 1050;  Qij_C[41][38] = 357;   Qij_C[41][39] = 72; Qij_C[41][40] = 9267;    Qij_C[41][41] = 0; Qij_C[41][42] = 11188; Qij_C[41][43] = 17792;    Qij_C[41][44] = 0;  Qij_C[41][45] = 383;    Qij_C[41][46] = 0;   Qij_C[41][47] = 15;   Qij_C[41][48] = 38;    Qij_C[41][49] = 0;   Qij_C[41][50] = 28;  Qij_C[41][51] = 224;  Qij_C[41][52] = 240;   Qij_C[41][53] = 52;  Qij_C[41][54] = 372;    Qij_C[41][55] = 7;   Qij_C[41][56] = 38;    Qij_C[41][57] = 0;   Qij_C[41][58] = 23;   Qij_C[41][59] = 15;    Qij_C[41][60] = 9;
		Qij_C[42][0] = 13;  	Qij_C[42][1] = 171;  	Qij_C[42][2] = 144;  	Qij_C[42][3] = 67;   	Qij_C[42][4] = 84;   	Qij_C[42][5] = 0;  	Qij_C[42][6] = 405;  Qij_C[42][7] = 77;   Qij_C[42][8] = 0;  		Qij_C[42][9] = 328; 		Qij_C[42][10] = 1567;  	Qij_C[42][11] = 398;  Qij_C[42][12] = 14;   	Qij_C[42][13] = 22;  		Qij_C[42][14] = 116;    Qij_C[42][15] = 0;   Qij_C[42][16] = 53;   Qij_C[42][17] = 31;  Qij_C[42][18] = 148;   Qij_C[42][19] = 29;   Qij_C[42][20] = 36;   Qij_C[42][21] = 55;  Qij_C[42][22] = 251;    Qij_C[42][23] = 9;    Qij_C[42][24] = 0;    Qij_C[42][25] = 0;  Qij_C[42][26] = 515;    Qij_C[42][27] = 0;    Qij_C[42][28] = 0;    Qij_C[42][29] = 1;   Qij_C[42][30] = 39;    Qij_C[42][31] = 0;    Qij_C[42][32] = 0;   Qij_C[42][33] = 32;  Qij_C[42][34] = 749;   Qij_C[42][35] = 88;  Qij_C[42][36] = 360;  Qij_C[42][37] = 151; Qij_C[42][38] = 2466;   Qij_C[42][39] = 35; Qij_C[42][40] = 21307; Qij_C[42][41] = 11188;    Qij_C[42][42] = 0; Qij_C[42][43] = 11092;   Qij_C[42][44] = 86;    Qij_C[42][45] = 0;  Qij_C[42][46] = 380;    Qij_C[42][47] = 0;    Qij_C[42][48] = 3;   Qij_C[42][49] = 14;  Qij_C[42][50] = 162;   Qij_C[42][51] = 49;  Qij_C[42][52] = 532;   Qij_C[42][53] = 10;   Qij_C[42][54] = 39;  Qij_C[42][55] = 214;   Qij_C[42][56] = 42;    Qij_C[42][57] = 9;   Qij_C[42][58] = 11;  Qij_C[42][59] = 122;    Qij_C[42][60] = 2;
		Qij_C[43][0] = 44;   	Qij_C[43][1] = 98;   	Qij_C[43][2] = 32; 		Qij_C[43][3] = 829;  	Qij_C[43][4] = 46;   	Qij_C[43][5] = 91;   Qij_C[43][6] = 0;  	Qij_C[43][7] = 349;  Qij_C[43][8] = 0;    	Qij_C[43][9] = 6;    	Qij_C[43][10] = 0; 		Qij_C[43][11] = 3432; Qij_C[43][12] = 0;    	Qij_C[43][13] = 0;   		Qij_C[43][14] = 23;   Qij_C[43][15] = 46;    Qij_C[43][16] = 0;    Qij_C[43][17] = 0;   Qij_C[43][18] = 43;  Qij_C[43][19] = 266;   Qij_C[43][20] = 29;   Qij_C[43][21] = 16;    Qij_C[43][22] = 0;  Qij_C[43][23] = 161;  Qij_C[43][24] = 117;    Qij_C[43][25] = 0;    Qij_C[43][26] = 0;  Qij_C[43][27] = 688;    Qij_C[43][28] = 9;    Qij_C[43][29] = 0;    Qij_C[43][30] = 9;   Qij_C[43][31] = 50;   Qij_C[43][32] = 28;    Qij_C[43][33] = 0;   Qij_C[43][34] = 30; Qij_C[43][35] = 1058;  Qij_C[43][36] = 171;    Qij_C[43][37] = 0;    Qij_C[43][38] = 0; Qij_C[43][39] = 1264; Qij_C[43][40] = 13656; Qij_C[43][41] = 17792; Qij_C[43][42] = 11092;    Qij_C[43][43] = 0;    Qij_C[43][44] = 0;    Qij_C[43][45] = 0;   Qij_C[43][46] = 21;  Qij_C[43][47] = 557;    Qij_C[43][48] = 0;   Qij_C[43][49] = 62;   Qij_C[43][50] = 60;   Qij_C[43][51] = 18;   Qij_C[43][52] = 85;  Qij_C[43][53] = 293;    Qij_C[43][54] = 0;    Qij_C[43][55] = 0;  Qij_C[43][56] = 515;   Qij_C[43][57] = 44;    Qij_C[43][58] = 0;    Qij_C[43][59] = 0;   Qij_C[43][60] = 32;
		Qij_C[44][0] = 153;  	Qij_C[44][1] = 26;   	Qij_C[44][2] = 16;   	Qij_C[44][3] = 55; 		Qij_C[44][4] = 1694; 	Qij_C[44][5] = 20;   Qij_C[44][6] = 36;   Qij_C[44][7] = 0;  	Qij_C[44][8] = 249;   	Qij_C[44][9] = 87;    	Qij_C[44][10] = 0;   		Qij_C[44][11] = 31;	Qij_C[44][12] = 11512;    Qij_C[44][13] = 0;  		Qij_C[44][14] = 626;  Qij_C[44][15] = 125;  Qij_C[44][16] = 276;   Qij_C[44][17] = 36;   Qij_C[44][18] = 31;   Qij_C[44][19] = 23;  Qij_C[44][20] = 394;   Qij_C[44][21] = 63;    Qij_C[44][22] = 0;    Qij_C[44][23] = 0;   Qij_C[44][24] = 86;    Qij_C[44][25] = 0;    Qij_C[44][26] = 0;    Qij_C[44][27] = 0; Qij_C[44][28] = 2164;    Qij_C[44][29] = 5;    Qij_C[44][30] = 7;  Qij_C[44][31] = 131;  Qij_C[44][32] = 367;   Qij_C[44][33] = 19;   Qij_C[44][34] = 38;   Qij_C[44][35] = 24; Qij_C[44][36] = 3240;    Qij_C[44][37] = 0;    Qij_C[44][38] = 0;   Qij_C[44][39] = 14;  Qij_C[44][40] = 629;    Qij_C[44][41] = 0;   Qij_C[44][42] = 86;    Qij_C[44][43] = 0;    Qij_C[44][44] = 0; Qij_C[44][45] = 10722; Qij_C[44][46] = 21679; Qij_C[44][47] = 15228;    Qij_C[44][48] = 2;   Qij_C[44][49] = 18;  Qij_C[44][50] = 396;    Qij_C[44][51] = 2;    Qij_C[44][52] = 0;   Qij_C[44][53] = 70;   Qij_C[44][54] = 24;    Qij_C[44][55] = 6;   Qij_C[44][56] = 52; Qij_C[44][57] = 3202;   Qij_C[44][58] = 13;  Qij_C[44][59] = 251;   Qij_C[44][60] = 83;
		Qij_C[45][0] = 13;   	Qij_C[45][1] = 86;   	Qij_C[45][2] = 11;   	Qij_C[45][3] = 21;   	Qij_C[45][4] = 1; 		Qij_C[45][5] = 1080; Qij_C[45][6] = 0;  	Qij_C[45][7] = 148;  Qij_C[45][8] = 5;  		Qij_C[45][9] = 170;   	Qij_C[45][10] = 38;   	Qij_C[45][11] = 16;  	Qij_C[45][12] = 158; 		Qij_C[45][13] = 6084;  	Qij_C[45][14] = 190;   Qij_C[45][15] = 79;   Qij_C[45][16] = 29;   Qij_C[45][17] = 75;   Qij_C[45][18] = 25;   Qij_C[45][19] = 15;   Qij_C[45][20] = 36;  Qij_C[45][21] = 199;   Qij_C[45][22] = 69;    Qij_C[45][23] = 0;    Qij_C[45][24] = 0;   Qij_C[45][25] = 52;   Qij_C[45][26] = 36;   Qij_C[45][27] = 18;  Qij_C[45][28] = 120; Qij_C[45][29] = 1603;   Qij_C[45][30] = 42;   Qij_C[45][31] = 18;   Qij_C[45][32] = 24;  Qij_C[45][33] = 141;   Qij_C[45][34] = 26;    Qij_C[45][35] = 0;    Qij_C[45][36] = 0; Qij_C[45][37] = 2241;    Qij_C[45][38] = 0;    Qij_C[45][39] = 0;    Qij_C[45][40] = 0;  Qij_C[45][41] = 383;    Qij_C[45][42] = 0;    Qij_C[45][43] = 0; Qij_C[45][44] = 10722;    Qij_C[45][45] = 0; Qij_C[45][46] = 9288; Qij_C[45][47] = 17102;   Qij_C[45][48] = 69;    Qij_C[45][49] = 7;   Qij_C[45][50] = 49;  Qij_C[45][51] = 199;    Qij_C[45][52] = 0;   Qij_C[45][53] = 15;  Qij_C[45][54] = 105;    Qij_C[45][55] = 4;   Qij_C[45][56] = 28;   Qij_C[45][57] = 73;  Qij_C[45][58] = 460;   Qij_C[45][59] = 35;    Qij_C[45][60] = 6;
		Qij_C[46][0] = 10;   	Qij_C[46][1] = 12;   	Qij_C[46][2] = 54;   	Qij_C[46][3] = 12;  	Qij_C[46][4] = 206;  	Qij_C[46][5] = 66;  	Qij_C[46][6] = 995;  Qij_C[46][7] = 155;  Qij_C[46][8] = 0;   		Qij_C[46][9] = 10;  		Qij_C[46][10] = 106;   	Qij_C[46][11] = 28; 	Qij_C[46][12] = 1567;  	Qij_C[46][13] = 928; 		Qij_C[46][14] = 1219;  Qij_C[46][15] = 743;   Qij_C[46][16] = 10;   Qij_C[46][17] = 18;   Qij_C[46][18] = 62;   Qij_C[46][19] = 23;   Qij_C[46][20] = 58;   Qij_C[46][21] = 21;  Qij_C[46][22] = 154;   Qij_C[46][23] = 27;    Qij_C[46][24] = 0;   Qij_C[46][25] = 20;   Qij_C[46][26] = 58;   Qij_C[46][27] = 12;   Qij_C[46][28] = 16;   Qij_C[46][29] = 24;  Qij_C[46][30] = 827;    Qij_C[46][31] = 0;   Qij_C[46][32] = 16;    Qij_C[46][33] = 0;  Qij_C[46][34] = 161;    Qij_C[46][35] = 5;  Qij_C[46][36] = 591;   Qij_C[46][37] = 80; Qij_C[46][38] = 2849;   Qij_C[46][39] = 37;    Qij_C[46][40] = 0;    Qij_C[46][41] = 0;  Qij_C[46][42] = 380;   Qij_C[46][43] = 21; Qij_C[46][44] = 21679; Qij_C[46][45] = 9288;    Qij_C[46][46] = 0; Qij_C[46][47] = 10663;   Qij_C[46][48] = 17;    Qij_C[46][49] = 9;   Qij_C[46][50] = 85;   Qij_C[46][51] = 19;  Qij_C[46][52] = 271;   Qij_C[46][53] = 46;   Qij_C[46][54] = 16;   Qij_C[46][55] = 27;   Qij_C[46][56] = 54;    Qij_C[46][57] = 0;   Qij_C[46][58] = 42; Qij_C[46][59] = 1017;   Qij_C[46][60] = 60;
		Qij_C[47][0] = 37;   	Qij_C[47][1] = 20;   	Qij_C[47][2] = 3;  		Qij_C[47][3] = 100;  	Qij_C[47][4] = 65;   	Qij_C[47][5] = 72;  	Qij_C[47][6] = 141; 	Qij_C[47][7] = 1227; Qij_C[47][8] = 31;   	Qij_C[47][9] = 69;    	Qij_C[47][10] = 0;  		Qij_C[47][11] = 233;  Qij_C[47][12] = 389;   	Qij_C[47][13] = 53;  		Qij_C[47][14] = 259; Qij_C[47][15] = 6623;   Qij_C[47][16] = 82;    Qij_C[47][17] = 1;   Qij_C[47][18] = 28;   Qij_C[47][19] = 68;    Qij_C[47][20] = 0;    Qij_C[47][21] = 0;   Qij_C[47][22] = 65;  Qij_C[47][23] = 258;    Qij_C[47][24] = 0;   Qij_C[47][25] = 15;    Qij_C[47][26] = 3;   Qij_C[47][27] = 96;    Qij_C[47][28] = 0;   Qij_C[47][29] = 28;   Qij_C[47][30] = 11; Qij_C[47][31] = 1661;   Qij_C[47][32] = 62;    Qij_C[47][33] = 0;    Qij_C[47][34] = 4;  Qij_C[47][35] = 187;    Qij_C[47][36] = 0;    Qij_C[47][37] = 0;    Qij_C[47][38] = 0; Qij_C[47][39] = 2567;    Qij_C[47][40] = 0;   Qij_C[47][41] = 15;    Qij_C[47][42] = 0;  Qij_C[47][43] = 557; Qij_C[47][44] = 15228; Qij_C[47][45] = 17102; Qij_C[47][46] = 10663;    Qij_C[47][47] = 0;    Qij_C[47][48] = 0;    Qij_C[47][49] = 80;   Qij_C[47][50] = 96;   Qij_C[47][51] = 61;    Qij_C[47][52] = 0;  Qij_C[47][53] = 218;   Qij_C[47][54] = 60;   Qij_C[47][55] = 20;  Qij_C[47][56] = 108;  Qij_C[47][57] = 175;    Qij_C[47][58] = 0;  Qij_C[47][59] = 236;  Qij_C[47][60] = 446;
		Qij_C[48][0] = 8;  		Qij_C[48][1] = 196;  	Qij_C[48][2] = 11;   	Qij_C[48][3] = 0;    	Qij_C[48][4] = 0;   	Qij_C[48][5] = 33;   Qij_C[48][6] = 9;   	Qij_C[48][7] = 17;   Qij_C[48][8] = 20;   	Qij_C[48][9] = 79;    	Qij_C[48][10] = 0;    	Qij_C[48][11] = 0;    Qij_C[48][12] = 1;   		Qij_C[48][13] = 42;   	Qij_C[48][14] = 21;    Qij_C[48][15] = 1;   Qij_C[48][16] = 56; Qij_C[48][17] = 1624;   Qij_C[48][18] = 58;    Qij_C[48][19] = 0;    Qij_C[48][20] = 0;   Qij_C[48][21] = 47;   Qij_C[48][22] = 22;    Qij_C[48][23] = 3;    Qij_C[48][24] = 0;  Qij_C[48][25] = 139;   Qij_C[48][26] = 17;    Qij_C[48][27] = 0;    Qij_C[48][28] = 0;  Qij_C[48][29] = 128;   Qij_C[48][30] = 14;   Qij_C[48][31] = 18;    Qij_C[48][32] = 9;   Qij_C[48][33] = 76;    Qij_C[48][34] = 6;    Qij_C[48][35] = 0;    Qij_C[48][36] = 1;   Qij_C[48][37] = 28;   Qij_C[48][38] = 68;   Qij_C[48][39] = 11;    Qij_C[48][40] = 0;   Qij_C[48][41] = 38;    Qij_C[48][42] = 3;    Qij_C[48][43] = 0;    Qij_C[48][44] = 2;   Qij_C[48][45] = 69;   Qij_C[48][46] = 17;    Qij_C[48][47] = 0;    Qij_C[48][48] = 0; Qij_C[48][49] = 25720;   Qij_C[48][50] = 23;  Qij_C[48][51] = 260;   Qij_C[48][52] = 70;    Qij_C[48][53] = 0;  Qij_C[48][54] = 623;   Qij_C[48][55] = 80;    Qij_C[48][56] = 0;   Qij_C[48][57] = 76; Qij_C[48][58] = 1911;   Qij_C[48][59] = 49;  Qij_C[48][60] = 300;
		Qij_C[49][0] = 16;   	Qij_C[49][1] = 0;   	Qij_C[49][2] = 11;  	Qij_C[49][3] = 316;  	Qij_C[49][4] = 12;   	Qij_C[49][5] = 21;   Qij_C[49][6] = 52;   Qij_C[49][7] = 61;   Qij_C[49][8] = 0;   		Qij_C[49][9] = 10;   	Qij_C[49][10] = 31;  		Qij_C[49][11] = 157;  Qij_C[49][12] = 29;    	Qij_C[49][13] = 7;   		Qij_C[49][14] = 32;   Qij_C[49][15] = 64;  Qij_C[49][16] = 122;  Qij_C[49][17] = 137;   Qij_C[49][18] = 42; Qij_C[49][19] = 2184;    Qij_C[49][20] = 7;    Qij_C[49][21] = 0;    Qij_C[49][22] = 4;   Qij_C[49][23] = 43;   Qij_C[49][24] = 68;    Qij_C[49][25] = 4;    Qij_C[49][26] = 0;  Qij_C[49][27] = 362;   Qij_C[49][28] = 68;    Qij_C[49][29] = 1;   Qij_C[49][30] = 39;  Qij_C[49][31] = 138;   Qij_C[49][32] = 16;    Qij_C[49][33] = 0;   Qij_C[49][34] = 16;  Qij_C[49][35] = 122;   Qij_C[49][36] = 19;   Qij_C[49][37] = 11;    Qij_C[49][38] = 0;   Qij_C[49][39] = 54;    Qij_C[49][40] = 9;    Qij_C[49][41] = 0;   Qij_C[49][42] = 14;   Qij_C[49][43] = 62;   Qij_C[49][44] = 18;    Qij_C[49][45] = 7;    Qij_C[49][46] = 9;   Qij_C[49][47] = 80; Qij_C[49][48] = 25720;    Qij_C[49][49] = 0;   Qij_C[49][50] = 28;   Qij_C[49][51] = 18;    Qij_C[49][52] = 0;  Qij_C[49][53] = 400;    Qij_C[49][54] = 0;  Qij_C[49][55] = 110; Qij_C[49][56] = 1025;  Qij_C[49][57] = 127;  Qij_C[49][58] = 360;   Qij_C[49][59] = 41; Qij_C[49][60] = 2355;
		Qij_C[50][0] = 133;  	Qij_C[50][1] = 79;   	Qij_C[50][2] = 52;  	Qij_C[50][3] = 139; 	Qij_C[50][4] = 3129; 	Qij_C[50][5] = 113;  Qij_C[50][6] = 232;  Qij_C[50][7] = 489;  Qij_C[50][8] = 79; 		Qij_C[50][9] = 214;    	Qij_C[50][10] = 4;  		Qij_C[50][11] = 528;  Qij_C[50][12] = 209;    	Qij_C[50][13] = 6;  		Qij_C[50][14] = 153;    Qij_C[50][15] = 0;  Qij_C[50][16] = 403;   Qij_C[50][17] = 53;  Qij_C[50][18] = 109;   Qij_C[50][19] = 76; Qij_C[50][20] = 2829;    Qij_C[50][21] = 0;  Qij_C[50][22] = 244;    Qij_C[50][23] = 0;  Qij_C[50][24] = 163;    Qij_C[50][25] = 0;   Qij_C[50][26] = 31;    Qij_C[50][27] = 1;  Qij_C[50][28] = 154;    Qij_C[50][29] = 0;    Qij_C[50][30] = 0;    Qij_C[50][31] = 0;  Qij_C[50][32] = 118;   Qij_C[50][33] = 35;   Qij_C[50][34] = 43;   Qij_C[50][35] = 52; Qij_C[50][36] = 3185;  Qij_C[50][37] = 201;    Qij_C[50][38] = 0;  Qij_C[50][39] = 301;  Qij_C[50][40] = 198;   Qij_C[50][41] = 28;  Qij_C[50][42] = 162;   Qij_C[50][43] = 60;  Qij_C[50][44] = 396;   Qij_C[50][45] = 49;   Qij_C[50][46] = 85;   Qij_C[50][47] = 96;   Qij_C[50][48] = 23;   Qij_C[50][49] = 28;    Qij_C[50][50] = 0; Qij_C[50][51] = 11009; Qij_C[50][52] = 36566; Qij_C[50][53] = 15154;   Qij_C[50][54] = 83;   Qij_C[50][55] = 83;  Qij_C[50][56] = 238; Qij_C[50][57] = 2230;   Qij_C[50][58] = 11;  Qij_C[50][59] = 662;   Qij_C[50][60] = 77;
		Qij_C[51][0] = 24;  	Qij_C[51][1] = 277;  	Qij_C[51][2] = 24;   	Qij_C[51][3] = 32;   	Qij_C[51][4] = 81; 		Qij_C[51][5] = 2315; Qij_C[51][6] = 682;  Qij_C[51][7] = 170;  Qij_C[51][8] = 26;  		Qij_C[51][9] = 983;   	Qij_C[51][10] = 12;   	Qij_C[51][11] = 51;   Qij_C[51][12] = 54;   	Qij_C[51][13] = 35;   	Qij_C[51][14] = 39;   Qij_C[51][15] = 30;   Qij_C[51][16] = 90;  Qij_C[51][17] = 211;   Qij_C[51][18] = 80;   Qij_C[51][19] = 22;    Qij_C[51][20] = 0; Qij_C[51][21] = 2535;    Qij_C[51][22] = 0;    Qij_C[51][23] = 0;    Qij_C[51][24] = 0;  Qij_C[51][25] = 177;   Qij_C[51][26] = 50;   Qij_C[51][27] = 11;    Qij_C[51][28] = 0;  Qij_C[51][29] = 214;   Qij_C[51][30] = 34;    Qij_C[51][31] = 0;   Qij_C[51][32] = 14;  Qij_C[51][33] = 115;   Qij_C[51][34] = 42;    Qij_C[51][35] = 0;  Qij_C[51][36] = 127; Qij_C[51][37] = 2338;  Qij_C[51][38] = 354;  Qij_C[51][39] = 180;   Qij_C[51][40] = 59;  Qij_C[51][41] = 224;   Qij_C[51][42] = 49;   Qij_C[51][43] = 18;    Qij_C[51][44] = 2;  Qij_C[51][45] = 199;   Qij_C[51][46] = 19;   Qij_C[51][47] = 61;  Qij_C[51][48] = 260;   Qij_C[51][49] = 18; Qij_C[51][50] = 11009;    Qij_C[51][51] = 0; Qij_C[51][52] = 19335; Qij_C[51][53] = 15656;  Qij_C[51][54] = 766;   Qij_C[51][55] = 23;    Qij_C[51][56] = 0;   Qij_C[51][57] = 39;  Qij_C[51][58] = 444;   Qij_C[51][59] = 51;    Qij_C[51][60] = 0;
		Qij_C[52][0] = 53;   	Qij_C[52][1] = 40;   	Qij_C[52][2] = 70;   	Qij_C[52][3] = 78;  	Qij_C[52][4] = 578;  	Qij_C[52][5] = 0; 	Qij_C[52][6] = 6944; Qij_C[52][7] = 362;  Qij_C[52][8] = 12;  		Qij_C[52][9] = 697;   	Qij_C[52][10] = 72;  		Qij_C[52][11] = 366;  Qij_C[52][12] = 88;   	Qij_C[52][13] = 15;  		Qij_C[52][14] = 229;   Qij_C[52][15] = 18;    Qij_C[52][16] = 0;  Qij_C[52][17] = 112;  Qij_C[52][18] = 288;    Qij_C[52][19] = 0;  Qij_C[52][20] = 131;    Qij_C[52][21] = 0; Qij_C[52][22] = 5851;    Qij_C[52][23] = 0;   Qij_C[52][24] = 53;  Qij_C[52][25] = 105;  Qij_C[52][26] = 385;    Qij_C[52][27] = 0;  Qij_C[52][28] = 340;    Qij_C[52][29] = 0;    Qij_C[52][30] = 0;    Qij_C[52][31] = 0;   Qij_C[52][32] = 53;   Qij_C[52][33] = 76;   Qij_C[52][34] = 84;   Qij_C[52][35] = 20;  Qij_C[52][36] = 250;  Qij_C[52][37] = 324; Qij_C[52][38] = 9766;    Qij_C[52][39] = 0;    Qij_C[52][40] = 0;  Qij_C[52][41] = 240;  Qij_C[52][42] = 532;   Qij_C[52][43] = 85;    Qij_C[52][44] = 0;    Qij_C[52][45] = 0;  Qij_C[52][46] = 271;    Qij_C[52][47] = 0;   Qij_C[52][48] = 70;    Qij_C[52][49] = 0; Qij_C[52][50] = 36566; Qij_C[52][51] = 19335;    Qij_C[52][52] = 0; Qij_C[52][53] = 21330;  Qij_C[52][54] = 157;  Qij_C[52][55] = 277;   Qij_C[52][56] = 90;    Qij_C[52][57] = 0;    Qij_C[52][58] = 0; Qij_C[52][59] = 2501;   Qij_C[52][60] = 99;
		Qij_C[53][0] = 54;   	Qij_C[53][1] = 87;   	Qij_C[53][2] = 26;  	Qij_C[53][3] = 289;  	Qij_C[53][4] = 567;  	Qij_C[53][5] = 279;  Qij_C[53][6] = 0; 	Qij_C[53][7] = 2679; Qij_C[53][8] = 54;  		Qij_C[53][9] = 312;   	Qij_C[53][10] = 33;  		Qij_C[53][11] = 938;  Qij_C[53][12] = 0;   		Qij_C[53][13] = 15;   	Qij_C[53][14] = 75;   Qij_C[53][15] = 72;  Qij_C[53][16] = 143;   Qij_C[53][17] = 43;   Qij_C[53][18] = 55;  Qij_C[53][19] = 315;    Qij_C[53][20] = 0;   Qij_C[53][21] = 65;    Qij_C[53][22] = 0; Qij_C[53][23] = 2744;    Qij_C[53][24] = 0;    Qij_C[53][25] = 0;    Qij_C[53][26] = 0;  Qij_C[53][27] = 326;    Qij_C[53][28] = 0;    Qij_C[53][29] = 0;   Qij_C[53][30] = 20;  Qij_C[53][31] = 278;   Qij_C[53][32] = 42;    Qij_C[53][33] = 1;   Qij_C[53][34] = 36;  Qij_C[53][35] = 138;  Qij_C[53][36] = 303;  Qij_C[53][37] = 250;  Qij_C[53][38] = 450; Qij_C[53][39] = 2454;   Qij_C[53][40] = 80;   Qij_C[53][41] = 52;   Qij_C[53][42] = 10;  Qij_C[53][43] = 293;   Qij_C[53][44] = 70;   Qij_C[53][45] = 15;   Qij_C[53][46] = 46;  Qij_C[53][47] = 218;    Qij_C[53][48] = 0;  Qij_C[53][49] = 400;  Qij_C[53][50] = 15154; Qij_C[53][51] = 15656; Qij_C[53][52] = 21330;    Qij_C[53][53] = 0;   Qij_C[53][54] = 37;   Qij_C[53][55] = 16; Qij_C[53][56] = 1004;   Qij_C[53][57] = 89;    Qij_C[53][58] = 0;  Qij_C[53][59] = 133;  Qij_C[53][60] = 476;
		Qij_C[54][0] = 15;  	Qij_C[54][1] = 116;  	Qij_C[54][2] = 16;   	Qij_C[54][3] = 0;   	Qij_C[54][4] = 22;  	Qij_C[54][5] = 153;  Qij_C[54][6] = 0;   	Qij_C[54][7] = 41;   Qij_C[54][8] = 7;  		Qij_C[54][9] = 792;   	Qij_C[54][10] = 20;  		Qij_C[54][11] = 105;  Qij_C[54][12] = 16;   	Qij_C[54][13] = 62;   	Qij_C[54][14] = 22;    Qij_C[54][15] = 1;   Qij_C[54][16] = 60;  Qij_C[54][17] = 276;   Qij_C[54][18] = 35;    Qij_C[54][19] = 6;    Qij_C[54][20] = 0;   Qij_C[54][21] = 49;   Qij_C[54][22] = 31;   Qij_C[54][23] = 12;   Qij_C[54][24] = 53;  Qij_C[54][25] = 908;  Qij_C[54][26] = 109;    Qij_C[54][27] = 0;    Qij_C[54][28] = 0;  Qij_C[54][29] = 152;    Qij_C[54][30] = 9;   Qij_C[54][31] = 21;    Qij_C[54][32] = 0;   Qij_C[54][33] = 24;   Qij_C[54][34] = 11;    Qij_C[54][35] = 0;   Qij_C[54][36] = 27;  Qij_C[54][37] = 197;  Qij_C[54][38] = 134;   Qij_C[54][39] = 32;    Qij_C[54][40] = 0;  Qij_C[54][41] = 372;   Qij_C[54][42] = 39;    Qij_C[54][43] = 0;   Qij_C[54][44] = 24;  Qij_C[54][45] = 105;   Qij_C[54][46] = 16;   Qij_C[54][47] = 60;  Qij_C[54][48] = 623;    Qij_C[54][49] = 0;   Qij_C[54][50] = 83;  Qij_C[54][51] = 766;  Qij_C[54][52] = 157;   Qij_C[54][53] = 37;   Qij_C[54][54] = 0;  Qij_C[54][55] = 164; Qij_C[54][56] = 29318;   Qij_C[54][57] = 46;  Qij_C[54][58] = 275;   Qij_C[54][59] = 53;   Qij_C[54][60] = 60;
		Qij_C[55][0] = 9;    	Qij_C[55][1] = 7;   	Qij_C[55][2] = 24;   	Qij_C[55][3] = 11;   	Qij_C[55][4] = 19;  	Qij_C[55][5] = 9;   	Qij_C[55][6] = 44;   Qij_C[55][7] = 0;   	Qij_C[55][8] = 23;   	Qij_C[55][9] = 19;  		Qij_C[55][10] = 264;   	Qij_C[55][11] = 27;   Qij_C[55][12] = 14;    	Qij_C[55][13] = 7;   		Qij_C[55][14] = 45;   Qij_C[55][15] = 10;   Qij_C[55][16] = 38;   Qij_C[55][17] = 20;   Qij_C[55][18] = 97;   Qij_C[55][19] = 63;   Qij_C[55][20] = 14;    Qij_C[55][21] = 0;   Qij_C[55][22] = 68;    Qij_C[55][23] = 0;  Qij_C[55][24] = 130;   Qij_C[55][25] = 40;  Qij_C[55][26] = 576;   Qij_C[55][27] = 14;   Qij_C[55][28] = 36;    Qij_C[55][29] = 9;   Qij_C[55][30] = 51;    Qij_C[55][31] = 9;    Qij_C[55][32] = 5;    Qij_C[55][33] = 1;   Qij_C[55][34] = 13;    Qij_C[55][35] = 3;   Qij_C[55][36] = 17;   Qij_C[55][37] = 15;   Qij_C[55][38] = 32;    Qij_C[55][39] = 0;    Qij_C[55][40] = 4;    Qij_C[55][41] = 7;  Qij_C[55][42] = 214;    Qij_C[55][43] = 0;    Qij_C[55][44] = 6;    Qij_C[55][45] = 4;   Qij_C[55][46] = 27;   Qij_C[55][47] = 20;   Qij_C[55][48] = 80;  Qij_C[55][49] = 110;   Qij_C[55][50] = 83;   Qij_C[55][51] = 23;  Qij_C[55][52] = 277;   Qij_C[55][53] = 16;   Qij_C[55][54] = 164;    Qij_C[55][55] = 0;  Qij_C[55][56] = 186;   Qij_C[55][57] = 24;   Qij_C[55][58] = 74;  Qij_C[55][59] = 357;  Qij_C[55][60] = 102;
		Qij_C[56][0] = 20;   	Qij_C[56][1] = 4;   	Qij_C[56][2] = 13;  	Qij_C[56][3] = 191;  	Qij_C[56][4] = 75;   	Qij_C[56][5] = 10;  	Qij_C[56][6] = 134;  Qij_C[56][7] = 194;  Qij_C[56][8] = 52;  		Qij_C[56][9] = 169;   	Qij_C[56][10] = 36;  		Qij_C[56][11] = 981;  Qij_C[56][12] = 14;   	Qij_C[56][13] = 10;   	Qij_C[56][14] = 29;   Qij_C[56][15] = 90;   Qij_C[56][16] = 70;   Qij_C[56][17] = 21;   Qij_C[56][18] = 43;  Qij_C[56][19] = 475;   Qij_C[56][20] = 11;    Qij_C[56][21] = 0;   Qij_C[56][22] = 44;  Qij_C[56][23] = 101;   Qij_C[56][24] = 51;    Qij_C[56][25] = 0;   Qij_C[56][26] = 50; Qij_C[56][27] = 1302;   Qij_C[56][28] = 59;    Qij_C[56][29] = 9;   Qij_C[56][30] = 17;  Qij_C[56][31] = 147;   Qij_C[56][32] = 13;    Qij_C[56][33] = 9;    Qij_C[56][34] = 3;   Qij_C[56][35] = 41;   Qij_C[56][36] = 87;   Qij_C[56][37] = 22;   Qij_C[56][38] = 96;  Qij_C[56][39] = 203;   Qij_C[56][40] = 34;   Qij_C[56][41] = 38;   Qij_C[56][42] = 42;  Qij_C[56][43] = 515;   Qij_C[56][44] = 52;   Qij_C[56][45] = 28;   Qij_C[56][46] = 54;  Qij_C[56][47] = 108;    Qij_C[56][48] = 0; Qij_C[56][49] = 1025;    Qij_C[56][50] = 238;    Qij_C[56][51] = 0;   Qij_C[56][52] = 90; Qij_C[56][53] = 1004;   Qij_C[56][54] = 29318; Qij_C[56][55] = 186;    Qij_C[56][56] = 0;   Qij_C[56][57] = 81;   Qij_C[56][58] = 30;   Qij_C[56][59] = 96;  Qij_C[56][60] = 378;
		Qij_C[57][0] = 59;   	Qij_C[57][1] = 4;    	Qij_C[57][2] = 4;   	Qij_C[57][3] = 48;  	Qij_C[57][4] = 295;  	Qij_C[57][5] = 3;   	Qij_C[57][6] = 49;   Qij_C[57][7] = 67;   Qij_C[57][8] = 87;   	Qij_C[57][9] = 33;   	Qij_C[57][10] = 51;    	Qij_C[57][11] = 0; 	Qij_C[57][12] = 3243;  	Qij_C[57][13] = 111;  	Qij_C[57][14] = 536;  Qij_C[57][15] = 201;   Qij_C[57][16] = 93;    Qij_C[57][17] = 5;   Qij_C[57][18] = 50;   Qij_C[57][19] = 80;   Qij_C[57][20] = 99;   Qij_C[57][21] = 18;   Qij_C[57][22] = 11;    Qij_C[57][23] = 7;    Qij_C[57][24] = 0;   Qij_C[57][25] = 40;    Qij_C[57][26] = 2;   Qij_C[57][27] = 49; Qij_C[57][28] = 26307; Qij_C[57][29] = 3595; Qij_C[57][30] = 4180; Qij_C[57][31] = 4065;   Qij_C[57][32] = 32;   Qij_C[57][33] = 16;   Qij_C[57][34] = 20;    Qij_C[57][35] = 0;  Qij_C[57][36] = 293;   Qij_C[57][37] = 42;    Qij_C[57][38] = 0;   Qij_C[57][39] = 43;   Qij_C[57][40] = 23;    Qij_C[57][41] = 0;    Qij_C[57][42] = 9;   Qij_C[57][43] = 44; Qij_C[57][44] = 3202;   Qij_C[57][45] = 73;    Qij_C[57][46] = 0;  Qij_C[57][47] = 175;   Qij_C[57][48] = 76;  Qij_C[57][49] = 127;   Qij_C[57][50] = 2230;   Qij_C[57][51] = 39;    Qij_C[57][52] = 0;   Qij_C[57][53] = 89;   Qij_C[57][54] = 46;   Qij_C[57][55] = 24;   Qij_C[57][56] = 81;    Qij_C[57][57] = 0;  Qij_C[57][58] = 609; Qij_C[57][59] = 22864;  Qij_C[57][60] = 787;
		Qij_C[58][0] = 6;   	Qij_C[58][1] = 34;   	Qij_C[58][2] = 0;    	Qij_C[58][3] = 0;   	Qij_C[58][4] = 11;   	Qij_C[58][5] = 74;   Qij_C[58][6] = 5;   	Qij_C[58][7] = 23;   Qij_C[58][8] = 2;   		Qij_C[58][9] = 34;    	Qij_C[58][10] = 0;    	Qij_C[58][11] = 0;   	Qij_C[58][12] = 33;  		Qij_C[58][13] = 356;   	Qij_C[58][14] = 89;   Qij_C[58][15] = 29;   Qij_C[58][16] = 18;  Qij_C[58][17] = 166;   Qij_C[58][18] = 13;   Qij_C[58][19] = 22;   Qij_C[58][20] = 12;   Qij_C[58][21] = 82;    Qij_C[58][22] = 3;    Qij_C[58][23] = 0;    Qij_C[58][24] = 0;   Qij_C[58][25] = 56;    Qij_C[58][26] = 8;    Qij_C[58][27] = 7;  Qij_C[58][28] = 106; Qij_C[58][29] = 1293;  Qij_C[58][30] = 136;    Qij_C[58][31] = 0;    Qij_C[58][32] = 2;   Qij_C[58][33] = 13;    Qij_C[58][34] = 4;    Qij_C[58][35] = 0;    Qij_C[58][36] = 0;   Qij_C[58][37] = 78;   Qij_C[58][38] = 59;   Qij_C[58][39] = 10;    Qij_C[58][40] = 1;   Qij_C[58][41] = 23;   Qij_C[58][42] = 11;    Qij_C[58][43] = 0;   Qij_C[58][44] = 13;  Qij_C[58][45] = 460;   Qij_C[58][46] = 42;    Qij_C[58][47] = 0; Qij_C[58][48] = 1911;  Qij_C[58][49] = 360;   Qij_C[58][50] = 11;  Qij_C[58][51] = 444;    Qij_C[58][52] = 0;    Qij_C[58][53] = 0;   Qij_C[58][54] = 275;   Qij_C[58][55] = 74;   Qij_C[58][56] = 30;  Qij_C[58][57] = 609;    Qij_C[58][58] = 0;  Qij_C[58][59] = 391; Qij_C[58][60] = 15594;
		Qij_C[59][0] = 28;   	Qij_C[59][1] = 22;   	Qij_C[59][2] = 39;   	Qij_C[59][3] = 36;   	Qij_C[59][4] = 92;   	Qij_C[59][5] = 39;  	Qij_C[59][6] = 306;  Qij_C[59][7] = 79;   Qij_C[59][8] = 13;    	Qij_C[59][9] = 0;   		Qij_C[59][10] = 36;   	Qij_C[59][11] = 47;  	Qij_C[59][12] = 833;   	Qij_C[59][13] = 27; 		Qij_C[59][14] = 1607;  Qij_C[59][15] = 399;   Qij_C[59][16] = 63;   Qij_C[59][17] = 20;   Qij_C[59][18] = 95;   Qij_C[59][19] = 27;   Qij_C[59][20] = 87;    Qij_C[59][21] = 3;  Qij_C[59][22] = 109;   Qij_C[59][23] = 72;   Qij_C[59][24] = 25;    Qij_C[59][25] = 0;   Qij_C[59][26] = 45;   Qij_C[59][27] = 98; Qij_C[59][28] = 6745; Qij_C[59][29] = 2691; Qij_C[59][30] = 13314; Qij_C[59][31] = 4641;   Qij_C[59][32] = 46;    Qij_C[59][33] = 0;   Qij_C[59][34] = 18;   Qij_C[59][35] = 16;   Qij_C[59][36] = 82;   Qij_C[59][37] = 24;  Qij_C[59][38] = 480;   Qij_C[59][39] = 68;    Qij_C[59][40] = 0;   Qij_C[59][41] = 15;  Qij_C[59][42] = 122;    Qij_C[59][43] = 0;  Qij_C[59][44] = 251;   Qij_C[59][45] = 35; Qij_C[59][46] = 1017;  Qij_C[59][47] = 236;   Qij_C[59][48] = 49;   Qij_C[59][49] = 41;  Qij_C[59][50] = 662;   Qij_C[59][51] = 51; Qij_C[59][52] = 2501;  Qij_C[59][53] = 133;   Qij_C[59][54] = 53;  Qij_C[59][55] = 357;   Qij_C[59][56] = 96; Qij_C[59][57] = 22864;  Qij_C[59][58] = 391;    Qij_C[59][59] = 0;  Qij_C[59][60] = 717;
		Qij_C[60][0] = 4;    	Qij_C[60][1] = 8;    	Qij_C[60][2] = 6;   	Qij_C[60][3] = 41;   	Qij_C[60][4] = 23;   	Qij_C[60][5] = 7;   	Qij_C[60][6] = 51;   Qij_C[60][7] = 82;   Qij_C[60][8] = 10;   	Qij_C[60][9] = 10;   	Qij_C[60][10] = 12;   	Qij_C[60][11] = 49;  	Qij_C[60][12] = 157;   	Qij_C[60][13] = 23;  		Qij_C[60][14] = 126;  Qij_C[60][15] = 437;   Qij_C[60][16] = 35;   Qij_C[60][17] = 36;   Qij_C[60][18] = 11;  Qij_C[60][19] = 172;    Qij_C[60][20] = 0;    Qij_C[60][21] = 0;   Qij_C[60][22] = 26;   Qij_C[60][23] = 97;    Qij_C[60][24] = 8;    Qij_C[60][25] = 0;   Qij_C[60][26] = 10;   Qij_C[60][27] = 70;  Qij_C[60][28] = 112;    Qij_C[60][29] = 0;  Qij_C[60][30] = 186; Qij_C[60][31] = 1304;    Qij_C[60][32] = 8;    Qij_C[60][33] = 0;    Qij_C[60][34] = 3;   Qij_C[60][35] = 14;   Qij_C[60][36] = 39;    Qij_C[60][37] = 1;   Qij_C[60][38] = 19;   Qij_C[60][39] = 89;   Qij_C[60][40] = 15;    Qij_C[60][41] = 9;    Qij_C[60][42] = 2;   Qij_C[60][43] = 32;   Qij_C[60][44] = 83;    Qij_C[60][45] = 6;   Qij_C[60][46] = 60;  Qij_C[60][47] = 446;  Qij_C[60][48] = 300; Qij_C[60][49] = 2355;   Qij_C[60][50] = 77;    Qij_C[60][51] = 0;   Qij_C[60][52] = 99;  Qij_C[60][53] = 476;   Qij_C[60][54] = 60;  Qij_C[60][55] = 102;  Qij_C[60][56] = 378;  Qij_C[60][57] = 787; Qij_C[60][58] = 15594;  Qij_C[60][59] = 717;    Qij_C[60][60] = 0;

		Qij_CF[0] = 0.02822690;		Qij_CF[1] = 0.02061369;		Qij_CF[2] = 0.03188328;		Qij_CF[3] = 0.01823573;		Qij_CF[4] = 0.01687049;		Qij_CF[5] = 0.01596372;		Qij_CF[6] = 0.00588962;		Qij_CF[7] = 0.01439150;		Qij_CF[8] = 0.01350151;	
		Qij_CF[9] = 0.01905801;		Qij_CF[10] = 0.01184545;	Qij_CF[11] = 0.01362231;	Qij_CF[12] = 0.00936364;	Qij_CF[13] = 0.01995639;	Qij_CF[14] = 0.02187084;	Qij_CF[15] = 0.01746871;	Qij_CF[16] = 0.01366905;	Qij_CF[17] = 0.01437178;
		Qij_CF[18] = 0.03367871;	Qij_CF[19] = 0.01159197;	Qij_CF[20] = 0.01775514;	Qij_CF[21] = 0.01498936;	Qij_CF[22] = 0.00587931;	Qij_CF[23] = 0.01759862;	Qij_CF[24] = 0.00618492;	Qij_CF[25] = 0.00871203;	Qij_CF[26] = 0.00848822;
		Qij_CF[27] = 0.00541856;	Qij_CF[28] = 0.00803094;	Qij_CF[29] = 0.01733987;	Qij_CF[30] = 0.03732844;	Qij_CF[31] = 0.01501680;	Qij_CF[32] = 0.03109312;	Qij_CF[33] = 0.02458593;	Qij_CF[34] = 0.03886758;	Qij_CF[35] = 0.02516743;
		Qij_CF[36] = 0.01789650;	Qij_CF[37] = 0.02126045;	Qij_CF[38] = 0.00596404;	Qij_CF[39] = 0.01995207;	Qij_CF[40] = 0.01843678;	Qij_CF[41] = 0.01760767;	Qij_CF[42] = 0.01326870;	Qij_CF[43] = 0.01154937;	Qij_CF[44] = 0.00837208;
		Qij_CF[45] = 0.01375960;	Qij_CF[46] = 0.02650595;	Qij_CF[47] = 0.01359241;	Qij_CF[48] = 0.01598757;	Qij_CF[49] = 0.01319572;	Qij_CF[50] = 0.01333971;	Qij_CF[51] = 0.01596570;	Qij_CF[52] = 0.00432501;	Qij_CF[53] = 0.01711480;
		Qij_CF[54] = 0.01190004;	Qij_CF[55] = 0.01246153;	Qij_CF[56] = 0.01098177;	Qij_CF[57] = 0.00852088;	Qij_CF[58] = 0.01957246;	Qij_CF[59] = 0.01412514;	Qij_CF[60] = 0.01906532;
		
		}
	else if (doECMuser == YES)
		{
		/*fprintf (stderr, "\n\nIn Empirical_codon_model function: USER FILE \n");*/		

		for (i = 0; i < NUMCOD; i++)
			for (j = 0; j < NUMCOD; j++)
				{
				Qij_C[i][j] = Qij_CodUser[i][j];
				}
		for (j = 0; j < NUMCOD; j++)
			Qij_CF[j] = FreqsCodUser[j];

		/* Qij_CodUser[NUMCOD][NUMCOD], FreqsCodUser[NUMCOD]; */
		}
	else
		{
		fprintf (stderr, "\n\nWarning in Empirical_codon_model function: The Empirical codon model was not detected \n");		
		exit(-1);
		}


	
	/* Active to see the Qij matrix */
	/*fprintf (stderr, "\nIn the matrix Qij_C (Empirical_codon_model):\n");
	for (i = 0; i < NUMCOD; i++)
		for (j = 0; j < NUMCOD; j++)
			{
			fprintf (stderr, "%lf ", Qij_C[i][j]);
			if (j == NUMCOD-1)
				fprintf (stderr, "\n");
			}

	fprintf (stderr, "\nFrequencies:\n");
	for (j = 0; j < NUMCOD; j++)
		{
		fprintf (stderr, "%lf ", Qij_CF[j]);
		}
	fprintf (stderr, "\n");*/

	/*fprintf (stderr, "\n End of Empirical_codon_model function: OK \n"); */


	}








/************************** giveAAcontribution *************************/
/* It calculates the aa contribution for the GY94 codon models */
double giveAAcontribution (int x, int y)
	{
	double contributionValue, sumPi_AAc;
	int codoni, codonj, aai, aaj, OKaai, OKaaj;
	int i, j;

	contributionValue = 1.0;
	/*fprintf (stderr, "\nIn giveAAcontribution function \n");*/	


	codoni = x;
	codonj = y;
	
	/* 
	 0:AAA  1:AAC  2:AAG  3:AAT	 4:ACA	5:ACC  6:ACG  7:ACT  8:AGA  9:AGC
	10:AGG 11:AGT 12:ATA 13:ATC 14:ATG 15:ATT 16:CAA 17:CAC 18:CAG 19:CAT
	20:CCA 21:CCC 22:CCG 23:CCT 24:CGA 25:CGC 26:CGG 27:CGT 28:CTA 29:CTC
	30:CTG 31:CTT 32:GAA 33:GAC 34:GAG 35:GAT 36:GCA 37:GCC 38:GCG 39:GCT
	40:GGA 41:GGC 42:GGG 43:GGT 44:GTA 45:GTC 46:GTG 47:GTT 48:TAC 49:TAT
	50:TCA 51:TCC 52:TCG 53:TCT 54:TGC 55:TGG 56:TGT 57:TTA 58:TTC 59:TTG
	60:TTT 
	*/
	/* 0:A 1:R 2:N 3:D 4:C 5:Q 6:E 7:G 8:H 9:I 10:L 11:K 12:M 13:F 14:P 15:S 16:T 17:W 18:Y 19:V */	


	/*
	 ----------------------------------------------  
	 Phe F TTT | Ser S TCT | Tyr Y TAT | Cys C TGT   
    	   TTC |       TCC |       TAC |       TGC   
	 Leu L TTA |       TCA | End * TAA | End * TGA   
    	   TTG |       TCG |       TAG | Trp W TGG   
	 ----------------------------------------------  
	 Leu L CTT | Pro P CCT | His H CAT | Arg R CGT   
    	   CTC |       CCC |       CAC |       CGC   
 		   CTA |       CCA | Gln Q CAA |       CGA   
    	   CTG |       CCG |       CAG |       CGG   
	 ----------------------------------------------  
	 Ile I ATT | Thr T ACT | Asn N AAT | Ser S AGT   
   		   ATC |       ACC |       AAC |       AGC   
   		   ATA |       ACA | Lys K AAA | Arg R AGA   
 	 Met M ATG |       ACG |       AAG |       AGG   
 	 ----------------------------------------------  
	 Val V GTT | Ala A GCT | Asp D GAT | Gly G GGT   
   		   GTC |       GCC |       GAC |       GGC   
 		   GTA |       GCA | Glu E GAA |       GGA   
    	   GTG |       GCG |       GAG |       GGG   
	 ---------------------------------------------- 
	*/

	/*
	codon currentAA -> OkAA
	AAA = AAG 	 	14 -> 11
	AAC = AAT 	 	13 -> 2
	ATG				4 -> 12
	ATA = ATC = ATT 3 -> 9
	AGA = AGG		19 -> 1
	AGC = AGT 		6 -> 15
	AC_ 			8 -> 16
	TAA = TAG = 25 (stop)
	TAC = TAT 		10 -> 18
	TTA = TTG 		2 -> 10
	TTC = TTT 		1 -> 13
	TGA 25 (stop)
	TGC = TGT 		17 -> 4
	TGG 			18 -> 17
	TC_ 			6 -> 15
	CAA = CAG 		12 -> 5
	CAC = CAT 		11 -> 8
	CT_ 			2 -> 10
	CG_ 			19 -> 1
	CC_ 			7 -> 14
	GAA = GAG		16 -> 6
	GAC = GAT		15 -> 3
	GT_ 			5 -> 19
	GG_ 			0 -> 7
	GC_ 			9 -> 0
	*/
	
	/* get the amino acid derived from this codon */
	aai = codonTable_DnDs(codoni);
	aaj = codonTable_DnDs(codonj);
	
	/* Adating order to empirical amino acid matrices */
 
	if (aai == 0)
		OKaai = 7;
	else if (aai == 1)
		OKaai = 13;
	else if (aai == 2)
		OKaai = 10;
	else if (aai == 3)
		OKaai = 9;
	else if (aai == 4)
		OKaai = 12;
	else if (aai == 5)
		OKaai = 19;
	else if (aai == 6)
		OKaai = 15;
	else if (aai == 7)
		OKaai = 14;
	else if (aai == 8)
		OKaai = 16;
	else if (aai == 9)
		OKaai = 0;
	else if (aai == 10)
		OKaai = 18;
	else if (aai == 11)
		OKaai = 8;
	else if (aai == 12)
		OKaai = 5;
	else if (aai == 13)
		OKaai = 2;
	else if (aai == 14)
		OKaai = 11;
	else if (aai == 15)
		OKaai = 3;
	else if (aai == 16)
		OKaai = 6;
	else if (aai == 17)
		OKaai = 4;
	else if (aai == 18)
		OKaai = 17;
	else if (aai == 19)
		OKaai = 1;
	else
		{
		fprintf (stderr, "\nError1 in giveAAcontribution function: aa (%d)\n", aai);		
		exit(-1);
		}
	
	
	if (aaj == 0)
		OKaaj = 7;
	else if (aaj == 1)
		OKaaj = 13;
	else if (aaj == 2)
		OKaaj = 10;
	else if (aaj == 3)
		OKaaj = 9;
	else if (aaj == 4)
		OKaaj = 12;
	else if (aaj == 5)
		OKaaj = 19;
	else if (aaj == 6)
		OKaaj = 15;
	else if (aaj == 7)
		OKaaj = 14;
	else if (aaj == 8)
		OKaaj = 16;
	else if (aaj == 9)
		OKaaj = 0;
	else if (aaj == 10)
		OKaaj = 18;
	else if (aaj == 11)
		OKaaj = 8;
	else if (aaj == 12)
		OKaaj = 5;
	else if (aaj == 13)
		OKaaj = 2;
	else if (aaj == 14)
		OKaaj = 11;
	else if (aaj == 15)
		OKaaj = 3;
	else if (aaj == 16)
		OKaaj = 6;
	else if (aaj == 17)
		OKaaj = 4;
	else if (aaj == 18)
		OKaaj = 17;
	else if (aaj == 19)
		OKaaj = 1;
	else
		{
		fprintf (stderr, "\nError2 in giveAAcontribution function: aa (%d)\n", aaj);		
		exit(-1);
		}
	
	/** OKaai, OKaaj **/
	/* empirical amino acid matrices are partially activated for getting values from matrices */
	if (doGY94xBlosum62 == YES)
		doBlosum62 = YES;
	else if (doGY94xCpRev == YES)
		doCpRev = YES;
	else if (doGY94xDayhoff == YES)
		doDayhoff = YES;
	else if (doGY94xDayhoffDCMUT == YES)
		doDayhoffDCMUT = YES;
	else if (doGY94xHIVb == YES)
		doHIVb = YES;
	else if (doGY94xHIVw == YES)
		doHIVw = YES;
	else if (doGY94xJTT == YES)
		doJTT = YES;
	else if (doGY94xJonesDCMUT == YES)
		doJonesDCMUT = YES;
	else if (doGY94xLG == YES)
		doLG = YES;
	else if (doGY94xMtart == YES)
		doMtart = YES;
	else if (doGY94xMtmam == YES)
		doMtmam = YES;
	else if (doGY94xMtrev24 == YES)
		doMtrev24 = YES;
	else if (doGY94xRtRev == YES)
		doRtRev = YES;
	else if (doGY94xVT == YES)
		doVT = YES;
	else if (doGY94xWAG == YES)
		doWAG = YES;
	else if (doGY94xEAAMUser == YES)
		doEAAMUser = YES;
	else
		{
		fprintf (stderr, "\nError3 in giveAAcontribution function: Amino acid matrix not found. \n");		
		exit(-1);
		}

	Empirical_AA_model();

	doAAmodel = NO;
	doBlosum62 = NO;
	doCpRev = NO;
	doDayhoff = NO;
	doDayhoffDCMUT = NO;
	doHIVb = NO;
	doHIVw = NO;
	doJTT = NO;
	doJonesDCMUT = NO;
	doLG = NO;
	doMtart = NO;
	doMtmam = NO;
	doMtrev24 = NO;
	doRtRev = NO;
	doVT = NO;
	doWAG = NO;
	doEAAMUser = NO;


	/* Qij_AA[i][j], AA_EM_Pi[j] */
		
	/* check if the matrix is symmetric: [0][1] = [1][0] */
	for (i = 0; i < NUMAA; i++)
		for (j = 0; j < NUMAA; j++)
			{
			if (i == j) /* cjeck main diagonal, should be = 0 */
				{
				if (Qij_AA[i][j] > 0.00000000001 || Qij_AA[i][j] < -0.00000000001)
					{
					if (noisy > 3)
						fprintf (stderr, "\n\n> Warning in the emperical amino acid matrix (giveAAcontribution function). Main diagonal is different to 0: Q[%d][%d] = %lf \n\n", i, j, Qij_AA[i][j]);
					}
				}
			else /* [0][1] = [1][0] */
				{
				if (Qij_AA[i][j] != Qij_AA[j][i])
					{
					if (noisy > 3)
						fprintf (stderr, "\n\n> Warning in the emperical amino acid matrix (giveAAcontribution function). Matrix is not symmetric: Q[%d][%d] (%lf) = Q[%d][%d] (%lf) \n\n", i, j, Qij_AA[i][j], j, i, Qij_AA[j][i]);
					}

				}			
			}


	/* Active to see the EAAM Qij matrix and Freqs */
	/*fprintf (stderr, "\nIn the matrix Qij_AA:\n");
	for (i = 0; i < NUMAA; i++)
		for (j = 0; j < NUMAA; j++)
			{
			fprintf (stderr, "Qij_AA[%d][%d] = %lf ", i, j, Qij_AA[i][j]);
			if (j == NUMAA-1)
				fprintf (stderr, "\n");
			}
	for (j = 0; j < NUMAA; j++)
		{
		fprintf (stderr, "\n Freqs: AA_EM_Pi[%d] = %lf ", j, AA_EM_Pi[j]);
		}*/


	/** 2. Add frequencies **/
	/* Frequencies from the EAAM are used */
	/* 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 */
	/* A R N D C Q E G H I L K M F P S T W Y V */
	
	/* check */
	for (i = 0; i < NUMAA; i++) 
		if (AA_EM_Pi[i] < 0 || AA_EM_Pi[i] > 1)
			{
			fprintf (stderr, "ERROR: Bad number of EAAM frequencies (it must to be between 0 and 1) (%lf). giveAAcontribution function \n\n", AA_EM_Pi[i]);
			PrintUsage();
			}

	/* Freqs must sum 1 */
	sumPi_AAc = 0.0;
	for (i = 0; i < NUMAA; i++)
		{
		sumPi_AAc = sumPi_AAc + AA_EM_Pi[i];
		}
	if (sumPi_AAc != 1.0) 
		{
		for (i = 0; i < NUMAA; i++)
			{
			AA_EM_Pi[i]/=sumPi_AAc;
			}
		}

	/* see freqs */
	/*for (j = 0; j < NUMAA; j++)
		{
		fprintf (stderr, "\n Freqs: AA_EM_Pi[%d] = %lf ", j, AA_EM_Pi[j]);
		}*/

	for (i = 0; i < NUMAA; i++)
		{
		for (j = 0; j < NUMAA; j++)
			{
			Qij_AA[i][j] = Qij_AA[i][j]*AA_EM_Pi[j];
			}
		}
		
	/* Matrix is ready for taking the amino acid contribution: Qij_AA[i][j] */
	contributionValue = Qij_AA[OKaai][OKaaj];


	/*fprintf(stderr,"\n Codon change %d %d -> AA: %d %d -> AAok: %d %d; contributionValue = %lf \n", codoni, codonj, aai, aaj, OKaai, OKaaj, contributionValue);*/
	return contributionValue;
	}












/************************** makeCodonFromNuc *************************/
/* It Builds the codon from the 3 nucleotides (numbers). It returns the codon number from the three nucleotides number */
int makeCodonFromNuc (int x, int y, int z)
	{

	if ( x < 0 || x > 3 || y < 0 || y > 3 || z < 0 || z > 3)
		{
		fprintf (fpmpi, "\nWarning in makeCodonFromNuc function.");		
		exit(-1);
		}
		
	if (x == 0)
		{
		if (y == 0)
			{
			if (z == 0)
				return (0); /* AAA */
			else if (z == 1)
				return (1); /* AAC */
			else if (z == 2)
				return (2); /* AAG */
			else
				return (3); /* AAT */
			}
		else if (y == 1)
			{
			if (z == 0)
				return (4); /* ACA */
			else if (z == 1)
				return (5); /* ACC */
			else if (z == 2)
				return (6); /* ACG */
			else
				return (7); /* ACT */
			}
		else if (y == 2)
			{
			if (z == 0)
				return (8); /* AGA */
			else if (z == 1)
				return (9); /* AGC */
			else if (z == 2)
				return (10); /* AGG */
			else
				return (11); /* AGT */
			}
		else
			{
			if (z == 0)
				return (12); /* ATA */
			else if (z == 1)
				return (13); /* ATC */
			else if (z == 2)
				return (14); /* ATG */
			else
				return (15); /* ATT */
			}
		}
	else if (x == 1)
		{
		if (y == 0)
			{
			if (z == 0)
				return (16); /* CAA */
			else if (z == 1)
				return (17); /* CAC */
			else if (z == 2)
				return (18); /* CAG */
			else
				return (19); /* CAT */
			}
		else if (y == 1)
			{
			if (z == 0)
				return (20); /* CCA */
			else if (z == 1)
				return (21); /* CCC */
			else if (z == 2)
				return (22); /* CCG */
			else
				return (23); /* CCT */
			}
		else if (y == 2)
			{
			if (z == 0)
				return (24); /* CGA */
			else if (z == 1)
				return (25); /* CGC */
			else if (z == 2)
				return (26); /* CGG */
			else
				return (27); /* CGT */
			}
		else
			{
			if (z == 0)
				return (28); /* CTA */
			else if (z == 1)
				return (29); /* CTC */
			else if (z == 2)
				return (30); /* CTG */
			else
				return (31); /* CTT */
			}
		}
	else if (x == 2)
		{
		if (y == 0)
			{
			if (z == 0)
				return (32); /* GAA */
			else if (z == 1)
				return (33); /* GAC */
			else if (z == 2)
				return (34); /* GAG */
			else
				return (35); /* GAT */
			}
		else if (y == 1)
			{
			if (z == 0)
				return (36); /* GCA */
			else if (z == 1)
				return (37); /* GCC */
			else if (z == 2)
				return (38); /* GCG */
			else
				return (39); /* GCT */
			}
		else if (y == 2)
			{
			if (z == 0)
				return (40); /* GGA */
			else if (z == 1)
				return (41); /* GGC */
			else if (z == 2)
				return (42); /* GGG */
			else
				return (43); /* GGT */
			}
		else
			{
			if (z == 0)
				return (44); /* GTA */
			else if (z == 1)
				return (45); /* GTC */
			else if (z == 2)
				return (46); /* GTG */
			else
				return (47); /* GTT */
			}
		}
	else								/* changing to 61 codons erasing the stop codons */
		{
		if (y == 0)
			{
			if (z == 0) /* TAA */	/* STOP CODON!! */
				{				
				fprintf (fpmpi, "\n warning in makeCodonFromNuc by an TAA stop codon");
				exit (-1);
				} 
			else if (z == 1)
				return (48); /* TAC */
			else if (z == 2) /* TAG */	/* STOP CODON!! */
				{
				fprintf (fpmpi, "\n warning in makeCodonFromNuc by an TAG stop codon");				
				exit (-1);
				}
			else
				return (49); /* TAT */
			}
		else if (y == 1)
			{
			if (z == 0)
				return (50); /* TCA */
			else if (z == 1)
				return (51); /* TCC */
			else if (z == 2)
				return (52); /* TCG */
			else
				return (53); /* TCT */
			}
		else if (y == 2)
			{
			if (z == 0) /* TGA */	/* STOP CODON!! */
				{				
				fprintf (fpmpi, "\n warning in makeCodonFromNuc by an TGA stop codon");
				exit (-1);
				}
			else if (z == 1)
				return (54); /* TGC */
			else if (z == 2)
				return (55); /* TGG */
			else
				return (56); /* TGT */
			}
		else
			{
			if (z == 0)
				return (57); /* TTA */
			else if (z == 1)
				return (58); /* TTC */
			else if (z == 2)
				return (59); /* TTG */
			else
				return (60); /* TTT */
			}
		}
	return (61);
	}




/************************* codonTable_frequencies_MRCA ***************************/
/******** adapted from codontable function written by Rasmus Nielsen **********/
/* This function generates the frequencies for each codon. */

double codonTable_frequencies_MRCA(int cod)
	{
	/*A = 0, C = 1, G = 2, T = 3*/
	int i, j;
	double b;
	double A[3], C[3], G[3], T[3];
	
	j = 0;
	
	
	for (i = 0; i < 3; i++)
		{
		A[i] = p_i_codon[i+j];
		C[i] = p_i_codon[i+1+j];
		G[i] = p_i_codon[i+2+j];
		T[i] = p_i_codon[i+3+j];
		j = j+3;		
		/*fprintf (fpmpi, "\n A[%d] = %lf, C[%d] = %lf, G[%d] = %lf, T[%d] = %lf", i, A[i], i, C[i], i, G[i], i, T[i]);*/
		}
	
	if (cod > 63)
		{		
		fprintf (fpmpi, "\n Warning in codonTable_frequencies_MRCA function. cod >= 64.");
		return -1;
		}
	if (cod < 16){									/*** A ***/
		if (cod < 4){								
			if (cod == 0) b = A[0]*A[1]*A[2];		/* AAA */
			else if (cod == 1) b = A[0]*A[1]*C[2];	/* AAC */
			else if (cod == 2) b = A[0]*A[1]*G[2];	/* AAG */
			else b = A[0]*A[1]*T[2];				/* AAT */
			}
		else if (cod > 11){								
			cod = cod - 12;
			if (cod == 0) b = A[0]*T[1]*A[2];		/* ATA */
			else if (cod == 1) b = A[0]*T[1]*C[2];	/* ATC */
			else if (cod == 2) b = A[0]*T[1]*G[2];	/* ATG */
			else b = A[0]*T[1]*T[2];				/* ATT */
			}
		else if (cod > 7){								
			cod = cod - 8;
			if (cod == 0) b = A[0]*G[1]*A[2];		/* AGA */
			else if (cod == 1) b = A[0]*G[1]*C[2];	/* AGC */
			else if (cod == 2) b = A[0]*G[1]*G[2];	/* AGG */
			else b = A[0]*G[1]*T[2];				/* AGT */
			}
		else {
			if (cod == 4) b = A[0]*C[1]*A[2];		/* ACA */
			else if (cod == 5) b = A[0]*C[1]*C[2];	/* ACC */
			else if (cod == 6) b = A[0]*C[1]*G[2];	/* ACG */
			else b = A[0]*C[1]*T[2];				/* ACT */
			}
		}
	else if (cod > 47){								/*** T ***/
		cod = cod - 48;	
		if (cod < 4){										
			if (cod == 0) 
				{
				b = T[0]*A[1]*A[2];		/* TAA */		/* STOP CODON!! */
				b = 0.0;
				}
			else if (cod == 1) b = T[0]*A[1]*C[2];	/* TAC */
			else if (cod == 2)
				{
				b = T[0]*A[1]*G[2];	/* TAG */		/* STOP CODON!! */
				b = 0.0;
				}
			else b = T[0]*A[1]*T[2];				/* TAT */
			}
		else if (cod > 11){								
			cod = cod - 12;
			if (cod == 0) b = T[0]*T[1]*A[2];		/* TTA */
			else if (cod == 1) b = T[0]*T[1]*C[2];	/* TTC */
			else if (cod == 2) b = T[0]*T[1]*G[2];	/* TTG */
			else b = T[0]*T[1]*T[2];				/* TTT */
			}
		else if (cod > 7){							
			cod = cod - 8;
			if (cod == 0) 
				{
				b = T[0]*G[1]*A[2];		/* TGA */		/* STOP CODON!! */
				b = 0.0;
				}
			else if (cod == 1) b = T[0]*G[1]*C[2];	/* TGC */
			else if (cod == 2) b = T[0]*G[1]*G[2];	/* TGG */
			else b = T[0]*G[1]*T[2];				/* TGT */
			}
		else {
			if (cod == 52) b = T[0]*C[1]*A[2];		/* TCA */
			else if (cod == 53) b = T[0]*C[1]*C[2];	/* TCC */
			else if (cod == 54) b = T[0]*C[1]*G[2];	/* TCG */
			else b = T[0]*C[1]*T[2];				/* TCT */
			}									   	
		}
	else if (cod < 32){								/*** C ***/
		cod = cod - 16;
		if (cod < 4){								
			if (cod == 0) b = C[0]*A[1]*A[2];		/* CAA */
			else if (cod == 1) b = C[0]*A[1]*C[2];	/* CAC */
			else if (cod == 2) b = C[0]*A[1]*G[2];	/* CAG */
			else b = C[0]*A[1]*T[2];				/* CAT */
			}
		else if (cod > 11){ 
			if (cod == 28) b = C[0]*T[1]*A[2];		/* CTA */
			else if (cod == 29) b = C[0]*T[1]*C[2];	/* CTC */
			else if (cod == 30) b = C[0]*T[1]*G[2];	/* CTG */
			else b = C[0]*T[1]*T[2];				/* CTT */
			}
		else if (cod > 7){ 
			if (cod == 24) b = C[0]*G[1]*A[2];		/* CGA */
			else if (cod == 25) b = C[0]*G[1]*C[2];	/* CGC */
			else if (cod == 26) b = C[0]*G[1]*G[2];	/* CGG */
			else b = C[0]*G[1]*T[2];				/* CGT */
			}							
		else {
			if (cod == 20) b = C[0]*C[1]*A[2];		/* CCA */
			else if (cod == 21) b = C[0]*C[1]*C[2];	/* CCC */
			else if (cod == 22) b = C[0]*C[1]*G[2];	/* CCG */
			else b = C[0]*C[1]*T[2];				/* CCT */
			}											
		}
	else if (cod > 31 && cod < 48){					/*** G ***/
		cod = cod - 32;
		if (cod < 4){									
			if (cod == 0) b = G[0]*A[1]*A[2];		/* GAA */
			else if (cod == 1) b = G[0]*A[1]*C[2];	/* GAC */
			else if (cod == 2) b = G[0]*A[1]*G[2];	/* GAG */
			else b = G[0]*A[1]*T[2];				/* GAT */
			}
		else if (cod > 11){
			if (cod == 44) b = G[0]*T[1]*A[2];		/* GTA */
			else if (cod == 45) b = G[0]*T[1]*C[2];	/* GTC */
			else if (cod == 46) b = G[0]*T[1]*G[2];	/* GTG */
			else b = G[0]*T[1]*T[2];				/* GTT */
			}							
		else if (cod > 7){
			if (cod == 40) b = G[0]*G[1]*A[2];		/* GGA */
			else if (cod == 41) b = G[0]*G[1]*C[2];	/* GGC */
			else if (cod == 42) b = G[0]*G[1]*G[2];	/* GGG */
			else b = G[0]*G[1]*T[2];				/* GGT */
			}											
		else{
			if (cod == 36) b = G[0]*C[1]*A[2];		/* GCA */
			else if (cod == 37) b = G[0]*C[1]*C[2];	/* GCC */
			else if (cod == 38) b = G[0]*C[1]*G[2];	/* GCG */
			else b = G[0]*C[1]*T[2];				/* GCT */
			}				 										
		}
	else {
			fprintf (fpmpi, "error in codonTable_frequencies_MRCA function\n"); 
			exit(-1);
		}
	
	/*fprintf (fpmpi, "\n In codonTable_frequencies_MRCA, cod = %d, b = %lf", cod, b);*/
	
	return b;
	}


/************************* codonTable_frequencies ***************************/
/******** adapted from codontable function written by Rasmus Nielsen **********/
/* This function generates the frequencies for each codon. */

double codonTable_frequencies(int cod)
	{
	/*A = 0, C = 1, G = 2, T = 3*/
	int i, j;
	double b;
	double A[3], C[3], G[3], T[3];
	
	j = 0;
	
	/*
	fprintf (fpmpi, "\n In codonTable_frequencies, cod = %d,", cod);
	*/
	
	
	for (i = 0; i < 3; i++)
		{
		A[i] = p_i_codon[i+j];
		C[i] = p_i_codon[i+1+j];
		G[i] = p_i_codon[i+2+j];
		T[i] = p_i_codon[i+3+j];
		j = j+3;
		
		/*
		fprintf (fpmpi, "\n A[%d] = %lf, C[%d] = %lf, G[%d] = %lf, T[%d] = %lf", i, A[i], i, C[i], i, G[i], i, T[i]);		
		*/
		}

	
	if (cod > 60)
		return -1;
	if (cod>=48)
		cod++;
	if (cod>=50)
		cod++;
	if (cod>=56)
		cod++;
	if (cod < 16){									/*** A ***/
		if (cod < 4){								
			if (cod == 0) b = A[0]*A[1]*A[2];		/* AAA */
			else if (cod == 1) b = A[0]*A[1]*C[2];	/* AAC */
			else if (cod == 2) b = A[0]*A[1]*G[2];	/* AAG */
			else b = A[0]*A[1]*T[2];				/* AAT */
			}
		else if (cod > 11){								
			cod = cod - 12;
			if (cod == 0) b = A[0]*T[1]*A[2];		/* ATA */
			else if (cod == 1) b = A[0]*T[1]*C[2];	/* ATC */
			else if (cod == 2) b = A[0]*T[1]*G[2];	/* ATG */
			else b = A[0]*T[1]*T[2];				/* ATT */
			}
		else if (cod > 7){								
			cod = cod - 8;
			if (cod == 0) b = A[0]*G[1]*A[2];		/* AGA */
			else if (cod == 1) b = A[0]*G[1]*C[2];	/* AGC */
			else if (cod == 2) b = A[0]*G[1]*G[2];	/* AGG */
			else b = A[0]*G[1]*T[2];				/* AGT */
			}
		else {
			if (cod == 4) b = A[0]*C[1]*A[2];		/* ACA */
			else if (cod == 5) b = A[0]*C[1]*C[2];	/* ACC */
			else if (cod == 6) b = A[0]*C[1]*G[2];	/* ACG */
			else b = A[0]*C[1]*T[2];				/* ACT */
			}
		}
	else if (cod > 47){								/*** T ***/
		cod = cod - 48;	
		if (cod < 4){										
			if (cod == 0) 
				{
				b = T[0]*A[1]*A[2];		/* TAA */		/* STOP CODON!! */
				b = 0.0;
				
				fprintf (fpmpi, "\n warning in codonTable_frequencies by an TAA stop codon");
				exit (-1);
				}
			else if (cod == 1) b = T[0]*A[1]*C[2];	/* TAC */
			else if (cod == 2)
				{
				b = T[0]*A[1]*G[2];	/* TAG */		/* STOP CODON!! */
				b = 0.0;
				
				fprintf (fpmpi, "\n warning in codonTable_frequencies by an TAG stop codon");
				exit (-1);
				}
			else b = T[0]*A[1]*T[2];				/* TAT */
			}
		else if (cod > 11){								
			cod = cod - 12;
			if (cod == 0) b = T[0]*T[1]*A[2];		/* TTA */
			else if (cod == 1) b = T[0]*T[1]*C[2];	/* TTC */
			else if (cod == 2) b = T[0]*T[1]*G[2];	/* TTG */
			else b = T[0]*T[1]*T[2];				/* TTT */
			}
		else if (cod > 7){							
			cod = cod - 8;
			if (cod == 0) 
				{
				b = T[0]*G[1]*A[2];		/* TGA */		/* STOP CODON!! */
				b = 0.0;
				
				fprintf (fpmpi, "\n warning in codonTable_frequencies by an TGA stop codon");				
				exit (-1);
				}
			else if (cod == 1) b = T[0]*G[1]*C[2];	/* TGC */
			else if (cod == 2) b = T[0]*G[1]*G[2];	/* TGG */
			else b = T[0]*G[1]*T[2];				/* TGT */
			}
		else {
			if (cod == 52) b = T[0]*C[1]*A[2];		/* TCA */
			else if (cod == 53) b = T[0]*C[1]*C[2];	/* TCC */
			else if (cod == 54) b = T[0]*C[1]*G[2];	/* TCG */
			else b = T[0]*C[1]*T[2];				/* TCT */
			}									   	
		}
	else if (cod < 32){								/*** C ***/
		cod = cod - 16;
		if (cod < 4){								
			if (cod == 0) b = C[0]*A[1]*A[2];		/* CAA */
			else if (cod == 1) b = C[0]*A[1]*C[2];	/* CAC */
			else if (cod == 2) b = C[0]*A[1]*G[2];	/* CAG */
			else b = C[0]*A[1]*T[2];				/* CAT */
			}
		else if (cod > 11){ 
			if (cod == 28) b = C[0]*T[1]*A[2];		/* CTA */
			else if (cod == 29) b = C[0]*T[1]*C[2];	/* CTC */
			else if (cod == 30) b = C[0]*T[1]*G[2];	/* CTG */
			else b = C[0]*T[1]*T[2];				/* CTT */
			}
		else if (cod > 7){ 
			if (cod == 24) b = C[0]*G[1]*A[2];		/* CGA */
			else if (cod == 25) b = C[0]*G[1]*C[2];	/* CGC */
			else if (cod == 26) b = C[0]*G[1]*G[2];	/* CGG */
			else b = C[0]*G[1]*T[2];				/* CGT */
			}							
		else {
			if (cod == 20) b = C[0]*C[1]*A[2];		/* CCA */
			else if (cod == 21) b = C[0]*C[1]*C[2];	/* CCC */
			else if (cod == 22) b = C[0]*C[1]*G[2];	/* CCG */
			else b = C[0]*C[1]*T[2];				/* CCT */
			}											
		}
	else if (cod > 31 && cod < 48){					/*** G ***/
		cod = cod - 32;
		if (cod < 4){									
			if (cod == 0) b = G[0]*A[1]*A[2];		/* GAA */
			else if (cod == 1) b = G[0]*A[1]*C[2];	/* GAC */
			else if (cod == 2) b = G[0]*A[1]*G[2];	/* GAG */
			else b = G[0]*A[1]*T[2];				/* GAT */
			}
		else if (cod > 11){
			if (cod == 44) b = G[0]*T[1]*A[2];		/* GTA */
			else if (cod == 45) b = G[0]*T[1]*C[2];	/* GTC */
			else if (cod == 46) b = G[0]*T[1]*G[2];	/* GTG */
			else b = G[0]*T[1]*T[2];				/* GTT */
			}							
		else if (cod > 7){
			if (cod == 40) b = G[0]*G[1]*A[2];		/* GGA */
			else if (cod == 41) b = G[0]*G[1]*C[2];	/* GGC */
			else if (cod == 42) b = G[0]*G[1]*G[2];	/* GGG */
			else b = G[0]*G[1]*T[2];				/* GGT */
			}											
		else{
			if (cod == 36) b = G[0]*C[1]*A[2];		/* GCA */
			else if (cod == 37) b = G[0]*C[1]*C[2];	/* GCC */
			else if (cod == 38) b = G[0]*C[1]*G[2];	/* GCG */
			else b = G[0]*C[1]*T[2];				/* GCT */
			}				 										
		}
	else {
			
		fprintf (fpmpi, "error in codonTable_frequencies function\n"); 			
		exit(-1);
		}
		
	return b;
	}






/****************************** codonTable_DnDs *******************************/
/******** adapted from codontable function written by Rasmus Nielsen **********/
/* This function generates the aminoacid for each codon. It can use to compare two codons and say if they are synonimous or nonsynonymous
For stop codons we will use b = 25 like the number of aa */
int codonTable_DnDs(int cod)
	{
	/*A = 0, C = 1, G = 2, T = 3*/
	int b;

	if (cod > 60)
		return -1;
	if (cod>=48)
		cod++;
	if (cod>=50)
		cod++;
	if (cod>=56)
		cod++;
	if (cod < 16){									/*A*/
		if (cod < 4){										/*A*/
			if (cod==3||cod==1) b=13;
			else b=14;
			}
		else if (cod > 11){								/*T*/
			cod = cod - 12;
			if (cod==2) b=4;
			else b=3;
			}
		else if (cod > 7){								/*G*/
			cod = cod - 8;
			if (cod==3||cod==1) b=6;
			else b=19;
			}
		else b=8;											/*C*/
		}
	else if (cod > 47){							/*T*/
		cod = cod - 48;	
		if (cod < 4){										/*A*/
			if (cod==3||cod==1) b=10;
			else 
				{
				b=25;	/* two stop codons */
				fprintf (stderr, "\n warning in codonTable_DnDs by a stop codon");
				exit (-1);
				}
			}
		else if (cod > 11){								/*T*/
			cod = cod - 12;
			if (cod==3||cod==1) b=1;
			else b=2;
			}
		else if (cod > 7){								/*G*/
			cod = cod - 8;
			if (cod==3||cod==1) b=17;
			else if (cod==0)
				{
				b=25; /* one stop codon */
				fprintf (stderr, "\n warning in codonTable_DnDs by a stop codon");
				exit (-1);
				}
			else b=18;
			}
		else b=6;									   	/*C*/
		}
	else if (cod < 32){							/*C*/
		cod = cod - 16;
		if (cod < 4){										/*A*/
			if (cod==3||cod==1) b=11;
			else b=12;
			}
		else if (cod > 11) b=2;							/*T*/
		else if (cod > 7) b=19;							/*G*/
		else b=7;											/*C*/
		}
	else if (cod > 31 && cod < 48){			/*G*/
		cod = cod - 32;
		if (cod < 4){										/*A*/
			if (cod==3||cod==1) b=15;
			else b=16;
			}
		else if (cod > 11) b=5;							/*T*/
		else if (cod > 7) b=0;							/*G*/
		else b=9;											/*C*/
		}
	else {fprintf (stderr, "error in codon table DnDs\n"); exit(-1);}
	return b;
	}



/****************************** numdif_codon *******************************/
/* adapted from numdif function written by Rasmus Nielsen */
/* Compare 2 codons by nucletotide diferences (return 0-3 diferences) */
int numdif_codon(int codon1, int codon2)
	{
	int i, returner = 0;
	double cod1[3], cod2[3];
	
	
	if (codon1>=48)
		codon1++;
	if (codon1>=50)
		codon1++;
	if (codon1>=56)
		codon1++;	
	if (codon2>=48)
		codon2++;
	if (codon2>=50)
		codon2++;
	if (codon2>=56)
		codon2++;
	cod1[0] = floor((double)codon1/16.0);
	cod1[1] = floor(((double)codon1 - 16.0*cod1[0])/4.0);
	cod1[2] = (double)codon1 - 4.0*cod1[1] - 16.0*cod1[0];
	cod2[0] = floor((double)codon2/16.0);
	cod2[1] = floor(((double)codon2 - 16.0*cod2[0])/4.0);
	cod2[2] = (double)codon2 - 4.0*cod2[1] - 16.0*cod2[0];
	for (i=0; i<3; i++)
		{
		if (cod1[i] != cod2[i])
			returner++;
		}
	return returner; /* 0, 1, 2 or 3 */
	}


/****************************** number_to_codon *******************************/
/* adapted from number_to_codon function written by Rasmus Nielsen */
/* from one codon number to the three nucleotides letters */
 void number_to_codon(int ind, char out[])
	{
	int i, codon[3];
	
	if (ind < 0) /* important check, not eraser */
		{
		fprintf (fpmpi, "\n Warning in number_to_codon: ind = %d", ind);
		exit (-1);
		}


	if (ind > 60)
		{
		fprintf (fpmpi, "\n stop codon in number_to_codon %d\n", ind); 
		exit(-1);
		}
	if (ind>=48)
		ind++;
	if (ind>=50)
		ind++;
	if (ind>=56)
		ind++;
	if (ind == 48 || ind == 50 || ind == 56) /* Cheking */
		{
		fprintf (fpmpi, "\n Warning in number_to_codon");
		exit (-1);
		}
	codon[0] = floor((double)ind/16.0);
	codon[1] = floor((ind - 16.0*(double)codon[0])/4.0);
	codon[2] = ind - 4*codon[1] - 16*codon[0];
	for (i=0; i<3; i++)
		{
		if (codon[i] == 0)
			out[i] = 'A';
		else if (codon[i] == 1)
			out[i] = 'C';
		else if (codon[i] == 2)
			out[i] = 'G';
		else if (codon[i] == 3)
			out[i] = 'T';
		else {			
			fprintf (fpmpi, "error in codon (%i)\n",ind); 			
			exit(-1);
			}
		}
	}


/****************************** number_to_codon2 *******************************/
/* adapted from number_to_codon function written by Rasmus Nielsen */
/* from one codon number to the three nucleotides letters */
 void number_to_codon2(int ind, int out[])
	{
	/*int i, codon[3];*/
	
	if (ind < 0) /* important check, not eraser */
		{
		fprintf (fpmpi, "\n Warning in number_to_codon2: ind = %d", ind);
		exit (-1);
		}


	if (ind > 60)
		{
		fprintf (fpmpi, "\n stop codon in number_to_codon2 %d\n", ind); 
		exit(-1);
		}
	if (ind>=48)
		ind++;
	if (ind>=50)
		ind++;
	if (ind>=56)
		ind++;
	if (ind == 48 || ind == 50 || ind == 56) /* Cheking */
		{
		fprintf (fpmpi, "\n Warning in number_to_codon2");
		exit (-1);
		}
	out[0] = floor((double)ind/16.0);
	out[1] = floor((ind - 16.0*(double)out[0])/4.0);
	out[2] = ind - 4*out[1] - 16*out[0];
	}









/****************************** number_to_codon_MRCA *******************************/
/* adapted from number_to_codon function written by Rasmus Nielsen */
/* from one codon number to the three nucleotides numbers for MRCA*/
 void number_to_codon_MRCA(int ind, int codon[])
	{
	codon[0] = floor((double)ind/16.0);
	codon[1] = floor((ind - 16.0*(double)codon[0])/4.0);
	codon[2] = ind - 4*codon[1] - 16*codon[0];
	}






/****************************** codon_tr_tv *******************************/
/* adapted from tr_tv function written by Rasmus Nielsen */
/* It determines, between two codons, if 1 mutation is a transversion or a transition 
(return 0 or 1. return 2 if the value for this codon change is null (several substitutions or main diagonal)).
 It's for the codon model version HKY */
 int codon_tr_tv(int indi, int indj)
	{
	char codon1[3], codon2[3];
	int i, cod1, cod2;
	
	if (indi > 60 || indj > 60)
		{
		fprintf (stderr, "\n stop codon1 \n");
		exit(-1);
		}
		
	number_to_codon(indi, codon1);
	number_to_codon(indj, codon2);
	
	for (i=0; i<3; i++)
		{
		if (codon1[i] != codon2[i])
			{
			if (codon1[i] == 'A' || codon1[i] == 'G')
				cod1 = 0;
			else cod1 = 1;
			if (codon2[i] == 'A' || codon2[i] == 'G')
				cod2 = 0;
			else cod2 = 1;
			return abs(cod1 - cod2);
			}
		}
	
	fprintf (stderr, "\nERROR IN codon_tr_tv function!!");
	exit(-1);
	return (0);
	}



/****************************** codon_Rmat *******************************/
/*determines, between two codons, the corresponding rate for the codon model version GTR. 
It returns the rate of the change between these codons*/
 double codon_Rmat(int indi, int indj)
	{
	char codon1[3], codon2[3];
	int i/*, k*/; /* Rmat[6] from parameters input file*/
	double rate;
	
	rate = 1.0;
	/*k = 0;*/
	
	number_to_codon(indi, codon1);
	number_to_codon(indj, codon2);
	if (indi > 60 || indj > 60)
		{
		fprintf (stderr, "\n stop codon2 \n");
		exit(-1);
		}
	
	for (i=0; i<3; i++)
		{
		if (codon1[i] != codon2[i]) /* Important for codon with just 1 difference (more than 1 difference will be null..) */
			{
			/*k++;*/
			if (codon1[i] == 'A' && codon2[i] == 'C')
				rate = Rmat[0];
			else if (codon1[i] == 'A' && codon2[i] == 'G')
				rate = Rmat[1];
			else if (codon1[i] == 'A' && codon2[i] == 'T')
				rate = Rmat[2];
			else if (codon1[i] == 'C' && codon2[i] == 'G')
				rate = Rmat[3];
			else if (codon1[i] == 'C' && codon2[i] == 'T')
				rate = Rmat[4];
			else if (codon1[i] == 'G' && codon2[i] == 'T')
				rate = Rmat[5];
		
			else if (codon2[i] == 'A' && codon1[i] == 'C')
				rate = Rmat[0];
			else if (codon2[i] == 'A' && codon1[i] == 'G')
				rate = Rmat[1];
			else if (codon2[i] == 'A' && codon1[i] == 'T')
				rate = Rmat[2];
			else if (codon2[i] == 'C' && codon1[i] == 'G')
				rate = Rmat[3];
			else if (codon2[i] == 'C' && codon1[i] == 'T')
				rate = Rmat[4];
			else if (codon2[i] == 'G' && codon1[i] == 'T')
				rate = Rmat[5];
			else
				{
				fprintf (stderr, "\nERROR IN codon_Rmat function!!");
				exit(-1);
				}
			}
		}
	/*if (k == 0 || k > 1)*/ /* main diagonal principal and more than one substitution = 0 */
	/*	return 0;*/
	
	return rate;
	}

/****************************** codon_NRmat *******************************/
/*determines, between two codons, the corresponding rate for the codon model version NOT REVERSIBLE GTR. 
It returns the rate of the change between these codons*/
 double codon_NRmat(int indi, int indj)
	{
	char codon1[3], codon2[3];
	int i/*, k*/; /* Rmat[12] from parameters input file*/
	double rate;
	
	rate = 1.0;
	/*k = 0;*/
	
	number_to_codon(indi, codon1);
	number_to_codon(indj, codon2);
	if (indi > 60 || indj > 60)
		{
		fprintf (stderr, "\n stop codon3 \n");
		exit(-1);
		}
		
	for (i=0; i<3; i++) /*	NRmat: AC CA AG GA AT TA CG GC CT TC GT=1 TG */
		{
		if (codon1[i] != codon2[i]) /* Important for codon with just 1 difference (more than 1 difference will be null..) */
			{
			/*k++;*/
			if (codon1[i] == 'A' && codon2[i] == 'C')
				rate = NRmat[0];
			else if (codon1[i] == 'C' && codon2[i] == 'A')
				rate = NRmat[1];
			else if (codon1[i] == 'A' && codon2[i] == 'G')
				rate = NRmat[2];
			else if (codon1[i] == 'G' && codon2[i] == 'A')
				rate = NRmat[3];
			else if (codon1[i] == 'A' && codon2[i] == 'T')
				rate = NRmat[4];
			else if (codon1[i] == 'T' && codon2[i] == 'A')
				rate = NRmat[5];
			else if (codon1[i] == 'C' && codon2[i] == 'G')
				rate = NRmat[6];
			else if (codon1[i] == 'G' && codon2[i] == 'C')
				rate = NRmat[7];
			else if (codon1[i] == 'C' && codon2[i] == 'T')
				rate = NRmat[8];
			else if (codon1[i] == 'T' && codon2[i] == 'C')
				rate = NRmat[9];
			else if (codon1[i] == 'G' && codon2[i] == 'T')
				rate = NRmat[10];
			else if (codon1[i] == 'T' && codon2[i] == 'G')
				rate = NRmat[11];
		
			/*else if (codon2[i] == 'A' && codon1[i] == 'C')
				rate = NRmat[0];
			else if (codon2[i] == 'C' && codon1[i] == 'A')
				rate = NRmat[1];
			else if (codon2[i] == 'A' && codon1[i] == 'G')
				rate = NRmat[2];
			else if (codon2[i] == 'G' && codon1[i] == 'A')
				rate = NRmat[3];
			else if (codon2[i] == 'A' && codon1[i] == 'T')
				rate = NRmat[4];
			else if (codon2[i] == 'T' && codon1[i] == 'A')
				rate = NRmat[5];
			else if (codon2[i] == 'C' && codon1[i] == 'G')
				rate = NRmat[6];
			else if (codon2[i] == 'G' && codon1[i] == 'C')
				rate = NRmat[7];
			else if (codon2[i] == 'C' && codon1[i] == 'T')
				rate = NRmat[8];
			else if (codon2[i] == 'T' && codon1[i] == 'C')
				rate = NRmat[9];
			else if (codon2[i] == 'G' && codon1[i] == 'T')
				rate = NRmat[10];
			else if (codon2[i] == 'T' && codon1[i] == 'G')
				rate = NRmat[11];*/
			else
				{
				fprintf (stderr, "\nERROR IN codon_NRmat function!!");
				exit(-1);
				}
			}
		}
	
	return rate;
	}





/*************** AAevolModel **********************/
/* It builds the Pij matrix from Cijk (variable global) and time */
void AAevolModel (double Pij[NUMAA][NUMAA], double branchLength, double varRate) /*, long int *seed)*/
	{	
	int 	i, j, k;
	double	t, expt[NUMAA]/*, GammaVarRateOmega*/; 
	/* double 			Rmat_AA[NUMAA+2], Qij_AAa[NUMAA*NUMAA], Cijk_AA[NUMAA*NUMAA*NUMAA*NUMAA], Root_AA[NUMAA], Qij_AA[NUMAA][NUMAA]; */ /* global variables */

	double a;
	
	a = 0;
	k = 0;
	
	/*fprintf (fpmpi, "\nIN AA MODEL FUNCTION\n");*/

	
	/*fprintf (fpmpi, "\n varRate = %lf", varRate);*/
	if (varRate > 0)
		varRate = varRate / (1.0 - pinv);
	t = branchLength * varRate;
	
	if (t<1e-6) 
		{ 
		/*fprintf (fpmpi, "\n TIEMPO BAJO.   branchLength = %lf, varRate = %lf", branchLength, varRate);*/
		for (i=0; i<NUMAA; i++) 
			for (j=0; j<NUMAA; j++) 
				{
				if (i==j)
					Pij[i][j] = 1.0;
				else 	
					Pij[i][j] = 0.0;
				}
		}
	else
		{
		for (k=1; k<NUMAA; k++) 
			expt[k]=exp(t*Root_AA[k]);
		
		for (i=0; i<NUMAA; i++) 
			for (j=0; j<NUMAA; j++) 
				{
				Pij[i][j] = Cijk_AA[i*NUMAA*NUMAA+j*NUMAA+0]; 
				for (k=1; k<NUMAA; k++)
					Pij[i][j]+=Cijk_AA[i*NUMAA*NUMAA+j*NUMAA+k]*expt[k];			/* THIS SLOWS DOWN THE PROGRAM!!! */ /* 15,5 seg, without 0,7 seg*/
				}
		}
	
	
	/* Active this to see the Pij matrix, but for all branches.. */
	/*fprintf (fpmpi, "\n");
	for (k=0; k<NUMAA; k++)
		{
		for (i=0; i<NUMAA; i++) 
			fprintf (fpmpi, "\nPij[%d][%d] = %lf ", k, i, Pij[k][i]);
		}*/
	
	
	
	/*for (i=0; i<NUMAA; i++)
		{
	//	fprintf (stderr, "\n");
		a = 0;
		for (j=0; j<NUMAA; j++)
			{
	//		fprintf (stderr, "PCodonM[%d][%d] = %3.2f ",i,j,Pij[i][j]);
			a = a + Pij[i][j];
			}
	
		if (a>1.1 || a <0.99)
			{
			fprintf (stderr, "\n a = %lf \n\n", a);
			exit (-5);
			}
		}
	*/
	}








/*************** CodonModel **********************/
/* It builds the Pij matrix from Cijk (variable global) and time */
void CodonModel (double Pij[NUMCOD][NUMCOD], double branchLength, double varRate) /*, long int *seed)*/
	{	
	int 	i, j, k;
	double	t, expt[NUMCOD]/*, GammaVarRateOmega*/; 
	/* double 			Rmat_C[66], Qij_CC[4096], Cijk_C[16777216], mr, tstv, Root_C[NUMCOD], Qij_C[NUMCOD][NUMCOD];*/ /* global variables */
	double a;
	
	a = 0;
	k = 0;
	
	/*fprintf (fpmpi, "\nIN CODON MODEL FUNCTION\n");*/
	/*fprintf (fpmpi, "\n*** NORMAL omega = %lf ***\n", omega);*/
	/* for each site and each branch */
	/*if (doOmegaRateHetCont == YES) 
		{
		GammaVarRateOmega = RndGamma (OmegaRateHet, seed) / OmegaRateHet; 
		omega = OmegaInit*GammaVarRateOmega;
		buildCodonMatrix_Qij_Cijk ();
		}*/
	
	/*fprintf (fpmpi, "\n varRate = %lf", varRate);*/
	if (varRate > 0)
		varRate = varRate / (1.0 - pinv);
	t = branchLength * varRate;
	
	if (t<1e-6) 
		{ 
		/*fprintf (fpmpi, "\n TIEMPO BAJO.   branchLength = %lf, varRate = %lf", branchLength, varRate);*/
		for (i=0; i<NUMCOD; i++) 
			for (j=0; j<NUMCOD; j++) 
				{
				if (i==j)
					Pij[i][j] = 1.0;
				else 	
					Pij[i][j] = 0.0;
				}
		}
	else
		{
		for (k=1; k<NUMCOD; k++) 
			expt[k]=exp(t*Root_C[k]);
		
		for (i=0; i<NUMCOD; i++) 
			for (j=0; j<NUMCOD; j++) 
				{
				Pij[i][j] = Cijk_C[i*NUMCOD*NUMCOD+j*NUMCOD+0]; 
				for (k=1; k<NUMCOD; k++)
					Pij[i][j]+=Cijk_C[i*NUMCOD*NUMCOD+j*NUMCOD+k]*expt[k];			/* THIS SLOWS DOWN THE PROGRAM!!! */ /* 15,5 seg, without 0,7 seg*/
				}
		}
	
	
	/* Active this to see the Pij matrix */
	
	/*fprintf (fpmpi, "\n");
	for (k=0; k<NUMCOD; k++)
		{
		for (i=0; i<NUMCOD; i++) 
			fprintf (fpmpi, "\nPij[%d][%d] = %lf ", k, i, Pij[k][i]);
		}*/
	
	
	
	/*for (i=0; i<NUMCOD; i++)
		{
	//	fprintf (stderr, "\n");
		a = 0;
		for (j=0; j<NUMCOD; j++)
			{
	//		fprintf (stderr, "PCodonM[%d][%d] = %3.2f ",i,j,Pij[i][j]);
			a = a + Pij[i][j];
			}
	
		if (a>1.1 || a <0.99)
			{
			fprintf (stderr, "\n a = %lf \n\n", a);
			exit (-5);
			}
		}
	*/
	}



/*************** CodonModel_Cat **********************/
/* It builds the Pij matrix from Cijk (variable global) and time */
void CodonModel_Cat (double Pij[NUMCOD][NUMCOD], double branchLength, double varRate) /* long int *seed, int numOmegaCat */ 
	{	
	int 	i, j, k, category;
	double	t, expt[NUMCOD]/*, ran*/; 
	/*double	*cumProbCat, *hetProb;*/
	/* double 			Rmat_C[66], Qij_CC[4096], Cijk_C[16777216], mr, tstv, Root_C[NUMCOD], Qij_C[NUMCOD][NUMCOD];*/ /* global variables */
	
	k = 0;
	category = 0;
	/*cumProbCat =  (double*) calloc ((numOmegaCat+1), sizeof (double));  
	if (cumProbCat == NULL)
		{
		fprintf (fpmpi, "Could not allocate cumProbCat (%lu bytes)", (numOmegaCat+1) * (long) sizeof (double));
		exit(1);
		}
	hetProb =  (double*) calloc ((numOmegaCat+1), sizeof (double));  
	if (hetProb == NULL)
		{
		fprintf (fpmpi, "Could not allocate hetProb (%lu bytes)", (numOmegaCat+1) * (long) sizeof (double));
		exit(1);
		}*/

	
		
	if (doOmegaProb == YES)
		{

		/*for (j=1; j<=numOmegaCat; j++)
			cumProbCat[j] = 0;
		cumProbCat[0] = 0;
		for (j=1; j<=numOmegaCat; j++)
			cumProbCat[j] = cumProbCat[j-1] + omegaProb[j];
		ran = RandomUniform(seed);
		category = bbinInOmegaCat (ran, cumProbCat, numOmegaCat);
		j = 0;*/
		category = ProbCategory;
		/*fprintf (stderr, "\n category = %d \n", category);*/
		}

	if (doOmegaRateHetDisc == YES)
		{
		/*for (j=1; j<=numOmegaCat; j++)
			{
			cumProbCat[j] = 0;
			hetProb[j] = 1.0/numOmegaCat;
			}
		cumProbCat[0] = 0;
		for (j=1; j<=numOmegaCat; j++)
			cumProbCat[j] = cumProbCat[j-1] + hetProb[j];
		ran = RandomUniform(seed);
		category = bbinInOmegaCat (ran, cumProbCat, numOmegaCat);
		j = 0;*/
		category = GammCategory;
		}
		
	if (doM1 == YES)
		{
		category = M1_FinalSite_omega;
		/*fprintf (stderr, "\n category = %d \n", category);*/
		}
	
	
	/*fprintf (fpmpi, "\n*** CAT category = %d ***\n", category);*/
	
	/*free (cumProbCat);
	free (hetProb);*/
	
	if (varRate > 0)
		varRate = varRate / (1.0 - pinv);
	t = branchLength * varRate;
	
	if (t<1e-6) 
		{ 
		for (i=0; i<NUMCOD; i++) 
			for (j=0; j<NUMCOD; j++) 
				{
				if (i==j)
					Pij[i][j] = 1.0;
				else 	
					Pij[i][j] = 0.0;
				}
		}
	else
		{
		for (k=1; k<NUMCOD; k++)
			expt[k]=exp(t*QijOmegas[category-1].Root_C_cat[k]);
			
		for (i=0; i<NUMCOD; i++) 
			for (j=0; j<NUMCOD; j++) 
				{
				Pij[i][j] = QijOmegas[category-1].Cijk_C_cat[i*NUMCOD*NUMCOD+j*NUMCOD+0]; 
				for (k=1; k<NUMCOD; k++)
					Pij[i][j]+=QijOmegas[category-1].Cijk_C_cat[i*NUMCOD*NUMCOD+j*NUMCOD+k]*expt[k];			/* THIS SLOWS DOWN THE PROGRAM!!! */ /* example, with 15,5 seg, without 0,7 seg*/
				}
		}
		
		
	/* Active this to see the Pij matrix */
	/*		
	fprintf (fpmpi, "\n");
	for (k=0; k<NUMCOD; k++)
		{
		for (i=0; i<NUMCOD; i++) 
			fprintf (fpmpi, "\nPij[%d][%d] = %lf ", k, i, Pij[k][i]);
		}
	*/

	}






	/*************** CodonModel_specialBranches **********************/
/* It builds the Pij matrix from Cijk (variable global) and time. dN/dS different for each branch */
void CodonModel_specialBranches (double Pij[NUMCOD][NUMCOD], double branchLength, double varRate, long int *seed, int siteCodon, int label1, int label2, int index1, int index2, double BBM0w)
	{	
	int 	i, j, k;
	double	t, expt[NUMCOD]/*, GammaVarRateOmega*/; 
	/* double 			Rmat_C[66], Qij_CC[4096], Cijk_C[16777216], mr, tstv, Root_C[NUMCOD], Qij_C[NUMCOD][NUMCOD];*/ /* global variables */
	double a;
	
	int			category, M8option;
	double		ran;
	double 		*cumProbCat, *cumProbCatM1, VarOmega1, GammaVarRateOmega, betaVar;
	double 		*cumProbCatM8, *hetProb;
	double		cumProbCatM6[3], cumProbCatM910[3];
	double		GammaVarRateOmegaM6, VarOmegaM6, GammaVarRateOmegaM910, VarOmegaM910;
	
	M8option = 0;
	a = 0;
	k = 0;
	category = 0;
	
	/*fprintf (fpmpi, "\nIN CODON MODEL FUNCTION\n");*/
	/*fprintf (fpmpi, "\n*** NORMAL omega = %lf ***\n", omega);*/
	/* for each site and each branch */
	/*if (doOmegaRateHetCont == YES) 
		{
		GammaVarRateOmega = RndGamma (OmegaRateHet, seed) / OmegaRateHet; 
		omega = OmegaInit*GammaVarRateOmega;
		buildCodonMatrix_Qij_Cijk ();
		}*/


	i = siteCodon;
	if (doGivenUserTrees == YES)
		{
		i = siteCodon+1;
		}

	if (noisy >= 2 && doOmegaProb == NO && doOmegaRateHetDisc == NO && doM1 == NO) /* print the evolution per branch */
		{
		
		if (i > BBBcounter)
			{
			if (i == 1)
				fprintf(stderr,"\n ..Working on site %d/%d", i, numSites);
			else
				fprintf(stderr," %d/%d", i, numSites);

			if (i == numSites)
				fprintf(stderr,"\n\n");

			BBBcounter = i;
			}
		}


	/************* M0 with different dN/dS per branch  *************/
		if (doBBM0 == YES) /* M0 with dN/dS per branch */ /* this case could run faster using categories for Qij.. */
			{
			omega = BBM0w;

			buildCodonMatrix_Qij_Cijk ();

			/*fprintf(stderr,"\nSite %d, Branch (NetNodes %d - %d, length %3.6f) -> Omega = %3.5f\n\n", i, label1, label2, branchLength, omega);*/

			if (doPrintOmegasPerSitefiles == YES) /* print omegas to file */
				{
				fprintf(fpOmegasPerSitePrint,"Site %d, Branch (NetNodes %d - %d, length %3.6f) -> Omega = %3.5f\n", i, label1, label2, branchLength, omega);
				}
			}



	/************* Heteregeneous codon models, variation of dN/dS per site and branch according to the same function **************/
		

		if (doOmegaProb == YES)
			{
			cumProbCat =  (double*) calloc ((numOmegaCat+1), sizeof (double));  
			if (cumProbCat == NULL)
				{
				fprintf (fpmpi, "Could not allocate cumProbCat (%lu bytes)", (numOmegaCat+1) * (long) sizeof (double));
				exit(1);
				}
			
			for (j=1; j<=numOmegaCat; j++)
				cumProbCat[j] = 0;
			cumProbCat[0] = 0;
			for (j=1; j<=numOmegaCat; j++)
				cumProbCat[j] = cumProbCat[j-1] + omegaProb[j];
			ran = RandomUniform(seed);
			ProbCategory = bbinInOmegaCat (ran, cumProbCat, numOmegaCat);
			j = 0;
			free (cumProbCat);
			/*fprintf (stderr, "\n ProbCategory = %d \n", ProbCategory);*/
			
			category = ProbCategory;

			if (doPrintOmegasPerSitefiles == YES) /* print omegas to file */
				{
				fprintf(fpOmegasPerSitePrint,"Site %d, Branch (NetNodes %d - %d, length %3.6f) -> Omega = %3.5f\n", i, label1, label2, branchLength, omegaVal[ProbCategory]);
				}
			}

		if (doOmegaRateHetDisc == YES)
			{
			hetProb =  (double*) calloc ((numOmegaCat+1), sizeof (double));  
			if (hetProb == NULL)
				{
				fprintf (fpmpi, "Could not allocate hetProb (%lu bytes)", (numOmegaCat+1) * (long) sizeof (double));
				exit(1);
				}
			cumProbCat =  (double*) calloc ((numOmegaCat+1), sizeof (double));  
			if (cumProbCat == NULL)
				{
				fprintf (fpmpi, "Could not allocate cumProbCat (%lu bytes)", (numOmegaCat+1) * (long) sizeof (double));
				exit(1);
				}			

			for (j=1; j<=numOmegaCat; j++)
				{
				cumProbCat[j] = 0;
				hetProb[j] = 1.0/numOmegaCat;
				}
			cumProbCat[0] = 0;
			for (j=1; j<=numOmegaCat; j++)
				cumProbCat[j] = cumProbCat[j-1] + hetProb[j];
			ran = RandomUniform(seed);
			GammCategory = bbinInOmegaCat (ran, cumProbCat, numOmegaCat);
			j = 0;
			free (hetProb);
			free (cumProbCat);

			category = GammCategory;
			
			/*fprintf (stderr, "\n GammCategory = %d \n", GammCategory);*/
			if (doPrintOmegasPerSitefiles == YES) /* print omegas to file */
				{
				fprintf(fpOmegasPerSitePrint,"Site %d, Branch (NetNodes %d - %d, length %3.6f) -> Omega = %3.5f\n", i, label1, label2, branchLength, omegaValGammaRate[GammCategory]);
				}
			}


		if (doM1 == YES) /* for each site */ /* Important Note: M1_FinalSite_omega = 1, prop0, omega will be 0; if M1_FinalSite_omega = 2, prop1, omega will be 1  */
			{
			cumProbCatM1 =  (double*) calloc ((numOmegaCat+1), sizeof (double));  
			if (cumProbCatM1 == NULL)
				{
				fprintf (fpmpi, "Could not allocate cumProbCatM1 (%lu bytes)", (numOmegaCat+1) * (long) sizeof (double));
				exit(1);
				}
			
			/*fprintf(fpmpi,"\n Categ number = %d \n", numOmegaCat);*/ 


			for (j=1; j<=numOmegaCat; j++)
				cumProbCatM1[j] = 0;
			cumProbCatM1[0] = 0;
			for (j=1; j<=numOmegaCat; j++)
				{
				cumProbCatM1[j] = cumProbCatM1[j-1] + omegaProb[j];
				/*fprintf (stderr, "\n cumProbCatM1[%d] = %lf \n", j, cumProbCatM1[j]);*/
				}
			ran = RandomUniform(seed);
			M1_FinalSite_omega = bbinInOmegaCat (ran, cumProbCatM1, numOmegaCat);
			j = 0;
			/*fprintf (stderr, "\n M1_FinalSite_omega (or category) = %d, ran = %lf \n", M1_FinalSite_omega, ran);*/

			category = M1_FinalSite_omega;

			if (doPrintOmegasPerSitefiles == YES) /* print omegas to file */
				{
				if (M1_FinalSite_omega == 1)
					{
					fprintf(fpOmegasPerSitePrint,"Site %d, Branch (NetNodes %d - %d, length %3.6f) -> Omega = %3.5f\n", i, label1, label2, branchLength, M1_omega0);
					}
				if (M1_FinalSite_omega == 2)
					{
					fprintf(fpOmegasPerSitePrint,"Site %d, Branch (NetNodes %d - %d, length %3.6f) -> Omega = 1.00000\n", i, label1, label2, branchLength);
					}
				}
			
			free (cumProbCatM1);
			}
		
		/*  End of discrete models */

		/* Continuos models  */
		if (doOmegaRateHetCont == YES) /* M5. for each site */
			{
			GammaVarRateOmega = RndGamma (OmegaRateHet, seed) / OmegaRateHet; 
			VarOmega1 = OmegaInit*GammaVarRateOmega;
			omega = roundit(VarOmega1,5);
			if (doPrintOmegasPerSitefiles == YES) /* print omegas to file */
				{
				fprintf(fpOmegasPerSitePrint,"Site %d, Branch (NetNodes %d - %d, length %3.6f) -> Omega = %3.5f\n", i, label1, label2, branchLength, omega);
				}
			/*fprintf(stderr,"doOmegaRateHetCont - Site %d - Omega %3.5f\n", i, omega);*/

			/*fprintf(stderr, "\nBEFORE Cijk_C[10*NUMCOD*NUMCOD+10*NUMCOD+10] = %d\n", Cijk_C[10*NUMCOD*NUMCOD+10*NUMCOD+10]);
			fprintf(stderr, "\nBEFORE Cijk_C[5*NUMCOD*NUMCOD+5*NUMCOD+5] = %d\n", Cijk_C[5*NUMCOD*NUMCOD+5*NUMCOD+5]);*/

			buildCodonMatrix_Qij_Cijk ();
			/*fprintf(stderr, "\nAFTER Cijk_C[10*NUMCOD*NUMCOD+10*NUMCOD+10] = %d\n", Cijk_C[10*NUMCOD*NUMCOD+10*NUMCOD+10]);
			fprintf(stderr, "\nAFTER Cijk_C[5*NUMCOD*NUMCOD+5*NUMCOD+5] = %d\n", Cijk_C[5*NUMCOD*NUMCOD+5*NUMCOD+5]);*/	
			}

		if (doM6 == YES) /* for each site */
			{		/* M6_P0, M6_P1; OmegaRateHetM6_0 OmegaM6_0 OmegaInitM6_0; OmegaRateHetM6_1 OmegaM6_1 OmegaInitM6_1 */

			for (j=1; j<=2; j++)
				cumProbCatM6[j] = 0;
			cumProbCatM6[0] = 0;
			cumProbCatM6[1] = M6_P0;
			cumProbCatM6[2] = M6_P0 + M6_P1;

			ran = RandomUniform(seed);
			M6_FinalSite_omega = bbinInOmegaCat (ran, cumProbCatM6, 2);
			j = 0;
			/*fprintf (stderr, "\n M6_FinalSite_omega (or category) = %d, ran = %lf \n", M6_FinalSite_omega, ran);*/


			if (M6_FinalSite_omega == 1) /* gamma distribt 1 */
				{
				GammaVarRateOmegaM6 = RndGamma (OmegaRateHetM6_0, seed) / OmegaRateHetM6_0; 
				VarOmegaM6 = OmegaInitM6_0*GammaVarRateOmegaM6;
				omega = roundit(VarOmegaM6,5);
				}
			else if (M6_FinalSite_omega == 2) /* gamma distribt 2 */
				{
				GammaVarRateOmegaM6 = RndGamma (OmegaRateHetM6_1, seed) / OmegaRateHetM6_1; 
				VarOmegaM6 = OmegaInitM6_1*GammaVarRateOmegaM6;
				omega = roundit(VarOmegaM6,5);
				}
			else
				{
				fprintf (stderr, "\n ERROR in CodonModel_specialBranches function, M6 codon model. Parameter M6_FinalSite_omega must be 1 or 2 (%d) \n", M6_FinalSite_omega);
				exit (-1);
				}
			/*fprintf(stderr,"Site %d - Omega %3.5f\n", i, omega);*/
			buildCodonMatrix_Qij_Cijk ();


			if (doPrintOmegasPerSitefiles == YES) /* print omegas to file */
				{
				fprintf(fpOmegasPerSitePrint,"Site %d, Branch (NetNodes %d - %d, length %3.6f) -> Omega = %3.5f\n", i, label1, label2, branchLength, omega);
				}			
			}

		if (doM7 == YES) /* for each site */  
			{
			/*fprintf (stderr, "\n M7_p_beta = %lf, M7_q_beta = %lf \n", M7_p_beta, M7_q_beta);*/	
			betaVar = RandomBeta (M7_p_beta, M7_q_beta, seed); /* Thanks to David Posada! */
			M7_FinalSite_omega = betaVar;

			omega = roundit(M7_FinalSite_omega,5);

			/*omega = M7_FinalSite_omega;
			if (omega < 0.001)
				omega = 0.00;*/	
			/*fprintf (stderr, "\n M7: Site %d, omega = %lf, M7_FinalSite_omega = %lf  \n", i, omega, M7_FinalSite_omega);*/	
			buildCodonMatrix_Qij_Cijk ();

			if (doPrintOmegasPerSitefiles == YES) /* print omegas to file */
				{
				fprintf(fpOmegasPerSitePrint,"Site %d, Branch (NetNodes %d - %d, length %3.6f) -> Omega = %3.5f\n", i, label1, label2, branchLength, omega);
				}
			}


		if (doM8 == YES) /* for each site */  
			{
			cumProbCatM8 =  (double*) calloc ((3), sizeof (double));  
			if (cumProbCatM8 == NULL)
				{
				fprintf (fpmpi, "Could not allocate cumProbCatM8 (%lu bytes)", (3) * (long) sizeof (double));
				exit(1);
				}

			for (j=0; j<=2; j++)
				cumProbCatM8[j] = 0;
			/*fprintf (stderr, "\n M8_P0_beta = %lf, M8_P1_omega = %lf \n", M8_P0_beta, M8_P1_omega);*/			
			for (j=1; j<=2; j++)
				{
				if (j == 1)
					{
					cumProbCatM8[j] = cumProbCatM8[j-1] + M8_P0_beta;
					}
				if (j == 2)
					{
					cumProbCatM8[j] = cumProbCatM8[j-1] + M8_P1_omega;
					}
				/*fprintf (stderr, "\n cumProbCatM8[%d] = %lf \n", j, cumProbCatM8[j]);*/
				}
			
			ran = RandomUniform(seed);
			M8option = bbinInOmegaCat (ran, cumProbCatM8, 2);
			j = 0;			
			free (cumProbCatM8);
			M8_FinalSite_omega = -1.0;
			/*fprintf (stderr, "\n M8option (or category) = %d, ran = %lf \n", M8option, ran);*/

			if (M8option == 1) /* beta distribution */ /* M8_p_beta, M8_q_beta -> M8_omegaP0 */
				{
				/* From David Posada. Thanks to David!! */
				/*int		i, numReps;
				long int	seed;
				double	betaVar, p, q, sum, sumsq, variance;
				seed = time(NULL); 			
				p = 0.3;
				q = 0.5;
				sum = 0;
				numReps = 1000;
				fprintf (stderr, "beta variable = ");
				for (i=0; i<numReps; i++)
					{
					betaVar = RandomBeta (p, q, &seed);
					fprintf (stderr, " %6.4f", betaVar);
					sum += betaVar;
					sumsq += pow(betaVar,2);
					}
				variance = (1.0 / (double) (numReps-1)) * (sumsq - pow(sum,2) / (double) numReps);
				fprintf (stderr, "\nmean = %6.4f  var = %6.4f", sum/=numReps, variance);
				return 0;*/

				betaVar = RandomBeta (M8_p_beta, M8_q_beta, seed);
				M8_omegaP0 = betaVar;
				M8_FinalSite_omega = M8_omegaP0;
				/*fprintf (stderr, "\n option 1, omega = %lf   D.beta: p = %lf, q = %lf \n", M8_FinalSite_omega, M8_p_beta, M8_q_beta);*/
				}
			else if (M8option == 2) /* direct omega */
				{
				M8_FinalSite_omega = M8_omegaP1;
				/*fprintf (stderr, "\n option 2, omega = %lf \n", M8_FinalSite_omega);*/
				}
			else
				{
				fprintf (fpmpi, "\n Error in M8option (%d): CodonModel_specialBranches \n", M8option);
				exit(1);
				}
			

			if (M8_FinalSite_omega == -1.0) /* Check point */
				{
				fprintf (fpmpi, "\n Error in M8_FinalSite_omega (-1): CodonModel_specialBranches \n");
				exit(1);
				}

			/*fprintf (stderr, "\n M8: Site %d, M8_FinalSite_omega = %lf  \n", i, M8_FinalSite_omega);*/
			/*omega = M8_FinalSite_omega;*/
			
			omega = roundit(M8_FinalSite_omega,5);

			/*fprintf (stderr, "\n M8: Site %d, omega = %lf  \n", i, omega);*/
			/*if (omega < 0.001)
				omega = 0.00;*/

			buildCodonMatrix_Qij_Cijk ();

			if (doPrintOmegasPerSitefiles == YES) /* print omegas to file */
				{
				fprintf(fpOmegasPerSitePrint,"Site %d, Branch (NetNodes %d - %d, length %3.6f) -> Omega = %3.5f\n", i, label1, label2, branchLength, omega);
				}
			}


		if (doM9 == YES || doM10 == YES) /* for each site */
			{		/* M910_P0, M910_P1; M910_p_beta M910_q_beta; OmegaRateHetM910_1 OmegaM910_1 OmegaInitM910_1 */

			for (j=1; j<=2; j++)
				cumProbCatM910[j] = 0;
			cumProbCatM910[0] = 0;
			cumProbCatM910[1] = M910_P0;
			cumProbCatM910[2] = M910_P0 + M910_P1;

			ran = RandomUniform(seed);
			M910_FinalSite_omega = bbinInOmegaCat (ran, cumProbCatM910, 2);
			j = 0;
			/*fprintf (stderr, "\n M910_FinalSite_omega (or category) = %d, ran = %lf \n", M910_FinalSite_omega, ran);*/


			if (M910_FinalSite_omega == 1) /* beta distribt */
				{
				/*fprintf (stderr, "\n M910_p_beta = %lf, M910_q_beta = %lf \n", M910_p_beta, M910_q_beta);*/	
				betaVar = RandomBeta (M910_p_beta, M910_q_beta, seed); /* Thanks to David Posada! */
				VarOmegaM910 = betaVar;

				omega = roundit(VarOmegaM910,5);
			
				/*fprintf (stderr, "\n M9 or M10: Site %d, M910_p_beta = %lf, M910_q_beta = %lf, betaVar = %lf, VarOmegaM910 = %lf, omega = %lf \n", i, M910_p_beta, M910_q_beta, betaVar, VarOmegaM910, omega);*/	
				}
			else if (M910_FinalSite_omega == 2) /* gamma distribt */
				{
				if (doM9 == YES) /* GammaVarRateOmegaM910, VarOmegaM910 */
					{
					GammaVarRateOmegaM910 = RndGamma (OmegaRateHetM910_1, seed) / OmegaRateHetM910_1; 
					VarOmegaM910 = OmegaInitM910_1*GammaVarRateOmegaM910;
					omega = roundit(VarOmegaM910,5);
					}
				else if (doM10 == YES) 
					{
					GammaVarRateOmegaM910 = RndGamma (OmegaRateHetM910_1, seed) / OmegaRateHetM910_1; 
					VarOmegaM910 = OmegaInitM910_1*GammaVarRateOmegaM910;
					omega = roundit(VarOmegaM910,5);

					omega = omega + 1; /* in Model M10, omega from the beta distribution is +1, so here always > 1: PSSs */
					}
				else
					{
					fprintf (stderr, "\n ERROR in CodonModel_specialBranches function, M9 or M10 codon model. \n");
					exit (-1);
					}
				}
			else
				{
				fprintf (stderr, "\n ERROR in CodonModel_specialBranches function, M9 or M10 codon model. Parameter M910_FinalSite_omega must be 1 or 2 (%d) \n", M910_FinalSite_omega);
				exit (-1);
				}

			/*fprintf(stderr,"Site %d (case %d) - Omega %3.5f\n", i, M910_FinalSite_omega, omega);*/
			/*fprintf(stderr,"Site %d - Omega %3.5f\n", i, omega);*/
			buildCodonMatrix_Qij_Cijk ();


			if (doPrintOmegasPerSitefiles == YES) /* print omegas to file */
				{
				fprintf(fpOmegasPerSitePrint,"Site %d, Branch (NetNodes %d - %d, length %3.6f) -> Omega = %3.5f\n", i, label1, label2, branchLength, omega);
				}			
		
			}

		i = 0;

	/**** End ALL VARIABLE CODON MODELS ****/
	


	/**** CALCULATION OF Pij MATRIX ****/

	if (doOmegaRateHetCont == YES || doM6 == YES || doM7 == YES || doM8 == YES || doM9 == YES || doM10 == YES || doBBM0 == YES) /* CONTINUOUS MODELS + doBBM0 */
		{
		/*fprintf (fpmpi, "\n varRate = %lf", varRate);*/
		if (varRate > 0)
			varRate = varRate / (1.0 - pinv);
		t = branchLength * varRate;
	
		if (t<1e-6) 
			{ 
			/*fprintf (fpmpi, "\n TIEMPO BAJO.   branchLength = %lf, varRate = %lf", branchLength, varRate);*/
			for (i=0; i<NUMCOD; i++) 
				for (j=0; j<NUMCOD; j++) 
					{
					if (i==j)
						Pij[i][j] = 1.0;
					else 	
						Pij[i][j] = 0.0;
					}
			}
		else
			{
			for (k=1; k<NUMCOD; k++) 
				expt[k]=exp(t*Root_C[k]);
		
			for (i=0; i<NUMCOD; i++) 
				for (j=0; j<NUMCOD; j++) 
					{
					Pij[i][j] = Cijk_C[i*NUMCOD*NUMCOD+j*NUMCOD+0]; 
					for (k=1; k<NUMCOD; k++)
						Pij[i][j]+=Cijk_C[i*NUMCOD*NUMCOD+j*NUMCOD+k]*expt[k];			/* THIS SLOWS DOWN THE PROGRAM!!! */ /* 15,5 seg, without 0,7 seg*/
					}
			}
		
		/*fprintf(stderr,"\nCalculated matrix for Site %d, Branch (NetNodes %d - %d, length %3.6f) -> Omega = %3.5f\n", siteCodon, label1, label2, branchLength, omega);*/

		/* Active this to see the Pij matrix */
		/*fprintf (fpmpi, "\n");
		for (k=0; k<NUMCOD; k++)
			{
			for (i=0; i<NUMCOD; i++) 
				fprintf (fpmpi, "\nPij[%d][%d] = %lf ", k, i, Pij[k][i]);
			}*/
	
		/*for (i=0; i<NUMCOD; i++)
			{
		//	fprintf (stderr, "\n");
			a = 0;
			for (j=0; j<NUMCOD; j++)
				{
		//		fprintf (stderr, "PCodonM[%d][%d] = %3.2f ",i,j,Pij[i][j]);
				a = a + Pij[i][j];
				}
	
			if (a>1.1 || a <0.99)
				{
				fprintf (stderr, "\n a = %lf \n\n", a);
				exit (-5);
				}
			}
		*/
		}
	else if (doOmegaProb == YES || doOmegaRateHetDisc == YES || doM1 == YES) /* DISCRETE MODELS */
		{

		if (varRate > 0)
			varRate = varRate / (1.0 - pinv);
		t = branchLength * varRate;
	
		if (t<1e-6) 
			{ 
			for (i=0; i<NUMCOD; i++) 
				for (j=0; j<NUMCOD; j++) 
					{
					if (i==j)
						Pij[i][j] = 1.0;
					else 	
						Pij[i][j] = 0.0;
					}
			}
		else
			{
			for (k=1; k<NUMCOD; k++)
				expt[k]=exp(t*QijOmegas[category-1].Root_C_cat[k]);
			
			for (i=0; i<NUMCOD; i++) 
				for (j=0; j<NUMCOD; j++) 
					{
					Pij[i][j] = QijOmegas[category-1].Cijk_C_cat[i*NUMCOD*NUMCOD+j*NUMCOD+0]; 
					for (k=1; k<NUMCOD; k++)
						Pij[i][j]+=QijOmegas[category-1].Cijk_C_cat[i*NUMCOD*NUMCOD+j*NUMCOD+k]*expt[k];			/* THIS SLOWS DOWN THE PROGRAM!!! */ /* example, with 15,5 seg, without 0,7 seg*/
					}
			}
		
		
		/* Active this to see the Pij matrix */
		/*		
		fprintf (fpmpi, "\n");
		for (k=0; k<NUMCOD; k++)
			{
			for (i=0; i<NUMCOD; i++) 
				fprintf (fpmpi, "\nPij[%d][%d] = %lf ", k, i, Pij[k][i]);
			}
		*/

		}
	else
		{
		fprintf (stderr, "\n ERROR in CodonModel_specialBranches: model not found for the calculation of Pij matrix. \n");
		exit (-1);
		}



	}











/*********************** Amino Acid Substitution Models ***************************************/
/***********************************************************************************************/

/********************************** EvolveSequenceOnTree_NEW_AA ***********************************/
/* This function evolves amino acid sequences on the coalescent trees */

void EvolveSequenceOnTree_NEW_AA (long int *seed, double m, double alpha, double p_i_aa[20], int numNuc, int indNumRE, int *arrayIndBreakpointsOrd, char *MRCAsequence, int numSites, int dataSetNum, char *dirStability)
	{
	int			i, w, j, sitePosition;
	double		varRate, ran, cumPi[20];
	int			*arrayIndBreakpointsOrd_C;
	int 		GMRCA_label;
	/*TreeNode	*q;*/

	w = sitePosition = j = 0;
	GMRCA_label = -1;
	/*fprintf (fpmpi, "En EvolveSequenceOnTree_NEW_AA function \n");*/	

	arrayIndBreakpointsOrd_C = (int *)calloc((indNumRE+1),(long) sizeof(int));
	if (!arrayIndBreakpointsOrd_C)
		{
		fprintf (fpmpi, "Could not allocate arrayIndBreakpointsOrd_C (%lu bytes)\n", (indNumRE+1)  * (long) sizeof(int));
		exit (1);
		}
	

	/* making codon breakpoints */
	for (i = 0; i < indNumRE+1; i++)
		arrayIndBreakpointsOrd_C[i] = fabs(arrayIndBreakpointsOrd[i]/3);
	


	/** Label of GMRCA **/
	w = 0; /* NETRECODON Ahora solo hay un nodo raiz, "GMRCA" base de toda la red */
	GMRCA_label =  TellMeGMRCALabel (treeRootInit[w]); 
	if (GMRCA_label < 0) /* MRCA from File */
		{
		fprintf (fpmpi, "Error in GMRCA_label, in EvolveSequenceOnTree_NEW function \n");
		exit (1);
		}
	/*fprintf (fpmpi, "GMRCA LAbel %d\n", GMRCA_label);*/	





	if (doMRCAFile == YES) /* MRCA from File */
		{
		for (i = 1; i <= numNuc; i++)		/* taking MRCA sequence */
			{	
			/* form OLD . La secuencia de entrada es GMRCA */
			if (i == arrayIndBreakpointsOrd[w]) /* recombinations, breakpoints. CAMBIA LA RAIZ DEL ARBOL */
				w++;
			w = 0; /* NETRECODON Ahora solo hay un nodo raiz, "GMRCA" base de toda la red */
			
			matrix[pos(GMRCA_label,i,numNuc)] = WhichAANumber(MRCAsequence[i-1]); /* from MRCA input file */
			}

		/* activate this to print GMRCA seq from file */
		/*fprintf (fpmpi, "\nGMRCA sequence: %s", MRCAsequence);
		fprintf (fpmpi, "\n\n");*/


		}
	else /* MRCA from aa frequencies */
		{		
		for (i = 1; i <= numNuc; i++)
			{
			cumPi[0] = p_i_aa[0];
			for (j = 1; j < 20; j++)
				cumPi[j] = cumPi[j-1] + p_i_aa[j];
			
			ran = RandomUniform(seed);

			if (ran >= 0.0 && ran <= cumPi[0])
				matrix[pos(GMRCA_label,i,numSites)] = 0;
			else if (ran > cumPi[0] && ran <= cumPi[1])
				matrix[pos(GMRCA_label,i,numSites)] = 1;
			else if (ran > cumPi[1] && ran <= cumPi[2])
				matrix[pos(GMRCA_label,i,numSites)] = 2;
			else if (ran > cumPi[2] && ran <= cumPi[3])
				matrix[pos(GMRCA_label,i,numSites)] = 3;
			else if (ran > cumPi[3] && ran <= cumPi[4])
				matrix[pos(GMRCA_label,i,numSites)] = 4;
			else if (ran > cumPi[4] && ran <= cumPi[5])
				matrix[pos(GMRCA_label,i,numSites)] = 5;
			else if (ran > cumPi[5] && ran <= cumPi[6])
				matrix[pos(GMRCA_label,i,numSites)] = 6;
			else if (ran > cumPi[6] && ran <= cumPi[7])
				matrix[pos(GMRCA_label,i,numSites)] = 7;
			else if (ran > cumPi[7] && ran <= cumPi[8])
				matrix[pos(GMRCA_label,i,numSites)] = 8;
			else if (ran > cumPi[8] && ran <= cumPi[9])
				matrix[pos(GMRCA_label,i,numSites)] = 9;
			else if (ran > cumPi[9] && ran <= cumPi[10])
				matrix[pos(GMRCA_label,i,numSites)] = 10;
			else if (ran > cumPi[10] && ran <= cumPi[11])
				matrix[pos(GMRCA_label,i,numSites)] = 11;
			else if (ran > cumPi[11] && ran <= cumPi[12])
				matrix[pos(GMRCA_label,i,numSites)] = 12;
			else if (ran > cumPi[12] && ran <= cumPi[13])
				matrix[pos(GMRCA_label,i,numSites)] = 13;
			else if (ran > cumPi[13] && ran <= cumPi[14])
				matrix[pos(GMRCA_label,i,numSites)] = 14;
			else if (ran > cumPi[14] && ran <= cumPi[15])
				matrix[pos(GMRCA_label,i,numSites)] = 15;
			else if (ran > cumPi[15] && ran <= cumPi[16])
				matrix[pos(GMRCA_label,i,numSites)] = 16;
			else if (ran > cumPi[16] && ran <= cumPi[17])
				matrix[pos(GMRCA_label,i,numSites)] = 17;
			else if (ran > cumPi[17] && ran <= cumPi[18])
				matrix[pos(GMRCA_label,i,numSites)] = 18;
			else
				matrix[pos(GMRCA_label,i,numSites)] = 19;
			
			}
		}
	
	

	if (doProtStabAAFile == YES) /* POP_EVOL from Ugo Bastolla */
		{
    	w = 0; 		
		i = 1;
		
		mkdir("Results/ProteinStability",S_IRWXU);	/* Create "Results" folder (with type S_IRWXU (read, write and execute)) */ 
		#ifdef MAC					
			strcpy (dirStability,":Results/ProteinStability:");	/* Copy the string in char variable dir = Results (char), is different mac vs windows */
		#else
			strcpy (dirStability,"Results/ProteinStability/");
		#endif
		/*fprintf (fpmpi, "\n\n In all SimulateDataForSite_AA_RECURSIVE_NET_Pop_Evol \n\n");*/
		SimulateDataForSite_AA_RECURSIVE_NET_Pop_Evol (treeRootInit[w], i, numSites, m, seed, dataSetNum, dirStability);

		/*fprintf (fpmpi, "\n\n End all SimulateDataForSite_AA_RECURSIVE_NET_Pop_Evol \n\n");*/
		}
	else /* Common AA models  */
		{

		/*fprintf (fpmpi, "\n Entra en la recursion amino acidica, EvolveSequenceOnTree_NEW_AA, numRE = %d", numRE);*/
		/*exit(-3);*/

		w = 0;
	
		for (i = 1; i <= numSites; i++)	/************* Other sequences */ /* FOR EACH SITE (amino acid) **********/
			{
			/*fprintf (fpmpi, "\n\n +++++++ AA = %d ++++++++ \n\n", i);*/

			if (RandomUniform(seed) < pinv)		
				varRate = 0.0;
			else
				{
				if (doRateHet == YES)
					varRate = RndGamma (alpha, seed) / alpha; 
				else
					varRate = 1; 
				}
			if (doHetVectorFile == YES)
				{
				varRate = varRate*vectorHetRates[i-1];
				}

			/* form OLD . La secuencia de entrada es GMRCA */
			if (i == (arrayIndBreakpointsOrd_C[w]+1) && indNumRE != 0)
				w++;
			w = 0; /* NETRECODON Ahora solo hay un nodo raiz, "GMRCA" base de toda la red */


			SimulateDataForSite_AA_RECURSIVE_NET (treeRootInit[w], i, numSites, m, varRate, seed);
			}
		/*fprintf (fpmpi, "\n\n SALE DE LA RECURSION \n\n");*/

		}


	free (arrayIndBreakpointsOrd_C);

	}









/*********************** Nucleotidic Substitution Models ***************************************/
/***********************************************************************************************/

/********************************** EvolveSequenceOnTree_NEW ***********************************/
/* This function evolves sequences on the coalescent trees by nucleotide model */

void EvolveSequenceOnTree_NEW (long int *seed, double m, double kappa, 
							double alpha, double p_i[4], int numNuc, int indNumRE, int *arrayIndBreakpointsOrd, char *MRCAsequence, int numSites, int dataSetNum, char *dirStability)
	{
	int			i, w, j, sitePosition, k;
	double		varRate, ran, cumPi[4];
	int			*arrayIndBreakpointsOrd_C;
	int 		GMRCA_label;
	int			*codonMRCASeq;

	double		cumFreq[64];
	int			nucX[3];
	/*TreeNode	*q;*/

	w = sitePosition = j = k = 0;
	GMRCA_label = -1;
	/*fprintf (fpmpi, "En EvolveSequenceOnTree_NEW function \n");*/	

	arrayIndBreakpointsOrd_C = (int *)calloc((indNumRE+1),(long) sizeof(int));
	if (!arrayIndBreakpointsOrd_C)
		{
		fprintf (fpmpi, "Could not allocate arrayIndBreakpointsOrd_C (%lu bytes)\n", (indNumRE+1)  * (long) sizeof(int));
		exit (1);
		}
	
	/* making codon breakpoints */
	for (i = 0; i < indNumRE+1; i++)
		arrayIndBreakpointsOrd_C[i] = fabs(arrayIndBreakpointsOrd[i]/3);
	

	/** Label of GMRCA **/
	w = 0; /* NETRECODON Ahora solo hay un nodo raiz, "GMRCA" base de toda la red */
	GMRCA_label =  TellMeGMRCALabel (treeRootInit[w]); 
	if (GMRCA_label < 0) /* MRCA from File */
		{
		fprintf (fpmpi, "Error in GMRCA_label in the EvolveSequenceOnTree_NEW function \n");
		exit (1);
		}
	/*fprintf (fpmpi, "GMRCA LAbel %d\n", GMRCA_label);*/	

	if (doMRCAFile == YES) /* MRCA from File */
		{
		for (i = 1; i <= numNuc; i++)		/* taking MRCA sequence */
			{	
			/* form OLD . La secuencia de entrada es GMRCA */
			if (i == arrayIndBreakpointsOrd[w]) /* recombinations, breakpoints. CAMBIA LA RAIZ DEL ARBOL */
				w++;
			w = 0; /* NETRECODON Ahora solo hay un nodo raiz, "GMRCA" base de toda la red */
			
			matrix[pos(GMRCA_label,i,numNuc)] = WhichNucNumber(MRCAsequence[i-1]); /* from MRCA input file */
			}
		}
	else /* MRCA from nucleotide frequencies */
		{
	
		if (doProtStabDNAFile == YES) /* coding data, will be codified to a protein.. */
			{
			codonMRCASeq = (int *)calloc((numSites/3+3),(long) sizeof(int));
			if (!codonMRCASeq)
				{
				fprintf (fpmpi, "Could not allocate codonMRCASeq (%lu bytes)\n", (numSites/3+3)  * (long) sizeof(int));		
				exit (1);
				}

			k=0;
			for (i = 0; i < 3; i++) /* here we assume equal freqs for the 3 nt positions in the codon */
				{
				p_i_codon[i+k] = p_i[0];
				k++;
				p_i_codon[i+k] = p_i[1];
				k++;
				p_i_codon[i+k] = p_i[2];
				k++;
				p_i_codon[i+k] = p_i[3];
				}
			/*fprintf (fpmpi, "\n p_i_codon[%d] = %lf, p_i_codon[%d] = %lf, p_i_codon[%d] = %lf, p_i_codon[%d] = %lf", 0, p_i_codon[0], 1, p_i_codon[1], 2, p_i_codon[2], 3, p_i_codon[3]);
			fprintf (fpmpi, "\n p_i_codon[%d] = %lf, p_i_codon[%d] = %lf, p_i_codon[%d] = %lf, p_i_codon[%d] = %lf", 4, p_i_codon[4], 5, p_i_codon[5], 6, p_i_codon[6], 7, p_i_codon[7]);
			fprintf (fpmpi, "\n p_i_codon[%d] = %lf, p_i_codon[%d] = %lf, p_i_codon[%d] = %lf, p_i_codon[%d] = %lf", 8, p_i_codon[8], 9, p_i_codon[9], 10, p_i_codon[10], 11, p_i_codon[11]);*/


			cumFreq[0] = codonTable_frequencies_MRCA(0);
			for (i = 1; i <= 63; i++)
				cumFreq[i] = cumFreq[i-1] + codonTable_frequencies_MRCA(i);				

			for (i = 1; i <= 63; i++)
				cumFreq[i] = cumFreq[i]/cumFreq[63];
		
		
			for (i=1; i <= numNuc/3; i++)
				{
				ran = RandomUniform(seed);
				codonMRCASeq[i] = bbin_EnterMRCA(ran, cumFreq); /* codon MRCA sequence */
				/*fprintf (fpmpi, "\n ran = %lf", ran);
				fprintf (fpmpi, " codonMRCASeq[%d] = %d \n", i, codonMRCASeq[i]);*/
						
				if (codonMRCASeq[i] == 48 || codonMRCASeq[i] == 50 || codonMRCASeq[i] == 56) /* Cheking stop codons */
					{
					fprintf (fpmpi, "\n Warning by stop codons in EvolveSequenceOnTree_Codon (%d, %d)", i, codonMRCASeq[i]);
					exit (-2);
					}
				}

			k=0;
			for (i=1; i <= numNuc/3; i++)
				{
				
				number_to_codon_MRCA(codonMRCASeq[i], nucX);

				matrix[pos(GMRCA_label,i+k,numSites)] = nucX[0];
				k++;
				matrix[pos(GMRCA_label,i+k,numSites)] = nucX[1];
				k++;
				matrix[pos(GMRCA_label,i+k,numSites)] = nucX[2];
				/*fprintf (fpmpi, "Loop2. codonMRCASeq[%d] = %d; nucX[0] = %d, nucX[1] = %d, nucX[2] = %d \n", i, codonMRCASeq[i], nucX[0], nucX[1], nucX[2]);*/
				}

			free (codonMRCASeq);

			}
		else
			{	
			for (i = 1; i <= numNuc; i++)
				{
				cumPi[0] = p_i[0];
				for (j = 1; j < 4; j++)
					cumPi[j] = cumPi[j-1] + p_i[j];
			
				ran = RandomUniform(seed);

				if (ran >= 0.0 && ran <= cumPi[0])
					matrix[pos(GMRCA_label,i,numSites)] = 0;
				else if (ran > cumPi[0] && ran <= cumPi[1])
					matrix[pos(GMRCA_label,i,numSites)] = 1;
				else if (ran > cumPi[1] && ran <= cumPi[2])
					matrix[pos(GMRCA_label,i,numSites)] = 2;
				else
					matrix[pos(GMRCA_label,i,numSites)] = 3;
				}
			}
		}
	

	
	if (doProtStabDNAFile == YES) /* POP_EVOL from Ugo Bastolla */
		{
    	w = 0; 		/* w=0, it starts from the GMRCA and let's apply the site 1 (the sequence should have at least 1 site) */
		i = 1;
		
		mkdir("Results/ProteinStability",S_IRWXU);	/* Create "Results" folder (with type S_IRWXU (read, write and execute)) */ 
		#ifdef MAC					
			strcpy (dirStability,":Results/ProteinStability:");	/* Copy the string in char variable dir = Results (char), is different mac vs windows */
		#else
			strcpy (dirStability,"Results/ProteinStability/");
		#endif

		SimulateDataForSite_Nucleotide_RECURSIVE_NET_Pop_Evol (treeRootInit[w], i, numSites, m, kappa, seed, dataSetNum, dirStability);

		/*fprintf (fpmpi, "\n\n End all SimulateDataForSite_Nucleotide_RECURSIVE_NET_Pop_Evol \n\n");*/
		}
	else /* Common DNA models  */
		{
		/*fprintf (fpmpi, "\n Entra en la recursion nucleotidica, EvolveSequenceOnTree_NEW, numRE = %d", numRE);*/
		w = 0;
	
		for (i = 1; i <= numSites; i++)	/************* Other sequences */ /* do this FOR EACH SITE (NUCLEOTIDE)**********/
			{
			/*fprintf (fpmpi, "\n\n +++++++ NUCLEOTIDE = %d ++++++++ \n\n", i);*/

			if (RandomUniform(seed) < pinv)		
				varRate = 0.0;
			else
				{
				if (doRateHet == YES)
					varRate = RndGamma (alpha, seed) / alpha; 
				else
					varRate = 1; 
				}
			if (doHetVectorFile == YES)
				{
				varRate = varRate*vectorHetRates[i-1];
				}

			/* form OLD . La secuencia de entrada es GMRCA */
			if (i == (arrayIndBreakpointsOrd_C[w]+1) && indNumRE != 0)
				w++;
			w = 0; /* NETRECODON Ahora solo hay un nodo raiz, "GMRCA" base de toda la red */



			SimulateDataForSite_Nucleotide_RECURSIVE_NET (treeRootInit[w], i, numSites, m, varRate, kappa, seed);
			}
		/*fprintf (fpmpi, "\n\n SALE DE LA RECURSION \n\n");*/
		}


	free (arrayIndBreakpointsOrd_C);

	}








/********************************** TellMeGMRCALabel ***********************************/
/* It returns the GMRCA label */

int		TellMeGMRCALabel (TreeNode *p)
	{
	int			j;
	j = -1;
	
	if (p != NULL)
		{
		if (p->anc1 == NULL) /* root */		
			{
			j = p->label;
			}
		}
	return (j);
	}





/*void EvolveSequenceOnTree (long int *seed, double m, double kappa, 
							double alpha, double p_i[4], int numSites, int *arrayIndBreakpointsOrd, char *MRCAsequence)
{
	int			i, w;
	double		varRate;
	
	w = 0;
	
	for (i = 1; i <= numSites; i++)
		{
	  	if (RandomUniform(seed) < pinv)		
	  		varRate = 0.0;
	  	else
	  		{
		  	if (doRateHet == YES)
		  		varRate = RndGamma (alpha, seed) / alpha; 
			else
				varRate = 1; 
			}
		if (doHetVectorFile == YES)
			{
			varRate = varRate*vectorHetRates[i-1];
			}
		
		if (i == arrayIndBreakpointsOrd[w])
			w++;
*/
		/*fprintf (fpmpi, "\n w = %d, treeRootNodex[w] label = %d, index = %d  \n", w, treeRootNodex[w]->label, treeRootNodex[w]->index);*/
/*
		SimulateDataForSite (treeRootNodex[w], i, numSites, m, kappa, p_i, varRate, seed, MRCAsequence);
		}
}*/



/********************************** SimulateDataForSite ***********************************/
/* Simulates the nucleotide substitution process for a given site */
/*
void SimulateDataForSite (TreeNodex *p, int siteNum, int numSites, double m, 
							double kappa, double p_i[4], double varRate, long int *seed, char *MRCAsequence)
{
	int			i;
	double		ran, cumPi[4], cumProb[4], Pij[4][4];
	
		
	if (p != NULL)
		{
		if (p->anc1 == NULL) *//* root */	
/*			{
			if (doMRCAFile == YES)
				{
				matrix[pos(p->label,siteNum,numSites)] = WhichNucNumber(MRCAsequence[siteNum-1]); *//* from MRCA input file */
/*				}
			else
				{
				cumPi[0] = p_i[0];
				for (i = 1; i < 4; i++)
					cumPi[i] = cumPi[i-1] + p_i[i];
				ran = RandomUniform(seed);
*/
				/*if (p->label == 1)
					{
					fprintf(stderr,"\n ***** p->label = %d, p->index = %d,  p->time = %lf, sitioNum = %d, deme = %d, node_original = %d \n", p->label, p->index,  p->time, siteNum, p->indexOldMigPop, p->NetIndex);
					}*/
				/*fprintf (fpmpi, "\n p->label = %d \n", p->label);*/
/*
				if (ran >= 0.0 && ran <= cumPi[0])
					matrix[pos(p->label,siteNum,numSites)] = 0;
				else if (ran > cumPi[0] && ran <= cumPi[1])
					matrix[pos(p->label,siteNum,numSites)] = 1;
				else if (ran > cumPi[1] && ran <= cumPi[2])
					matrix[pos(p->label,siteNum,numSites)] = 2;
				else
					matrix[pos(p->label,siteNum,numSites)] = 3;
				}
			}
		else			
			{
			if (p->isOutgroup == YES)
				SubstitutionMatrix (Pij, p->length * m, kappa, varRate, p_i);
			else 				
				SubstitutionMatrix (Pij, (p->anc1->time - p->time) * m, kappa, varRate, p_i);
			
			cumProb[0] = Pij[matrix[pos(p->anc1->label,siteNum,numSites)]][0];
			for (i=1; i<4; i++)
				cumProb[i] = cumProb[i-1] + Pij[matrix[pos(p->anc1->label,siteNum,numSites)]][i];
			ran = RandomUniform(seed);
*/
			/*if (p->label == 1)
				{
				fprintf(stderr,"\n ***** p->label = %d, p->index = %d,  p->time = %lf, (p->anc1->time - p->time) = %lf, sitioNum = %d, deme = %d, node_original = %d \n", p->label, p->index,  p->time, (p->anc1->time - p->time), siteNum, p->indexOldMigPop, p->NetIndex);
				}*/
/*			if (ran >= 0.0 && ran <= cumProb[0])
				matrix[pos(p->label,siteNum,numSites)] = 0; 
			else if (ran > cumProb[0] && ran <= cumProb[1])
				matrix[pos(p->label,siteNum,numSites)] = 1; 
			else if (ran > cumProb[1] && ran <= cumProb[2])
				matrix[pos(p->label,siteNum,numSites)] = 2; 
			else
				matrix[pos(p->label,siteNum,numSites)] = 3; 
			
			if (matrix[pos(p->label,siteNum,numSites)] != matrix[pos(p->anc1->label,siteNum,numSites)])
				numMU++;	
			}
*/		
		/* It crosses the tree */
/*		SimulateDataForSite (p->left, siteNum, numSites, m, kappa, p_i, varRate, seed, MRCAsequence);
		SimulateDataForSite (p->right, siteNum, numSites, m, kappa, p_i, varRate, seed, MRCAsequence);	
		if (thereisOutgroup == YES)
			SimulateDataForSite (p->outgroup, siteNum, numSites, m, kappa, p_i, varRate, seed, MRCAsequence);	
		}
}
*/


/********************* Substitution matrix **********************/
/* Sets the apropriate model of nucleotide substitution  */
static void SubstitutionMatrix (double ch_prob[4][4], double branchLength, double kappa, double varRate, double p_i[4])
{
	if (doHKY == YES)
		HKY (ch_prob, branchLength, kappa, varRate, p_i);
	if (doGTnR == YES)
		GTnR (ch_prob, branchLength, varRate, p_i);
	if (doGTR == YES)
		GTR (ch_prob, branchLength, varRate, p_i);
}





/*********************************** HKY **************************************/
/*	HKY performs Hasegawa-Kishino-Yano 85 correction */ 
 
void HKY (double Pij[4][4], double branchLength, double kappa, double varRate, double p_i[4])
{
	int			i, j;
	double		A, t, PIj, beta; 

	beta = 0.5 / ((p_i[0] + p_i[2])*(p_i[1] + p_i[3]) + kappa*((p_i[0]*p_i[2]) + (p_i[1]*p_i[3])));

	if (varRate > 0)
		varRate = varRate / (1.0 - pinv);

	t = branchLength * varRate;
	/*fprintf(stderr,"\n t = %lf \n", t);*/	

	if (t == 0.0)		/* no mutations */
		{
		for (i=0; i<4; i++)
			{
			for (j=0; j<4; j++)
				{
				if (i == j)
					Pij[i][j] = 1.0;
				else 
					Pij[i][j] = 0.0;
				}
			}
		}
	else				/*there are mutations */
		for (i=0; i<4; i++)
		  	{
		  	for (j=0; j<4; j++)
				{
				if (j == 0 || j == 2)	/* purine */
					PIj = p_i[0] + p_i[2];
				else
					PIj = p_i[1] + p_i[3]; /* pyrimidine */
					
				A = 1 + PIj*(kappa-1);
				
				if (i==j) /* diagonal principal */
					Pij[i][j] = p_i[j] + p_i[j]*(1/PIj - 1)*exp(-beta*t) + ((PIj-p_i[j])/PIj)*exp(-beta*t*A);
				else if ((i==0 && j==2) || (i==1 && j==3) || (i==2 && j==0) || (i==3 && j==1)) /* transition */
					Pij[i][j] = p_i[j] + p_i[j]*(1/PIj - 1)*exp(-beta*t) - (p_i[j]/PIj)*exp(-beta*t*A);
				else /* transversion */
					Pij[i][j] = p_i[j]*(1-exp(-beta*t));
				}
			}
}






/*************** GTR **********************/
void GTR (double Pij[4][4], double branchLength, double varRate, double p_i[4])
{	
	int 	i, j, k;
	double	t, expt[4];
	/* double Rmat[6], Qij[16], Cijk[256], Root[4], mr, tstv; Global Variables*/
	
	if (varRate > 0)
		varRate = varRate / (1.0 - pinv);

	t = branchLength * varRate;

	k=0;
	for (i=0; i<3; i++) 
		for (j=i+1; j<4; j++)
      		if (i*4+j != 11)
				Qij[i*4+j]=Qij[j*4+i]=Rmat[k++];
				
	Qij[3*4+2]=Qij[2*4+3]=1.0;
	
	for (i=0; i<4; i++) 
		for (j=0; j<4; j++)
			Qij[i*4+j] *= p_i[j];
				
	mr=0;		
	for (i=0; i<4; i++) {
		Qij[i*4+i]=0; 
		Qij[i*4+i]=-(Qij[i*4]+Qij[i*4+1]+Qij[i*4+2]+Qij[i*4+3]); 
		
		mr-=p_i[i]*Qij[i*4+i];
		}

	EigenREV(Root, Cijk);
	
	/* calculate mean ts/tv ratio */
	mr=2*(p_i[3]*Qij[3*4+1]+p_i[0]*Qij[0*4+2]);
	tstv=mr/(1-mr); 
	
	
	/* P(t)ij = SUM Cijk * exp{Root*t}*/
	if (t<1e-6) 
		{ 
		for (i=0; i<4; i++) 
			for (j=0; j<4; j++) 
				{
				if (i==j)
					Pij[i][j] = 1.0;
				else 	
					Pij[i][j] = 0.0;
				}
		}
	else
		{
		for (k=1; k<4; k++) 
			expt[k]=exp(t*Root[k]);
		for (i=0; i<4; i++) 
			for (j=0; j<4; j++) 
				{
				Pij[i][j]=Cijk[i*4*4+j*4+0];
				for (k=1; k<4; k++)
					Pij[i][j]+=Cijk[i*4*4+j*4+k]*expt[k];
				}
		}
		
	
	/*
	for (i=0; i<4; i++)
		{
		fprintf(fpmpi,"\n");
		for (j=0; j<4; j++)
			{
			fprintf(fpmpi,"%5.4f ",Pij[i][j]);
			}
		}
		fprintf(fpmpi,"\n\n");
	*/
}





/*************** GTnR **********************/
/* GTR non reversible */
void GTnR (double Pij[4][4], double branchLength, double varRate, double p_i[4])
{	
	int 	i, j, k;
	double	t, expt[4];
		
	if (varRate > 0)
		varRate = varRate / (1.0 - pinv);

	t = branchLength * varRate;
	
	/*	
		A	C	G	T
	A	0	1	2	3
	C	4	5	6	7
	G	8	9	10	11
	T	12	13	14	15
	*/

	/* fills no symetrical matrix */
	k=0;
	for (i=0; i<3; i++) 
		for (j=i+1; j<4; j++)
			{
			Qij[i*4+j]=NRmat[k++];
			Qij[j*4+i]=NRmat[k++];
			}

	
/*	AC CA AG GA AT TA CG GC CT TC GT=1 TG */
	
	/* all rates relative to GT */
	Qij[11] = 1.0;
	
	for (i=0; i<4; i++) 
		for (j=0; j<4; j++) 
			Qij[i*4+j] *= p_i[j];
			
	mr=0;		
	for (i=0; i<4; i++) 
		{
		Qij[i*4+i]=0; 
		Qij[i*4+i]=-(Qij[i*4]+Qij[i*4+1]+Qij[i*4+2]+Qij[i*4+3]); 
		mr-=p_i[i]*Qij[i*4+i];
		}
	
	EigenREV(Root, Cijk);
	
/* calculate mean ts/tv ratio */ /*double check*/
/*	mr=2*(p_i[3]*Qij[3*4+1]+p_i[0]*Qij[0*4+2]);*/
	mr = p_i[3]*Qij[3*4+1] + p_i[0]*Qij[0*4+2] + p_i[1]*Qij[1*4+3] + p_i[2]*Qij[2*4+0] ;
	tstv=mr/(1-mr);
	
/* P(t)ij = SUM Cijk * exp{Root*t}
*/
	if (t<1e-6) /* too small branch */
		{ 
		for (i=0; i<4; i++) 
			for (j=0; j<4; j++) 
				{
				if (i==j)
					Pij[i][j] = 1.0;
				else 	
					Pij[i][j] = 0.0;
				}
		}
	else
		{
		for (k=1; k<4; k++) 
			expt[k]=exp(t*Root[k]);
		for (i=0; i<4; i++) 
			for (j=0; j<4; j++) 
				{
				Pij[i][j]=Cijk[i*4*4+j*4+0];
				for (k=1; k<4; k++)
					Pij[i][j]+=Cijk[i*4*4+j*4+k]*expt[k];
				}
		}
	
	/*
	for (i=0; i<4; i++)
		{
		fprintf(fpmpi,"\n");
		for (j=0; j<4; j++)
			{
			fprintf(fpmpi,"%5.4f ",Pij[i][j]);
			}
		}
		fprintf(fpmpi,"\n\n");
		
	*/
}







/***********************************************************************************************/
/************************************ user-specified trees ************************************/
/***********************************************************************************************/


/********************************** EvolveSequenceOnTree_UserTrees_Nt ***********************************/
/* This function evolves sequences on the user-specified trees by nucleotide model */

void EvolveSequenceOnTree_UserTrees_Nt (long int *seed, double kappa, double alpha, double p_i[4], int numSites, int numNuc, char *MRCAsequence, int dataSetNum, char *dirStability)
{
	int			siteNum, treeNum;
	double		siteRate=0.0;
	Treetnode	*roottnode;
	/*fprintf (fpmpi, "\n\n EvolveSequenceOnTree_NEW_AA. seed = %lu \n", seed);*/

/* fprintf (fpmpi, "\n Init of EvolveSequenceOnTree_UserTrees_Nt \n\n"); */
/*	fprintf(fpmpi, "\nMRCAsequence0: %d\n", WhichNucNumber(MRCAsequence[0]));
	fprintf(fpmpi, "\nMRCAsequence1: %d\n", WhichNucNumber(MRCAsequence[1]));
	fprintf(fpmpi, "\nMRCAsequence2: %d\n", WhichNucNumber(MRCAsequence[2]));
	fprintf(fpmpi, "\nMRCAsequence3: %d\n", WhichNucNumber(MRCAsequence[3]));	*/


	if (doProtStabDNAFile == YES) /* POP_EVOL from Ugo Bastolla */
		{
    	siteNum=0,treeNum=0;
		
		mkdir("Results/ProteinStability",S_IRWXU);	/* Create "Results" folder (with type S_IRWXU (read, write and execute)) */ 
		#ifdef MAC					
			strcpy (dirStability,":Results/ProteinStability:");	/* Copy the string in char variable dir = Results (char), is different mac vs windows */
		#else
			strcpy (dirStability,"Results/ProteinStability/");
		#endif


		/* decide which tree */ 
		if (siteNum<tree[treeNum].end)
			roottnode = (Treetnode *)tree[treeNum].tnode;
		else
			roottnode = (Treetnode *)tree[++treeNum].tnode;


		SimulateDataForSite_UserTrees_Nt_Pop_Evol (roottnode, siteNum, numSites, numNuc, kappa, p_i, siteRate, seed, MRCAsequence, dataSetNum, dirStability);

		/*fprintf (fpmpi, "\n\n End all SimulateDataForSite_UserTrees_Nt_Pop_Evol \n\n");*/
		}
	else /* Common DNA models  */
		{
		for (siteNum=0,treeNum=0; siteNum<numSites; siteNum++)
			{
		  	if (RandomUniform(seed) < pinv)
	  			siteRate = 0.0;
		  	else
		  		{
			  	if (doRateHet == YES)
			  		siteRate = RandomGamma (alpha, seed) / alpha;
				else
					siteRate = 1;
				}
			if (doHetVectorFile == YES)
				{
				siteRate = siteRate*vectorHetRates[siteNum];
				}
		
			/* decide which tree */ 
			if (siteNum<tree[treeNum].end)
				roottnode = (Treetnode *)tree[treeNum].tnode;
			else
				roottnode = (Treetnode *)tree[++treeNum].tnode;
		
			SimulateDataForSite_UserTrees_Nt (roottnode, siteNum, numSites, numNuc, kappa, p_i, siteRate, seed, MRCAsequence);		
			}
		}
	
/*fprintf (fpmpi, "\n End of EvolveSequenceOnTree_UserTrees_Nt \n\n");*/

}



/********************************** SimulateDataForSite_UserTrees_Nt ***********************************/
/* Simulates the nucleotide substitution process for a given site */

void SimulateDataForSite_UserTrees_Nt (Treetnode *p, int siteNum, int numSites, int numNuc, 
							double kappa, double p_i[4], double siteRate, long int *seed, char *MRCAsequence)
{
	int			i;
	double		ran, cumPi[4], cumProb[4], Pij[4][4];

	if (p != NULL)
		{
		if (p->parent == NULL) /* root */
			{

			if (doMRCAFile == YES) /* MRCA from File */
				{		
				matrix[pos(p->label,siteNum,numNuc)] = WhichNucNumber(MRCAsequence[siteNum]); /* from MRCA input file */
				}
			else /* MRCA from nucleotide frequencies */
				{		
				cumPi[0] = p_i[0];
				for (i = 1; i < 4; i++)
					cumPi[i] = cumPi[i-1] + p_i[i];
			
				ran = RandomUniform(seed);
	
				if (ran >= 0.0 && ran <= cumPi[0])
					matrix[pos(p->label,siteNum,numSites)] = 0;
				else if (ran > cumPi[0] && ran <= cumPi[1])
					matrix[pos(p->label,siteNum,numSites)] = 1;
				else if (ran > cumPi[1] && ran <= cumPi[2])
					matrix[pos(p->label,siteNum,numSites)] = 2;
				else
					matrix[pos(p->label,siteNum,numSites)] = 3;
				}

			/*fprintf (fpmpi, "\nsite %d root %d (%s) ", siteNum+1, p->index, p->name);*/
/*			fprintf (fpmpi, "%c", WhichNuc(matrix[pos(p->label,siteNum,numSites)]));
*/
			}
		else
			{
			SubstitutionMatrix (Pij, p->length, kappa, siteRate, p_i); /* Ok = */
			cumProb[0] = Pij[matrix[pos(p->parent->label,siteNum,numSites)]][0];
			for (i=1; i<4; i++)
				cumProb[i] = cumProb[i-1] + Pij[matrix[pos(p->parent->label,siteNum,numSites)]][i];
			ran = RandomUniform(seed);
			if (ran >= 0.0 && ran <= cumProb[0])
				matrix[pos(p->label,siteNum,numSites)] = 0;
			else if (ran > cumProb[0] && ran <= cumProb[1])
				matrix[pos(p->label,siteNum,numSites)] = 1;
			else if (ran > cumProb[1] && ran <= cumProb[2])
				matrix[pos(p->label,siteNum,numSites)] = 2;
			else
				matrix[pos(p->label,siteNum,numSites)] = 3;

			/*fprintf (fperr, "\nsite %d tnode %d (%s), its parent is: tnode %d (%s)", siteNum+1, p->index, p->name, p->parent->index, p->parent->name);*/
/*			if (matrix[pos(p->label,siteNum,numSites)] != matrix[pos(p->parent->label,siteNum,numSites)])
				fprintf (fpmpi, " %c>%c", WhichNuc(matrix[pos(p->parent->label,siteNum,numSites)]), WhichNuc(matrix[pos(p->label,siteNum,numSites)]));
*/

			if (matrix[pos(p->label,siteNum,numSites)] != matrix[pos(p->parent->label,siteNum,numSites)])
				{
				numMU++;	
				/*fprintf(stderr,"\n < MUT, numMU = %d [%c>%c]\n", numMU, WhichNuc(matrix[pos(p->parent->label,siteNum,numSites)]), WhichNuc(matrix[pos(p->label,siteNum,numSites)]));*/
				}

			}
		
		for (i=0; i<p->numChildren; i++)
			SimulateDataForSite_UserTrees_Nt (p->child[i], siteNum, numSites, numNuc, kappa, p_i, siteRate, seed, MRCAsequence);		

		}
}




/********************************** EvolveSequenceOnTree_UserTrees_AA ***********************************/
/* This function evolves amino acid sequences on the user-specified trees */

void EvolveSequenceOnTree_UserTrees_AA (long int *seed, double alpha, double p_i_aa[20], int numSites, int numNuc, char *MRCAsequence, int dataSetNum, char *dirStability)
	{

	int			siteNum, treeNum;
	double		siteRate;
	Treetnode	*roottnode;


	if (doProtStabAAFile == YES) /* POP_EVOL from Ugo Bastolla */
		{
    	siteNum=0,treeNum=0;
		
		mkdir("Results/ProteinStability",S_IRWXU);	/* Create "Results" folder (with type S_IRWXU (read, write and execute)) */ 
		#ifdef MAC					
			strcpy (dirStability,":Results/ProteinStability:");	/* Copy the string in char variable dir = Results (char), is different mac vs windows */
		#else
			strcpy (dirStability,"Results/ProteinStability/");
		#endif


		/* decide which tree */ 
		if (siteNum<tree[treeNum].end)
			roottnode = (Treetnode *)tree[treeNum].tnode;
		else
			roottnode = (Treetnode *)tree[++treeNum].tnode;

		/*fprintf (fpmpi, "\n\n In all SimulateDataForSite_UserTrees_AA_Pop_Evol \n\n");*/
		SimulateDataForSite_UserTrees_AA_Pop_Evol (roottnode, siteNum, numSites, numNuc, p_i_aa, seed, MRCAsequence, dataSetNum, dirStability);

		/*fprintf (fpmpi, "\n\n End all SimulateDataForSite_UserTrees_AA_Pop_Evol \n\n");*/
		}
	else /* Common AA models  */
		{
		for (siteNum=0,treeNum=0; siteNum<numSites; siteNum++)
			{
		  	if (RandomUniform(seed) < pinv)
		  		siteRate = 0.0;
		  	else
	 	 		{
			  	if (doRateHet == YES)
			  		siteRate = RandomGamma (alpha, seed) / alpha;
				else
					siteRate = 1;
				}
			if (doHetVectorFile == YES)
				{
				siteRate = siteRate*vectorHetRates[siteNum];
				}
		
			/* decide which tree */ 
			if (siteNum<tree[treeNum].end)
				roottnode = (Treetnode *)tree[treeNum].tnode;
			else
				roottnode = (Treetnode *)tree[++treeNum].tnode;
		
			SimulateDataForSite_UserTrees_AA (roottnode, siteNum, numSites, numNuc, p_i_aa, siteRate, seed, MRCAsequence);		
			}	
		}
	}




/********************************** SimulateDataForSite_UserTrees_AA ***********************************/
/* Simulates the amino acid substitution process for a given site */

void SimulateDataForSite_UserTrees_AA (Treetnode *p, int siteNum, int numSites, int numNuc, 
							double p_i_aa[20], double siteRate, long int *seed, char *MRCAsequence)
{
	int			i;
	double		ran, cumPi[20], cumProb[20], Pij[20][20];

	if (p != NULL)
		{
		if (p->parent == NULL) /* root */
			{

			if (doMRCAFile == YES) /* MRCA from File */
				{
				matrix[pos(p->label,siteNum,numNuc)] = WhichAANumber(MRCAsequence[siteNum]); /* from MRCA input file */
				}
			else /* MRCA from amino acid frequencies */
				{				
				cumPi[0] = p_i_aa[0];
				for (i = 1; i < 20; i++)
					cumPi[i] = cumPi[i-1] + p_i_aa[i];

				ran = RandomUniform(seed);

				if (ran >= 0.0 && ran <= cumPi[0])
					matrix[pos(p->label,siteNum,numSites)] = 0;
				else if (ran > cumPi[0] && ran <= cumPi[1])
					matrix[pos(p->label,siteNum,numSites)] = 1;
				else if (ran > cumPi[1] && ran <= cumPi[2])
					matrix[pos(p->label,siteNum,numSites)] = 2;
				else if (ran > cumPi[2] && ran <= cumPi[3])
					matrix[pos(p->label,siteNum,numSites)] = 3;
				else if (ran > cumPi[3] && ran <= cumPi[4])
					matrix[pos(p->label,siteNum,numSites)] = 4;
				else if (ran > cumPi[4] && ran <= cumPi[5])
					matrix[pos(p->label,siteNum,numSites)] = 5;
				else if (ran > cumPi[5] && ran <= cumPi[6])
					matrix[pos(p->label,siteNum,numSites)] = 6;
				else if (ran > cumPi[6] && ran <= cumPi[7])
					matrix[pos(p->label,siteNum,numSites)] = 7;
				else if (ran > cumPi[7] && ran <= cumPi[8])
					matrix[pos(p->label,siteNum,numSites)] = 8;
				else if (ran > cumPi[8] && ran <= cumPi[9])
					matrix[pos(p->label,siteNum,numSites)] = 9;
				else if (ran > cumPi[9] && ran <= cumPi[10])
					matrix[pos(p->label,siteNum,numSites)] = 10;
				else if (ran > cumPi[10] && ran <= cumPi[11])
					matrix[pos(p->label,siteNum,numSites)] = 11;
				else if (ran > cumPi[11] && ran <= cumPi[12])
					matrix[pos(p->label,siteNum,numSites)] = 12;
				else if (ran > cumPi[12] && ran <= cumPi[13])
					matrix[pos(p->label,siteNum,numSites)] = 13;
				else if (ran > cumPi[13] && ran <= cumPi[14])
					matrix[pos(p->label,siteNum,numSites)] = 14;
				else if (ran > cumPi[14] && ran <= cumPi[15])
					matrix[pos(p->label,siteNum,numSites)] = 15;
				else if (ran > cumPi[15] && ran <= cumPi[16])
					matrix[pos(p->label,siteNum,numSites)] = 16;
				else if (ran > cumPi[16] && ran <= cumPi[17])
					matrix[pos(p->label,siteNum,numSites)] = 17;
				else if (ran > cumPi[17] && ran <= cumPi[18])
					matrix[pos(p->label,siteNum,numSites)] = 18;
				else
					matrix[pos(p->label,siteNum,numSites)] = 19;
				}

			/*fprintf (fpmpi, "\nsite %d root %d (%s) ", siteNum+1, p->index, p->name);*/
/*			fprintf (fpmpi, "%c", WhichNuc(matrix[pos(p->label,siteNum,numSites)]));
*/
			}
		else
			{
			AAevolModel (Pij, p->length, siteRate); /* Ok = */

			cumProb[0] = Pij[matrix[pos(p->parent->label,siteNum,numSites)]][0];
			for (i=1; i<20; i++)
				cumProb[i] = cumProb[i-1] + Pij[matrix[pos(p->parent->label,siteNum,numSites)]][i];
			ran = RandomUniform(seed);
							
			if (ran >= 0.0 && ran <= cumProb[0])
				matrix[pos(p->label,siteNum,numSites)] = 0; 
			else if (ran > cumProb[0] && ran <= cumProb[1])
				matrix[pos(p->label,siteNum,numSites)] = 1; 
			else if (ran > cumProb[1] && ran <= cumProb[2])
				matrix[pos(p->label,siteNum,numSites)] = 2;
			else if (ran > cumProb[2] && ran <= cumProb[3])
				matrix[pos(p->label,siteNum,numSites)] = 3; 
			else if (ran > cumProb[3] && ran <= cumProb[4])
				matrix[pos(p->label,siteNum,numSites)] = 4;
			else if (ran > cumProb[4] && ran <= cumProb[5])
				matrix[pos(p->label,siteNum,numSites)] = 5; 
			else if (ran > cumProb[5] && ran <= cumProb[6])
				matrix[pos(p->label,siteNum,numSites)] = 6;
			else if (ran > cumProb[6] && ran <= cumProb[7])
				matrix[pos(p->label,siteNum,numSites)] = 7; 
			else if (ran > cumProb[7] && ran <= cumProb[8])
				matrix[pos(p->label,siteNum,numSites)] = 8;
			else if (ran > cumProb[8] && ran <= cumProb[9])
				matrix[pos(p->label,siteNum,numSites)] = 9; 
			else if (ran > cumProb[9] && ran <= cumProb[10])
				matrix[pos(p->label,siteNum,numSites)] = 10;
			else if (ran > cumProb[10] && ran <= cumProb[11])
				matrix[pos(p->label,siteNum,numSites)] = 11; 
			else if (ran > cumProb[11] && ran <= cumProb[12])
				matrix[pos(p->label,siteNum,numSites)] = 12;
			else if (ran > cumProb[12] && ran <= cumProb[13])
				matrix[pos(p->label,siteNum,numSites)] = 13; 
			else if (ran > cumProb[13] && ran <= cumProb[14])
				matrix[pos(p->label,siteNum,numSites)] = 14;
			else if (ran > cumProb[14] && ran <= cumProb[15])
				matrix[pos(p->label,siteNum,numSites)] = 15; 
			else if (ran > cumProb[15] && ran <= cumProb[16])
				matrix[pos(p->label,siteNum,numSites)] = 16;
			else if (ran > cumProb[16] && ran <= cumProb[17])
				matrix[pos(p->label,siteNum,numSites)] = 17; 
			else if (ran > cumProb[17] && ran <= cumProb[18])
				matrix[pos(p->label,siteNum,numSites)] = 18;
			else
				matrix[pos(p->label,siteNum,numSites)] = 19; 
			

			/*fprintf (fpmpi, "\nsite %d tnode %d (%s), its parent is: tnode %d (%s)", siteNum+1, p->index, p->name, p->parent->index, p->parent->name);*/
/*			if (matrix[pos(p->label,siteNum,numSites)] != matrix[pos(p->parent->label,siteNum,numSites)])
				fprintf (fpmpi, " %c>%c", WhichAA(matrix[pos(p->parent->label,siteNum,numSites)]), WhichAA(matrix[pos(p->label,siteNum,numSites)]));
*/

			if (matrix[pos(p->label,siteNum,numSites)] != matrix[pos(p->parent->label,siteNum,numSites)])
					{
					numMU++;	
					/*fprintf(stderr,"\n < MUT, numMU = %d [%c>%c]\n", numMU, WhichAA(matrix[pos(p->parent->label,siteNum,numSites)]), WhichAA(matrix[pos(p->label,siteNum,numSites)]));*/
					}

			}
		
		for (i=0; i<p->numChildren; i++)
			SimulateDataForSite_UserTrees_AA (p->child[i], siteNum, numSites, numNuc, p_i_aa, siteRate, seed, MRCAsequence);	
		}
}





/********************************** EvolveSequenceOnTree_UserTrees_Codon ***********************************/
/* This function evolves codon sequences on the user-specified trees */

void EvolveSequenceOnTree_UserTrees_Codon (long int *seed, double alpha, int numSites, int numNuc, char *MRCAsequence, int numOmegaCat)
	{

	int			siteNum, treeNum;
	double		siteRate;
	Treetnode	*roottnode;
	
	int 		a, e, numCo;
	double		*BBM0cumProbCat;
	double		ran;
	int			BBM0ProbCategory;
	double 		*cumProbCatM1, *cumProbCatM8, *cumProbCat, *hetProb;
	double		betaVar, GammaVarRateOmega, VarOmega1;
	double		cumProbCatM6[3], cumProbCatM910[3];
	double		GammaVarRateOmegaM6, VarOmegaM6, GammaVarRateOmegaM910, VarOmegaM910;
	double		BBM0GammaVarRateOmega, BBM0VarOmega1, BBM0omega, BBM0betaVar, BBM0M7_FinalSite_omega, BBM0partialomega;
	Treetnode	*roottnode_x, *x;
	int			i, w, n, j, sitePosition, siteCodon, M8option, z;
	double		cumFreq[64];
	int			out_C[4], codon[3];
	int			*codonMRCASeqx;
	double		dNdSbranches[MAX_tnodeS];

	w = sitePosition = a = j = M8option = e = z = 0;
	n = siteCodon = 1;
	out_C[0] = out_C[1] = out_C[2] = out_C[3] = -1;
	BBM0omega = -1;	
				

	/***************** MRCA sequence *********************/

	codonMRCASeqx = (int *)calloc((numSites+1),(long) sizeof(int));
	if (!codonMRCASeqx)
		{
		fprintf (fpmpi, "Could not allocate codonMRCASeqx (%lu bytes)\n", (numSites+1)  * (long) sizeof(int));		
		exit (1);
		}

	if (doMRCAFile == YES) /* MRCA from File */
		{
		for (i = 1; i <= numNuc; i++)		/* taking MRCA sequence */
			{
			sitePosition = n;	/* site position */
			n++;
			if (n == 4)
				n = 1;

			if (sitePosition == 1)
				out_C[1] = WhichNucNumber(MRCAsequence[i-1]); /* MRCAsequence goes from 0 to numNuc-1 */
			else if (sitePosition == 2)
				out_C[2] = WhichNucNumber(MRCAsequence[i-1]);
			else
				{
				out_C[3] = WhichNucNumber(MRCAsequence[i-1]);
			
				if ((out_C[1] == 3 && out_C[2] == 0 && out_C[3] == 0) || (out_C[1] == 3 && out_C[2] == 0 && out_C[3] == 2) || (out_C[1] == 3 && out_C[2] == 2 && out_C[3] == 0)) /* Checking stop codons */
					{
					fprintf (fpmpi, "\nWarning: There are some STOP CODON in your MRCA sequence (site %d):", siteCodon);
					if (out_C[1] == 3 && out_C[2] == 0 && out_C[3] == 0)
						fprintf (fpmpi, " TAA");
					if (out_C[1] == 3 && out_C[2] == 0 && out_C[3] == 2)
						fprintf (fpmpi, " TAG");
					if (out_C[1] == 3 && out_C[2] == 2 && out_C[3] == 0)
						fprintf (fpmpi, " TGA");
					exit(-1);
					}
				if (out_C[0] != -1 || out_C[1] != -1 || out_C[2] != -1 || out_C[3] != -1)	
					{
					codonMRCASeqx[siteCodon] = makeCodonFromNuc(out_C[1], out_C[2], out_C[3]);

					if (codonMRCASeqx[siteCodon] > 60)
						{
						fprintf (fpmpi, "\n stop codon20 \n");
						exit(-1);
						}
					siteCodon++;
					out_C[0] = out_C[1] = out_C[2] = out_C[3] = -1;
					}
				else
					{
					fprintf (fpmpi, "\nWarning: Error from EnterCodonMRCA function");
					exit (-1);
					}
				}
			}
		}
	else /* MRCA from nucleotide frequencies */
		{
		cumFreq[0] = codonTable_frequencies_MRCA(0);
		for (i = 1; i <= 63; i++)
			cumFreq[i] = cumFreq[i-1] + codonTable_frequencies_MRCA(i);

		/*fprintf (fpmpi, "\n cumFreq[0] = %lf", cumFreq[0]);*/
		for (i = 1; i <= 63; i++)
			{
			cumFreq[i] = cumFreq[i]/cumFreq[63];
			/*fprintf (fpmpi, "\n cumFreq[%d] = %lf", i, cumFreq[i]);*/
			}
		
		for (i=1; i <= numSites; i++)
			{
			ran = RandomUniform(seed);
			codonMRCASeqx[i] = bbin_EnterMRCA(ran, cumFreq); /* codon MRCA sequence */
			/*if (i == 1)
				{
				fprintf (fpmpi, "\n ran = %lf", ran);
				fprintf (fpmpi, "\n codonMRCASeqx[%d] = %d", i, codonMRCASeqx[i]);
				}*/
			
			/*fprintf (fpmpi, "\n codon[%d] = %d", i, codonMRCASeqx[i]);*/  /* active to see the GMRCA codon sequence */

/*			matrixC[pos(out_C[0],i,numSites)] = codonMRCASeqx[i]; */
			
			if (codonMRCASeqx[i] == 48 || codonMRCASeqx[i] == 50 || codonMRCASeqx[i] == 56) /* Cheking stop codons */
				{
				fprintf (fpmpi, "\n Warning by stop codons in EvolveSequenceOnTree_Codon");
				exit (-2);
				}
			}
	

		numCo = 1;
		for (i = 1; i <= numNuc; i++)
			{
			/*fprintf (fpmpi, "\n nuc %d, numCo %d", i, numCo);*/			
			
			sitePosition = n;	/* site position */
			n++;
			
			if (n == 4)
				n = 1;
				
			if (sitePosition == 1 && i != 1)
				numCo++;
				

			number_to_codon_MRCA(codonMRCASeqx[numCo], codon); /* de un codon salen 3 nucleotidos para el vector "codon" */

			if (sitePosition == 1)
				{
				out_C[1] = codon[0];
				/*fprintf (fpmpi, "\n out_C[%d] = %d", sitePosition, out_C[sitePosition]);*/
				}
			else if (sitePosition == 2)
				{
				out_C[2] = codon[1];
				/*fprintf (fpmpi, "\n out_C[%d] = %d", sitePosition, out_C[sitePosition]);*/
				}
			else
				{
				out_C[3] = codon[2];
				/*fprintf (fpmpi, "\n out_C[%d] = %d", sitePosition, out_C[sitePosition]);*/	

				if ((out_C[1] == 3 && out_C[2] == 0 && out_C[3] == 0) || (out_C[1] == 3 && out_C[2] == 0 && out_C[3] == 2) || (out_C[1] == 3 && out_C[2] == 2 && out_C[3] == 0))
					{
					fprintf (fpmpi, "\nWarning: There are some STOP CODONS in the MRCA sequence:");
					if (out_C[1] == 3 && out_C[2] == 0 && out_C[3] == 0)
						fprintf (fpmpi, " TAA");
					if (out_C[1] == 3 && out_C[2] == 0 && out_C[3] == 2)
						fprintf (fpmpi, " TAG");
					if (out_C[1] == 3 && out_C[2] == 2 && out_C[3] == 0)
						fprintf (fpmpi, " TGA");						
					exit(-1);
					}
				
				if (out_C[0] != -1 || out_C[1] != -1 || out_C[2] != -1 || out_C[3] != -1)	
					{
					/*matrixC[pos(out_C[0],siteCodon,numSites)] = makeCodonFromNuc(out_C[1], out_C[2], out_C[3]);*/
					codonMRCASeqx[siteCodon] = makeCodonFromNuc(out_C[1], out_C[2], out_C[3]);
					/*fprintf (fpmpi, "\n from nuc Freq, GMRCA, out_C_0 = %d\n", out_C[0]);*/
					
					if (codonMRCASeqx[siteCodon] > 60)
						{
						fprintf (fpmpi, "\n stop codon21 \n");
						exit(-1);
						}
					siteCodon++;
					out_C[0] = out_C[1] = out_C[2] = out_C[3] = -1;
					}
				else
					{
					fprintf (fpmpi, "\nWarning: Error from EnterCodonMRCA function");
					exit (-1);
					}
				}
			}


		}
	


	/**************************************/
	/* VARIABLE dN/dS per branch, it is included in the node.. */
	/*fprintf (fpmpi, "\n Entra en la recursion, EvolveSequenceOnTree_Codon, numRE = %d, numREbreakCod = %d", numRE, numREbreakCod);*/
	w = 0;
	if (doPrintOmegasPerSitefiles == YES && doVariableDnDsBranches == NO) /* print omegas to file */
		fprintf(fpOmegasPerSitePrint,"Site      OmegaValue\n");
	if (doPrintOmegasPerSitefiles == YES && doVariableDnDsBranches == YES) /* print omegas to file */
		fprintf(fpOmegasPerSitePrint,"Site,   Branch   ->   OmegaValue\n");

	if  (doVariableDnDsBranches == YES && doOmegaProb == NO && doOmegaRateHetDisc == NO && doM1 == NO)
		{
		if (noisy >= 2)
			fprintf (stderr, "> Variable omega per branch may take some time \n");
		}

	/**** Special for dN/dS constant (M0) in per dN/dS branch *****/
	if  (doVariableDnDsBranches == YES && doBBM0 == YES) /* BBmodelNumber 1,2,3 */
		{
		/*fprintf (stderr, "\n * Variable omega per branch and M0 *\n");*/

		for (a=0; a<MAX_tnodeS; a++)
			dNdSbranches[a] = -1;

		for (a=0; a<MAX_tnodeS; a++)
			{
			if (BBmodelNumber == 1) /* categories from the user */ /* BBnumOmegaCat, BBomegaVal, BBomegaProb,  */
				{
				BBM0cumProbCat =  (double*) calloc ((BBnumOmegaCat+1), sizeof (double));  
				if (BBM0cumProbCat == NULL)
					{
					fprintf (fpmpi, "Could not allocate BBM0cumProbCat (%lu bytes)", (BBnumOmegaCat+1) * (long) sizeof (double));
					exit(1);
					}
			
				for (e=1; e<=BBnumOmegaCat; e++)
					BBM0cumProbCat[e] = 0;
				BBM0cumProbCat[0] = 0;
	
				for (e=1; e<=BBnumOmegaCat; e++)
					BBM0cumProbCat[e] = BBM0cumProbCat[e-1] + BBomegaProb[e];
				ran = RandomUniform(seed);

				BBM0ProbCategory = bbinInOmegaCat (ran, BBM0cumProbCat, BBnumOmegaCat);
				e = 0;
				free (BBM0cumProbCat);
				/*fprintf (stderr, "\n BBM0ProbCategory = %d \n", BBM0ProbCategory);*/

				BBM0partialomega = BBomegaVal[BBM0ProbCategory];
				BBM0omega = roundit(BBM0partialomega,5);

				/*fprintf (stderr, "\n BBM0omega 1 = %lf", BBM0omega);*/
				}
			else if (BBmodelNumber == 2) /* gamma distribution */ /* BBOmegaRateHet, BBomega, BBOmegaInit */
				{
				BBM0GammaVarRateOmega = RndGamma (BBOmegaRateHet, seed) / BBOmegaRateHet; 
				BBM0VarOmega1 = BBOmegaInit*BBM0GammaVarRateOmega;
				BBM0omega = roundit(BBM0VarOmega1,5);

				/*fprintf (stderr, "\n BBM0omega 2 = %lf", BBM0omega);*/
				}
			else if (BBmodelNumber == 3) /* beta distribution */ /* BBM7_p_beta, BBM7_q_beta */
				{
				BBM0betaVar = RandomBeta (BBM7_p_beta, BBM7_q_beta, seed);
				BBM0M7_FinalSite_omega = BBM0betaVar;
				BBM0omega = roundit(BBM0M7_FinalSite_omega,5);

				/*fprintf (stderr, "\n BBM0omega 3 = %lf", BBM0omega);*/
				}
			else
				{
				fprintf (stderr, "\n ERROR in EvolveSequenceOnTree_Codon function, bad M0 model from dN/dS per branch: BBmodelNumber (%d) \n", BBmodelNumber);
				exit (-1);
				}

			dNdSbranches[a] = BBM0omega;
			/*fprintf (stderr, "\n Branchx: %d, BBM0omega = %lf, MAX_tnodeS=%d \n", a, BBM0omega, MAX_tnodeS);*/
			}
		a = 0;

		/* Introduce omega values in tnodes */
		/*for (z=0; z<numTrees; z++)
			{
			roottnode_x = (Treetnode *)tree[z].tnode;
			AsignDNDSbranches (roottnode_x, MAX_tnodeS, dNdSbranches);
			}*/

		for (z=0; z<numTrees; z++)
			{
			roottnode_x = (Treetnode *)tree[z].tnode;

			for (j=0; j<2*numSequences; j++)
				{
				x = roottnode_x + j;
				x->BBM0omg = dNdSbranches[j]; /* remember this means same procedure for all trees of a same replicate */
				
				/*fprintf (stderr, "Branchx: %d, BBM0omega = %lf, p->index = %d, Value(p->BBM0omg) = %lf \n", j, dNdSbranches[j], x->index, x->BBM0omg);*/
				}
			}

		}



	/****************** Now for each codon *******************/
	for (siteNum=0,treeNum=0; siteNum<numSites; siteNum++)
		{


		/******* ALL VARIABLE CODON MODELS PER SITE. PROB, GAMMA, M1, M7 and M8 codon models *******/
		if (doVariableDnDsBranches == NO) /* variation only per site, not per branch */
		{
		if (doOmegaProb == YES)
			{
			cumProbCat =  (double*) calloc ((numOmegaCat+1), sizeof (double));  
			if (cumProbCat == NULL)
				{
				fprintf (fpmpi, "Could not allocate cumProbCat (%lu bytes)", (numOmegaCat+1) * (long) sizeof (double));
				exit(1);
				}
			
			for (j=1; j<=numOmegaCat; j++)
				cumProbCat[j] = 0;
			cumProbCat[0] = 0;
			for (j=1; j<=numOmegaCat; j++)
				cumProbCat[j] = cumProbCat[j-1] + omegaProb[j];
			ran = RandomUniform(seed);
			ProbCategory = bbinInOmegaCat (ran, cumProbCat, numOmegaCat);
			j = 0;
			free (cumProbCat);
			/*fprintf (stderr, "\n ProbCategory = %d \n", ProbCategory);*/
			if (doPrintOmegasPerSitefiles == YES) /* print omegas to file */
				{
				fprintf(fpOmegasPerSitePrint,"Site %d - Omega %3.5f\n", siteNum+1, omegaVal[ProbCategory]);
				}
			}

		if (doOmegaRateHetDisc == YES)
			{
			hetProb =  (double*) calloc ((numOmegaCat+1), sizeof (double));  
			if (hetProb == NULL)
				{
				fprintf (fpmpi, "Could not allocate hetProb (%lu bytes)", (numOmegaCat+1) * (long) sizeof (double));
				exit(1);
				}
			cumProbCat =  (double*) calloc ((numOmegaCat+1), sizeof (double));  
			if (cumProbCat == NULL)
				{
				fprintf (fpmpi, "Could not allocate cumProbCat (%lu bytes)", (numOmegaCat+1) * (long) sizeof (double));
				exit(1);
				}			

			for (j=1; j<=numOmegaCat; j++)
				{
				cumProbCat[j] = 0;
				hetProb[j] = 1.0/numOmegaCat;
				}
			cumProbCat[0] = 0;
			for (j=1; j<=numOmegaCat; j++)
				cumProbCat[j] = cumProbCat[j-1] + hetProb[j];
			ran = RandomUniform(seed);
			GammCategory = bbinInOmegaCat (ran, cumProbCat, numOmegaCat);
			j = 0;
			free (hetProb);
			free (cumProbCat);

			/*fprintf (stderr, "\n GammCategory = %d \n", GammCategory);*/
			if (doPrintOmegasPerSitefiles == YES) /* print omegas to file */
				{
				fprintf(fpOmegasPerSitePrint,"Site %d - Omega %3.5f\n", siteNum+1, omegaValGammaRate[GammCategory]);
				}
			}



		if (doM1 == YES) /* for each site */ /* Important Note: M1_FinalSite_omega = 1, prop0, omega will be 0; if M1_FinalSite_omega = 2, prop1, omega will be 1  */
			{
			cumProbCatM1 =  (double*) calloc ((numOmegaCat+1), sizeof (double));  
			if (cumProbCatM1 == NULL)
				{
				fprintf (fpmpi, "Could not allocate cumProbCatM1 (%lu bytes)", (numOmegaCat+1) * (long) sizeof (double));
				exit(1);
				}
			
			/*fprintf(fpmpi,"\n Categ number = %d \n", numOmegaCat);*/ 


			for (j=1; j<=numOmegaCat; j++)
				cumProbCatM1[j] = 0;
			cumProbCatM1[0] = 0;
			for (j=1; j<=numOmegaCat; j++)
				{
				cumProbCatM1[j] = cumProbCatM1[j-1] + omegaProb[j];
				/*fprintf (stderr, "\n cumProbCatM1[%d] = %lf \n", j, cumProbCatM1[j]);*/
				}
			ran = RandomUniform(seed);
			M1_FinalSite_omega = bbinInOmegaCat (ran, cumProbCatM1, numOmegaCat);
			j = 0;
			/*fprintf (stderr, "\n M1_FinalSite_omega (or category) = %d, ran = %lf \n", M1_FinalSite_omega, ran);*/
			if (doPrintOmegasPerSitefiles == YES) /* print omegas to file */
				{
				if (M1_FinalSite_omega == 1)
					{
					fprintf(fpOmegasPerSitePrint,"Site %d - Omega %3.5f\n", siteNum+1, M1_omega0);
					}
				if (M1_FinalSite_omega == 2)
					{
					fprintf(fpOmegasPerSitePrint,"Site %d - Omega 1.00000\n", siteNum+1);
					}
				}
			
			free (cumProbCatM1);
			}
		

		if (doOmegaRateHetCont == YES) /* M5. for each site */
			{
			GammaVarRateOmega = RndGamma (OmegaRateHet, seed) / OmegaRateHet; 
			VarOmega1 = OmegaInit*GammaVarRateOmega;
			omega = roundit(VarOmega1,5);
			if (doPrintOmegasPerSitefiles == YES) /* print omegas to file */
				{
				fprintf(fpOmegasPerSitePrint,"Site %d - Omega %3.5f\n", siteNum+1, omega);
				}
			/*fprintf(stderr,"doOmegaRateHetCont - Site %d - Omega %3.5f\n", i, omega);*/

			/*fprintf(stderr, "\nBEFORE Cijk_C[10*NUMCOD*NUMCOD+10*NUMCOD+10] = %d\n", Cijk_C[10*NUMCOD*NUMCOD+10*NUMCOD+10]);
			fprintf(stderr, "\nBEFORE Cijk_C[5*NUMCOD*NUMCOD+5*NUMCOD+5] = %d\n", Cijk_C[5*NUMCOD*NUMCOD+5*NUMCOD+5]);*/

			buildCodonMatrix_Qij_Cijk ();
			/*fprintf(stderr, "\nAFTER Cijk_C[10*NUMCOD*NUMCOD+10*NUMCOD+10] = %d\n", Cijk_C[10*NUMCOD*NUMCOD+10*NUMCOD+10]);
			fprintf(stderr, "\nAFTER Cijk_C[5*NUMCOD*NUMCOD+5*NUMCOD+5] = %d\n", Cijk_C[5*NUMCOD*NUMCOD+5*NUMCOD+5]);*/	
			}

		if (doM6 == YES) /* for each site */
			{		/* M6_P0, M6_P1; OmegaRateHetM6_0 OmegaM6_0 OmegaInitM6_0; OmegaRateHetM6_1 OmegaM6_1 OmegaInitM6_1 */

			for (j=1; j<=2; j++)
				cumProbCatM6[j] = 0;
			cumProbCatM6[0] = 0;
			cumProbCatM6[1] = M6_P0;
			cumProbCatM6[2] = M6_P0 + M6_P1;

			ran = RandomUniform(seed);
			M6_FinalSite_omega = bbinInOmegaCat (ran, cumProbCatM6, 2);
			j = 0;
			/*fprintf (stderr, "\n M6_FinalSite_omega (or category) = %d, ran = %lf \n", M6_FinalSite_omega, ran);*/


			if (M6_FinalSite_omega == 1) /* gamma distribt 1 */
				{
				GammaVarRateOmegaM6 = RndGamma (OmegaRateHetM6_0, seed) / OmegaRateHetM6_0; 
				VarOmegaM6 = OmegaInitM6_0*GammaVarRateOmegaM6;
				omega = roundit(VarOmegaM6,5);
				}
			else if (M6_FinalSite_omega == 2) /* gamma distribt 2 */
				{
				GammaVarRateOmegaM6 = RndGamma (OmegaRateHetM6_1, seed) / OmegaRateHetM6_1; 
				VarOmegaM6 = OmegaInitM6_1*GammaVarRateOmegaM6;
				omega = roundit(VarOmegaM6,5);
				}
			else
				{
				fprintf (stderr, "\n ERROR in EvolveSequenceOnTree_Codon function, M6 codon model. Parameter M6_FinalSite_omega must be 1 or 2 (%d) \n", M6_FinalSite_omega);
				exit (-1);
				}
			/*fprintf(stderr,"Site %d - Omega %3.5f\n", i, omega);*/
			buildCodonMatrix_Qij_Cijk ();


			if (doPrintOmegasPerSitefiles == YES) /* print omegas to file */
				{
				fprintf(fpOmegasPerSitePrint,"Site %d - Omega %3.5f\n", siteNum+1, omega);
				}			
			}

		if (doM7 == YES) /* for each site */  
			{
			/*fprintf (stderr, "\n M7_p_beta = %lf, M7_q_beta = %lf \n", M7_p_beta, M7_q_beta);*/	
			betaVar = RandomBeta (M7_p_beta, M7_q_beta, seed); /* Thanks to David Posada! */
			M7_FinalSite_omega = betaVar;

			omega = roundit(M7_FinalSite_omega,5);

			/*omega = M7_FinalSite_omega;
			if (omega < 0.001)
				omega = 0.00;*/	
			/*fprintf (stderr, "\n M7: Site %d, omega = %lf, M7_FinalSite_omega = %lf  \n", i, omega, M7_FinalSite_omega);*/	
			buildCodonMatrix_Qij_Cijk ();

			if (doPrintOmegasPerSitefiles == YES) /* print omegas to file */
				{
				fprintf(fpOmegasPerSitePrint,"Site %d - Omega %3.5f\n", siteNum+1, omega);
				}
			}


		if (doM8 == YES) /* for each site */  
			{
			cumProbCatM8 =  (double*) calloc ((3), sizeof (double));  
			if (cumProbCatM8 == NULL)
				{
				fprintf (fpmpi, "Could not allocate cumProbCatM8 (%lu bytes)", (3) * (long) sizeof (double));
				exit(1);
				}

			for (j=0; j<=2; j++)
				cumProbCatM8[j] = 0;
			/*fprintf (stderr, "\n M8_P0_beta = %lf, M8_P1_omega = %lf \n", M8_P0_beta, M8_P1_omega);*/			
			for (j=1; j<=2; j++)
				{
				if (j == 1)
					{
					cumProbCatM8[j] = cumProbCatM8[j-1] + M8_P0_beta;
					}
				if (j == 2)
					{
					cumProbCatM8[j] = cumProbCatM8[j-1] + M8_P1_omega;
					}
				/*fprintf (stderr, "\n cumProbCatM8[%d] = %lf \n", j, cumProbCatM8[j]);*/
				}
			
			ran = RandomUniform(seed);
			M8option = bbinInOmegaCat (ran, cumProbCatM8, 2);
			j = 0;			
			free (cumProbCatM8);
			M8_FinalSite_omega = -1.0;
			/*fprintf (stderr, "\n M8option (or category) = %d, ran = %lf \n", M8option, ran);*/

			if (M8option == 1) /* beta distribution */ /* M8_p_beta, M8_q_beta -> M8_omegaP0 */
				{
				/* From David Posada. Thanks David! */
				/*int		i, numReps;
				long int	seed;
				double	betaVar, p, q, sum, sumsq, variance;
				seed = time(NULL); 			
				p = 0.3;
				q = 0.5;
				sum = 0;
				numReps = 1000;
				fprintf (stderr, "beta variable = ");
				for (i=0; i<numReps; i++)
					{
					betaVar = RandomBeta (p, q, &seed);
					fprintf (stderr, " %6.4f", betaVar);
					sum += betaVar;
					sumsq += pow(betaVar,2);
					}
				variance = (1.0 / (double) (numReps-1)) * (sumsq - pow(sum,2) / (double) numReps);
				fprintf (stderr, "\nmean = %6.4f  var = %6.4f", sum/=numReps, variance);
				return 0;*/

				betaVar = RandomBeta (M8_p_beta, M8_q_beta, seed);
				M8_omegaP0 = betaVar;
				M8_FinalSite_omega = M8_omegaP0;
				/*fprintf (stderr, "\n option 1, omega = %lf   D.beta: p = %lf, q = %lf \n", M8_FinalSite_omega, M8_p_beta, M8_q_beta);*/
				}
			else if (M8option == 2) /* direct omega */
				{
				M8_FinalSite_omega = M8_omegaP1;
				/*fprintf (stderr, "\n option 2, omega = %lf \n", M8_FinalSite_omega);*/
				}
			else
				{
				fprintf (fpmpi, "\n Error in M8option (%d): EvolveSequenceOnTree_Codon \n", M8option);
				exit(1);
				}
			

			if (M8_FinalSite_omega == -1.0) /* Check point */
				{
				fprintf (fpmpi, "\n Error in M8_FinalSite_omega (-1): EvolveSequenceOnTree_Codon \n");
				exit(1);
				}

			/*fprintf (stderr, "\n M8: Site %d, M8_FinalSite_omega = %lf  \n", i, M8_FinalSite_omega);*/
			/*omega = M8_FinalSite_omega;*/
			
			omega = roundit(M8_FinalSite_omega,5);

			/*fprintf (stderr, "\n M8: Site %d, omega = %lf  \n", i, omega);*/
			/*if (omega < 0.001)
				omega = 0.00;*/

			buildCodonMatrix_Qij_Cijk ();

			if (doPrintOmegasPerSitefiles == YES) /* print omegas to file */
				{
				fprintf(fpOmegasPerSitePrint,"Site %d - Omega %3.5f\n", siteNum+1, omega);
				}
			}


		if (doM9 == YES || doM10 == YES) /* for each site */
			{		/* M910_P0, M910_P1; M910_p_beta M910_q_beta; OmegaRateHetM910_1 OmegaM910_1 OmegaInitM910_1 */

			for (j=1; j<=2; j++)
				cumProbCatM910[j] = 0;
			cumProbCatM910[0] = 0;
			cumProbCatM910[1] = M910_P0;
			cumProbCatM910[2] = M910_P0 + M910_P1;

			ran = RandomUniform(seed);
			M910_FinalSite_omega = bbinInOmegaCat (ran, cumProbCatM910, 2);
			j = 0;
			/*fprintf (stderr, "\n M910_FinalSite_omega (or category) = %d, ran = %lf \n", M910_FinalSite_omega, ran);*/


			if (M910_FinalSite_omega == 1) /* beta distribt */
				{
				/*fprintf (stderr, "\n M910_p_beta = %lf, M910_q_beta = %lf \n", M910_p_beta, M910_q_beta);*/	
				betaVar = RandomBeta (M910_p_beta, M910_q_beta, seed); /* Thanks to David Posada! */
				VarOmegaM910 = betaVar;

				omega = roundit(VarOmegaM910,5);
			
				/*fprintf (stderr, "\n M9 or M10: Site %d, M910_p_beta = %lf, M910_q_beta = %lf, betaVar = %lf, VarOmegaM910 = %lf, omega = %lf \n", i, M910_p_beta, M910_q_beta, betaVar, VarOmegaM910, omega);*/	
				}
			else if (M910_FinalSite_omega == 2) /* gamma distribt */
				{
				if (doM9 == YES) /* GammaVarRateOmegaM910, VarOmegaM910 */
					{
					GammaVarRateOmegaM910 = RndGamma (OmegaRateHetM910_1, seed) / OmegaRateHetM910_1; 
					VarOmegaM910 = OmegaInitM910_1*GammaVarRateOmegaM910;
					omega = roundit(VarOmegaM910,5);
					}
				else if (doM10 == YES) 
					{
					GammaVarRateOmegaM910 = RndGamma (OmegaRateHetM910_1, seed) / OmegaRateHetM910_1; 
					VarOmegaM910 = OmegaInitM910_1*GammaVarRateOmegaM910;
					omega = roundit(VarOmegaM910,5);

					omega = omega + 1; /* in Model M10, omega from the beta distribution is +1, so here always > 1: PSSs */
					}
				else
					{
					fprintf (stderr, "\n ERROR in EvolveSequenceOnTree_Codon function, M9 or M10 codon model. \n");
					exit (-1);
					}
				}
			else
				{
				fprintf (stderr, "\n ERROR in EvolveSequenceOnTree_Codon function, M9 or M10 codon model. Parameter M910_FinalSite_omega must be 1 or 2 (%d) \n", M910_FinalSite_omega);
				exit (-1);
				}

			/*fprintf(stderr,"Site %d (case %d) - Omega %3.5f\n", i, M910_FinalSite_omega, omega);*/
			/*fprintf(stderr,"Site %d - Omega %3.5f\n", i, omega);*/
			buildCodonMatrix_Qij_Cijk ();


			if (doPrintOmegasPerSitefiles == YES) /* print omegas to file */
				{
				fprintf(fpOmegasPerSitePrint,"Site %d - Omega %3.5f\n", siteNum+1, omega);
				}			
		
			}
		}

	/*** End ALL VARIABLE CODON MODELS ***/
	/***********/


	  	if (RandomUniform(seed) < pinv)
	  		siteRate = 0.0;
	  	else
	  		{
		  	if (doRateHet == YES)
		  		siteRate = RandomGamma (alpha, seed) / alpha;
			else
				siteRate = 1;
			}
		if (doHetVectorFile == YES)
			{
			siteRate = siteRate*vectorHetRates[siteNum];
			}
		
		/* decide which tree */ 
		if (siteNum<tree[treeNum].end)
			roottnode = (Treetnode *)tree[treeNum].tnode;
		else
			roottnode = (Treetnode *)tree[++treeNum].tnode;
		
		SimulateDataForSite_UserTrees_Codon (roottnode, siteNum, numSites, numNuc, siteRate, seed, MRCAsequence, codonMRCASeqx);		
		}

	free (codonMRCASeqx);	
	}


/************************ AsignDNDSbranches **********************/
/* dN/dS values per branch in tnodes */
/*void AsignDNDSbranches (Treetnode *p, int howManytnodes, double dNdSbranches[MAX_tnodeS])
{
	int		i;
	
    for (i=0; i<howManytnodes; i++)
        {
		p[i].BBM0omg = dNdSbranches[i];
		fprintf (stderr, "Branchx: %d, BBM0omega = %lf, p->index = %d, Value(p->BBM0omg) = %lf \n", i, dNdSbranches[i], p->index, p->BBM0omg);
	    }       
}*/



/********************************** SimulateDataForSite_UserTrees_Codon ***********************************/
/* Simulates the codon substitution process for a given site */

void SimulateDataForSite_UserTrees_Codon (Treetnode *p, int siteNum, int numSites, int numNuc, 
							double siteRate, long int *seed, char *MRCAsequence, int *codonMRCASeqx)
{
	int			i, j;
	int			n;
	double		ran, cumProb[NUMCOD], Pij[NUMCOD][NUMCOD];
	double a;
	int aminoacid1, aminoacid2;


	n = 1;

	if (p != NULL)
		{
		if (p->parent == NULL) /* root */
			{
			matrixC[pos(p->label,siteNum,numSites)] = codonMRCASeqx[siteNum+1] /*matrixC[pos(-1,siteNum,numSites)]*/; /* MRCA seq comes from file or nt freqs, ok?  */
			/*fprintf(fpmpi, "\ncodonMRCASeqx0: %d\n", codonMRCASeqx[0]);
			fprintf(fpmpi, "\ncodonMRCASeqx1: %d\n", codonMRCASeqx[1]);
			fprintf(fpmpi, "\ncodonMRCASeqx2: %d\n", codonMRCASeqx[2]);
			fprintf(fpmpi, "\ncodonMRCASeqx3: %d\n", codonMRCASeqx[3]);*/

			/*fprintf (fpmpi, "\nsite %d root %d (%s), codon %d ",siteNum+1, p->index, p->name, matrixC[pos(p->label,siteNum,numSites)]);*/
			}
		else
			{ 
						
			if (doVariableDnDsBranches == NO)
				{
				if (doOmegaCat == YES || doOmegaRateHetDisc == YES)
					CodonModel_Cat (Pij, p->length, siteRate);
				else /* omega cte or doOmegaRateHetCont == YES or doM6 == YES or doM9 or doM10 or doMG94 */
					CodonModel (Pij, p->length, siteRate);
				}
			else /* dN/dS varies per branch */
				{
				/*fprintf (fpmpi, "\nIn SimulateDataForSite_UserTrees_Codon. Site %d, p->index %d, p->BBM0omg = %lf",siteNum+1, p->index, p->BBM0omg);*/
				CodonModel_specialBranches (Pij, p->length, siteRate, seed, siteNum, p->label, p->parent->label, p->index, p->parent->index, p->BBM0omg);
				}
			
			/* Introduce Mutacion */
			cumProb[0] = Pij[matrixC[pos(p->parent->label,siteNum,numSites)]][0];
			j = matrixC[pos(p->parent->label,siteNum,numSites)];
			
			/*fprintf (fpmpi, "\n Pij[%d][x]", j);		
			fprintf (fpmpi, "\n matrixC[pos(p->parent->label,siteNum,numSites) = %d", matrixC[pos(p->parent->label,siteNum,numSites)]);
			fprintf (fpmpi, "\n cumProb[0] = %lf", cumProb[0]);*/
			
			for (i=1; i<NUMCOD; i++)
				{
				cumProb[i] = cumProb[i-1] + Pij[matrixC[pos(p->parent->label,siteNum,numSites)]][i];
				/*fprintf (fpmpi, "\n cumProb[%d] = %lf", i, cumProb[i]);*/
				}
								
			ran = RandomUniform(seed);
			matrixC[pos(p->label,siteNum,numSites)] = bbin(ran, cumProb); /* binary search in the probabilities */
			
			/*fprintf (fpmpi, "\nsite %d tnode %d (%s), its parent is: tnode %d (%s), codon %d", siteNum+1, p->index, p->name, p->parent->index, p->parent->name, matrixC[pos(p->label,siteNum,numSites)]);*/

			if (matrixC[pos(p->label,siteNum,numSites)] > 60)  /* check */
				{
				for (i=0; i<NUMCOD; i++)
					{
					fprintf (stderr, "\n");
					a = 0;
					for (j=0; j<NUMCOD; j++)
						{
						fprintf (stderr, "P[%d][%d] = %3.2f ",i,j,Pij[i][j]);
						a = a + Pij[i][j];
						}
					fprintf (stderr, "\n a = %lf \n\n", a);
					}
				
				fprintf (stderr, "\n SimulateDataForSite_Codon: 1. stop codon22 %d\n", matrixC[pos(p->label,siteNum,numSites)]);
				exit(-1);
				}
			
			/* init Mutacion */
			if (matrixC[pos(p->label,siteNum,numSites)] != matrixC[pos(p->parent->label,siteNum,numSites)])
				{
				numMU++;
				/*fprintf(stderr,"\n < MUT, numMU = %d \n", numMU);*/

				aminoacid1 = codonTable_DnDs(matrixC[pos(p->label,siteNum,numSites)]);
				aminoacid2 = codonTable_DnDs(matrixC[pos(p->parent->label,siteNum,numSites)]);
				if (aminoacid1 == aminoacid2)
					{
					numMU_S++;
					/*fprintf (stderr, "\n Syn mut: %d to %d, numMU_S = %d \n", aminoacid1, aminoacid2, numMU_S);*/
					}
				else
					{
					numMU_NS++;
					/*fprintf (stderr, "\n NonSyn mut: %d to %d, numMU_NS = %d \n", aminoacid1, aminoacid2, numMU_NS);*/
					}
				if ((aminoacid1 == -1) || (aminoacid2 == -1))
					{
					fprintf (stderr, "\n error in type of mutations (codon) %d -> %d\n", matrixC[pos(p->parent->label,siteNum,numSites)], matrixC[pos(p->label,siteNum,numSites)]);
					fprintf (stderr, "\n error in type of mutations (aa) %d -> %d\n", aminoacid2, aminoacid1);
					exit(-1);
					}
				aminoacid1 = aminoacid2 = -1;
				}

			/*	fprintf (stderr, " Node %d to %d - matrixC[pos(p->label,siteNum,numSites)] = %d, matrixC[pos(p->parent->label,siteNum,numSites)] = %d, numMU = %d \n", p->index, p->parent->index, matrixC[pos(p->label,siteNum,numSites)], matrixC[pos(p->parent->label,siteNum,numSites)], numMU);
				fprintf (stderr, " (p->anc1->time - p->time) = %lf \n", (p->anc1->time - p->time)); */

/*			if (matrixC[pos(p->label,siteNum,numSites)] != matrixC[pos(p->parent->label,siteNum,numSites)])
				fprintf (fpmpi, " %c>%c", codonTable_DnDs(matrixC[pos(p->parent->label,siteNum,numSites)]), codonTable_DnDs(matrixC[pos(p->label,siteNum,numSites)]));
*/
			/* end Mutacion */
		

			}
		
		for (i=0; i<p->numChildren; i++)
			SimulateDataForSite_UserTrees_Codon (p->child[i], siteNum, numSites, numNuc, siteRate, seed, MRCAsequence, codonMRCASeqx);	
		}
}





/************************************************************/
/************************************************************/
/************************* Pop_Evol *************************/
/* This simulates a DNA sequence accoring to the estability of the enconded amino acid sequence. Estability of the protein structure is considered
 Adapted from Pop_evol, by Ugo Bastolla
*/
/* Program dna_evol.
   Needs a target structure and a starting DNA sequence.
   Attempts DNA mutations with given mutational bias.
   alpha, Z, energy are computed for the mutated sequence.
   The mutation is accepted or not according to selection criteria.
   The base composition is evaluated at every time step.
*/
/* New version 11/07/2012:
   Now energy parameters and genetic codes are given in header files
   energy_BKV.h gen_code.h
   It is possible to give as input either a PDB file (extension .pdb is
   needed) or a file with a nucleotide sequence and the name of the target
   pdb, which must be contained in the defeult input file structures.in
*/
char		*Pop_evolDNA (double branchLength, char *current_seq, int numSites, int dataSetNum, int Labelbranch, char *dirStability, int AlmostRootNode, long int *seed)
{
 /*fprintf (fpmpi,"\n\nPop_evolDNA Init  \n");*/
  /***********************
          INPUT
  ************************/
  // Input files
  char file_pdb[N_CHAR], file_str[N_CHAR], file_seq[N_CHAR];
  char fit_def[1000], name_file[N_CHAR];

  // Genetic code
  // char *codon[64], coded_aa[64], name_code[200];

  /***********************
         SEQUENCES
  ************************/
  short *aa_seq=NULL, *aa_seq0=NULL;
  char *dna_seq=NULL, nuc_new='X';
  int nuc_mut=0, res_mut=0, aa_new;

  /***********************
         Wild Type
  ************************/
  float fitness_wt;

  /***********************
         MUTANT
  ************************/
  float fitness_mut=1;

  /***********************
          SIMULATION
  ************************/
  int i, j, aa_subst=0, synonimous;
  long it_mut=0, /*n_change=0,*/ syn_subst=0;
  int it_print, it1=0;
  double it_trans, it_subst=0;
  int MAcounter=0;

  /***********************
          OUTPUT
  ************************/
  FILE *file_stab=NULL, *file_dna, *file_ave=NULL/*, *file_out*/;
  // Average stability and fitness
  double it_sum=0;
  double E_nat_ave=0, f_ave=0, DG_ave=0;
  double E_nat_dev=0, f_dev=0, DG_dev=0;

  // Count substitutions
  double num_syn_subst=0, num_aa_subst=0;
  // Sequence entropy
  double seq_entr_sum=0, seq_entr_dev=0, entr_dev;
  float seq_entr, seq_entr_mut;
  int n_seq_entr=0;
  int **aa_distr, **aa_distr0;
  // Loads
  double Tload_sum=0, Tload_dev=0, Mload_sum=0, Mload_dev=0;
  int Nload=0; 
   // New
  int ExpectedNumberMutations;
  int ExpectedNumberSubstitutions;
  int CountDNAsubs;
  int CountDNAmutations;

  // Input operations
  sprintf(FILE_CODE, FILE_CODE_DEF);
  sC1=0.1; sC0=0; s0=0.0; TEMP=1; // default
  ini_print=0;
  ExpectedNumberMutations = 0;
  ExpectedNumberSubstitutions = 0;
  CountDNAsubs = 0;
  CountDNAmutations = 0;
  sprintf(file_seq, "ProteinStability_Replicate%d_Branch%d", dataSetNum+1, Labelbranch);
  INI_STAT=0;

  Get_para(/*argc, argv,*/ FILE_PDB, chain, file_seq, FILE_STR,
	   &N_pop, &TEMP, &s0, &sC0, &sC1, &IT_MAX, freq_nuc,
	   &tt_ratio, &REM3, dir_out, &bvalue, &NEUTRAL);
  sprintf(file_str, "%s", FILE_STR);
  sprintf(file_pdb, "%s", FILE_PDB);

  // Random numbers
/*iran=randomgenerator();*/
  iran = *seed+(dataSetNum+1+*seed)*Labelbranch; /* MA: let's use the seed specified in the main input file of ProteinEvolver (parameters) */
  InitRandom( (RANDOMTYPE)iran);
  /*fprintf (fpmpi,"\n\n iran: %lu %lu \n\n", iran, *seed+(dataSetNum+1+*seed)*Labelbranch);*/


   /***** Checking input settings *****/
/*fprintf (fpmpi,"\nINPUT SETTINGS\n");
  fprintf (fpmpi,"PDB file, file_pdb: %s\n", file_pdb);
  fprintf (fpmpi,"PDB chain, chain: %s\n", chain);
  fprintf (fpmpi,"Population size: %d\n", N_pop);
  fprintf (fpmpi,"Temperature: %.2f \n", TEMP);
  fprintf (fpmpi,"Entropy per residue (unfolded, s0): %.3f\n", s0);
  fprintf (fpmpi,"Entropy per residue (misfolded, sC1): %.3f\n", sC1);
  fprintf (fpmpi,"Entropy per residue offset (misfolded, sC0): %.3f\n", sC0);
  fprintf (fpmpi,"Transition-transversion ratio: %.2f\n", tt_ratio);
  fprintf (fpmpi,"freq_nuc(%c): %f\n", NUC_CODE[0], freq_nuc[0]);
  fprintf (fpmpi,"freq_nuc(%c): %f\n", NUC_CODE[1], freq_nuc[1]);
  fprintf (fpmpi,"freq_nuc(%c): %f\n", NUC_CODE[2], freq_nuc[2]);
  fprintf (fpmpi,"freq_nuc(%c): %f\n", NUC_CODE[3], freq_nuc[3]);
  fprintf (fpmpi,"seed: %ld \n", iran);*/
  /*fprintf (fpmpi,"Contact interactions file: %s\n", FILE_ENE);*/
/*  fprintf (fpmpi,"Contacts matrices file: %s or %s\n", FILE_STR, file_str);*/
  /*fprintf (fpmpi,"Energies file: %s\n", FILE_ENE_DEF);
  fprintf (fpmpi,"Genetic code file: %s\n", FILE_CODE_DEF);*/
/*  fprintf (fpmpi,"Branch length: %lf\n", branchLength);
  fprintf (fpmpi,"Replicate: %d, LabelBranch: %d \n", dataSetNum+1, Labelbranch);
  fprintf (fpmpi,"dirStability: %s / file_seq: %s / dir_out = %s \n", dirStability, file_seq, dir_out);
  fprintf (fpmpi,"AlmostRootNode: %d\n", AlmostRootNode);*/ /* =0: DNA sequence from input sequence; =1: DNA sequence from input sequence but compared with aa sequence of pdb*/
/*  fprintf (fpmpi,"END INPUT SETTINGS\n\n\n");*/

  // Compute contact matrix from PDB file
  len_amm=Get_pdb(&target, &aa_seq, file_pdb, chain); /* it also extracts aa_seq from the pdb file */
  /*fprintf (fpmpi,"\nlen_amm = %d, aa_seq2 = %s ", len_amm, aa_seq);
  for(i=0; i<len_amm; i++) 
	{
    fprintf (fpmpi,"%c", AMIN_CODE[aa_seq[i]]);	
    }
  fprintf (fpmpi,"\n\n\n");*/
  if(len_amm > 0){
    Fill_C_nat(len_amm, target.contact);
  }else{
    // or read contact matrix from precomputed matrices
    Get_target(file_str, file_pdb, &len_amm);
    if(len_amm>0){
      fprintf (fpmpi,"contact matrix %s found in %s, %d residues\n",
	     file_pdb, file_str, len_amm);
    }else{
     fprintf (fpmpi,"contact matrix %s not found in %s\n", file_pdb, file_str);
      exit(8);
    }
  }

  // Read sequence from file
  /*if(file_seq[0]!='\0'){
    char inputseq[N_CHAR];
    sprintf(inputseq, "%s%s", INPUT_DIR, file_seq); 
    if(Check_file(inputseq)==0){
      fprintf (fpmpi,"WARNING, directory %s does not contain file %s\n",
	     INPUT_DIR, file_seq);
    }else{
	  fprintf (fpmpi,"\n\nReading sequence from input file \n");
      dna_seq=Read_sequence2(&len_dna, inputseq, numSites);
	  fprintf (fpmpi,"\n dna_seq1 = %s \n", dna_seq);
      if(dna_seq==NULL)goto extract_dna;
      if((len_amm>0)&&(aa_seq!=NULL)&&
	 (Compare_amm_dna(dna_seq,len_dna,aa_seq,len_amm,codon,coded_aa)==0))
	len_dna=0;
    }
  }*/
  /*extract_dna:
  if(aa_seq==NULL){
  aa_seq=NULL; 
  aa_seq=malloc(len_amm*sizeof(short));
  fprintf (fpmpi,"Translate_new\n");
  Translate_new(dna_seq, aa_seq, len_amm, codon, coded_aa);
  }
  if(len_dna<=0){
    fprintf (fpmpi,"Estracting DNA sequence from AA sequence\n");
    dna_seq=Extract_dna(&len_dna, len_amm, aa_seq, codon, coded_aa);
  }*/
  if (AlmostRootNode == 0) /* almost all nodes, aa_seq must come from dna_seq (previous node).. */
	{
	/*printf("\nPop_evol: Normal node\n");*/
  	dna_seq=Read_sequence2(&len_dna, current_seq, numSites);
	if(dna_seq==NULL) /* but this should not be used.. */
		{
		dna_seq=Extract_dna(&len_dna, len_amm, aa_seq, codon, coded_aa);
		fprintf (fpmpi,"\nWarning: Extract_dna from the amino acid sequence of the pdb file\n");
		}
	
	aa_seq=NULL; 
    aa_seq=malloc(len_amm*sizeof(short));
    Translate_new(dna_seq, aa_seq, len_amm, codon, coded_aa);
	} 
  else /* nodes close to the root (in the root the DNA sequence must codify the aa sequence of the pdb) */
	{
	/*printf("\nPop_evol: Node of branch with the root\n");*/
  	dna_seq=Read_sequence2(&len_dna, current_seq, numSites);    
    if(dna_seq==NULL) /* but this should not be used.. */
		{
		dna_seq=Extract_dna(&len_dna, len_amm, aa_seq, codon, coded_aa);
		fprintf (fpmpi,"\nWarning: Extract_dna from the amino acid sequence of the pdb file\n");
		}

	if((len_amm>0)&&(aa_seq!=NULL)&&(Compare_amm_dna(dna_seq,len_dna,aa_seq,len_amm,codon,coded_aa)==0))
		{
		len_dna=0;
		dna_seq=Extract_dna(&len_dna, len_amm, aa_seq, codon, coded_aa);
		}
	} 

  /*fprintf (fpmpi,"\nlen_dna = %d, dna_seq = ", len_dna);
  for(i=0; i<len_dna; i++) 
	{
    fprintf (fpmpi,"%c", dna_seq[i]);	
    }
  fprintf (fpmpi,"\nlen_amm = %d, aa_seq = ", len_amm);
  for(i=0; i<len_amm; i++) 
	{
    fprintf (fpmpi,"%c", AMIN_CODE[aa_seq[i]]);	
    }
  fprintf (fpmpi,"\n\n\n");*/


  // Number of events (mutations or substitutions): branchlength * number of sites
  if (doMutationalBranches == YES)
	ExpectedNumberMutations = branchLength*len_dna;
  else
	ExpectedNumberSubstitutions = branchLength*len_dna;
  /*fprintf (fpmpi,"\nExpectedNumberMutations: %d\n", ExpectedNumberMutations);
  fprintf (fpmpi,"ExpectedNumberSubstitutions: %d\n", ExpectedNumberSubstitutions);*/


  /* Rates of change */
  rateSite = (double *) calloc(numSites+1,(long) sizeof(double)); /* rate per site */
  if (!rateSite)
		{
		fprintf (stderr, "Could not allocate rateSite (%lu bytes)\n", (numSites+1)  * (long) sizeof (double));
		exit (1);
		}
  Ini_count (dna_seq, len_dna, count);
  Compute_rates (rate, freq_nuc, tt_ratio, dna_seq, seed); /* It computes rate and rateSite */


  // Number of iterations
  // IT_MAX*=len_amm;
  it_trans=len_amm; if(it_trans > IT_MAX*0.1)it_trans= IT_MAX*0.1;
  it_print=1000; if(it_print > IT_MAX*0.1)it_print= IT_MAX*0.1;

  // Reference sequence
  aa_seq0=malloc(len_amm*sizeof(short));
  for(i=0; i<len_amm; i++)aa_seq0[i]=aa_seq[i];

  // Amino acid distribution
  aa_distr=(int **)malloc(len_amm*sizeof(int *));
  for(i=0; i<len_amm; i++){
     aa_distr[i]=(int *)malloc(20*sizeof(int));
    for(j=0; j<20; j++)aa_distr[i][j]=0;
  }
  aa_distr0=(int **)malloc(len_amm*sizeof(int *));
  for(i=0; i<len_amm; i++){
    aa_distr0[i]=(int *)malloc(20*sizeof(int));
    for(j=0; j<20; j++)aa_distr0[i][j]=0;
  }
  seq_entr_mut=Sequence_entropy_mut(freq_nuc, codon, coded_aa);

  // Initialize energy calculations. Obsolete
  /*interactions=Allocate_mat2_f(20, 20);
  sprintf(file_ene, "%s%s", INPUT_DIR, FILE_ENE);
  if(strncmp(file_ene, "energy.in", 9)==0){
    Read_ene_par(file_ene, interactions);
  }else{
    Read_ene_new(file_ene, interactions);
    fprintf (fpmpi,"Reading energy parameters from file %s\n", file_ene);
    }*/

  /************ Change april 2012 *******************************/
  double E_nat_wt=0.0, E1_wt=0.0, E2_wt=0.0, E23_wt=0.0, E3_wt=0.0;
  double E_nat_mut, E1_mut, E2_mut, E23_mut, E3_mut;
  float DeltaG=0.0, DeltaG_wt, T0; //DeltaG_PDB
  /*printf("\ndirStability: %s / file_seq: %s / dir_out = %s \n", dirStability, file_seq, dir_out);*/
  if(REM3){
    DeltaG_wt=Compute_DG_REM3(aa_seq, len_amm, &E_nat_wt, &E1_wt,
			      &E2_wt, &E23_wt, &E3_wt, file_str, dirStability, file_seq);
	if (printPopEvolOutputFiles == 2)
		{
    	sprintf(name_file, "%s%s%s_%s_DeltaG_3.dat", dirStability, file_seq, dir_out, target.name);
    	T0=Print_DG_REM3(E_nat_wt, E1_wt, E2_wt, E23_wt, E3_wt, name_file);
		}
	else
    	T0=Print_DG_REM3_NoPrint(E_nat_wt, E1_wt, E2_wt, E23_wt, E3_wt);
  }else{
    DeltaG_wt=
      Compute_DG_REM2(aa_seq, len_amm, &E_nat_wt, &E1_wt, &E2_wt, file_str, dirStability, file_seq);
	if (printPopEvolOutputFiles == 2)
		{
    	sprintf(name_file, "%s%s%s_%s_DeltaG_2.dat", dirStability, file_seq, dir_out, target.name);
    	T0=Print_DG_REM2(E_nat_wt, E1_wt, E2_wt, name_file);
		}
	else
    	T0=Print_DG_REM2_NoPrint(E_nat_wt, E1_wt, E2_wt);
  }
  if (noisy > 3)
  	fprintf (fpmpi,"Temperature with smallest |DG|: T=%.2f\n", T0);
  if(DeltaG_wt > 0){
	if (noisy > 2)
    	fprintf (fpmpi,"WARNING, unstable target structure! DG_wt=%.2f at T=%.2f\n", DeltaG_wt, TEMP);
  }

  // Fitness
  fitness_wt=1./(1+exp(DeltaG_wt)); // exit(8);
  strcpy(fit_def, "F=1./(1+exp(DeltaG))");
  if(INI_NEUTRAL){DeltaG_thr=DeltaG_wt*Coeff_thr; INI_NEUTRAL=0;}

  /******************** End change *********************/

  // Output operations (wild type sequence needed)
  if (printPopEvolOutputFiles == 2)
		{
	 	Output_name(name_file, dir_out, target.name, TEMP, s0, N_pop, freq_nuc, dirStability, file_seq, NEUTRAL);
 		file_dna=open_file(name_file, EXT_DNA, aa_seq, 2, fit_def);
 		fclose(file_dna);
 	 	file_ave=open_file(name_file, EXT_AVE, aa_seq, 0, fit_def);
 	 	file_stab=open_file(name_file, EXT_OUT, aa_seq, 1, fit_def);
  // Printing
  		fprintf(file_stab, "%3d  %c  %.3f  %.3f %7.4f",
	  		res_mut, AMIN_CODE[aa_seq[0]], E_nat_wt, DeltaG_wt, fitness_wt);
  		fflush(file_stab);
		}


  // Simulating evolution
  /*fprintf (fpmpi,"\n\nIt starts mutations \n\n");*/
  while(1){
    
   	if (doMutationalBranches == YES && CountDNAmutations == ExpectedNumberMutations) /* end by mutations*/
		goto EndDNAMuts;
	if (doMutationalBranches == NO && CountDNAsubs == ExpectedNumberSubstitutions) /* end by substitutions*/
		goto EndDNAMuts;
	
    // Mutation
    CountDNAmutations++; /* each try is a DNA mutation */
    it_mut++;
	numMutationAttemptsRep++;
	/*fprintf (fpmpi,"\n\n-> Evaluates mutation (CountDNAmutations = %d)", CountDNAmutations);*/
	/*fprintf (fpmpi,"\nit_mut = %d\n", it_mut);*/

    synonimous=Mutate_seq(dna_seq, len_dna, codon, coded_aa,
			  aa_seq, len_amm, freq_nuc, tt_ratio, count, rate,
			  &nuc_mut, &nuc_new, &res_mut, &aa_new, seed);
	/*fprintf (fpmpi,"\nres_mut = %d, nuc_mut = %d, nuc_new = %c\n", res_mut, nuc_mut, nuc_new);*/

    if(synonimous > 0){
      /*fprintf (fpmpi,"\n Synonymous mutation");*/
      if(it_subst >= it_trans)num_syn_subst++;
      syn_subst++;
	  /*fprintf (fpmpi,"syn; syn_subst = %d\n", syn_subst);*/
      goto Update_dna;

    }else if(synonimous==0){
      /*fprintf (fpmpi,"\n Non-synonymous mutation");*/
      E_nat_mut=E_nat_wt; E1_mut=E1_wt; E2_mut=E2_wt;
      if(REM3){
	E23_mut=E23_wt; E3_mut=E3_wt;
	DeltaG=Mutate_DG_REM3(aa_seq, len_amm, res_mut, aa_new, &E_nat_mut,
			      &E1_mut, &E2_mut, &E23_mut, &E3_mut);
      }else{
	DeltaG=Mutate_DG_REM2(aa_seq, len_amm, res_mut, aa_new,
			      &E_nat_mut, &E1_mut, &E2_mut);
      }
      if(NEUTRAL){
	/* CHANGE UB, 3/12/2012: Allow neutral evolution */
	if(DeltaG<=DeltaG_thr){aa_subst=1;}else{aa_subst=0;}
      }else{
	fitness_mut=1./(1+exp(DeltaG));
	aa_subst=Selection(fitness_mut, fitness_wt, N_pop);
      }
      /*fprintf (fpmpi,"\naa_subst = %d (1 accept, 0 not accepted)", aa_subst);*/ // aa_subst = 1 means accept; aa_subst = 0 means reject
      if(aa_subst<=0)continue;
    }else{ 
      continue;  // Stop codon
    }

    // A substitution has occurred
	MAcounter++;
	/*fprintf (fpmpi,"\n An aa non-synonymous substitution was accepted [#: %d]\n", MAcounter);*/

    // Print thermodynamic properties (also in transient)
    it_subst++;
	if (printPopEvolOutputFiles == 2)
		{
    	fprintf(file_stab, " %ld %ld\n", syn_subst, it_mut);
    	fprintf(file_stab, "%3d  %c  %.3f  %.3f %7.4f", res_mut, AMIN_CODE[aa_new], E_nat_mut, DeltaG, fitness_mut);
		}
    /*fprintf (fpmpi,"Thermodynamic properties:\n");
	fprintf (fpmpi,"syn_subst = %2d; it_mut = %3d\n", syn_subst, it_mut);
 	fprintf (fpmpi,"res_mut = %3d; aa_new = %d; AMIN_CODE[aa_new] = %c;  E_nat_mut = %.3f;  DeltaG = %.3f; fitness_mut = %7.4f, it_subst = %lf \n", res_mut, aa_new, AMIN_CODE[aa_new], E_nat_mut, DeltaG, fitness_mut, it_subst);*/
    //fflush(file_stab);
    
    // Statistics after the transient
    /*fprintf (fpmpi,"\n it_subst = %lf, it_trans = %lf \n", it_subst, it_trans);*/
    if(it_subst >= it_trans){
      // Average old amino acid sequence, weight=it_mut
      
      // Update amino acid distribution
      for(i=0; i<len_amm; i++)aa_distr0[i][aa_seq[i]]+=it_mut;
      
      // Averages
      E_nat_ave +=it_mut*E_nat_wt; E_nat_dev+=it_mut*E_nat_wt*E_nat_wt;
      DG_ave+=it_mut*DeltaG_wt; DG_dev+=it_mut*DeltaG_wt*DeltaG_wt;
      f_ave+=it_mut*fitness_wt; f_dev+=it_mut*fitness_wt*fitness_wt;
      it_sum+=it_mut;
     
      num_aa_subst++; it1++;
      // Print averages
      if(it1==it_print){
	it1=0;
	/* Loads
	double translation_load, mutation_load;
	Compute_load(&translation_load, &mutation_load,
		     aa_seq, len_amm, dna_seq, len_dna,
		     fitness_wt, E_nat_wt, E1_wt, E2_wt, E23_wt, E3_wt,
		     Conf_entropy, codon, coded_aa);
	Tload_sum+=translation_load;
	Tload_dev+=translation_load*translation_load;
	Mload_sum+=mutation_load;
	Mload_dev+=mutation_load*mutation_load;
	Nload++; */
      }
      seq_entr=Sequence_entropy(aa_distr0, len_amm)-seq_entr_mut;
      for(i=0; i<len_amm; i++){
	for(j=0; j<20; j++){
	  aa_distr[i][j]+=aa_distr0[i][j]; aa_distr0[i][j]=0;
	}
      }
      seq_entr_sum+=seq_entr; seq_entr_dev+=seq_entr*seq_entr; n_seq_entr++;
	  if (printPopEvolOutputFiles == 2)
      		Print_ave(file_ave, it_sum, num_aa_subst, N_pop, f_ave, f_dev, E_nat_ave, E_nat_dev, DG_ave, DG_dev,
						seq_entr, num_syn_subst, num_aa_subst, Tload_sum, Tload_dev, Mload_sum, Mload_dev, Nload, NEUTRAL);
    }
    
  /*Update_AA:*/
    aa_seq[res_mut]=aa_new;
    DeltaG_wt=DeltaG;
    fitness_wt=fitness_mut;
    E_nat_wt=E_nat_mut;
    E1_wt=E1_mut; E2_wt=E2_mut;
    if(REM3){E23_wt=E23_mut; E3_wt=E3_mut;}
    it_mut=0; syn_subst=0;
    /*fprintf (fpmpi," Update AA sequence (aa substitution): res_mut = %d, aa_seq[res_mut] = %d -> aa_new = %d\n", res_mut, aa_seq[res_mut], aa_new);*/  

  Update_dna:
    if(aa_subst ||(synonimous > 0)){
      count[Code_nuc(dna_seq[nuc_mut])]--;
      count[Code_nuc(nuc_new)]++;
      dna_seq[nuc_mut]=nuc_new;
    }
  CountDNAsubs++; /* each change in the DNA sequence is a DNA substitution */
  /*fprintf (fpmpi," \nUpdate DNA sequence (dna substitution): nuc_mut = %d, dna_seq[nuc_mut] = %d -> nuc_new = %d, CountDNAmutations = %d, CountDNAsubs = %d\n", nuc_mut, dna_seq[nuc_mut], nuc_new, CountDNAmutations, CountDNAsubs);
  fprintf (fpmpi,"Nucleotide substitution in position %d \n", nuc_mut);*/


  EndDNAMuts:
  /*if(num_aa_subst == IT_MAX)break; */
  if (doMutationalBranches == YES)
    {
	if(CountDNAmutations >= ExpectedNumberMutations)
		{
		/*fprintf (fpmpi,"\nEND. CountDNAmutations = %d, ExpectedNumberMutations = %d, numMutationAttemptsRep = %d \n", CountDNAmutations, ExpectedNumberMutations, numMutationAttemptsRep);*/
		break;
		}
     }
  else
    {
	if(CountDNAsubs >= ExpectedNumberSubstitutions)
		{
		/*fprintf (fpmpi,"\nEND. CountDNAsubs = %d, ExpectedNumberSubstitutions = %d, numMutationAttemptsRep = %d \n", CountDNAsubs, ExpectedNumberSubstitutions, numMutationAttemptsRep);*/
		break;
		}
    }

  } /* end while */



  if (printPopEvolOutputFiles == 2)
  	fprintf(file_stab, " %ld %ld\n", syn_subst, it_mut);
  if (noisy > 3)
  	fprintf(fpmpi,"DNA Mutations = %d, DNA Substitutions = %d (non-synonymous = %d)\n", CountDNAmutations, CountDNAsubs, MAcounter);
  CountDNAsubsRep += CountDNAsubs;
  CountDNAsubsNSRep += MAcounter;
  /*fprintf (fpmpi,"syn_subst = %2d; it_mut = %d\n", syn_subst, it_mut);*/

  /******** final seqs ********/ 
  /*fprintf (fpmpi,"\n\nFinal sequences:");*/
  /*fprintf (fpmpi,"AA:");
  for(i=0; i<len_amm; i++)
	{
    fprintf (fpmpi,"\n %d, %d, %c", i, aa_seq[i], AMIN_CODE[aa_seq[i]]);	
    }
  fprintf (fpmpi,"\n\n");
  fprintf (fpmpi,"DNA:");
  for(i=0; i<len_dna; i++)
	{
    fprintf (fpmpi,"\n %d, %c", i, dna_seq[i]);	
    }
  fprintf (fpmpi,"\n");*/

  /* dna */
  /*fprintf (fpmpi,"\n%s\n", dna_seq);*/
  /* aa */
  /*for(i=0; i<len_amm; i++) 
	{
    fprintf (fpmpi,"%c", AMIN_CODE[aa_seq[i]]);	
    }
  fprintf (fpmpi,"\n");*/



  /*********************** Final results    *****************************/

  if (printPopEvolOutputFiles == 2)
		{
 	 	fclose(file_ave);
  		fclose(file_stab);
		}


  // Loads
  /*{
    double translation_load, mutation_load;
    Compute_load(&translation_load, &mutation_load,
		 aa_seq, len_amm, dna_seq, len_dna,
		 fitness_wt, E_nat_wt, E1_wt, E2_wt, E23_wt, E3_wt,
		 Conf_entropy, codon, coded_aa);
    Tload_sum+=translation_load;
    Tload_dev+=translation_load*translation_load;
    Mload_sum+=mutation_load;
    Mload_dev+=mutation_load*mutation_load;
    Nload++;
  }*/
  // Entropy
  for(i=0; i<len_amm; i++){
    for(j=0; j<20; j++){
      aa_distr[i][j]+=aa_distr0[i][j]; aa_distr0[i][j]=0;
    }
  }
  entr_dev=seq_entr_dev-seq_entr_sum*seq_entr_sum/n_seq_entr;
  entr_dev=sqrt(entr_dev)/n_seq_entr;
  seq_entr=Sequence_entropy(aa_distr, len_amm)-seq_entr_mut;

  it_sum+=it_mut;
  if (printPopEvolOutputFiles > 0)
		{
		  if (printPopEvolOutputFiles == 1)
			{
		    if(NEUTRAL)
				{
		        sprintf(name_file, "%s%s_%s_T%.2f_S0%.2f_Neutral_GC%.2f", dirStability, file_seq, dir_out, TEMP, s0, freq_nuc[Code_nuc('G')]+freq_nuc[Code_nuc('C')]);
		    	}
			else
				{
		        sprintf(name_file, "%s%s_%s_T%.2f_S0%.2f_N%d_GC%.2f", dirStability, file_seq, dir_out, TEMP, s0, N_pop, freq_nuc[Code_nuc('G')]+freq_nuc[Code_nuc('C')]);
		    	}
			}
  		Print_final(name_file, it_sum, TEMP, s0, N_pop, freq_nuc, f_ave, f_dev, E_nat_ave, E_nat_dev, DG_ave, DG_dev, seq_entr, entr_dev,
	      			Tload_sum, Tload_dev, Mload_sum, Mload_dev, Nload, num_syn_subst, num_aa_subst, dna_seq, len_dna, NEUTRAL);
		}
  //Print_dna(dna_seq, file_dna, iter);

  free(rateSite);
  free(aa_seq);
  free(aa_seq0);
  for(i=0; i<len_amm; i++){
     free(aa_distr[i]);
     free(aa_distr0[i]);
  }
  free(aa_distr);
  free(aa_distr0);

  /*fprintf (fpmpi,"\n\nPop_evolDNA End  \n");*/
  return(dna_seq);
  /*free(dna_seq);*/
}



/************************* Pop_evolAA *************************/
/* This version simulates only AA (without using DNA information) */
char		*Pop_evolAA (double branchLength, char *current_seq, int numSites, int dataSetNum, int Labelbranch, char *dirStability, int AlmostRootNode, long int *seed)
{
 /*fprintf (fpmpi,"Pop_evolAA Init  ");*/
  /***********************
          INPUT
  ************************/
  // Input files
  char file_pdb[N_CHAR], file_str[N_CHAR], file_seq[N_CHAR];
  char fit_def[1000], name_file[N_CHAR];

  /***********************
         SEQUENCES
  ************************/
  short *aa_seq=NULL, *aa_seq0=NULL;
  /*char *dna_seq=NULL*//*, nuc_new*/;
  int /*nuc_mut,*/ res_mut=0, aa_new=0;
  char *aa_seqLetters=malloc((numSites+1)*sizeof(char));

  /***********************
         Wild Type
  ************************/
  float fitness_wt;

  /***********************
         MUTANT
  ************************/
  float fitness_mut=1;

  /***********************
          SIMULATION
  ************************/
  int i, j, aa_subst, synonimous;
  long it_mut=0, /*n_change=0,*/ syn_subst=0;
  int it_print, it1=0;
  double it_trans, it_subst=0;
  int MAcounter=0;
  int m, control1;

  /***********************
          OUTPUT
  ************************/
  FILE *file_stab=NULL, /* *file_dna,*/ *file_ave=NULL/*, *file_out*/;
  // Average stability and fitness
  double it_sum=0;
  double E_nat_ave=0, f_ave=0, DG_ave=0;
  double E_nat_dev=0, f_dev=0, DG_dev=0;

  // Count substitutions
  double num_syn_subst=0, num_aa_subst=0;
  // Sequence entropy
  double seq_entr_sum=0, seq_entr_dev=0, entr_dev;
  float seq_entr, seq_entr_mut;
  int n_seq_entr=0;
  int **aa_distr, **aa_distr0;
  // Loads
  double Tload_sum=0, Tload_dev=0, Mload_sum=0, Mload_dev=0;
  int Nload=0; 
   // New
  int ExpectedNumberMutations;
  int ExpectedNumberSubstitutions;
  int CountDNAsubs;
  int CountDNAmutations;

  /*fprintf (fpmpi,"\nIn Pop_evolAA \n\n");
  fprintf (fpmpi,"\ndirStability = %s \n\n", dirStability);*/


  // Input operations
  sprintf(FILE_CODE, FILE_CODE_DEF);
  sC1=0.1; sC0=0; s0=0.0; TEMP=1; // default
  ini_print=0;
  ExpectedNumberMutations = 0;
  ExpectedNumberSubstitutions = 0;
  CountDNAsubs = 0;
  CountDNAmutations = 0;
  sprintf(file_seq, "ProteinStability_Replicate%d_Branch%d", dataSetNum+1, Labelbranch);
  INI_STAT=0;

  Get_para(/*argc, argv,*/ FILE_PDB, chain, file_seq, FILE_STR,
	   &N_pop, &TEMP, &s0, &sC0, &sC1, &IT_MAX, freq_nuc,
	   &tt_ratio, &REM3, dir_out, &bvalue, &NEUTRAL);
  sprintf(file_str, "%s", FILE_STR);
  sprintf(file_pdb, "%s", FILE_PDB);

  // Random numbers
/*iran=randomgenerator();*/
  iran = *seed+(dataSetNum+1+*seed)*Labelbranch; /* MA: let's use the seed specified in the main input file of ProteinEvolver (parameters) */
  InitRandom( (RANDOMTYPE)iran);
  /*fprintf (fpmpi,"\n\n iran: %lu %lu \n\n", iran, *seed+(dataSetNum+1+*seed)*Labelbranch);*/


   /***** Checking input settings *****/
/*  fprintf (fpmpi,"\nINPUT SETTINGS\n");
  fprintf (fpmpi,"PDB file, file_pdb: %s\n", file_pdb);
  fprintf (fpmpi,"PDB chain, chain: %s\n", chain);
  fprintf (fpmpi,"Population size: %d\n", N_pop);
  fprintf (fpmpi,"Temperature: %.2f \n", TEMP);
  fprintf (fpmpi,"Entropy per residue (unfolded, s0): %.3f\n", s0);
  fprintf (fpmpi,"Entropy per residue (misfolded, sC1): %.3f\n", sC1);
  fprintf (fpmpi,"Entropy per residue offset (misfolded, sC0): %.3f\n", sC0);
  fprintf (fpmpi,"seedPopEvol: %ld \n", iran);*/
  /*fprintf (fpmpi,"Contact interactions file: %s\n", FILE_ENE);*/
/*  fprintf (fpmpi,"Contacts matrices file: %s or %s\n", FILE_STR, file_str);*/
  /*fprintf (fpmpi,"Energies file: %s\n", FILE_ENE_DEF);
  fprintf (fpmpi,"Genetic code file: %s\n", FILE_CODE_DEF);*/
/*  fprintf (fpmpi,"Branch length: %lf\n", branchLength);
  fprintf (fpmpi,"Replicate: %d, LabelBranch: %d \n", dataSetNum+1, Labelbranch);
  fprintf (fpmpi,"dirStability: %s / file_seq: %s / dir_out = %s \n", dirStability, file_seq, dir_out);
  fprintf (fpmpi,"AlmostRootNode: %d\n", AlmostRootNode);*/ /* =0: DNA sequence from input sequence; =1: DNA sequence from input sequence but compared with aa sequence of pdb*/
/*  fprintf (fpmpi,"Input current_seq: %s\n", current_seq);
  fprintf (fpmpi,"pdb file file_pdb: %s; Contacts matrices file file_str: %s\n", file_pdb, file_str);*/
/*  fprintf (fpmpi,"END INPUT SETTINGS\n\n\n");*/
 

  // Compute contact matrix from PDB file
  len_amm=Get_pdb(&target, &aa_seq, file_pdb, chain); /* it also extracts aa_seq from the pdb file */
  /* Activate to print the aa sequence of the pdb */
  /*fprintf (fpmpi,"\nlen_amm = %d, pdb sequence: ", len_amm);
  for(i=0; i<len_amm; i++)
	{
    fprintf (fpmpi,"%c", AMIN_CODE[aa_seq[i]]);	
    }
  fprintf (fpmpi,"\n\n\n");*/

  // contact matrix
  if(len_amm > 0){
    Fill_C_nat(len_amm, target.contact);
  }else{
    // or read contact matrix from precomputed matrices
    Get_target(file_str, file_pdb, &len_amm);
    if(len_amm>0){
      fprintf (fpmpi,"contact matrix %s found in %s, %d residues\n",
	     file_pdb, file_str, len_amm);
    }else{
     fprintf (fpmpi,"contact matrix %s not found in %s\n", file_pdb, file_str);
      exit(8);
    }
  }

  // Read sequence from file. Checking..
  if (len_amm != numSites)
	{
	fprintf (fpmpi,"\nERROR: length of the amino acid sequence from the pdb file (%d) is different to the length of the sequence specified in the settings (%d) \n", len_amm, numSites);
	fprintf (fpmpi,"\nlen_amm = %d, pdb sequence: ", len_amm);
  	for(i=0; i<len_amm; i++) 
    	fprintf (fpmpi,"%c", AMIN_CODE[aa_seq[i]]);	
 	 fprintf (fpmpi,"\n\n\n");

	PrintUsage();
	}

    
// AlmostRootNode = 0; /* MA mod */
if (AlmostRootNode != 0) /* nodes close to the root (aa sequence should be = pdb sequence) */ /* aa_seq */
	{
   /* fprintf (fpmpi,"\nAlmostRootNode Node!!!\n\n"); */
	control1 = 0;
	 for(i=0; i<numSites; i++)
		{
		if (AMIN_CODE[aa_seq[i]] != current_seq[i])
			{
			control1++;
			fprintf (fpmpi,"\nWarning: amino acid sequence from the pdb file is different to the length of the sequence specified by the user to the MRCA, at site %d (%c <-> %c) \n", i+1, AMIN_CODE[aa_seq[i]], current_seq[i]);
			continue;
			}
		}
	if (control1 > 0)
		{
		fprintf (fpmpi,"\nPDB sequence: ");
		for(m=0; m<len_amm; m++) 
    		fprintf (fpmpi,"%c", AMIN_CODE[aa_seq[m]]);	
		fprintf (fpmpi,"\nUser-specified sequence: %s \n\n", current_seq);
		fprintf (fpmpi,"\nRecommendation: use a GMRCA sequence (-x) equal to the pdb sequence \n");
		PrintUsage();
		}
	}
   else /* almost all nodes, aa_seq comes from current_seq (previous node).. */ /* aa_seq */
	{
	/*printf("\nPop_evol: Normal node\n");*/
	for(i=0; i<numSites; i++)
		{
		aa_seq[i] = Code_AA(current_seq[i]);
		if (AMIN_CODE[aa_seq[i]] != current_seq[i])
			{
			fprintf (fpmpi,"\nError in Ppo_evolAA: amino acid no detected in position %d! \n", i);
			exit (-2);
			}
		}

	 } 
  /* activate to see the input aa sequence */
  /*fprintf (fpmpi,"\nlen_amm = %d, aa_seq = ", len_amm);
  for(i=0; i<len_amm; i++) 
    fprintf (fpmpi,"%c", AMIN_CODE[aa_seq[i]]);	
  fprintf (fpmpi,"\n\n\n");*/


  // Number of events (mutations or substitutions): branchlength * number of sites
  if (doMutationalBranches == YES)
	ExpectedNumberMutations = branchLength*numSites;
  else
	ExpectedNumberSubstitutions = branchLength*numSites;
  /*fprintf (fpmpi,"ExpectedNumberMutations: %d\n", ExpectedNumberMutations);
  fprintf (fpmpi,"ExpectedNumberSubstitutions: %d\n", ExpectedNumberSubstitutions);*/
  

  /* Initialization of AA_EM_Pi and Qij_AA, default values (equal frequencies and rates) */
  for(i=0; i<NUMAA; i++)
	AA_EM_Pi[i] = 0.05;
  for(j=0; j<NUMAA; j++)
	for(i=0; i<NUMAA; i++)
		{
		if (i==j)
			Qij_AA[i][j]=0.0;
		else
			Qij_AA[i][j]=0.05;
		}
   /* An empirical amino acid model was specified */
   Empirical_AA_model (); /* Qij_AA[0 -> 19][0 -> 19], AA_EM_Pi[0 -> 19] */

  /* Frequencies introduced by the user +F */
  if (doFreqGiven == YES && NumberFrequencies == 20) 
		{
		for (j = 0; j < NUMAA; j++)
			AA_EM_Pi[j] = p_i_aa[j];
		}

  /* Translate order ProteinEvolver applied to PopEvol */
  /* ProteinEvolver: A R N D C Q E G H I L K M F P S T W Y V */
  /* PopEvol:        A E Q D N L G K S V R T P I M F Y C W H X */
  /* AA_EM_Pi_PopEvol[NUMAA], Qij_AA_PopEvol[NUMAA][NUMAA]; */
   for (j = 0; j < NUMAA; j++)
		AA_EM_Pi_PopEvol[j] = AA_EM_Pi[AdaptOrderToPopEvol(j)];
   for(j=0; j<NUMAA; j++)
		for(i=0; i<NUMAA; i++) 
			Qij_AA_PopEvol[i][j] = Qij_AA[AdaptOrderToPopEvol(i)][AdaptOrderToPopEvol(j)]; 

  /* activate to visualize the matrix and frequencies */
  /*for (j = 0; j < NUMAA; j++)
	 fprintf (fpmpi,"\nFreq AA %d: %lf", j, AA_EM_Pi_PopEvol[j]);
   fprintf (stderr, "\nIn the matrix Qij_AA_PopEvol, End:");
   for (i = 0; i < NUMAA; i++)
		for (j = 0; j < NUMAA; j++)
			fprintf (stderr, "\nQij_AA_PopEvol[%d][%d] = %lf ", i, j, Qij_AA_PopEvol[i][j]);*/


  /* Rates of change */
  rateAASite = (double *) calloc(numSites+1,(long) sizeof(double)); /* rate per site */
  if (!rateAASite)
		{
		fprintf (stderr, "Could not allocate rateAASite (%lu bytes)\n", (numSites+1)  * (long) sizeof (double));
		exit (1);
		}
  Ini_count_AA (aa_seq, len_amm, countAA); 
  Compute_ratesAA (rateAA, aa_seq, seed); /* It computes rateAA and rateAASite */
 


  // Number of iterations
  // IT_MAX*=len_amm;
  it_trans=len_amm; if(it_trans > IT_MAX*0.1)it_trans= IT_MAX*0.1;
  it_print=1000; if(it_print > IT_MAX*0.1)it_print= IT_MAX*0.1;


  // Reference sequence
  aa_seq0=malloc(len_amm*sizeof(short));
  for(i=0; i<len_amm; i++)aa_seq0[i]=aa_seq[i];
 

  // Amino acid distribution
  aa_distr=(int **)malloc(len_amm*sizeof(int *));
  for(i=0; i<len_amm; i++){
     aa_distr[i]=(int *)malloc(20*sizeof(int));
    for(j=0; j<20; j++)aa_distr[i][j]=0;
  }
  aa_distr0=(int **)malloc(len_amm*sizeof(int *));
  for(i=0; i<len_amm; i++){
    aa_distr0[i]=(int *)malloc(20*sizeof(int));
    for(j=0; j<20; j++)aa_distr0[i][j]=0;
  }
  
  seq_entr_mut = Sequence_entropy_mut_AA ();
  if (noisy > 3)
  	fprintf (fpmpi,"Computed entropy: %.2f\n", seq_entr_mut);


  // Initialize energy calculations. Obsolete
  /*interactions=Allocate_mat2_f(20, 20);
  sprintf(file_ene, "%s%s", INPUT_DIR, FILE_ENE);
  if(strncmp(file_ene, "energy.in", 9)==0){
    Read_ene_par(file_ene, interactions);
  }else{
    Read_ene_new(file_ene, interactions);
    fprintf (fpmpi,"Reading energy parameters from file %s\n", file_ene);
    }*/

  /************ Change april 2012 *******************************/
  double E_nat_wt=0.0, E1_wt=0.0, E2_wt=0.0, E23_wt=0.0, E3_wt=0.0;
  double E_nat_mut, E1_mut, E2_mut, E23_mut, E3_mut;
  float DeltaG=0.0, DeltaG_wt, T0; //DeltaG_PDB
  /*printf("\ndirStability: %s / file_seq: %s / dir_out = %s / file_str = %s \n", dirStability, file_seq, dir_out, file_str);*/
  if(REM3){
    DeltaG_wt=Compute_DG_REM3(aa_seq, len_amm, &E_nat_wt, &E1_wt,
			      &E2_wt, &E23_wt, &E3_wt, file_str, dirStability, file_seq);
   if (printPopEvolOutputFiles == 2)
		{
    	sprintf(name_file, "%s%s%s_%s_DeltaG_3.dat", dirStability, file_seq, dir_out, target.name);
    	T0=Print_DG_REM3(E_nat_wt, E1_wt, E2_wt, E23_wt, E3_wt, name_file);
		}
	else
    	T0=Print_DG_REM3_NoPrint(E_nat_wt, E1_wt, E2_wt, E23_wt, E3_wt);
  }else{
    DeltaG_wt=
      Compute_DG_REM2(aa_seq, len_amm, &E_nat_wt, &E1_wt, &E2_wt, file_str, dirStability, file_seq);
    sprintf(name_file, "%s%s%s_%s_DeltaG_2.dat", dirStability, file_seq, dir_out, target.name);
	if (printPopEvolOutputFiles == 2)
		{
    	sprintf(name_file, "%s%s%s_%s_DeltaG_2.dat", dirStability, file_seq, dir_out, target.name);
    	T0=Print_DG_REM2(E_nat_wt, E1_wt, E2_wt, name_file);
		}
	else
    	T0=Print_DG_REM2_NoPrint(E_nat_wt, E1_wt, E2_wt);
  }
  
  if (noisy > 3)
  	fprintf (fpmpi,"Temperature with smallest |DG|: T=%.2f\n", T0);
  if(DeltaG_wt > 0){
	if (noisy > 2)
    	fprintf (fpmpi,"WARNING, unstable target structure! DG_wt=%.2f at T=%.2f\n", DeltaG_wt, TEMP);
  }


  // Fitness
  fitness_wt=1./(1+exp(DeltaG_wt)); // exit(8);
  strcpy(fit_def, "F=1./(1+exp(DeltaG))");
  if(INI_NEUTRAL){DeltaG_thr=DeltaG_wt*Coeff_thr; INI_NEUTRAL=0;}

  /******************** End change *********************/

  // Output operations (wild type sequence needed)
	if (printPopEvolOutputFiles == 2)
		{
		  Output_name_AA (name_file, dir_out, target.name, TEMP, s0, N_pop, dirStability, file_seq, NEUTRAL);
  		/*file_dna=open_file_AA (name_file, EXT_DNA, aa_seq, 2, fit_def);*/
  		file_ave=open_file_AA (name_file, EXT_AVE, aa_seq, 0, fit_def);
  		file_stab=open_file_AA (name_file, EXT_OUT, aa_seq, 1, fit_def);

  // Printing
        //fprintf(file_stab, "%3d  %c  %.3f  %.3f  %.3f  %.3f %7.4f", res_mut, AMIN_CODE[aa_seq[0]], E_nat_wt, DeltaG_wt, fitness_wt);
        fprintf(file_stab, "%3d  %c  %.3f  %.3f  %.3f ", res_mut, AMIN_CODE[aa_seq[0]], E_nat_wt, DeltaG_wt, fitness_wt);
  		fflush(file_stab);
		}


  // Simulating evolution
  while(1){
    
   	if (doMutationalBranches == YES && CountDNAmutations == ExpectedNumberMutations) /* end by mutations*/
		goto EndDNAMuts;
	if (doMutationalBranches == NO && CountDNAsubs == ExpectedNumberSubstitutions) /* end by substitutions*/
		goto EndDNAMuts;


    // Mutation
	/*fprintf (fpmpi,"\n\n-> Evaluates mutation");*/
    it_mut++;
	CountDNAmutations++; /* each try is a DNA mutation */
	numMutationAttemptsRep++;
	/*fprintf (fpmpi,"\nit_mut = %d\n", it_mut);*/

    synonimous = Mutate_seq_AA (aa_seq, len_amm, countAA, rateAA, &res_mut, &aa_new, seed);
	/*fprintf (fpmpi,"\naa_new = %d, res_mut = %3d ", aa_new, res_mut);*/

    if(synonimous > 0){
      fprintf (fpmpi,"\n\n Synonymous mutation. Error: this should occur when evolving AA sequences. Check function Pop_evolAA\n");
	  exit (-1);
      /*if(it_subst >= it_trans)num_syn_subst++;
      syn_subst++;*/
	  /*fprintf (fpmpi,"syn; syn_subst = %d\n", syn_subst);*/
      /*goto Update_dna;*/

    }else if(synonimous==0){
      /*fprintf (fpmpi,"\n OK Non-synonymous mutation");*/
      E_nat_mut=E_nat_wt; E1_mut=E1_wt; E2_mut=E2_wt;
      if(REM3){
	E23_mut=E23_wt; E3_mut=E3_wt;
	DeltaG=Mutate_DG_REM3(aa_seq, len_amm, res_mut, aa_new, &E_nat_mut,
			      &E1_mut, &E2_mut, &E23_mut, &E3_mut);
      }else{
	DeltaG=Mutate_DG_REM2(aa_seq, len_amm, res_mut, aa_new,
			      &E_nat_mut, &E1_mut, &E2_mut);
      }
      if(NEUTRAL){
	/* CHANGE UB, 3/12/2012: Allow neutral evolution */
	if(DeltaG<=DeltaG_thr){aa_subst=1;}else{aa_subst=0;}
      }else{
	fitness_mut=1./(1+exp(DeltaG));
	aa_subst=Selection(fitness_mut, fitness_wt, N_pop);
      }
      if(aa_subst<=0)continue;
      /*fprintf (fpmpi,"\naa_subst = %d (1 accept, 0 not accepted)", aa_subst);*/ // aa_subst = 1 means accept; aa_subst = 0 means reject
    }else{ 
	  fprintf (fpmpi,"\n\n No mutation. Error: this should occur when evolving AA sequences. Check function Pop_evolAA\n");
	  exit (-1);
      /*continue;  */
    }

    // A substitution has occurred
	MAcounter++;
	/*fprintf (fpmpi,"\n An aa non-synonymous substitution was accepted [#: %d]\n", MAcounter);*/

    // Print thermodynamic properties (also in transient)
    it_subst++;
	if (printPopEvolOutputFiles == 2)
		{
    	fprintf(file_stab, " %ld %ld\n", syn_subst, it_mut);
    	//fprintf(file_stab, "%3d  %c  %.3f  %.3f %.3f %.3f %7.4f", res_mut, AMIN_CODE[aa_new], E_nat_mut, DeltaG, fitness_mut);
        fprintf(file_stab, "%3d  %c  %.3f  %.3f %.3f", res_mut, AMIN_CODE[aa_new], E_nat_mut, DeltaG, fitness_mut);
		}
    /*fprintf (fpmpi,"Thermodynamic properties:\n");
	fprintf (fpmpi,"syn_subst = %2d; it_mut = %3d\n", syn_subst, it_mut);
 	fprintf (fpmpi,"res_mut = %3d; aa_new = %d; AMIN_CODE[aa_new] = %c;  E_nat_mut = %.3f;  DeltaG = %.3f; fitness_mut = %7.4f, it_subst = %lf \n", res_mut, aa_new, AMIN_CODE[aa_new], E_nat_mut, DeltaG, fitness_mut, it_subst);*/
    //fflush(file_stab);
    
    // Statistics after the transient
    /*fprintf (fpmpi,"\n it_subst = %lf, it_trans = %lf \n", it_subst, it_trans);*/
    if(it_subst >= it_trans){
      // Average old amino acid sequence, weight=it_mut
      
      // Update amino acid distribution
      for(i=0; i<len_amm; i++)aa_distr0[i][aa_seq[i]]+=it_mut;
      
      // Averages
      E_nat_ave +=it_mut*E_nat_wt; E_nat_dev+=it_mut*E_nat_wt*E_nat_wt;
      DG_ave+=it_mut*DeltaG_wt; DG_dev+=it_mut*DeltaG_wt*DeltaG_wt;
      f_ave+=it_mut*fitness_wt; f_dev+=it_mut*fitness_wt*fitness_wt;
      it_sum+=it_mut;
     
      num_aa_subst++; it1++;
      // Print averages
      if(it1==it_print){
	it1=0;
	/* Loads
	double translation_load, mutation_load;
	Compute_load(&translation_load, &mutation_load,
		     aa_seq, len_amm, dna_seq, len_dna,
		     fitness_wt, E_nat_wt, E1_wt, E2_wt, E23_wt, E3_wt,
		     Conf_entropy, codon, coded_aa);
	Tload_sum+=translation_load;
	Tload_dev+=translation_load*translation_load;
	Mload_sum+=mutation_load;
	Mload_dev+=mutation_load*mutation_load;
	Nload++; */
      }
      seq_entr=Sequence_entropy(aa_distr0, len_amm)-seq_entr_mut;
      for(i=0; i<len_amm; i++){
	for(j=0; j<20; j++){
	  aa_distr[i][j]+=aa_distr0[i][j]; aa_distr0[i][j]=0;
	}
      }
      seq_entr_sum+=seq_entr; seq_entr_dev+=seq_entr*seq_entr; n_seq_entr++;
	  if (printPopEvolOutputFiles == 2)
      		Print_ave_AA (file_ave, it_sum, num_aa_subst, N_pop, f_ave, f_dev, E_nat_ave, E_nat_dev, DG_ave, DG_dev,
							seq_entr, num_syn_subst, num_aa_subst, Tload_sum, Tload_dev, Mload_sum, Mload_dev, Nload, NEUTRAL);
    }
    
  /*Update_AA:*/
	if (noisy >= 4)
		fprintf (fpmpi,"\nAmino acid substitution in position %d (%c -> %c)", res_mut+1, AMIN_CODE[aa_seq[res_mut]], AMIN_CODE[aa_new]);
    aa_seq[res_mut]=aa_new;
    DeltaG_wt=DeltaG;
    fitness_wt=fitness_mut;
    E_nat_wt=E_nat_mut;
    E1_wt=E1_mut; E2_wt=E2_mut;
    if(REM3){E23_wt=E23_mut; E3_wt=E3_mut;}
    it_mut=0; syn_subst=0;
    /*fprintf (fpmpi," Update AA sequence (aa substitution): res_mut = %d, aa_seq[res_mut] = %d -> aa_new = %d\n", res_mut, aa_seq[res_mut], aa_new);*/   

  /*Update_dna:
    if(aa_subst ||(synonimous > 0)){
      count[Code_nuc(dna_seq[nuc_mut])]--;
      count[Code_nuc(nuc_new)]++;
      dna_seq[nuc_mut]=nuc_new;
    }*/
  CountDNAsubs++; /* each change in the AA sequence is a AA substitution */
  /*fprintf (fpmpi," \nUpdate DNA sequence (dna substitution): nuc_mut = %d, dna_seq[nuc_mut] = %d -> nuc_new = %d, CountDNAmutations = %d, CountDNAsubs = %d\n", nuc_mut, dna_seq[nuc_mut], nuc_new, CountDNAmutations, CountDNAsubs);
  fprintf (fpmpi,"Nucleotide substitution in position %d \n", nuc_mut);*/ 

  EndDNAMuts:
  /*if(num_aa_subst == IT_MAX)break; */
  /*fprintf (fpmpi,"num_aa_subst = %.0f; IT_MAX = %ld, CountDNAmutations = %d, CountDNAsubs = %d\n", num_aa_subst, IT_MAX, CountDNAmutations, CountDNAsubs);*/
  if (doMutationalBranches == YES)
	{
	if(CountDNAmutations >= ExpectedNumberMutations)
		{
		break;
		}
	}
  else
	{
	if(CountDNAsubs >= ExpectedNumberSubstitutions)
		{
		break;
		}
	}
  } /* end while */


  if (printPopEvolOutputFiles == 2)
  	fprintf(file_stab, " %ld %ld\n", syn_subst, it_mut);
  CountDNAsubsRep += CountDNAsubs;
  /*if (noisy >= 3)
  	fprintf (fpmpi,"\nAA Mutations = %d, AA Substitutions = %d (non-synonymous = %d)\n", CountDNAmutations, CountDNAsubs, MAcounter);
  fprintf (fpmpi,"syn_subst = %2d; it_sum = %d\n", syn_subst, it_sum);*/


  /******** final seqs ********/ 
  /*fprintf (fpmpi,"\n\nFinal sequence: ");*/
  /*for(i=0; i<len_amm; i++)
	{
    fprintf (fpmpi,"\n %d, %d, %c", i, aa_seq[i], AMIN_CODE[aa_seq[i]]);	
    }
  fprintf (fpmpi,"\n\n");*/

  /*for(i=0; i<len_amm; i++) 
    	fprintf (fpmpi,"%c", AMIN_CODE[aa_seq[i]]);	
  fprintf (fpmpi,"\n");*/
  


  /*********************** Final results    *****************************/
  
 if (printPopEvolOutputFiles == 2)
		{
 	 	fclose(file_ave);
  		fclose(file_stab);
		}

  // Loads
  /*{
    double translation_load, mutation_load;
    Compute_load_AA(&translation_load, &mutation_load,
		 aa_seq, len_amm, fitness_wt, E_nat_wt, E1_wt, E2_wt, E23_wt, E3_wt, Conf_entropy);
    Tload_sum+=translation_load;
    Tload_dev+=translation_load*translation_load;
    Mload_sum+=mutation_load;
    Mload_dev+=mutation_load*mutation_load;
    Nload++;
  }*/
  // Entropy
  for(i=0; i<len_amm; i++){
    for(j=0; j<20; j++){
      aa_distr[i][j]+=aa_distr0[i][j]; aa_distr0[i][j]=0;
    }
  }
  entr_dev=seq_entr_dev-seq_entr_sum*seq_entr_sum/n_seq_entr;
  entr_dev=sqrt(entr_dev)/n_seq_entr;
  seq_entr=Sequence_entropy(aa_distr, len_amm)-seq_entr_mut;

  it_sum+=it_mut;
  if (printPopEvolOutputFiles > 0)
		{
		  if (printPopEvolOutputFiles == 1)
			{
		    if(NEUTRAL)
				{
		        sprintf(name_file, "%s%s_%s_T%.2f_S0%.2f_Neutral", dirStability, file_seq, dir_out, TEMP, s0);
			    }
			else
				{
		        sprintf(name_file, "%s%s_%s_T%.2f_S0%.2f_N%d", dirStability, file_seq, dir_out, TEMP, s0, N_pop);
		    	}
			}
  		Print_final_AA (name_file, it_sum, TEMP, s0, N_pop,
	      f_ave, f_dev, E_nat_ave, E_nat_dev, DG_ave, DG_dev,
	      seq_entr, entr_dev, Tload_sum, Tload_dev, Mload_sum, Mload_dev, Nload,
	      num_syn_subst, num_aa_subst, aa_seq, len_amm, NEUTRAL);
		}  


// change format
  for(i=0; i<len_amm; i++)
	aa_seqLetters[i] = AMIN_CODE[aa_seq[i]];
  /*fprintf (fpmpi,"\n");
  for(i=0; i<len_amm; i++) 
    	fprintf (fpmpi,"%c", AMIN_CODE[aa_seq[i]]);	
  fprintf (fpmpi,"\n");
	for(i=0; i<len_amm; i++) 
    	fprintf (fpmpi,"%c", aa_seqLetters[i]);	
  fprintf (fpmpi,"\n");*/
 
// free
  free(rateAASite);
  free(aa_seq);
  free(aa_seq0);
  for(i=0; i<len_amm; i++){
     free(aa_distr[i]);
     free(aa_distr0[i]);
  }
  free(aa_distr);
  free(aa_distr0);
  /*free(dna_seq);*/
  
  
  /*fprintf (fpmpi,"Pop_evolDNA End  ");*/
  return(aa_seqLetters);
  /*free(aa_seqLetters);*/
}






/************************* Get_para *************************/
/* upload the main input file for Pop_evol */
int Get_para(/*int argc, char **argv,*/ char *file_pdb,
	     char chain[], char *file_seq, char *file_str,
	     int *N_pop, float *TEMP, float *s0,
	     float *sC0, float *sC1, long *IT_MAX,
	     float *freq_nuc, float *trans_ratio, int *REM3,
	     char *dir_out, int *bvalue, int *NEUTRAL)
{
  char FILE_IN[N_CHAR]/*, string[N_CHAR]*/;
  int i/*, j, i_nuc*/; float sum=0/*, p*/;


  /*if(Find_string("-h", argv, argc, 2, string))help();
  if(argc < 2){
    printf("ERROR, input file name must be specified\n");
    help();
  }

  strcpy(FILE_IN, argv[1]);*/
  if (doProtStabDNAFile == YES)	
  	strcpy(FILE_IN, ProtStabDNAFile);	
  else if (doProtStabAAFile == YES)
  	strcpy(FILE_IN, ProtStabAAFile);	
  else
	{
    printf("ERROR Get_para, input file name must be specified\n");
    help();
	}

  Read_parameters(FILE_IN, file_pdb, chain, file_seq, file_str,
		  N_pop, TEMP, s0, sC0, sC1, REM3, IT_MAX,
		  freq_nuc, trans_ratio, bvalue, NEUTRAL);

  /*********************************************/

  /*if(argc <= 2)goto check;
  printf("! Changing parameters with command line:\n");

  for(j=2; j<argc; j++){
    if(strncmp(argv[j], "-pop", 4)==0){
      sscanf(argv[j+1], "%f", &p);
      if(p >=1){
	*N_pop=p; printf("Population size: %d\n", *N_pop); j++;
      }
    }else if(strncmp(argv[j], "-seq", 4)==0){
      strcpy(file_seq, argv[j+1]); 
      printf("Sequence file: %s\n", file_seq);
    }else if(strncmp(argv[j], "-tt", 3)==0){
      sscanf(argv[j+1], "%f", &p);
      if(p>1){
	*trans_ratio=p; j++;
	printf("Transition-transversion ratio: %.2f\n", *trans_ratio);
      }
    }else if(strncmp(argv[j], "-temp", 5)==0){
      sscanf(argv[j+1], "%f", &p);
      if(p>0){
	*TEMP=p; printf("Temperature: %3f\n", p); j++;
      }
    }else if(strncmp(argv[j], "-s0", 3)==0){
      sscanf(argv[j+1], "%f", &p);
      if(p>0){
	*s0=p; printf("Entropy per residue: %3f\n", *s0); j++;
      }
    }else if(strncmp(argv[j], "-it", 3)==0){
      sscanf(argv[j+1], "%f", &p);
      if(p>10){
	*IT_MAX=p; printf("Substitutions per residue: %.0f\n", *IT_MAX); j++;
      }
    }else if(strncmp(argv[j], "-f", 2)==0){
      sscanf(argv[j]+2, "%d", &i_nuc);
      sscanf(argv[j+1], "%f", &p);
      if((p>0)&&(p<1)){
	freq_nuc[i_nuc]=p; j++;
	printf("freq_nuc(%c): %f\n", NUC_CODE[i_nuc], freq_nuc[i_nuc]);
      }
    }else if(strncmp(argv[j], "-gc", 3)==0){
      sscanf(argv[j+1], "%f", &p);
      if((p>0)&&(p<1)){
	freq_nuc[Code_nuc('G')]=0.5*p;
	freq_nuc[Code_nuc('C')]=0.5*p;
	freq_nuc[Code_nuc('T')]=0.5*(1-p);
	freq_nuc[Code_nuc('A')]=0.5*(1-p);
	for(i=0; i<4; i++)
	  printf("freq_nuc(%c): %3f\n", NUC_CODE[i], freq_nuc[i]);
	j++;
      }*/
      /*}else if(strncmp(argv[j], "-gencode", 8)==0){
      strcpy(file_code, argv[j+1]); j++;
      printf("Genetic code: %s\n", file_code);*/
/*    }else if(strncmp(argv[j], "-d", 2)==0){
      strcpy(dir_out,argv[j+1]); j++;
      printf("Directory in is: %s\n",dir_out);
    }else{
      printf("WARNING, unrecognized option %s\n", argv[j]);
    }
  }

  printf("! End changing parameters\n\n"); */

  /*********************************************/

  // Checks
 /*check:*/
  if(*N_pop < 1){
    fprintf (fpmpi,"ERROR, %d is too small population size\n", *N_pop);
    fprintf (fpmpi,"Check the input file %s\n", FILE_IN);
  }

  for(i=0; i<4; i++)sum+=freq_nuc[i];
  if(sum!=1 && noisy > 3){
    fprintf (fpmpi,"Warning, nucleotide frequencies are not normalized.\n");
    fprintf (fpmpi,"Normalizing\n");
  }
  for(i=0; i<4; i++)freq_nuc[i]/=sum;

return(0);

}




/************************* Read_parameters *************************/
int Read_parameters(char *FILE_IN, char *file_pdb, char *chain,
		    char *file_seq, char *file_str, 
		    int *N_pop, float *TEMP, float *s0, float *sC0,
		    float *sC1, int *REM3, long *IT_MAX,
		    float *freq_nuc, float *trans_ratio, int *bvalue, int *NEUTRAL)
{
  FILE *file_in=fopen(FILE_IN, "r");
  char string[1000], nuc[3], dumm[80];
  int /*i,*/ i_nuc; float /*p,*/ sum=0;
  /*int line=0;*/
  int outputFilesValue=0;

  if(file_in==NULL){
    fprintf (fpmpi,"ERROR, input file %s does not exist\n", FILE_IN);
    help();
  }
  if (noisy > 2)
  	fprintf (fpmpi,"\n\nReading parameters for the substitution model from %s\n", FILE_IN);

  while(fgets(string, sizeof(string), file_in)!=NULL){
    if(string[0]=='#')continue;
    if(strncmp(string, "PDB=", 4)==0){
      sscanf(string+4,"%s", file_pdb);
    }else if(strncmp(string, "CHAIN=", 6)==0){
      sscanf(string+6,"%s", dumm); *chain=dumm[0];
    }/*else if(strncmp(string, "SEQ=", 4)==0){
      sscanf(string+4,"%s", file_seq);
    }*/else if(strncmp(string, "NPOP=", 5)==0){
      sscanf(string+5,"%d", N_pop);
    }else if(strncmp(string, "NEUTRAL=", 8)==0){
      sscanf(string+8,"%d", NEUTRAL);
    }else if(strncmp(string, "TEMP=", 5)==0){
      sscanf(string+5,"%f", TEMP);
    }else if(strncmp(string, "S0=", 3)==0){
      sscanf(string+3,"%f", s0); 
    }else if(strncmp(string, "SC1=", 4)==0){
      sscanf(string+4,"%f", sC1); 
    }else if(strncmp(string, "SC0=", 4)==0){
      sscanf(string+4,"%f", sC0); 
    }else if(strncmp(string, "REM3=", 5)==0){
      sscanf(string+5,"%d", REM3);
    }/*else if(strncmp(string, "FREQ", 4)==0){
      sscanf(string+4,"%s%f", nuc, &p);
      i_nuc=Code_nuc(nuc[0]); freq_nuc[i_nuc]=p; sum+=p;
    }*//*else if(strncmp(string, "TT_RATIO=", 9)==0){
      sscanf(string+9,"%f", trans_ratio);
    }else if(strncmp(string, "TMAX=", 5)==0){
      sscanf(string+5,"%ld", IT_MAX);
    }*/else if(strncmp(string, "FILE_STR=", 9)==0){
      sscanf(string+9,"%s", file_str);
    }else if(strncmp(string, "TYPE_BL=", 8)==0){
      sscanf(string+8,"%d", bvalue);
	}else if(strncmp(string, "OUTPUT_LEVEL=", 13)==0){
      sscanf(string+13,"%d", &outputFilesValue);
    }else{
      /*fprintf (fpmpi,"WARNING, uninterpreted line:\n%s", string);*/
	    ; 
    }
  }
  fclose(file_in);

  printPopEvolOutputFiles = outputFilesValue;

  /*fprintf (fpmpi,"Energies file: %s\n", file_ene_def);
  fprintf (fpmpi,"Genetic code file: %s\n", file_code_def);*/
  /* type of branches */
  if (*bvalue == 1) /* branches by mutations */
	{
	doMutationalBranches = YES;
	}
  else if (*bvalue == 2) /* branches by substitutions */
	{
	doMutationalBranches = NO;
	}
  else
	{
    printf("ERROR, type of branch length was not specified (%d)\n", *bvalue); 
	help();
	}
	
  /* nucleotide frequencies */ /* p_i is: A C G T */
  nuc[0] = 'A';	
  i_nuc=Code_nuc(nuc[0]); 
  freq_nuc[i_nuc]=p_i[0]; 
  sum+=p_i[0];
  /*fprintf (fpmpi,"\nFREQS: nuc = %s; i_nuc = %d; freq_nuc[i_nuc] = %lf; sum = %lf, p_i[0] = %lf\n", nuc, i_nuc, freq_nuc[i_nuc], sum, p_i[0]);*/
  nuc[0] = 'C';	
  i_nuc=Code_nuc(nuc[0]); 
  freq_nuc[i_nuc]=p_i[1];
  sum+=p_i[1];
  /*fprintf (fpmpi,"\nFREQS: nuc = %s; i_nuc = %d; freq_nuc[i_nuc] = %lf; sum = %lf, p_i[1] = %lf\n", nuc, i_nuc, freq_nuc[i_nuc], sum, p_i[1]);*/
  nuc[0] = 'G';	
  i_nuc=Code_nuc(nuc[0]); 
  freq_nuc[i_nuc]=p_i[2];
  sum+=p_i[2];
  /*fprintf (fpmpi,"\nFREQS: nuc = %s; i_nuc = %d; freq_nuc[i_nuc] = %lf; sum = %lf, p_i[2] = %lf\n", nuc, i_nuc, freq_nuc[i_nuc], sum, p_i[2]);*/
  nuc[0] = 'T';	
  i_nuc=Code_nuc(nuc[0]); 
  freq_nuc[i_nuc]=p_i[3];
  sum+=p_i[3];
  /*fprintf (fpmpi,"\nFREQS: nuc = %s; i_nuc = %d; freq_nuc[i_nuc] = %lf; sum = %lf, p_i[3] = %lf\n", nuc, i_nuc, freq_nuc[i_nuc], sum, p_i[3]);*/
 
  /* TI/TV */
  *trans_ratio = titv;
  /*fprintf (fpmpi,"\nTITV: trans_ratio = %lf; titv = %lf \n", *trans_ratio, titv);*/

  /*fprintf (fpmpi,"\nEnd Read_parameters\n");*/
  return(0);
}

/*int Find_string(char *flag, char **argv, int n_arg, int m, char *string)
{
  int i;
  for(i=0; i<n_arg; i++){
    if(strncmp(argv[i], flag, m)==0){
      i++; if(i<n_arg)strcpy(string, argv[i]);
      return(1);
    }
  }
  return(0);
}*/



/************************* help *************************/
void help ()
{
  fprintf (fpmpi,"Help for Pop_evol main input file, ");
  fprintf (fpmpi,"(ex. Pop_evol.in) \n");
  fprintf (fpmpi,"PDB 				<file>	   	# pdb file or pdb code in contact matrix file\n");
  fprintf (fpmpi,"FILE_STR      	<file>     	# file with contact matrices (alternative structures)\n");
  fprintf (fpmpi,"CHAIN				<A>		   	# native protein chain identifier (default: first chain)\n");
  fprintf (fpmpi,"SEQ           	<file>     	# file with DNA sequece\n");
  fprintf (fpmpi,"NPOP          	<10>       	# population size\n");
  fprintf (fpmpi,"TEMP          	<1.8>      	# Environmental temperature of evolution\n");
  fprintf (fpmpi,"S0            	<0.05>     	# Unfolded conformational entropy per residue \n");
  fprintf (fpmpi,"SC1           	<s0.05>    	# Misfolded conformational entropy per residue\n");
  fprintf (fpmpi,"SC0           	<0.0>      	# Misfolded conformational entropy, offset\n");
  fprintf (fpmpi,"REM3          	<0>        	# 0: Only second moment of misfolded energy, 1: third moment\n");
  fprintf (fpmpi,"TYPE_BranchLength <2>			# type of branch length (1: based on mutations, 2: based on substitutions)\n");

  fprintf (fpmpi,"FILE_ENE      	<file>     	# file with contact interaction parameters\n");

  exit(1);
}


/************************* AdaptOrderToPopEvol *************************/
/* Input ORDER value from PopEvol, output the order in ProteinEvolver */
int	AdaptOrderToPopEvol (int myValue)
{
/* PopEvol:        A(0) E(1) Q(2) D(3) N(4) L(5) G(6) K(7) S(8) V(9) R(10) T(11) P(12) I(13) M(14) F(15) Y(16) C(17) W(18) H(19) X(20) */
/* ProteinEvolver: A(0) R(1) N(2) D(3) C(4) Q(5) E(6) G(7) H(8) I(9) L(10) K(11) M(12) F(13) P(14) S(15) T(16) W(17) Y(18) V(19) */

int outValue;

if (myValue == 0) /* A */
	outValue = 0;
else if (myValue == 1) /* E */
	outValue = 6;
else if (myValue == 2) /* Q */
	outValue = 5;
else if (myValue == 3) /* D */
	outValue = 3;
else if (myValue == 4) /* N */
	outValue = 2;
else if (myValue == 5) /* L */
	outValue = 10;
else if (myValue == 6) /* G */
	outValue = 7;
else if (myValue == 7) /* K */
	outValue = 11;
else if (myValue == 8) /* S */
	outValue = 15;
else if (myValue == 9) /* V */
	outValue = 19;
else if (myValue == 10) /* R */
	outValue = 1;
else if (myValue == 11) /* T */
	outValue = 16;
else if (myValue == 12) /* P */
	outValue = 14;
else if (myValue == 13) /* I */
	outValue = 9;
else if (myValue == 14) /* M */
	outValue = 12;
else if (myValue == 15) /* F */
	outValue = 13;
else if (myValue == 16) /* Y */
	outValue = 18;
else if (myValue == 17) /* C */
	outValue = 4;
else if (myValue == 18) /* W */
	outValue = 17;
else if (myValue == 19) /* H */
	outValue = 8;
else if (myValue == 20) /* X, but never should be here */
	outValue = 20;
else
	{
	fprintf (fpmpi,"Error in AdaptOrderToPopEvol, amino acid not found %d\n", myValue);
  	exit(-1);
	}

return (outValue);
}


/************************* Code_nuc *************************/
int Code_nuc(char nuc)
{
  int i; /*char n;*/
  //i=(int)nuc; if(i>96){n=(char)(i-32);}else{n=nuc;}
  //if(n=='T')n='U';
  for(i=0; i<4; i++)if(nuc==NUC_CODE[i])return(i);
  fprintf (fpmpi,"Error, nuc %c\n", nuc);
  exit(-1);
}


/************************* Code_AA *************************/
int Code_AA(char res)
{
  short i; char r;
  //i=(int)res; if(i>96){r=(char)(i-32);}else{r=res;}
  if(res > 'a'){r=(char)((int)res-32);}else{r=res;}
  for(i=0; i<20; i++)if(r==AMIN_CODE[i])return(i);
  if(r=='*')return(-1); // STOP codon
  if((res!='-')&&(res!='.')&&(res!='*'))
    fprintf (fpmpi,"WARNING in Code_AA, wrong aa type %c\n", res);
  return(0);
}

/********************************** Code_AA2 ***********************************/
int Code_AA2(char res)
{
  short i; char r;
  i=(int)res; if(i>96){r=(char)(i-32);}else{r=res;}
  for(i=0; i<20; i++)if(r==AMIN_CODE[i])return(i);
  if(res=='X')return(0);
  if((res!='-')&&(res!='.')&&(res!='*'))
    fprintf (fpmpi,"Warning in Code_AA2, wrong aa type %c\n", res);
  return(-1);
}


/************************* Nuc_code *************************/
/* One letter codes */
char Nuc_code(int nuc)
{
  if((nuc<0)||(nuc>3)){
    fprintf (fpmpi,"Error in Nuc_code, wrong nucleotide code %d\n", nuc); exit(8);
  }
  return(NUC_CODE[nuc]);
}

/************************* Amin_code *************************/
char Amin_code(int amm)
{
  if((amm<0)||(amm>20)){
    fprintf (fpmpi,"Error in Amin_code, wrong amino acid code %d\n", amm); exit(8);
  }
  return(AMIN_CODE[amm]);
}



/************************* Transition *************************/
int Transition(char nuc)
{
  if(nuc=='A'){
    return(Code_nuc('G'));
  }else if((nuc=='T')||(nuc=='U')){
    return(Code_nuc('C'));
  }else if(nuc=='G'){
    return(Code_nuc('A'));
  }else if(nuc=='C'){
    return(Code_nuc('T'));
  }
  fprintf (fpmpi,"Error in Transition(), wrong nucleotide %c\n", nuc);
  exit(8);
}



/************************* Read_nuc_freq *************************/
/*void Read_nuc_freq(char *file_nuc_freq, float *freq_nuc,
	      float *trans_ratio, float *mut_rate)
{
  FILE *file_in=
    Open_file_r(file_nuc_freq, CODE_NAME, "nucleotide frequencies");
  char string[200], nuc[3]; int i; float f, sum=0;

  printf("Reading stationary nucleotide frequencies in %s\n",file_nuc_freq);
  for(i=0; i<4; i++){
    fgets(string, sizeof(string), file_in);
    sscanf(string, "%s %f", nuc, &f);
    freq_nuc[Code_nuc(nuc[0])]=f; sum+=f;
    //printf("%c %.3f\n", nuc[0], f);
  }
  fgets(string, sizeof(string), file_in);
  sscanf(string, "%f", trans_ratio);
  //printf("Transition-transversion ratio = %.1f\n", *trans_ratio);
  fgets(string, sizeof(string), file_in);
  sscanf(string, "%f", mut_rate);
  //printf("Mutation rate = %.2g\n", *mut_rate);
  fclose(file_in);

  if(sum!=1){
    //printf("Warning, frequencies not normalized. Normalizing:\n");
    for(i=0; i<4; i++){
      freq_nuc[i]/=sum; printf("%c %.3f\n", Nuc_code(i), freq_nuc[i]);
    }
  }
}*/


/************************* Random *************************/
/************************* randomgenerator *************************/
unsigned long randomgenerator(void)
{
     
     unsigned long tm;
     time_t seconds;
     
     time(&seconds);
     srand((unsigned)(seconds % 65536));
     do   /* waiting time equal 1 second */
       tm= clock();
     while (tm/CLOCKS_PER_SEC < (unsigned)(1));
     
     return((unsigned long) (rand()));

}


void InitRandom( RANDOMTYPE seed)
{
  int i, j;
  RANDOMTYPE random, composite;
  
  /* check size of RANDOMTYPE */
  if( sizeof( RANDOMTYPE) != 4)
    {
    //fprintf (fpmpi, "Wrong size for RANDOMTYPE.\n");
    }
  
  /* create array of random numbers */
  random= seed;
  for( i= 0; i < 16384; i++)
    {
      composite= (RANDOMTYPE)0;
      for( j= 0; j < 31; j++)
	{
	  /* overflow ? */
	  if( (random *= MULTIPLIER) > RANDOMLIMIT){
	    random -= (RANDOMLIMIT+1);
	  }	  
	  /* use only most significant bit */
	  composite= (composite << 1) | ((random >> 30) & 1);
	}
      random_array[i]= composite;
    }
  
  /* initialize the pointer */
  random_which1= random_array+10000;
  random_which2= random_array+10000-471;
  random_which3= random_array+10000-1586;
  random_which4= random_array+10000-6988;
  random_which5= random_array+10000-9689;
  random_end= random_array+16384;
}

RANDOMTYPE Random()
{
  /* create random number */
  if( ++random_which1 == random_end)
    {
      random_which1= random_array;
    }
  if( ++random_which2 == random_end)
    {
      random_which2= random_array;
    }
  if( ++random_which3 == random_end)
    {
      random_which3= random_array;
    }
  if( ++random_which4 == random_end)
    {
      random_which4= random_array;
    }
  if( ++random_which5 == random_end)
    {
      random_which5= random_array;
    }
  
  return( *random_which1=
	  *random_which2 ^ *random_which3 ^ *random_which4 ^ *random_which5);
}

double RandomFloating()
{
  /* create random number */
  if( ++random_which1 == random_end)
    {
      random_which1= random_array;
    }
  if( ++random_which2 == random_end)
    {
      random_which2= random_array;
    }
  if( ++random_which3 == random_end)
    {
      random_which3= random_array;
    }
  if( ++random_which4 == random_end)
    {
      random_which4= random_array;
    }
  if( ++random_which5 == random_end)
    {
      random_which5= random_array;
    }
  
  return( INVRANDOMLIMITFLOATING*
	  (double)(*random_which1=
		   *random_which2 ^ *random_which3 ^ 
		   *random_which4 ^ *random_which5));
}


/************************* Get_pdb *************************/
int Get_pdb(struct protein *prot, short **aa_seq, char *file, char *chain)
{
  int ANISOU, nmr, i/*, j*/;
  int nres=Read_coord(file, &nmr, seq, atom_read, chain, &ANISOU);
  if(nres<=0){
    fprintf (fpmpi,"WARNING, pdb file %s, no residue found (%d)\n", file, nres);
    return(0);
  }
  prot->length=nres;

  // File name
  char pdbid[200];
  GetPdbId(file, pdbid); if(*chain==' ')*chain='_';
  /*fprintf (fpmpi,"PDB %s chain %c nres=%d\n",pdbid,*chain,nres);*/
  sprintf(prot->name, "%s%c", pdbid, *chain);

  // Sequence
  (*aa_seq)=malloc(nres*sizeof(short));
  for(i=0; i<nres; i++){
    (*aa_seq)[i]=Code_AA(seq[i].amm);
  }

  // Contact matrix
  prot->contact=Contact_matrix(seq, nres, &prot->n_cont, 'c', 3);
  prot->cont_list=Contact2Contlist(prot->contact,nres,prot->n_cont);

  return(nres);
}


void GetPdbId(char *pdb_file_in, char *pdbid)
{
     /* This subroutine pretends to get the
        PDB id from a pdb file name, and ressembles
	quite a lot my "old-and-dirty-Perl" days */
	
  int start=0, end=0, i,j,end2=0;
  for(i=strlen(pdb_file_in)-1;i>=0;i--){
    char *ptr=pdb_file_in+i;
    if (*ptr=='.'){
      end=i-1;
    }else if((*ptr=='/')||(*ptr=='\\')){
      start=i+1; end2=i-1;
      break;
    }
  }
  j=0;
  for (i=start;i<=end;i++){
    pdbid[j]=pdb_file_in[i];
    j++;
  }
  pdbid[j]='\0';
}



/************************* Contact_matrix *************************/
short **Contact_matrix (struct residue *seq, int N_res, int *N_cont, char l_cont, int ij_min)
{
  short i_res, j_res, contact=0, num_cont[L_MAX], **Cont_map;
  struct contact Contact_list[L_MAX*40], *cont;
  struct residue *seq_i/*, *seq_j*/;


  if(init_map==0){
    cont_thr_a2=cont_thr_a*cont_thr_a;
    cont_thr_b2=cont_thr_b*cont_thr_b;
    cont_thr_c2=cont_thr_c*cont_thr_c;
    init_map++;
  }

  (*N_cont)=0;
  cont=Contact_list;
  for(i_res=0; i_res<N_res; i_res++){
    num_cont[i_res]=0; seq_i=seq+i_res;
    for(j_res=i_res+ij_min; j_res< N_res; j_res++){
      if(l_cont=='c'){
	contact=Contact(*seq_i, seq[j_res]);
      }else if(l_cont=='b'){
	contact=Contact_beta(*seq_i, seq[j_res]);
      }else if(l_cont=='a'){
	contact=Contact_alpha(*seq_i, seq[j_res]);
      }
      if(contact){
	cont->res1=i_res; cont->res2=j_res; cont++;
	(*N_cont)++; num_cont[i_res]++; 
      }
    }
  }

  Cont_map=Store_map(N_res, seq, num_cont, *N_cont, Contact_list, 1);

  float cont_thr=cont_thr_c;
  if(l_cont=='a'){cont_thr=cont_thr_a;}
  else if(l_cont=='b'){cont_thr=cont_thr_b;}
  /*fprintf (fpmpi,"Contact type %c, thr= %.2f, %d native contacts\n",
	 l_cont, cont_thr, *N_cont);*/

  return(Cont_map);
}



int Contact(struct residue res_i, struct residue res_j)
{
  atom *atom1=res_i.atom_ptr, *atom2;
  float dx, dy, dz, *r1, *r2; int i, j;

  //fprintf (fpmpi,"%c %c\n", res_i.amm, res_j.amm);
  for(i=0; i<res_i.n_atom; i++){
    r1=atom1->r;
    atom2=res_j.atom_ptr;
    for(j=0; j<res_j.n_atom; j++){
      r2=atom2->r;
      dx=(*(r1)  -*(r2));   if(fabs(dx)>cont_thr_c) goto new;
      dy=(*(r1+1)-*(r2+1)); if(fabs(dy)>cont_thr_c) goto new;
      dz=(*(r1+2)-*(r2+2)); if(fabs(dz)>cont_thr_c) goto new;
      if((dx*dx+dy*dy+dz*dz)<=cont_thr_c2) return(1);
    new:
      atom2++;
    }
    atom1++;
  }
  return(0);
}



int Contact_beta(struct residue res_i, struct residue res_j)
{
  atom *atom1=Find_atom(res_i, "CB"), *atom2=Find_atom(res_j, "CB");
  float dx, dy, dz;

  if((atom1==NULL)||(atom2==NULL))return(0);
  float *r1=atom1->r, *r2=atom2->r;
   dx=(*(r1)  -*(r2));   if(fabs(dx)>cont_thr_b) return(0);
   dy=(*(r1+1)-*(r2+1)); if(fabs(dy)>cont_thr_b) return(0);
   dz=(*(r1+2)-*(r2+2)); if(fabs(dz)>cont_thr_b) return(0);
  if((dx*dx+dy*dy+dz*dz)<=cont_thr_b2)return(1);
  return(0);
}


int Contact_alpha(struct residue res_i, struct residue res_j)
{
  atom *atom1=Find_atom(res_i, "CA"), *atom2=Find_atom(res_j, "CA");
  float dx, dy, dz;
  float *r1=atom1->r, *r2=atom2->r;
   dx=(*(r1)  -*(r2));   if(fabs(dx)>cont_thr_a) return(0);
   dy=(*(r1+1)-*(r2+1)); if(fabs(dy)>cont_thr_a) return(0);
   dz=(*(r1+2)-*(r2+2)); if(fabs(dz)>cont_thr_a) return(0);
  if((atom1==NULL)||(atom2==NULL))return(0);

  if((dx*dx+dy*dy+dz*dz)<=cont_thr_a2)return(1);
  return(0);
}

short **Store_map(int N_res, struct residue *seq, short *num_cont,
		  int N_cont, struct contact *Contact_list, int l_cont)
{
  short **Cont_map=malloc(N_res*sizeof(short *));
  int i_res, j_res, i_cont;
  struct contact *cont;

  for(i_res=0; i_res< N_res; i_res++){
    Cont_map[i_res]=malloc((num_cont[i_res]+1)*sizeof(short));
    Cont_map[i_res][num_cont[i_res]]=-1;
    num_cont[i_res]=0;
    if(l_cont)seq[i_res].n_cont=0;
  }

  cont=Contact_list;
  for(i_cont=0; i_cont<N_cont; i_cont++){
    i_res=cont->res1; j_res=cont->res2; cont++;
    Cont_map[i_res][num_cont[i_res]]=j_res;
    num_cont[i_res]++;
    if(l_cont){
      seq[i_res].n_cont++; seq[j_res].n_cont++;
    }
  }
  return(Cont_map);
}

atom *Find_atom(struct residue seq, char code[2])
{
  atom *atom1=seq.atom_ptr; int i;
  for(i=0; i<seq.n_atom; i++){
    if(strncmp(atom1->name, code, 2)==0)return(atom1);
    atom1++;
  }
  return(NULL);
}

struct contact *Contact2Contlist(short **contact, int nres, int ncont)
{
  struct contact *cont_list=malloc(ncont*sizeof(struct contact));
  struct contact *cont=cont_list; int i;
  for(i=0; i<nres; i++){
    short *Ci=contact[i];
    while(*Ci >= 0){
      cont->res1=i; cont->res2=*Ci; cont++; Ci++;
    }
  }
  return(cont_list);
}


/********************* energies ********************/
/************************* Compute_DG_REM3 *************************/
float Compute_DG_REM3(short *aa_seq, int L, double *E_nat,
		      double *E1_misf, double *E2_misf,
		      double *E23_misf, double *E3_misf,
		      char *file_str, char *dirStability, char *file_seq)
{
  if(INI_STAT==0){
    Contact_statistics(&Cont_freq, &C2, &C23, &C3, &A2, &A3, L, file_str, dirStability, file_seq, printPopEvolOutputFiles);
    SC=sC0+sC1*L; TEMP2=TEMP*TEMP; K2Thr=SC*TEMP2;
    Conf_entropy=s0*L; LEN=L;
    INI_STAT=1;
  }

  double Enat=0, E1=0, E2=0, E23=0, E3=0;
  float U, U2, U3, Gmisf, DeltaG;
  int i, j;

  for(i=0; i<L; i++){
    float *U_inter=Econt[aa_seq[i]];
    for(j=i+IJ_MIN; j<L; j++){
      U=U_inter[aa_seq[j]];
      E1+=Cont_freq[i][j]*U; U2=U*U;
      E2+=C2[i][j]*U2;
      E23+=C23[i][j]*U2; U3=U2*U;
      E3+=C3[i][j]*U3;
      if(C_nat[i][j])Enat+=U;
    }
  }
  (*E1_misf)=E1;
  (*E2_misf)=E2;
  (*E3_misf)=E3;
  (*E23_misf)=E23;
  (*E_nat)=Enat+Conf_entropy*TEMP;
  Gmisf=G_misf_3_TEMP(E1, E2, A2, E23, E3, A3);
  DeltaG=(Enat-Gmisf)/TEMP;
  return(DeltaG);
}

/************************* Mutate_DG_REM3 *************************/
float Mutate_DG_REM3(short *aa_seq, int L, int res_mut, short aa_new,
		     double *E_nat, double *E1, double *E2,
		     double *E23, double *E3)
{
  float *inter_mut=Econt[aa_new], U_mut;
  float *inter_wt=Econt[aa_seq[res_mut]], U_wt;
  int *Cnat_i=C_nat[res_mut], j;
  double *C1_i=Cont_freq[res_mut], *C2_i=C2[res_mut];
  double *C23_i=C23[res_mut], *C3_i=C3[res_mut];
  for(j=0; j<L; j++){
    if(abs(j-res_mut)<IJ_MIN)continue;
    U_mut=inter_mut[aa_seq[j]];
    U_wt=inter_wt[aa_seq[j]];
    (*E1)+=C1_i[j]*(U_mut-U_wt);
    float U2_mut=U_mut*U_mut, U2_wt=U_wt*U_wt;
    (*E2)+=C2_i[j]*(U2_mut-U2_wt);
    (*E23)+=C23_i[j]*(U2_mut-U2_wt);
    float U3_mut=U2_mut*U_mut, U3_wt=U2_wt*U_wt;
    (*E3)+=C3_i[j]*(U3_mut-U3_wt);
    if(Cnat_i[j])(*E_nat)+=(U_mut-U_wt);
  }
  float Gmisf=G_misf_3_TEMP(*E1, *E2, A2, *E23, *E3, A3);
  float DeltaG=((*E_nat)-Gmisf)/TEMP;
  return(DeltaG);
}

float G_misf_3_TEMP(double E1, double E2, double A2,
		    double E23, double E3, double A3)
{
  float K2=A2*E1*E1+E2, S;
  float K3=A3*E1*E1*E1+E3+E1*E23;
  float Tfreeze=Compute_Tfreeze_3(K2, K3, SC);
  if(TEMP<Tfreeze){K2/=Tfreeze; K3/=(Tfreeze*Tfreeze); S=SC*Tfreeze;}
  else{K2/=TEMP; K3/=TEMP2; S=SC*TEMP;}
  float Gmisf=E1-K2-S+K3;
  return(Gmisf);
}

/************************* Compute_DG_REM2 *************************/
float Compute_DG_REM2(short *aa_seq, int L, double *E_nat,
		      double *E1_misf, double *E2_misf,
		      char *file_str, char *dirStability, char *file_seq)
{
  if(INI_STAT==0){
    Contact_statistics(&Cont_freq, &C2, &C23, &C3, &A2, &A3, L, file_str, dirStability, file_seq,
		       printPopEvolOutputFiles);
    SC=sC0+sC1*L; TEMP2=TEMP*TEMP; K2Thr=SC*TEMP2;
    Conf_entropy=s0*L; LEN=L;
    if (noisy > 3)fprintf (fpmpi,"Conf_entropy= %.2f\n", Conf_entropy);
    INI_STAT=1;
  }

  double Enat=0, E1=0, E2=0;
  int i, j;

  for(i=0; i<L; i++){
    float *U_inter=Econt[aa_seq[i]];
    for(j=i+IJ_MIN; j<L; j++){
      float U=U_inter[aa_seq[j]], U2=U*U;
      E1+=Cont_freq[i][j]*U;
      E2+=C2[i][j]*U2;
      if(C_nat[i][j])Enat+=U;
    }
  }
  (*E1_misf)=E1;
  (*E2_misf)=E2;
  (*E_nat)=Enat+Conf_entropy*TEMP;
  float Gmisf=G_misf_2_TEMP(E1, E2, A2);
  float DeltaG=((*E_nat)-Gmisf)/TEMP;
  return(DeltaG);
}

float G_misf_2_TEMP(double E1, double E2, double A2){
  float K2=A2*E1*E1+E2, T;
  if(K2>K2Thr){T=sqrt(K2/SC);} // Freezing
  else{T=TEMP;}
  float Gmisf=E1-K2/T-SC*T;
  return(Gmisf);
}

/************************* Mutate_DG_REM2 *************************/
float Mutate_DG_REM2(short *aa_seq, int L, int res_mut, short aa_new,
		     double *E_nat, double *E1, double *E2)
{
  float *inter_mut=Econt[aa_new], U_mut;
  float *inter_wt=Econt[aa_seq[res_mut]], U_wt;
  int *Cnat_i=C_nat[res_mut], j;
  double *C1_i=Cont_freq[res_mut], *C2_i=C2[res_mut];
  for(j=0; j<L; j++){
    if(abs(j-res_mut)<IJ_MIN)continue;
    U_mut=inter_mut[aa_seq[j]];
    U_wt=inter_wt[aa_seq[j]];
    (*E1)+=C1_i[j]*(U_mut-U_wt);
    (*E2)+=C2_i[j]*(U_mut*U_mut-U_wt*U_wt);
    if(Cnat_i[j])(*E_nat)+=(U_mut-U_wt);
  }
  float Gmisf=G_misf_2_TEMP(*E1, *E2, A2);
  float DeltaG=((*E_nat)-Gmisf)/TEMP;
  return(DeltaG);
}

/************************* Print_DG_REM2 *************************/
float Print_DG_REM2(double E_nat, double E1, double E2, char *name)
{

  FILE *file_out=fopen(name, "w");
  if (noisy > 2)
  	fprintf (fpmpi,"Writing %s\n", name);
  float T, T_INI=0.1, T_END=5, T_STEP=0.1;
  float T0=0.0, DG0=100000;
  float K2=A2*E1*E1+E2, K2S;
  float Tfreeze=sqrt(K2/SC);
  float E_NAT=E_nat-Conf_entropy*TEMP;
  fprintf(file_out,
	  "# E_nat/L= %.3f K2/L= %.4f SC/L= %.3f Tfreeze= %.3f\n",
	  E_NAT/LEN, K2/LEN, SC/LEN, Tfreeze);
  fprintf(file_out, "# Temp. DeltaG/L (REM2)\n");
  for(T=T_INI; T<T_END; T+=T_STEP){
    if(T<Tfreeze){K2S=K2/Tfreeze+SC*Tfreeze;}  // Freezing
    else{K2S=K2/T+SC*T;}
    float DeltaG=(E_NAT-E1+K2S+Conf_entropy*T);
    fprintf(file_out, "%.1f %.5f\n", T, DeltaG/LEN);
    if(fabs(DeltaG)<fabs(DG0)){
      if((DeltaG<0)||(DG0>0)){DG0=DeltaG; T0=T;}
    }
  }
  fclose(file_out);
  /*fprintf (fpmpi,"\nT0 = %lf\n", T0);*/
  return(T0);
}


/************************* Print_DG_REM2_NoPrint *************************/
float Print_DG_REM2_NoPrint (double E_nat, double E1, double E2)
{
  float T, T_INI=0.1, T_END=5, T_STEP=0.1;
  float T0=0.0, DG0=100000;
  float K2=A2*E1*E1+E2, K2S;
  float Tfreeze=sqrt(K2/SC);
  float E_NAT=E_nat-Conf_entropy*TEMP;
 
  for(T=T_INI; T<T_END; T+=T_STEP){
    if(T<Tfreeze){K2S=K2/Tfreeze+SC*Tfreeze;}  // Freezing
    else{K2S=K2/T+SC*T;}
    float DeltaG=(E_NAT-E1+K2S+Conf_entropy*T);

    if(fabs(DeltaG)<fabs(DG0)){
      if((DeltaG<0)||(DG0>0)){DG0=DeltaG; T0=T;}
    }
  }
  
  /*fprintf (fpmpi,"\nT0 = %lf\n", T0);*/
  return(T0);
}


/************************* Print_DG_REM3 *************************/
float Print_DG_REM3(double E_nat, double E1, double E2,
		     double E23, double E3, char *name)
{
  FILE *file_out=fopen(name, "w");
  fprintf (fpmpi,"Writing %s\n", name);
  float T, T_INI=0.1, T_END=5, T_STEP=0.1;
  float K2=A2*E1*E1+E2, K3S;
  float K3=A3*E1*E1*E1+E3+E1*E23;
  float Tfreeze=Compute_Tfreeze_3(K2, K3, SC);
  float Tfreeze2=Tfreeze*Tfreeze;
  float T0=0.0, DG0=100000;
  float E_NAT=E_nat-Conf_entropy*TEMP;
  fprintf(file_out,"# Enat/L= %.3f K2/L= %.4f SC/L= %.3f K3/L= %.3f Tfreeze= %.3f\n", E_NAT/LEN, K2/LEN, SC/LEN, K3/LEN, Tfreeze);
  fprintf(file_out, "# Temp. DeltaG/L (REM3)\n");
  for(T=T_INI; T<T_END; T+=T_STEP){
    if(T<Tfreeze){K3S=K2/Tfreeze+SC*Tfreeze-K3/Tfreeze2;}  // Freezing     
    else{K3S=K2/T+SC*T-K3/(T*T);}
    float DeltaG=(E_NAT-E1+K3S+Conf_entropy*T);
    fprintf(file_out, "%.1f %.5f\n", T, DeltaG/LEN);
    if(fabs(DeltaG)<fabs(DG0)){
      if((DeltaG<0)||(DG0>0)){DG0=DeltaG; T0=T;}
    }
  }
  fclose(file_out);
  /*fprintf (fpmpi,"\nT0 = %lf\n", T0);*/
  return(T0);
}

/************************* Print_DG_REM3_NoPrint *************************/
float Print_DG_REM3_NoPrint (double E_nat, double E1, double E2,
		     double E23, double E3)
{
  float T, T_INI=0.1, T_END=5, T_STEP=0.1;
  float K2=A2*E1*E1+E2, K3S;
  float K3=A3*E1*E1*E1+E3+E1*E23;
  float Tfreeze=Compute_Tfreeze_3(K2, K3, SC);
  float Tfreeze2=Tfreeze*Tfreeze;
  float T0=0.0, DG0=100000;
  float E_NAT=E_nat-Conf_entropy*TEMP;
  
  for(T=T_INI; T<T_END; T+=T_STEP){
    if(T<Tfreeze){K3S=K2/Tfreeze+SC*Tfreeze-K3/Tfreeze2;}  // Freezing     
    else{K3S=K2/T+SC*T-K3/(T*T);}
    float DeltaG=(E_NAT-E1+K3S+Conf_entropy*T);
	
    if(fabs(DeltaG)<fabs(DG0)){
      if((DeltaG<0)||(DG0>0)){DG0=DeltaG; T0=T;}
    }
  }
  
  /*fprintf (fpmpi,"\nT0 = %lf\n", T0);*/
  return(T0);
}





float Compute_Tfreeze_3(float K2, float K3, float SC)
{
  if(K3>0)return(0);
  float T=sqrt(K2/SC), T_new, f, f1; int it;
  for(it=0; it<20; it++){
    f=SC*T*T*T-K2*T+2*K3;
    if(fabs(f)<0.0001)break;
    f1=3*SC*T*T-K2;
    T_new=T-f/f1;
  }
  return(T); 
}


/************************* Get_target *************************/
int Get_target(char *file_str, char *name_tar, int *len_tar)
{
  FILE *file_in=fopen(file_str, "r");
  char string[200], name[20], dumm[4];
  int N_prot=0, length, n_cont/*, i_res, j*/;
  int i, res1, res2, nc[L_MAX], found=0;
  struct contact *cont_list; 
  short **contact=NULL;

  if(file_in==NULL){
    fprintf (fpmpi,"ERROR, file %s not found (structures)\n", file_str); exit(8);
  }

  while(fgets(string, sizeof(string), file_in)!=NULL){

    if(strncmp(string, "#  All", 6)==0)continue;
    sscanf(string,"%s%d%d%s", dumm,&length,&n_cont,name);
    if(string[0]!='#'){
      fprintf (fpmpi,"No protein start symbol at %d. Read:\n%s",N_prot+1,string);
      exit(8);
    }
    N_prot++;

    /* Check if target */
    if(strncmp(name, name_tar, 4)==0){
      *len_tar=length;
      strcpy(target.name,name);
      target.n_cont=n_cont;
      target.length=length;
      cont_list=malloc((n_cont+1)*sizeof(struct contact));
      contact=malloc((length)*sizeof(short *));
      target.contact=contact;
      target.cont_list=cont_list;
      for(i=0; i<length; i++){
	contact[i]=malloc(NCMAX*sizeof(short)); nc[i]=0;
      }

      /* Read contact map */
      for(i=0; i<n_cont; i++){
	fgets(string, sizeof(string), file_in);
	sscanf(string,"%d%d",&res1,&res2);
	cont_list->res1=res1; cont_list->res2=res2; cont_list++;
	contact[res1][nc[res1]]=res2; nc[res1]++;
	//contact[res2][nc[res2]]=res1; nc[res2]++;
      }
      for(i=0; i<length; i++)contact[i][nc[i]]=-1;
      cont_list->res1=-1;
      found=1;
      break;
    }else{
      // Other structure; skipped
      for(i=0; i<n_cont; i++)fgets(string, sizeof(string), file_in);
    }
  }
  fclose(file_in);

  if(found==0){
    fprintf (fpmpi,"ERROR in Get_target, pdb %s not found in file %s, %d proteins\n",
	   name_tar, file_str, N_prot); exit(8);
  }
  Fill_C_nat(length, contact);
  return(1);
}

void Fill_C_nat(int length, short **contact)
{
  int i, j, Nc=0;
  // Allocate native contact matrix
  C_nat=malloc(length*sizeof(int *));
  for(i=0; i<length; i++){
    C_nat[i]=malloc(length*sizeof(int));
    for(j=0; j<length; j++)C_nat[i][j]=0;
  }
  for(i=0; i<length; i++){
    short *Ci=contact[i];
    while(*Ci>=0){
      C_nat[i][*Ci]=1; C_nat[*Ci][i]=1; Ci++; Nc++;
    }
  }
 /*fprintf (fpmpi,"Allocating native contact matrix, L=%d Nc=%d\n", length, Nc);*/

}


/************************* Contact_statistics *************************/
void Contact_statistics(double ***Cont_freq, double ***C2, double ***C23,
			double ***C3, double *A2, double *A3,
			int len_nat, char *file_str, char *dirStability,
			char *file_seq, int print)
{
  int N_PROT=Read_structures(file_str, prot);
  short j_prot=0, first, i, j;
  short res1, *res2, s1/*, s2*/;
  long n_str=0;

  // Allocate
  struct contact *Cont_list=malloc((40*len_nat)*sizeof(struct contact));
  double **Cont_Nc=Allocate_mat2_d(len_nat, len_nat);
  (*Cont_freq)=Allocate_mat2_d(len_nat, len_nat);
  (*C2)=Allocate_mat2_d(len_nat, len_nat);
  (*C3)=Allocate_mat2_d(len_nat, len_nat);
  (*C23)=Allocate_mat2_d(len_nat, len_nat);
  double NC1=0, NC2=0, NC3=0, Ncc;

  /* Generate alternative structures by threading */
  for(j_prot=0; j_prot< N_PROT; j_prot++){

    short len2=prot[j_prot].length;
    if(len2 < len_nat)continue;
    short **contact=prot[j_prot].contact;

    for(first=0; first<=len2-len_nat; first++){
      
      /* New structure */
      short last=first+len_nat;
      short Nc=0; struct contact *cont=Cont_list;
      for(res1=first; res1<last; res1++){
	res2=contact[res1]; s1=res1-first;
	while((*res2>=0)&&(*res2 < last)){
	  if(*res2 >= res1+IJ_MIN){
	    cont->res1=s1;
	    cont->res2=*res2-first;
	    Nc++; cont++;
	  }
	  res2++;
	}
      }
      // Statistics
      n_str++;
      NC1+=Nc; Ncc=Nc*Nc; NC2+=Ncc; Ncc*=Nc; NC3+=Ncc;
      cont=Cont_list;
      for(i=0; i<Nc; i++){
	(*Cont_freq)[cont->res1][cont->res2]++;
	Cont_Nc[cont->res1][cont->res2]+=Nc;
	cont++;
      }
    }
  }
  free(Cont_list);

  /* End of statistics, compute averages */
  double eta2=0, eta3=0, NC_C2=0, c, c2, c3;
  for(i=0; i<len_nat; i++){
    for(j=i+IJ_MIN; j<len_nat; j++){
      (*Cont_freq)[i][j]/=n_str;
      (*Cont_freq)[j][i]=(*Cont_freq)[i][j];
      Cont_Nc[i][j]/=n_str;
      c=(*Cont_freq)[i][j]; c2=c*c;
      eta2 += c2; eta3+=c2*c;
      NC_C2 += Cont_Nc[i][j]*c;
    }
  }
  NC1/=n_str; NC2/=n_str; NC3/=n_str; 
  Empty_matrix_d(Cont_Nc, len_nat);
  
  double NC1_2=NC1*NC1;
  double K1= NC1-eta2;
  double K2= NC2-NC1_2;
  double K3= NC3-3*NC2*NC1+2*NC1_2*NC1;
  double B2= (K2-K1)/(1.-eta2/NC1_2);
  double B33= K3-3*K2+6*NC_C2-6*eta2*(NC1+1)+2*NC1+4*eta3;
  double B32= K2-2*NC_C2+2*NC1*eta2-NC1+3*eta2-2*eta3;
  
  double C2_1=0.5;
  double C2_2=0.5*(1+(K2-K1)/NC1_2);
  double C23_1=3*B32/(NC1-eta2/NC1);
  double C23_2=3*B33/NC1_2;
  double C3_2=3*(1+B32/NC1_2);
  double C3_3=2*(1+B33/(NC1_2*NC1));
  
  for(i=0; i<len_nat; i++){
    //for(j=i+IJ_MIN; j<len_nat; j++){
    for(j=0; j<len_nat; j++){
      c=(*Cont_freq)[i][j]; c2=c*c; c3=c2*c;
      (*C2)[i][j]=C2_1*c-C2_2*c2;
      (*C23)[i][j]=C23_1*c-C23_2*c2;
      (*C3)[i][j]=c-C3_2*c2+C3_3*c3;
    }
  }
  *A2=B2/(2*NC1_2);
  *A3=B33/(6*(NC1_2*NC1-3*eta2*NC1));

  if(print==2){
    char nameout[400];
    sprintf(nameout, "%s%sContact_statistics_%d.dat", dirStability, file_seq, len_nat);
    /*sprintf(nameout, "Contact_statistics_%d.dat", len_nat);*/
    if (noisy > 2)
      fprintf (fpmpi,"Writing %s\n", nameout);
    FILE *file_out=fopen(nameout, "w");
    fprintf(file_out, "Contact statistics for protein of length %d\n",len_nat);
    fprintf(file_out, "<NC>= %.2f\n", NC1);
    fprintf(file_out, "<NC^2>-<NC>^2= %.2f  /<NC>= %.3f\n", K2, K2/NC1);
    fprintf(file_out, "<(NC-<NC>)^3>= %.2f  /<NC>= %.3f\n", K3, K3/NC1);
    fprintf(file_out, "sum_ij <C_ij>^2= %.2f\n", eta2); 
    fprintf(file_out, "sum_ij <C_ij>^3= %.2f\n", eta3);
    fprintf(file_out, "B2= %.3f B32= %.3f B33= %.3f\n", B2, B32, B33);
    fprintf(file_out,
	    "C2_2= %.3f C23_1= %.3f C23_2= %.3f C3_2= %.3f C3_3= %.3f\n",
	    C2_2, C23_1, C23_2, C3_2, C3_3);
    fprintf(file_out, "A2= %.6f A3= %.6f\n", *A2, *A3);
    fclose(file_out);
  }
  return;
}


/************************* Read_structures *************************/
int Read_structures(char *file_prot, struct protein *prot)
{
  FILE *file_in=fopen(file_prot, "r");
  char string[200], name[20], dumm[4];
  int N_prot=0, length_old=10000, length, n_cont/*, i_res*/;
  int i, res1, res2;
  struct contact *cont_list; short **contact, nc[L_MAX];
  
  N_prot=0;

  fgets(string, sizeof(string), file_in);
  while(fgets(string, sizeof(string), file_in)!=NULL){

    sscanf(string,"%s%d%d%s", dumm,&length,&n_cont,name);
    if(string[0]!='#'){
      fprintf (fpmpi,"No protein start symbol at %d\n",N_prot+1);
      fprintf (fpmpi,"%s\n",string);
      exit(8);
    }
    if(length>length_old){
      fprintf (fpmpi,"Bad ordered proteins: N_prot=%d, length=%d, previous=%d\n",
	     N_prot+1, length, length_old);
      exit(8);
    }

    length_old=length;
    cont_list=malloc((n_cont+1)*sizeof(struct contact));
    contact=malloc((length)*sizeof(short *));
    for(i=0; i<length; i++){
      contact[i]=malloc(NCMAX*sizeof(short)); nc[i]=0;
    }

    prot[N_prot].length=length; prot[N_prot].n_cont=n_cont;
    prot[N_prot].contact=contact;
    prot[N_prot].cont_list=cont_list;
    strcpy(prot[N_prot].name,name);
    N_prot++;

    /* Read contact map */
    for(i=0; i<n_cont; i++){
      fgets(string, sizeof(string), file_in);
      sscanf(string,"%d%d",&res1,&res2);
      cont_list->res1=res1; cont_list->res2=res2; cont_list++;
      contact[res1][nc[res1]]=res2; nc[res1]++;
      contact[res2][nc[res2]]=res1; nc[res2]++;
    }
    for(i=0; i<length; i++)contact[i][nc[i]]=-1;
    cont_list->res1=-1;
    if(N_prot==N_PROT_MAX-1)break;
  }
  fclose(file_in);
  prot[N_prot].length=0;

  return(N_prot);
}

void Store(struct state *ptr, struct protein *protein, int first,
      float energy, int n_cont){
  ptr->prot_ptr=protein;
  ptr->first=first;
  ptr->energy=energy;
  ptr->n_cont=n_cont;
 }


/************************* Read_sequence2 *************************/
char *Read_sequence2(int *len_dna, char *current_seq, int numSites)
{  
  /*char string[1000], *ptr;
  FILE *file_in=fopen(inputseq, "r");*/
  char *sequence/*, name[N_CHAR]*/;
  int i=0/*, j=0, amm, i_nuc*/;

  /*if(file_in==NULL){
    printf("WARNING, sequence file %s does not exist\n", inputseq);
    return(NULL);
  }

  printf("Reading %s\n",inputseq);
  fgets(string, sizeof(string), file_in);
  sscanf(string,"%s", seq_name); seq_name[0]=' ';
  printf("DNA sequence %s", seq_name);
  while(fgets(string, sizeof(string), file_in)!=NULL){
    ptr=string;
    while((ptr!=NULL)&&(*ptr!='\n')){
      if((*ptr=='a')||(*ptr=='A')||(*ptr=='t')||(*ptr=='T')||
	 (*ptr=='g')||(*ptr=='G')||(*ptr=='c')||(*ptr=='C')){
	(*len_dna)++;
      }else if((*ptr!=' ')&&(*ptr!='\0')){
	printf("Wrong character %d in DNA sequence %s: %c\n",
	       *len_dna, file, *ptr);
	exit(8);
      }
      ptr++;
    }
  }
  fclose(file_in);*/

  /*if(*len_dna==0)return(NULL);*/


  *len_dna = numSites;  
  /**length=len_dna/3;
  if((*length)*3!=len_dna)
    printf("WARNING, DNA sequence length %d not divisible by 3\n", len_dna);
  if (noisy > 2)
  	printf(" %d residues\n", *length);
  len_nat = numSites/3;*/


  // Reading
  sequence=(char *)malloc(*len_dna *sizeof(char));
  /*file_in=fopen(inputseq, "r");
  fgets(string, sizeof(string), file_in);
  while(fgets(string, sizeof(string), file_in)!=NULL){
    ptr=string;
    while((ptr!=NULL)&&(*ptr!='\n')){
      if((*ptr!=' ')&&(*ptr!='\0')){
	*ptr=Maiuscule(*ptr); sequence[i]=*ptr;
	i_nuc=Code_nuc(*ptr); i++;
      }
      ptr++;
    }
  }
  fclose(file_in);*/
 for(i=0; i<numSites; i++)
	sequence[i] = current_seq[i];
  
  return(sequence);
}


/************************* Compare_amm_dna *************************/
int  Compare_amm_dna(char *dna_seq, int len_dna, short *aa_seq, int len_amm,
		     char **codon, char *coded_aa)
{
  // Test if aa_seq and translation of dna_seq coincide
  /*int MUTMAX=3;*/
  short *aa_test=malloc(len_amm*sizeof(short));
  int i, /*j,*/ nmut=0;
  Translate_new(dna_seq, aa_test, len_amm, codon, coded_aa);
  for(i=0; i<len_amm; i++){
    if(aa_test[i]!=aa_seq[i]){
	  if (noisy > 2)
      	fprintf (fpmpi,"\nWARNING, different amino acid sequences (between codified from input DNA sequence and pdb): position = %d %c %c", i+1, AMIN_CODE[aa_seq[i]],AMIN_CODE[aa_test[i]] );
      /*fprintf (fpmpi,"  Extracting triplet\n");*/
      Extract_triplet(dna_seq, aa_seq, i, coded_aa, codon);
      nmut++;
    }
  }
  free(aa_test);
  return(1);
}

/************************* Translate_new *************************/
int Translate_new(char *dna_seq, short *aa_seq, int length,
		  char **codon, char *coded_aa)
{
  short i, j=0/*, i_codon*/; char ter[4];
  for(i=0; i<length; i++){
    j=3*i;
    aa_seq[i]=Coded_aaf(&(dna_seq[j]), codon, coded_aa);
    //aa_seq[i]=Triplet_code(&(dna_seq[j]));
    /*if(i==(i/60)*60)printf("\n# ");
    printf("%c", AMIN_CODE[aa_seq[i]]);*/
    if(aa_seq[i]<0){
      ter[0]=dna_seq[j]; ter[1]=dna_seq[j+1]; ter[2]=dna_seq[j+2];ter[3]='\0';
      fprintf (fpmpi,"\nError! Termination codon %s found at %d\n", ter, i);
      exit(8);
    }
  }
  /*printf("\n# ");*/
  return(0);
}


/************************* Extract_dna *************************/
char *Extract_dna(int *len_dna, int len_amm, short *aa_seq,
		  char **codon, char *coded_aa)
{
  char *dna_seq=malloc(3*len_amm*sizeof(char));
  int i/*, j, n*/;
  (*len_dna)=3*len_amm;

  for(i=0; i<len_amm; i++){
    Extract_triplet(dna_seq, aa_seq, i, coded_aa, codon);
  }
  if(Compare_amm_dna(dna_seq,*len_dna,aa_seq,len_amm,codon,coded_aa)==0)
    exit(8);
  return(dna_seq);
}

/************************* Extract_triplet *************************/
void Extract_triplet(char *dna_seq, short *aa_seq, int i,
		     char *coded_aa, char **codon)
{
  char amm=AMIN_CODE[aa_seq[i]];
  int jcod[64], n=0, j;
  for(j=0; j<64; j++)if(coded_aa[j]==amm){jcod[n]=j; n++;}
  int iran=(RandomFloating()*n); j=jcod[iran];
  int ki=3*i;
  dna_seq[ki]=codon[j][0];
  dna_seq[ki+1]=codon[j][1];
  dna_seq[ki+2]=codon[j][2];
}

/************************* Check_file *************************/
int Check_file(char *name){
  FILE *file_in=fopen(name, "r");
  if(file_in!=NULL){
    fclose(file_in); return(1);
  }
  return(0);
}


/************************* Minuscule *************************/
char Minuscule(char s){
  int i=(int)s;
  if((i>=65)&&(i<=90)){return((char)(i+32));}else{return(s);}
}

/************************* Maiuscule *************************/
char Maiuscule(char s){
  int i=(int)s;
  if(i>96){return((char)(i-32));}else{return(s);}
}

/************************* Open_file_r *************************/
FILE *Open_file_r(char *name, char *code_name, char *message)
{
  FILE *file_in=fopen(name, "r");
  if(file_in==NULL){
    fprintf (fpmpi,"ERROR in %s, input file %s not found (%s)\n",
	   code_name, name, message); exit(8);
  }
  return(file_in);
}

/************************* Read_column *************************/
float Read_column(char **s, char *string, int i)
{
  /* Reads the first column and updates the char pointer *s */
  float data; int read=0;
  sscanf(*s, "%f", &data);
  while(**s!='\n'){
    if(**s!=' '){
      if(read==0)read=1;
    }else{
      if(read)return(data);
    }
    (*s)++;
  }
  if(read)return(data);
  fprintf (fpmpi,"WARNING, column %d not read in line:\n%s", i, string);
  return(0);
}

/************************* Read_hydro_list *************************/
/*void Read_hydro_list(char *file_hydro, char *hydro_name, float *hydro)
{
  FILE *file_in=Open_file_r(file_hydro, CODE_NAME, "hydro scales ");
  char string[200], name[20], amm; int i, ia; float h;
  printf("Reading hydrophobicity scale in %s\n", file_hydro);

  while(fgets(string, sizeof(string), file_in)!=NULL){
    sscanf(string, "%s", name);
    if(strncmp(name, hydro_name, 3)==0){
      printf("Scale: %s\n", hydro_name);
      for(i=0; i<20; i++){
	fgets(string, sizeof(string), file_in);
	sscanf(string, "%c%f", &amm, &h);
	ia=Code_AA(amm); hydro[ia]=h;
	if(ia<0){
	  printf("Error in %s, wrong aa code %c. Goodbye\n",
		 file_hydro, amm); exit(8);
	}
      }
      fclose(file_in);
      return;
    }else{
      for(i=0; i<21; i++)fgets(string, sizeof(string), file_in);
    }
  }*/

  /* Normalizing the scale */
/*  {
    float ave=0, dev=0, h;
    for(i=0; i<20; i++){h=hydro[i]; ave+=h; dev+=h*h;}
    ave/=20; dev=sqrt(dev/20.-ave*ave);
    for(i=0; i<20; i++)hydro[i]/=dev;
  }

  printf("Error, scale %s not found in %s\n", hydro_name, file_hydro);
  exit(8);
}*/


/************************* Ini_count *************************/
void Ini_count(char *dna_seq, int len_dna, int *count)
{
  int i;
  for(i=0; i<4; i++)count[i]=0;
  for(i=0; i<len_dna; i++){
    count[Code_nuc(dna_seq[i])]++;
	/*fprintf (fpmpi,"i: %d, count[Code_nuc(dna_seq[i])]: %d (Code_nuc(dna_seq[i]) = %d)\n", i, count[Code_nuc(dna_seq[i])], Code_nuc(dna_seq[i]));*/
  }
} 


/************************* Ini_count_AA *************************/
void Ini_count_AA (short *aa_seq, int len_amm, int *countAA)
{
  int i;
  for(i=0; i<20; i++)countAA[i]=0;
  for(i=0; i<len_amm; i++)
	{
    countAA[aa_seq[i]]++;
	/*fprintf (fpmpi,"i: %d, countAA[aa_seq[i]]: %d, aa_seq[i] = %d\n", i, countAA[aa_seq[i]], aa_seq[i]);*/
  	}
} 





/************************* Mutate_seq *************************/
int Mutate_seq(char *dna_seq, int len_dna, char **codon, char *coded_aa,
	       short *aa_seq, int len_nat,
	       float *freq_nuc, float tt_ratio, int *count, float *rate, 
	       int *nuc_mut, char *nuc_new, int *res_mut, int *aa_new, long int *seed)
{
  int i; float ran, norm=0, sum=0;
  char /*triplet[3],*/ nuc_old;

  /*for(i=0; i<4; i++)norm+=count[i]*rate[i];
  ran=RandomFloating();  //ran=RandomVar0();
  ran*=norm;*/

  norm=0; /* Miguel */ /* now each site may have a different rate of change */
  for(i=0; i<len_dna; i++) 
	norm+=rateSite[i];
  ran=RandomFloating();  
  ran*=norm;


  for(i=0; i<len_dna; i++)
	{
    sum+=rateSite[i]; /* by Miguel */

    if(sum>=ran){
      *nuc_new=Mutate_nuc(dna_seq[i], freq_nuc, rate, tt_ratio);
      *nuc_mut=i; break;
      }
    }

  *res_mut=(*nuc_mut)/3; i=(*res_mut)*3; nuc_old=dna_seq[*nuc_mut];
  dna_seq[*nuc_mut]=*nuc_new;
  *aa_new=Coded_aaf(dna_seq+i, codon, coded_aa);
  dna_seq[*nuc_mut]=nuc_old;

  if(*aa_new==-1)return(-1);
  if((*aa_new)==aa_seq[*res_mut])return(1);

  return(0);
}


/************************* Mutate_seq_AA *************************/
int Mutate_seq_AA (short *aa_seq, int len_nat, int *countAA, float *rateAA, int *res_mut, int *aa_new, long int *seed)
{
  int i; float ran, norm=0, sum=0;
  char aaHere;

  /*for(i=0; i<20; i++)
	norm+=countAA[i]*rateAA[i];
  ran=RandomFloating();  
  ran*=norm;*/

  norm=0; /* Miguel */ /* now each site may have a different rate of change */
  for(i=0; i<len_nat; i++) 
	norm+=rateAASite[i];
  ran=RandomFloating();  
  ran*=norm;


 for(i=0; i<len_nat; i++)
    {
    sum+=rateAASite[i]; /* Miguel */

    if(sum>=ran){
	  aaHere = Mutate_aa(AMIN_CODE[aa_seq[i]], rateAA);
	  /*fprintf (fpmpi,"\n aaHere = %d", aaHere);*/
      *aa_new = Code_AA(aaHere);
      *res_mut=i; break;
    }
  }

  /**res_mut=(*nuc_mut)/3; i=(*res_mut)*3; nuc_old=dna_seq[*nuc_mut];
  dna_seq[*nuc_mut]=*nuc_new;*/
  /**aa_new=Coded_aaf(dna_seq+i, codon, coded_aa);
  dna_seq[*nuc_mut]=nuc_old;*/

  if(*aa_new==-1)return(-1);
  /*if((*aa_new)==aa_seq[*res_mut])return(1);*/
 /* all mutations are non-synonymous here*/

  /*fprintf (fpmpi,"\n->NEW AA: aa_new = %d \n", *aa_new);*/

  return(0);
}




/************************* Mutate_nuc *************************/
char Mutate_nuc(char nuc, float *freq_nuc, float *rate, float tt_ratio)
{
  int i_nuc=Code_nuc(nuc), j_nuc;
  float ran, p, sum=0;
  ran= RandomFloating(); if(ran >=1)ran=0.999999;
  //ran= RandomVar0();
  ran*=rate[i_nuc];
  /*fprintf (fpmpi,"\n->i_nuc = %d", i_nuc);
  fprintf (fpmpi,"\n->ran = %lf", ran);*/

  for(j_nuc=0; j_nuc<4; j_nuc++) /* A = 0; T = 1; G = 2; C = 3 */
	{
    if(j_nuc==i_nuc)
		continue;
    p=freq_nuc[j_nuc];

	/*fprintf (fpmpi,"\n j_nuc = %d, i_nuc = %d", j_nuc, i_nuc);*/
	if (doGTR == NO && doGTnR == NO)
		{
    	if(j_nuc==Transition(NUC_CODE[i_nuc]))
			p*=tt_ratio;
		}

	if (doGTR == YES) /* A = 0; T = 1; G = 2; C = 3 */
		{
 		if (j_nuc == 0) /* A: AC (0) AG (1) AT (2) */
			{
			if (i_nuc == 1) /* AT(2) */			
				p*=Rmat[2];
			if (i_nuc == 2) /* AG(1) */			
				p*=Rmat[1];
			if (i_nuc == 3) /* AC(0) */			
				p*=Rmat[0];
			}
		if (j_nuc == 1) /* T: AT (2) CT (4) GT (5) */
			{
			if (i_nuc == 0) /* TA(2) */			
				p*=Rmat[2];
			if (i_nuc == 2) /* TG(5) */			
				p*=Rmat[5];
			if (i_nuc == 3) /* TC(4) */			
				p*=Rmat[4];
			}
		if (j_nuc == 2) /* G: AG (1) CG (3) GT (5) */
			{
			if (i_nuc == 0) /* GA(1) */			
				p*=Rmat[1];
			if (i_nuc == 1) /* GT(5) */			
				p*=Rmat[5];
			if (i_nuc == 3) /* GC(3) */			
				p*=Rmat[3];
			}
		if (j_nuc == 3) /* C: AC (0) CG (3) CT (4) */
			{
			if (i_nuc == 0) /* CA(0) */			
				p*=Rmat[0];
			if (i_nuc == 1) /* CT(4) */			
				p*=Rmat[4];
			if (i_nuc == 2) /* CG(3) */			
				p*=Rmat[3];
			}
		}

	if (doGTnR == YES) /* A = 0; T = 1; G = 2; C = 3 */
		{
    	if (j_nuc == 0) /* A: AC (0) AG (2) AT (4) */
			{
			if (i_nuc == 1) /* AT(4) */			
				p*=NRmat[4];
			if (i_nuc == 2) /* AG(2) */			
				p*=NRmat[2];
			if (i_nuc == 3) /* AC(0) */			
				p*=NRmat[0];
			}
		if (j_nuc == 1) /* T: TA (5) TC (9) TG (11) */
			{
			if (i_nuc == 0) /* TA(5) */			
				p*=NRmat[5];
			if (i_nuc == 2) /* TG(11) */			
				p*=NRmat[11];
			if (i_nuc == 3) /* TC(9) */			
				p*=NRmat[9];
			}
		if (j_nuc == 2) /* G: GA (3) GC (7) GT (10) */
			{
			if (i_nuc == 0) /* GA(3) */			
				p*=NRmat[3];
			if (i_nuc == 1) /* GT(10) */			
				p*=NRmat[10];
			if (i_nuc == 3) /* GC(7) */			
				p*=NRmat[7];
			}
		if (j_nuc == 3) /* C: CA (1) CG (6) CT (8) */
			{
			if (i_nuc == 0) /* CA(1) */			
				p*=NRmat[1];
			if (i_nuc == 1) /* CT(8) */			
				p*=NRmat[8];
			if (i_nuc == 2) /* CG(6) */			
				p*=NRmat[6];
			}
		}

	/*fprintf (fpmpi,"\n->p(%d) = %lf", j_nuc, p);*/

    sum+=p; 
	if(ran<=sum)
		return(NUC_CODE[j_nuc]);
  	}
  fprintf (fpmpi,"Error in Mutate_nuc, nuc=%c, sum=%.4f ran=%.4f\n", nuc, sum, ran);
  exit(8);
}



/************************* Mutate_aa *************************/
char Mutate_aa (char aa, float *rateAA)
{
  int i_aa=Code_AA(aa), j_aa;
  float ran, p, sum=0;
  ran= RandomFloating(); if(ran >=1)ran=0.999999;
  //ran= RandomVar0();
  ran*=rateAA[i_aa];
  /*fprintf (fpmpi,"\n->i_aa = %d, rateAA[i_aa] = %lf", i_aa, rateAA[i_aa]);
  fprintf (fpmpi,"\n->ran = %lf", ran);*/

  for(j_aa=0; j_aa<20; j_aa++)  /* A=0 E=1 Q=2 D=3 N=4 L=5 G=6 K=7 S=8 V=9 R=10 T=11 P=12 I=13 M=14 F=15 Y=16 C=17 W=18 H=19 X */
	{
    if(j_aa==i_aa)
		continue;
    p=AA_EM_Pi_PopEvol[j_aa];
	/*fprintf (fpmpi,"\n->p(%d) = %lf", j_aa, p);*/

	if ((j_aa != i_aa) && (j_aa >= 0) && (j_aa <= 19) && (i_aa >= 0) && (i_aa <= 19)) /* though this should not be required.. */
		p*= Qij_AA_PopEvol[j_aa][i_aa];

	/*if (j_aa == 0) 
		{
		if (i_aa == 1)
			p*= Qij_AA_PopEvol[j_aa][1];
		if (i_aa == 2)
			p*= Qij_AA_PopEvol[j_aa][2];
		...
		if (i_aa == 19)
			p*= Qij_AA_PopEvol[j_aa][19];
	    }
	...
	if (j_aa == 19) 
		{
		}
	*/

	/*fprintf (fpmpi,"\n->p(%d) = %lf", j_aa, p);*/

    sum+=p; 
	if(ran<=sum)
		return(AMIN_CODE[j_aa]);
  	}
  fprintf (fpmpi,"Error in Mutate_aa, aa=%c, sum=%.4f ran=%.4f\n", aa, sum, ran);
  exit(8);

}



/************************* Compute_rates *************************/
int Compute_rates (float *rate, float *freq_nuc, float trans_ratio, char *dna_seq, long int *seed)
{
  float /*rate_max=0, mut_max=0.5,*/ k=trans_ratio-1;
  int i;
  double varRate;
  varRate=1;
  
  if (noisy > 2)
  	fprintf (fpmpi,"\nMutation rates: ");

  if (doGTR == NO && doGTnR == NO) /* titv, HKY */
	{		
  	for(i=0; i<4; i++)
    	{
    	rate[i]=1-freq_nuc[i]+k*freq_nuc[Transition(NUC_CODE[i])];
		if (noisy > 2)
    		fprintf (fpmpi,"%c= %.3f ", NUC_CODE[i], rate[i]);
    	}
	}

  if (doGTR == YES)
	{		
  	for(i=0; i<4; i++) /* A = 0; T = 1; G = 2; C = 3 */
    	{
    	if (i == 0) /* A: AC (0) AG (1) AT (2) */
	    	rate[i] = freq_nuc[1]*Rmat[2] + freq_nuc[2]*Rmat[1] + freq_nuc[3]*Rmat[0];
		if (i == 1) /* T: AT (2) CT (4) GT (5) */
	    	rate[i] = freq_nuc[0]*Rmat[2] + freq_nuc[2]*Rmat[5] + freq_nuc[3]*Rmat[4];
		if (i == 2) /* G: AG (1) CG (3) GT (5) */
	    	rate[i] = freq_nuc[0]*Rmat[1] + freq_nuc[1]*Rmat[5] + freq_nuc[3]*Rmat[3];
		if (i == 3) /* C: AC (0) CG (3) CT (4) */
	    	rate[i] = freq_nuc[0]*Rmat[0] + freq_nuc[1]*Rmat[4] + freq_nuc[2]*Rmat[3];

		if (noisy > 2)
    		fprintf (fpmpi,"%c= %.3f ", NUC_CODE[i], rate[i]);
    	}
	}

  if (doGTnR == YES)
	{		
  	for(i=0; i<4; i++) /* A = 0; T = 1; G = 2; C = 3 */ /* NRmat: AC (0) CA (1) AG (2) GA (3) AT (4) TA (5) CG (6) GC (7) CT (8) TC (9) GT=1 (10) TG (11) */
    	{
    	if (i == 0) /* A: AC (0) AG (2) AT (4) */
	    	rate[i] = freq_nuc[1]*NRmat[4] + freq_nuc[2]*NRmat[2] + freq_nuc[3]*NRmat[0];
		if (i == 1) /* T: TA (5) TC (9) TG (11) */
	    	rate[i] = freq_nuc[0]*NRmat[5] + freq_nuc[2]*NRmat[11] + freq_nuc[3]*NRmat[9];
		if (i == 2) /* G: GA (3) GC (7) GT (10) */
	    	rate[i] = freq_nuc[0]*NRmat[3] + freq_nuc[1]*NRmat[10] + freq_nuc[3]*NRmat[7];
		if (i == 3) /* C: CA (1) CG (6) CT (8) */
	    	rate[i] = freq_nuc[0]*NRmat[1] + freq_nuc[1]*NRmat[8] + freq_nuc[2]*NRmat[6];

		if (noisy > 2)
    		fprintf (fpmpi,"%c= %.3f ", NUC_CODE[i], rate[i]);
    	}
	}


   for(i=0; i<numSites; i++) /* Miguel */
    {
	if (RandomUniform(seed) < pinv)		
		varRate = 0.0;
	else
		{
		if (doRateHet == YES)
			varRate = RndGamma (alpha, seed) / alpha; 
		else
			varRate = 1; 
		}
	if (doHetVectorFile == YES)
		varRate = varRate*vectorHetRates[i];

	rateSite[i] = rate[Code_nuc(dna_seq[i])]*varRate;
	}


  if (noisy > 2)
  	fprintf (fpmpi,"\n");
  return(0);
}


/************************* Compute_ratesAA *************************/
int Compute_ratesAA (float *rateAA, short *aa_seq, long int *seed)
{
/* PopEvol:        A E Q D N L G K S V R T P I M F Y C W H X */
  int i;
  double varRate;
/* AA_EM_Pi_PopEvol[NUMAA], Qij_AA_PopEvol[NUMAA][NUMAA]; */
/* Qij_AA_PopEvol[0 -> 19][0 -> 19], AA_EM_Pi_PopEvol[0 -> 19] */

  varRate=1;
  
  if (noisy > 2)
  	fprintf (fpmpi,"\nMutation rates: ");

  for(i=0; i<20; i++) /* PopEvol:        A=0 E=1 Q=2 D=3 N=4 L=5 G=6 K=7 S=8 V=9 R=10 T=11 P=12 I=13 M=14 F=15 Y=16 C=17 W=18 H=19 X */
    {
	if (i == 0) /* A: 0 */
	   rateAA[i] = AA_EM_Pi_PopEvol[1]*Qij_AA_PopEvol[i][1] + AA_EM_Pi_PopEvol[2]*Qij_AA_PopEvol[i][2] + AA_EM_Pi_PopEvol[3]*Qij_AA_PopEvol[i][3] + AA_EM_Pi_PopEvol[4]*Qij_AA_PopEvol[i][4] + AA_EM_Pi_PopEvol[5]*Qij_AA_PopEvol[i][5] + 
				   AA_EM_Pi_PopEvol[6]*Qij_AA_PopEvol[i][6] + AA_EM_Pi_PopEvol[7]*Qij_AA_PopEvol[i][7] + AA_EM_Pi_PopEvol[8]*Qij_AA_PopEvol[i][8] + AA_EM_Pi_PopEvol[9]*Qij_AA_PopEvol[i][9] + AA_EM_Pi_PopEvol[10]*Qij_AA_PopEvol[i][10] + 
				   AA_EM_Pi_PopEvol[11]*Qij_AA_PopEvol[i][11] + AA_EM_Pi_PopEvol[12]*Qij_AA_PopEvol[i][12] + AA_EM_Pi_PopEvol[13]*Qij_AA_PopEvol[i][13] + AA_EM_Pi_PopEvol[14]*Qij_AA_PopEvol[i][14] + AA_EM_Pi_PopEvol[15]*Qij_AA_PopEvol[i][15] + 
				   AA_EM_Pi_PopEvol[16]*Qij_AA_PopEvol[i][16] + AA_EM_Pi_PopEvol[17]*Qij_AA_PopEvol[i][17] + AA_EM_Pi_PopEvol[18]*Qij_AA_PopEvol[i][18] + AA_EM_Pi_PopEvol[19]*Qij_AA_PopEvol[i][19];
	if (i == 1) /* E: 1 */
	    rateAA[i] = AA_EM_Pi_PopEvol[0]*Qij_AA_PopEvol[i][0] + AA_EM_Pi_PopEvol[2]*Qij_AA_PopEvol[i][2] + AA_EM_Pi_PopEvol[3]*Qij_AA_PopEvol[i][3] + AA_EM_Pi_PopEvol[4]*Qij_AA_PopEvol[i][4] + AA_EM_Pi_PopEvol[5]*Qij_AA_PopEvol[i][5] + 
				   AA_EM_Pi_PopEvol[6]*Qij_AA_PopEvol[i][6] + AA_EM_Pi_PopEvol[7]*Qij_AA_PopEvol[i][7] + AA_EM_Pi_PopEvol[8]*Qij_AA_PopEvol[i][8] + AA_EM_Pi_PopEvol[9]*Qij_AA_PopEvol[i][9] + AA_EM_Pi_PopEvol[10]*Qij_AA_PopEvol[i][10] + 
				   AA_EM_Pi_PopEvol[11]*Qij_AA_PopEvol[i][11] + AA_EM_Pi_PopEvol[12]*Qij_AA_PopEvol[i][12] + AA_EM_Pi_PopEvol[13]*Qij_AA_PopEvol[i][13] + AA_EM_Pi_PopEvol[14]*Qij_AA_PopEvol[i][14] + AA_EM_Pi_PopEvol[15]*Qij_AA_PopEvol[i][15] + 
				   AA_EM_Pi_PopEvol[16]*Qij_AA_PopEvol[i][16] + AA_EM_Pi_PopEvol[17]*Qij_AA_PopEvol[i][17] + AA_EM_Pi_PopEvol[18]*Qij_AA_PopEvol[i][18] + AA_EM_Pi_PopEvol[19]*Qij_AA_PopEvol[i][19];
	if (i == 2) /* Q: 2 */
	     rateAA[i] = AA_EM_Pi_PopEvol[0]*Qij_AA_PopEvol[i][0] + AA_EM_Pi_PopEvol[1]*Qij_AA_PopEvol[i][1] + AA_EM_Pi_PopEvol[3]*Qij_AA_PopEvol[i][3] + AA_EM_Pi_PopEvol[4]*Qij_AA_PopEvol[i][4] + AA_EM_Pi_PopEvol[5]*Qij_AA_PopEvol[i][5] + 
				   AA_EM_Pi_PopEvol[6]*Qij_AA_PopEvol[i][6] + AA_EM_Pi_PopEvol[7]*Qij_AA_PopEvol[i][7] + AA_EM_Pi_PopEvol[8]*Qij_AA_PopEvol[i][8] + AA_EM_Pi_PopEvol[9]*Qij_AA_PopEvol[i][9] + AA_EM_Pi_PopEvol[10]*Qij_AA_PopEvol[i][10] + 
				   AA_EM_Pi_PopEvol[11]*Qij_AA_PopEvol[i][11] + AA_EM_Pi_PopEvol[12]*Qij_AA_PopEvol[i][12] + AA_EM_Pi_PopEvol[13]*Qij_AA_PopEvol[i][13] + AA_EM_Pi_PopEvol[14]*Qij_AA_PopEvol[i][14] + AA_EM_Pi_PopEvol[15]*Qij_AA_PopEvol[i][15] + 
				   AA_EM_Pi_PopEvol[16]*Qij_AA_PopEvol[i][16] + AA_EM_Pi_PopEvol[17]*Qij_AA_PopEvol[i][17] + AA_EM_Pi_PopEvol[18]*Qij_AA_PopEvol[i][18] + AA_EM_Pi_PopEvol[19]*Qij_AA_PopEvol[i][19];
	if (i == 3) /* D: 3 */
	    rateAA[i] = AA_EM_Pi_PopEvol[0]*Qij_AA_PopEvol[i][0] + AA_EM_Pi_PopEvol[1]*Qij_AA_PopEvol[i][1] + AA_EM_Pi_PopEvol[2]*Qij_AA_PopEvol[i][2] + AA_EM_Pi_PopEvol[4]*Qij_AA_PopEvol[i][4] + AA_EM_Pi_PopEvol[5]*Qij_AA_PopEvol[i][5] + 
				   AA_EM_Pi_PopEvol[6]*Qij_AA_PopEvol[i][6] + AA_EM_Pi_PopEvol[7]*Qij_AA_PopEvol[i][7] + AA_EM_Pi_PopEvol[8]*Qij_AA_PopEvol[i][8] + AA_EM_Pi_PopEvol[9]*Qij_AA_PopEvol[i][9] + AA_EM_Pi_PopEvol[10]*Qij_AA_PopEvol[i][10] + 
				   AA_EM_Pi_PopEvol[11]*Qij_AA_PopEvol[i][11] + AA_EM_Pi_PopEvol[12]*Qij_AA_PopEvol[i][12] + AA_EM_Pi_PopEvol[13]*Qij_AA_PopEvol[i][13] + AA_EM_Pi_PopEvol[14]*Qij_AA_PopEvol[i][14] + AA_EM_Pi_PopEvol[15]*Qij_AA_PopEvol[i][15] + 
				   AA_EM_Pi_PopEvol[16]*Qij_AA_PopEvol[i][16] + AA_EM_Pi_PopEvol[17]*Qij_AA_PopEvol[i][17] + AA_EM_Pi_PopEvol[18]*Qij_AA_PopEvol[i][18] + AA_EM_Pi_PopEvol[19]*Qij_AA_PopEvol[i][19];

	if (i == 4) /* N: 4 */
	    rateAA[i] = AA_EM_Pi_PopEvol[0]*Qij_AA_PopEvol[i][0] + AA_EM_Pi_PopEvol[1]*Qij_AA_PopEvol[i][1] + AA_EM_Pi_PopEvol[2]*Qij_AA_PopEvol[i][2] + AA_EM_Pi_PopEvol[3]*Qij_AA_PopEvol[i][3] + AA_EM_Pi_PopEvol[5]*Qij_AA_PopEvol[i][5] + 
				   AA_EM_Pi_PopEvol[6]*Qij_AA_PopEvol[i][6] + AA_EM_Pi_PopEvol[7]*Qij_AA_PopEvol[i][7] + AA_EM_Pi_PopEvol[8]*Qij_AA_PopEvol[i][8] + AA_EM_Pi_PopEvol[9]*Qij_AA_PopEvol[i][9] + AA_EM_Pi_PopEvol[10]*Qij_AA_PopEvol[i][10] + 
				   AA_EM_Pi_PopEvol[11]*Qij_AA_PopEvol[i][11] + AA_EM_Pi_PopEvol[12]*Qij_AA_PopEvol[i][12] + AA_EM_Pi_PopEvol[13]*Qij_AA_PopEvol[i][13] + AA_EM_Pi_PopEvol[14]*Qij_AA_PopEvol[i][14] + AA_EM_Pi_PopEvol[15]*Qij_AA_PopEvol[i][15] + 
				   AA_EM_Pi_PopEvol[16]*Qij_AA_PopEvol[i][16] + AA_EM_Pi_PopEvol[17]*Qij_AA_PopEvol[i][17] + AA_EM_Pi_PopEvol[18]*Qij_AA_PopEvol[i][18] + AA_EM_Pi_PopEvol[19]*Qij_AA_PopEvol[i][19];

	if (i == 5) /* L: 5 */
	    rateAA[i] = AA_EM_Pi_PopEvol[0]*Qij_AA_PopEvol[i][0] + AA_EM_Pi_PopEvol[1]*Qij_AA_PopEvol[i][1] + AA_EM_Pi_PopEvol[2]*Qij_AA_PopEvol[i][2] + AA_EM_Pi_PopEvol[3]*Qij_AA_PopEvol[i][3] + AA_EM_Pi_PopEvol[4]*Qij_AA_PopEvol[i][4] + 
				   AA_EM_Pi_PopEvol[6]*Qij_AA_PopEvol[i][6] + AA_EM_Pi_PopEvol[7]*Qij_AA_PopEvol[i][7] + AA_EM_Pi_PopEvol[8]*Qij_AA_PopEvol[i][8] + AA_EM_Pi_PopEvol[9]*Qij_AA_PopEvol[i][9] + AA_EM_Pi_PopEvol[10]*Qij_AA_PopEvol[i][10] + 
				   AA_EM_Pi_PopEvol[11]*Qij_AA_PopEvol[i][11] + AA_EM_Pi_PopEvol[12]*Qij_AA_PopEvol[i][12] + AA_EM_Pi_PopEvol[13]*Qij_AA_PopEvol[i][13] + AA_EM_Pi_PopEvol[14]*Qij_AA_PopEvol[i][14] + AA_EM_Pi_PopEvol[15]*Qij_AA_PopEvol[i][15] + 
				   AA_EM_Pi_PopEvol[16]*Qij_AA_PopEvol[i][16] + AA_EM_Pi_PopEvol[17]*Qij_AA_PopEvol[i][17] + AA_EM_Pi_PopEvol[18]*Qij_AA_PopEvol[i][18] + AA_EM_Pi_PopEvol[19]*Qij_AA_PopEvol[i][19];

	if (i == 6) /* G: 6 */
	    rateAA[i] = AA_EM_Pi_PopEvol[0]*Qij_AA_PopEvol[i][0] + AA_EM_Pi_PopEvol[1]*Qij_AA_PopEvol[i][1] + AA_EM_Pi_PopEvol[2]*Qij_AA_PopEvol[i][2] + AA_EM_Pi_PopEvol[3]*Qij_AA_PopEvol[i][3] + AA_EM_Pi_PopEvol[4]*Qij_AA_PopEvol[i][4] + 
				   AA_EM_Pi_PopEvol[5]*Qij_AA_PopEvol[i][5] + AA_EM_Pi_PopEvol[7]*Qij_AA_PopEvol[i][7] + AA_EM_Pi_PopEvol[8]*Qij_AA_PopEvol[i][8] + AA_EM_Pi_PopEvol[9]*Qij_AA_PopEvol[i][9] + AA_EM_Pi_PopEvol[10]*Qij_AA_PopEvol[i][10] + 
				   AA_EM_Pi_PopEvol[11]*Qij_AA_PopEvol[i][11] + AA_EM_Pi_PopEvol[12]*Qij_AA_PopEvol[i][12] + AA_EM_Pi_PopEvol[13]*Qij_AA_PopEvol[i][13] + AA_EM_Pi_PopEvol[14]*Qij_AA_PopEvol[i][14] + AA_EM_Pi_PopEvol[15]*Qij_AA_PopEvol[i][15] + 
				   AA_EM_Pi_PopEvol[16]*Qij_AA_PopEvol[i][16] + AA_EM_Pi_PopEvol[17]*Qij_AA_PopEvol[i][17] + AA_EM_Pi_PopEvol[18]*Qij_AA_PopEvol[i][18] + AA_EM_Pi_PopEvol[19]*Qij_AA_PopEvol[i][19];

	if (i == 7) /* K: 7 */
	    rateAA[i] = AA_EM_Pi_PopEvol[0]*Qij_AA_PopEvol[i][0] + AA_EM_Pi_PopEvol[1]*Qij_AA_PopEvol[i][1] + AA_EM_Pi_PopEvol[2]*Qij_AA_PopEvol[i][2] + AA_EM_Pi_PopEvol[3]*Qij_AA_PopEvol[i][3] + AA_EM_Pi_PopEvol[4]*Qij_AA_PopEvol[i][4] + 
				   AA_EM_Pi_PopEvol[5]*Qij_AA_PopEvol[i][5] + AA_EM_Pi_PopEvol[6]*Qij_AA_PopEvol[i][6] + AA_EM_Pi_PopEvol[8]*Qij_AA_PopEvol[i][8] + AA_EM_Pi_PopEvol[9]*Qij_AA_PopEvol[i][9] + AA_EM_Pi_PopEvol[10]*Qij_AA_PopEvol[i][10] + 
				   AA_EM_Pi_PopEvol[11]*Qij_AA_PopEvol[i][11] + AA_EM_Pi_PopEvol[12]*Qij_AA_PopEvol[i][12] + AA_EM_Pi_PopEvol[13]*Qij_AA_PopEvol[i][13] + AA_EM_Pi_PopEvol[14]*Qij_AA_PopEvol[i][14] + AA_EM_Pi_PopEvol[15]*Qij_AA_PopEvol[i][15] + 
				   AA_EM_Pi_PopEvol[16]*Qij_AA_PopEvol[i][16] + AA_EM_Pi_PopEvol[17]*Qij_AA_PopEvol[i][17] + AA_EM_Pi_PopEvol[18]*Qij_AA_PopEvol[i][18] + AA_EM_Pi_PopEvol[19]*Qij_AA_PopEvol[i][19];

	if (i == 8) /* S: 8 */
	    rateAA[i] = AA_EM_Pi_PopEvol[0]*Qij_AA_PopEvol[i][0] + AA_EM_Pi_PopEvol[1]*Qij_AA_PopEvol[i][1] + AA_EM_Pi_PopEvol[2]*Qij_AA_PopEvol[i][2] + AA_EM_Pi_PopEvol[3]*Qij_AA_PopEvol[i][3] + AA_EM_Pi_PopEvol[4]*Qij_AA_PopEvol[i][4] + 
				   AA_EM_Pi_PopEvol[5]*Qij_AA_PopEvol[i][5] + AA_EM_Pi_PopEvol[6]*Qij_AA_PopEvol[i][6] + AA_EM_Pi_PopEvol[7]*Qij_AA_PopEvol[i][7] + AA_EM_Pi_PopEvol[9]*Qij_AA_PopEvol[i][9] + AA_EM_Pi_PopEvol[10]*Qij_AA_PopEvol[i][10] + 
				   AA_EM_Pi_PopEvol[11]*Qij_AA_PopEvol[i][11] + AA_EM_Pi_PopEvol[12]*Qij_AA_PopEvol[i][12] + AA_EM_Pi_PopEvol[13]*Qij_AA_PopEvol[i][13] + AA_EM_Pi_PopEvol[14]*Qij_AA_PopEvol[i][14] + AA_EM_Pi_PopEvol[15]*Qij_AA_PopEvol[i][15] + 
				   AA_EM_Pi_PopEvol[16]*Qij_AA_PopEvol[i][16] + AA_EM_Pi_PopEvol[17]*Qij_AA_PopEvol[i][17] + AA_EM_Pi_PopEvol[18]*Qij_AA_PopEvol[i][18] + AA_EM_Pi_PopEvol[19]*Qij_AA_PopEvol[i][19];

	if (i == 9) /* V: 9 */
	    rateAA[i] = AA_EM_Pi_PopEvol[0]*Qij_AA_PopEvol[i][0] + AA_EM_Pi_PopEvol[1]*Qij_AA_PopEvol[i][1] + AA_EM_Pi_PopEvol[2]*Qij_AA_PopEvol[i][2] + AA_EM_Pi_PopEvol[3]*Qij_AA_PopEvol[i][3] + AA_EM_Pi_PopEvol[4]*Qij_AA_PopEvol[i][4] + 
				   AA_EM_Pi_PopEvol[5]*Qij_AA_PopEvol[i][5] + AA_EM_Pi_PopEvol[6]*Qij_AA_PopEvol[i][6] + AA_EM_Pi_PopEvol[7]*Qij_AA_PopEvol[i][7] + AA_EM_Pi_PopEvol[8]*Qij_AA_PopEvol[i][8] + AA_EM_Pi_PopEvol[10]*Qij_AA_PopEvol[i][10] + 
				   AA_EM_Pi_PopEvol[11]*Qij_AA_PopEvol[i][11] + AA_EM_Pi_PopEvol[12]*Qij_AA_PopEvol[i][12] + AA_EM_Pi_PopEvol[13]*Qij_AA_PopEvol[i][13] + AA_EM_Pi_PopEvol[14]*Qij_AA_PopEvol[i][14] + AA_EM_Pi_PopEvol[15]*Qij_AA_PopEvol[i][15] + 
				   AA_EM_Pi_PopEvol[16]*Qij_AA_PopEvol[i][16] + AA_EM_Pi_PopEvol[17]*Qij_AA_PopEvol[i][17] + AA_EM_Pi_PopEvol[18]*Qij_AA_PopEvol[i][18] + AA_EM_Pi_PopEvol[19]*Qij_AA_PopEvol[i][19];

	if (i == 10) /* R: 10 */
	    rateAA[i] = AA_EM_Pi_PopEvol[0]*Qij_AA_PopEvol[i][0] + AA_EM_Pi_PopEvol[1]*Qij_AA_PopEvol[i][1] + AA_EM_Pi_PopEvol[2]*Qij_AA_PopEvol[i][2] + AA_EM_Pi_PopEvol[3]*Qij_AA_PopEvol[i][3] + AA_EM_Pi_PopEvol[4]*Qij_AA_PopEvol[i][4] + 
				   AA_EM_Pi_PopEvol[5]*Qij_AA_PopEvol[i][5] + AA_EM_Pi_PopEvol[6]*Qij_AA_PopEvol[i][6] + AA_EM_Pi_PopEvol[7]*Qij_AA_PopEvol[i][7] + AA_EM_Pi_PopEvol[8]*Qij_AA_PopEvol[i][8] + AA_EM_Pi_PopEvol[9]*Qij_AA_PopEvol[i][9] + 
				   AA_EM_Pi_PopEvol[11]*Qij_AA_PopEvol[i][11] + AA_EM_Pi_PopEvol[12]*Qij_AA_PopEvol[i][12] + AA_EM_Pi_PopEvol[13]*Qij_AA_PopEvol[i][13] + AA_EM_Pi_PopEvol[14]*Qij_AA_PopEvol[i][14] + AA_EM_Pi_PopEvol[15]*Qij_AA_PopEvol[i][15] + 
				   AA_EM_Pi_PopEvol[16]*Qij_AA_PopEvol[i][16] + AA_EM_Pi_PopEvol[17]*Qij_AA_PopEvol[i][17] + AA_EM_Pi_PopEvol[18]*Qij_AA_PopEvol[i][18] + AA_EM_Pi_PopEvol[19]*Qij_AA_PopEvol[i][19];

	if (i == 11) /* T: 11 */
	    rateAA[i] = AA_EM_Pi_PopEvol[0]*Qij_AA_PopEvol[i][0] + AA_EM_Pi_PopEvol[1]*Qij_AA_PopEvol[i][1] + AA_EM_Pi_PopEvol[2]*Qij_AA_PopEvol[i][2] + AA_EM_Pi_PopEvol[3]*Qij_AA_PopEvol[i][3] + AA_EM_Pi_PopEvol[4]*Qij_AA_PopEvol[i][4] + 
				   AA_EM_Pi_PopEvol[5]*Qij_AA_PopEvol[i][5] + AA_EM_Pi_PopEvol[6]*Qij_AA_PopEvol[i][6] + AA_EM_Pi_PopEvol[7]*Qij_AA_PopEvol[i][7] + AA_EM_Pi_PopEvol[8]*Qij_AA_PopEvol[i][8] + AA_EM_Pi_PopEvol[9]*Qij_AA_PopEvol[i][9] + 
				   AA_EM_Pi_PopEvol[10]*Qij_AA_PopEvol[i][10] + AA_EM_Pi_PopEvol[12]*Qij_AA_PopEvol[i][12] + AA_EM_Pi_PopEvol[13]*Qij_AA_PopEvol[i][13] + AA_EM_Pi_PopEvol[14]*Qij_AA_PopEvol[i][14] + AA_EM_Pi_PopEvol[15]*Qij_AA_PopEvol[i][15] + 
				   AA_EM_Pi_PopEvol[16]*Qij_AA_PopEvol[i][16] + AA_EM_Pi_PopEvol[17]*Qij_AA_PopEvol[i][17] + AA_EM_Pi_PopEvol[18]*Qij_AA_PopEvol[i][18] + AA_EM_Pi_PopEvol[19]*Qij_AA_PopEvol[i][19];

	if (i == 12) /* P: 12 */
	    rateAA[i] = AA_EM_Pi_PopEvol[0]*Qij_AA_PopEvol[i][0] + AA_EM_Pi_PopEvol[1]*Qij_AA_PopEvol[i][1] + AA_EM_Pi_PopEvol[2]*Qij_AA_PopEvol[i][2] + AA_EM_Pi_PopEvol[3]*Qij_AA_PopEvol[i][3] + AA_EM_Pi_PopEvol[4]*Qij_AA_PopEvol[i][4] + 
				   AA_EM_Pi_PopEvol[5]*Qij_AA_PopEvol[i][5] + AA_EM_Pi_PopEvol[6]*Qij_AA_PopEvol[i][6] + AA_EM_Pi_PopEvol[7]*Qij_AA_PopEvol[i][7] + AA_EM_Pi_PopEvol[8]*Qij_AA_PopEvol[i][8] + AA_EM_Pi_PopEvol[9]*Qij_AA_PopEvol[i][9] + 
				   AA_EM_Pi_PopEvol[10]*Qij_AA_PopEvol[i][10] + AA_EM_Pi_PopEvol[11]*Qij_AA_PopEvol[i][11] + AA_EM_Pi_PopEvol[13]*Qij_AA_PopEvol[i][13] + AA_EM_Pi_PopEvol[14]*Qij_AA_PopEvol[i][14] + AA_EM_Pi_PopEvol[15]*Qij_AA_PopEvol[i][15] + 
				   AA_EM_Pi_PopEvol[16]*Qij_AA_PopEvol[i][16] + AA_EM_Pi_PopEvol[17]*Qij_AA_PopEvol[i][17] + AA_EM_Pi_PopEvol[18]*Qij_AA_PopEvol[i][18] + AA_EM_Pi_PopEvol[19]*Qij_AA_PopEvol[i][19];

	if (i == 13) /* I: 13 */
	    rateAA[i] = AA_EM_Pi_PopEvol[0]*Qij_AA_PopEvol[i][0] + AA_EM_Pi_PopEvol[1]*Qij_AA_PopEvol[i][1] + AA_EM_Pi_PopEvol[2]*Qij_AA_PopEvol[i][2] + AA_EM_Pi_PopEvol[3]*Qij_AA_PopEvol[i][3] + AA_EM_Pi_PopEvol[4]*Qij_AA_PopEvol[i][4] + 
				   AA_EM_Pi_PopEvol[5]*Qij_AA_PopEvol[i][5] + AA_EM_Pi_PopEvol[6]*Qij_AA_PopEvol[i][6] + AA_EM_Pi_PopEvol[7]*Qij_AA_PopEvol[i][7] + AA_EM_Pi_PopEvol[8]*Qij_AA_PopEvol[i][8] + AA_EM_Pi_PopEvol[9]*Qij_AA_PopEvol[i][9] + 
				   AA_EM_Pi_PopEvol[10]*Qij_AA_PopEvol[i][10] + AA_EM_Pi_PopEvol[11]*Qij_AA_PopEvol[i][11] + AA_EM_Pi_PopEvol[12]*Qij_AA_PopEvol[i][12] + AA_EM_Pi_PopEvol[14]*Qij_AA_PopEvol[i][14] + AA_EM_Pi_PopEvol[15]*Qij_AA_PopEvol[i][15] + 
				   AA_EM_Pi_PopEvol[16]*Qij_AA_PopEvol[i][16] + AA_EM_Pi_PopEvol[17]*Qij_AA_PopEvol[i][17] + AA_EM_Pi_PopEvol[18]*Qij_AA_PopEvol[i][18] + AA_EM_Pi_PopEvol[19]*Qij_AA_PopEvol[i][19];

	if (i == 14) /* M: 14 */
	    rateAA[i] = AA_EM_Pi_PopEvol[0]*Qij_AA_PopEvol[i][0] + AA_EM_Pi_PopEvol[1]*Qij_AA_PopEvol[i][1] + AA_EM_Pi_PopEvol[2]*Qij_AA_PopEvol[i][2] + AA_EM_Pi_PopEvol[3]*Qij_AA_PopEvol[i][3] + AA_EM_Pi_PopEvol[4]*Qij_AA_PopEvol[i][4] + 
				   AA_EM_Pi_PopEvol[5]*Qij_AA_PopEvol[i][5] + AA_EM_Pi_PopEvol[6]*Qij_AA_PopEvol[i][6] + AA_EM_Pi_PopEvol[7]*Qij_AA_PopEvol[i][7] + AA_EM_Pi_PopEvol[8]*Qij_AA_PopEvol[i][8] + AA_EM_Pi_PopEvol[9]*Qij_AA_PopEvol[i][9] + 
				   AA_EM_Pi_PopEvol[10]*Qij_AA_PopEvol[i][10] + AA_EM_Pi_PopEvol[11]*Qij_AA_PopEvol[i][11] + AA_EM_Pi_PopEvol[12]*Qij_AA_PopEvol[i][12] + AA_EM_Pi_PopEvol[13]*Qij_AA_PopEvol[i][13] + AA_EM_Pi_PopEvol[15]*Qij_AA_PopEvol[i][15] + 
				   AA_EM_Pi_PopEvol[16]*Qij_AA_PopEvol[i][16] + AA_EM_Pi_PopEvol[17]*Qij_AA_PopEvol[i][17] + AA_EM_Pi_PopEvol[18]*Qij_AA_PopEvol[i][18] + AA_EM_Pi_PopEvol[19]*Qij_AA_PopEvol[i][19];

	if (i == 15) /* F: 15 */
	    rateAA[i] = AA_EM_Pi_PopEvol[0]*Qij_AA_PopEvol[i][0] + AA_EM_Pi_PopEvol[1]*Qij_AA_PopEvol[i][1] + AA_EM_Pi_PopEvol[2]*Qij_AA_PopEvol[i][2] + AA_EM_Pi_PopEvol[3]*Qij_AA_PopEvol[i][3] + AA_EM_Pi_PopEvol[4]*Qij_AA_PopEvol[i][4] + 
				   AA_EM_Pi_PopEvol[5]*Qij_AA_PopEvol[i][5] + AA_EM_Pi_PopEvol[6]*Qij_AA_PopEvol[i][6] + AA_EM_Pi_PopEvol[7]*Qij_AA_PopEvol[i][7] + AA_EM_Pi_PopEvol[8]*Qij_AA_PopEvol[i][8] + AA_EM_Pi_PopEvol[9]*Qij_AA_PopEvol[i][9] + 
				   AA_EM_Pi_PopEvol[10]*Qij_AA_PopEvol[i][10] + AA_EM_Pi_PopEvol[11]*Qij_AA_PopEvol[i][11] + AA_EM_Pi_PopEvol[12]*Qij_AA_PopEvol[i][12] + AA_EM_Pi_PopEvol[13]*Qij_AA_PopEvol[i][13] + AA_EM_Pi_PopEvol[14]*Qij_AA_PopEvol[i][14] + 
				   AA_EM_Pi_PopEvol[16]*Qij_AA_PopEvol[i][16] + AA_EM_Pi_PopEvol[17]*Qij_AA_PopEvol[i][17] + AA_EM_Pi_PopEvol[18]*Qij_AA_PopEvol[i][18] + AA_EM_Pi_PopEvol[19]*Qij_AA_PopEvol[i][19];

	if (i == 16) /* Y: 16 */
	    rateAA[i] = AA_EM_Pi_PopEvol[0]*Qij_AA_PopEvol[i][0] + AA_EM_Pi_PopEvol[1]*Qij_AA_PopEvol[i][1] + AA_EM_Pi_PopEvol[2]*Qij_AA_PopEvol[i][2] + AA_EM_Pi_PopEvol[3]*Qij_AA_PopEvol[i][3] + AA_EM_Pi_PopEvol[4]*Qij_AA_PopEvol[i][4] + 
				   AA_EM_Pi_PopEvol[5]*Qij_AA_PopEvol[i][5] + AA_EM_Pi_PopEvol[6]*Qij_AA_PopEvol[i][6] + AA_EM_Pi_PopEvol[7]*Qij_AA_PopEvol[i][7] + AA_EM_Pi_PopEvol[8]*Qij_AA_PopEvol[i][8] + AA_EM_Pi_PopEvol[9]*Qij_AA_PopEvol[i][9] + 
				   AA_EM_Pi_PopEvol[10]*Qij_AA_PopEvol[i][10] + AA_EM_Pi_PopEvol[11]*Qij_AA_PopEvol[i][11] + AA_EM_Pi_PopEvol[12]*Qij_AA_PopEvol[i][12] + AA_EM_Pi_PopEvol[13]*Qij_AA_PopEvol[i][13] + AA_EM_Pi_PopEvol[14]*Qij_AA_PopEvol[i][14] + 
				   AA_EM_Pi_PopEvol[15]*Qij_AA_PopEvol[i][15] + AA_EM_Pi_PopEvol[17]*Qij_AA_PopEvol[i][17] + AA_EM_Pi_PopEvol[18]*Qij_AA_PopEvol[i][18] + AA_EM_Pi_PopEvol[19]*Qij_AA_PopEvol[i][19];

	if (i == 17) /* C: 17 */
	    rateAA[i] = AA_EM_Pi_PopEvol[0]*Qij_AA_PopEvol[i][0] + AA_EM_Pi_PopEvol[1]*Qij_AA_PopEvol[i][1] + AA_EM_Pi_PopEvol[2]*Qij_AA_PopEvol[i][2] + AA_EM_Pi_PopEvol[3]*Qij_AA_PopEvol[i][3] + AA_EM_Pi_PopEvol[4]*Qij_AA_PopEvol[i][4] + 
				   AA_EM_Pi_PopEvol[5]*Qij_AA_PopEvol[i][5] + AA_EM_Pi_PopEvol[6]*Qij_AA_PopEvol[i][6] + AA_EM_Pi_PopEvol[7]*Qij_AA_PopEvol[i][7] + AA_EM_Pi_PopEvol[8]*Qij_AA_PopEvol[i][8] + AA_EM_Pi_PopEvol[9]*Qij_AA_PopEvol[i][9] + 
				   AA_EM_Pi_PopEvol[10]*Qij_AA_PopEvol[i][10] + AA_EM_Pi_PopEvol[11]*Qij_AA_PopEvol[i][11] + AA_EM_Pi_PopEvol[12]*Qij_AA_PopEvol[i][12] + AA_EM_Pi_PopEvol[13]*Qij_AA_PopEvol[i][13] + AA_EM_Pi_PopEvol[14]*Qij_AA_PopEvol[i][14] + 
				   AA_EM_Pi_PopEvol[15]*Qij_AA_PopEvol[i][15] + AA_EM_Pi_PopEvol[16]*Qij_AA_PopEvol[i][16] + AA_EM_Pi_PopEvol[18]*Qij_AA_PopEvol[i][18] + AA_EM_Pi_PopEvol[19]*Qij_AA_PopEvol[i][19];

	if (i == 18) /* W: 18 */
	    rateAA[i] = AA_EM_Pi_PopEvol[0]*Qij_AA_PopEvol[i][0] + AA_EM_Pi_PopEvol[1]*Qij_AA_PopEvol[i][1] + AA_EM_Pi_PopEvol[2]*Qij_AA_PopEvol[i][2] + AA_EM_Pi_PopEvol[3]*Qij_AA_PopEvol[i][3] + AA_EM_Pi_PopEvol[4]*Qij_AA_PopEvol[i][4] + 
				   AA_EM_Pi_PopEvol[5]*Qij_AA_PopEvol[i][5] + AA_EM_Pi_PopEvol[6]*Qij_AA_PopEvol[i][6] + AA_EM_Pi_PopEvol[7]*Qij_AA_PopEvol[i][7] + AA_EM_Pi_PopEvol[8]*Qij_AA_PopEvol[i][8] + AA_EM_Pi_PopEvol[9]*Qij_AA_PopEvol[i][9] + 
				   AA_EM_Pi_PopEvol[10]*Qij_AA_PopEvol[i][10] + AA_EM_Pi_PopEvol[11]*Qij_AA_PopEvol[i][11] + AA_EM_Pi_PopEvol[12]*Qij_AA_PopEvol[i][12] + AA_EM_Pi_PopEvol[13]*Qij_AA_PopEvol[i][13] + AA_EM_Pi_PopEvol[14]*Qij_AA_PopEvol[i][14] + 
				   AA_EM_Pi_PopEvol[15]*Qij_AA_PopEvol[i][15] + AA_EM_Pi_PopEvol[16]*Qij_AA_PopEvol[i][16] + AA_EM_Pi_PopEvol[17]*Qij_AA_PopEvol[i][17] + AA_EM_Pi_PopEvol[19]*Qij_AA_PopEvol[i][19];

	if (i == 19) /* H: 19 */
	    rateAA[i] = AA_EM_Pi_PopEvol[0]*Qij_AA_PopEvol[i][0] + AA_EM_Pi_PopEvol[1]*Qij_AA_PopEvol[i][1] + AA_EM_Pi_PopEvol[2]*Qij_AA_PopEvol[i][2] + AA_EM_Pi_PopEvol[3]*Qij_AA_PopEvol[i][3] + AA_EM_Pi_PopEvol[4]*Qij_AA_PopEvol[i][4] + 
				   AA_EM_Pi_PopEvol[5]*Qij_AA_PopEvol[i][5] + AA_EM_Pi_PopEvol[6]*Qij_AA_PopEvol[i][6] + AA_EM_Pi_PopEvol[7]*Qij_AA_PopEvol[i][7] + AA_EM_Pi_PopEvol[8]*Qij_AA_PopEvol[i][8] + AA_EM_Pi_PopEvol[9]*Qij_AA_PopEvol[i][9] + 
				   AA_EM_Pi_PopEvol[10]*Qij_AA_PopEvol[i][10] + AA_EM_Pi_PopEvol[11]*Qij_AA_PopEvol[i][11] + AA_EM_Pi_PopEvol[12]*Qij_AA_PopEvol[i][12] + AA_EM_Pi_PopEvol[13]*Qij_AA_PopEvol[i][13] + AA_EM_Pi_PopEvol[14]*Qij_AA_PopEvol[i][14] + 
				   AA_EM_Pi_PopEvol[15]*Qij_AA_PopEvol[i][15] + AA_EM_Pi_PopEvol[16]*Qij_AA_PopEvol[i][16] + AA_EM_Pi_PopEvol[17]*Qij_AA_PopEvol[i][17] + AA_EM_Pi_PopEvol[18]*Qij_AA_PopEvol[i][18];


	if (noisy > 2)
    	fprintf (fpmpi,"%c= %.3f ", AMIN_CODE[i], rateAA[i]);
    }



  for(i=0; i<numSites; i++) /* Miguel */
    {
	if (RandomUniform(seed) < pinv)		
		varRate = 0.0;
	else
		{
		if (doRateHet == YES)
			varRate = RndGamma (alpha, seed) / alpha; 
		else
			varRate = 1; 
		}
	if (doHetVectorFile == YES)
		varRate = varRate*vectorHetRates[i];

	rateAASite[i] = rateAA[aa_seq[i]]*varRate;
	}


 
  if (noisy > 2)
  	fprintf (fpmpi,"\n");
  return(0);
}





/************************* Print_ave *************************/
void Print_ave(FILE *file_ave,
	       double it_sum, float n_subst,
	       int N_pop,
	       double f_sum, double f_dev,
	       double E_sum, double E_dev,
	       double DG_sum, double DG_dev,
	       float seq_entr,
	       double num_syn_subst, double num_aa_subst,
	       double Tload_sum, double Tload_dev,
	       double Mload_sum, double Mload_dev,
	       int Nload, int NEUTRAL)
{
//   float t_indip=n_subst/20;
   float t_indip=1.0;

  if(ini_print==0){
    fprintf(file_ave, "# N  fitness (sd)     E    (sd)    gap  (sd)");
    fprintf(file_ave, " seq.entropy     Trans.load   (sd)  Mut.load  (sd)");
    fprintf(file_ave, "  syn/nonsyn reject  samples\n");
    ini_print=1;
  }
  if(NEUTRAL){
    fprintf(file_ave, "Neutral ");
  }else{
    fprintf(file_ave, "%3d ", N_pop);
  }
  Print_mean(file_ave, f_sum, f_dev, it_sum, t_indip);
  Print_mean(file_ave, E_sum, E_dev, it_sum, t_indip);
  Print_mean(file_ave, DG_sum, DG_dev, it_sum, t_indip);
  fprintf(file_ave, " %.4f ", seq_entr);
  Print_mean(file_ave, Tload_sum, Tload_dev, Nload, Nload);
  Print_mean(file_ave, Mload_sum, Mload_dev, Nload, Nload);
  fprintf(file_ave, " %.3f  %.4f ", num_syn_subst/num_aa_subst,
	  1.-(num_syn_subst+num_aa_subst)/it_sum);
  fprintf(file_ave, " %.0f\n", n_subst);
  fflush(file_ave);
}

/************************* Print_ave_AA *************************/
void Print_ave_AA (FILE *file_ave,
		   double it_sum, float n_subst,
		   int N_pop,
		   double f_sum, double f_dev,
		   double E_sum, double E_dev,
		   double DG_sum, double DG_dev,
		   float seq_entr,
		   double num_syn_subst, double num_aa_subst,
		   double Tload_sum, double Tload_dev,
		   double Mload_sum, double Mload_dev,
		   int Nload, int NEUTRAL)
{
//   float t_indip=n_subst/20;
   float t_indip=1.0;

  if(ini_print==0){
    fprintf(file_ave, "# N  fitness (sd)     E    (sd)    gap  (sd)");
    fprintf(file_ave, " seq.entropy     Trans.load   (sd)  Mut.load  (sd)");
    fprintf(file_ave, "  syn/nonsyn reject  samples\n");
    ini_print=1;
  }
  if(NEUTRAL){
    fprintf(file_ave, "Neutral ");
  }else{
    fprintf(file_ave, "%3d ", N_pop);
  }
  Print_mean(file_ave, f_sum, f_dev, it_sum, t_indip);
  Print_mean(file_ave, E_sum, E_dev, it_sum, t_indip);
  Print_mean(file_ave, DG_sum, DG_dev, it_sum, t_indip);
  fprintf(file_ave, " %.4f ", seq_entr);
  Print_mean(file_ave, Tload_sum, Tload_dev, Nload, Nload);
  Print_mean(file_ave, Mload_sum, Mload_dev, Nload, Nload);
  fprintf(file_ave, " %.3f  %.4f ", num_syn_subst/num_aa_subst,
	  1.-(num_syn_subst+num_aa_subst)/it_sum);
  fprintf(file_ave, " %.0f\n", n_subst);
  fflush(file_ave);
}



/************************* Print_mean *************************/
void Print_mean(FILE *file_out, float sum, float dev,
		float n_sum, float t_indip)
{
//   fprintf(file_out, " %.4f %.4f ", sum/n_sum,
// 	  sqrt((dev-sum*sum/n_sum)/(n_sum*t_indip)));
  fprintf(file_out, " %.8f %.8f ", sum/n_sum,
	  sqrt((dev-sum*sum/n_sum)/(n_sum*t_indip)));
}
    
/************************* Print_final *************************/
void Print_final(char *name_file, double it_sum,
		 float TEMP, float s0,
		 int N_pop, float *freq_nuc,
		 double f_ave, double f_dev, 
		 double E_ave, double E_dev,
		 double DG_ave, double DG_dev,
		 float seq_entr, double seq_entr_dev,
		 double Tload_sum, double Tload_dev,
		 double Mload_sum, double Mload_dev,
		 int Nload,
		 double num_syn_subst, double num_aa_subst,
		 char *dna_seq, int len_dna, int NEUTRAL)
{
  FILE *file_out; char name_out[200];
  short i, j, i_nuc, nuc_count[4][3], length;
//   float t_indep=num_aa_subst/10;
  float t_indep=1.0;

  sprintf(name_out, "%s_final.dat", name_file);
  if (noisy > 2)
  	fprintf (fpmpi,"Writing %s\n", name_out);
  file_out=fopen(name_out, "w");

  // Headers
  fprintf(file_out, "# TEMP S0 Npop GC  ");
  fprintf(file_out, " fitness (sd) E_nat (sd) DG (sd) seq_entr (sd)");
  fprintf(file_out, " Trans.load   (sd)  Mut.load  (sd)");
  fprintf(file_out, " syn/nosyn  reject samples");
  for(i=0; i<3; i++){
    fprintf(file_out, "  ");
    for(j=0; j<3; j++)fprintf(file_out, "%c%d ", NUC_CODE[i], j+1);
  }
  fprintf(file_out, "\n#\n");

  // Parameters
  fprintf(file_out, "%.2f %.3f ", TEMP, s0);
  if(NEUTRAL){
    fprintf(file_out, "Neutral ");
  }else{
    fprintf(file_out, "%3d ", N_pop);
  }
  fprintf(file_out, " %.2f", freq_nuc[Code_nuc('G')]+freq_nuc[Code_nuc('C')]);
  /*fprintf(file_out, " %.1f    ", tt_ratio);*/

  // Results
  Print_mean(file_out, f_ave, f_dev, it_sum, t_indep);
  Print_mean(file_out, E_ave, E_dev, it_sum, t_indep);
  Print_mean(file_out, DG_ave, DG_dev, it_sum, t_indep);
  fprintf(file_out, " %7.4g %7.4g ", seq_entr, seq_entr_dev);
  Print_mean(file_out, Tload_sum, Tload_dev, Nload, Nload);
  Print_mean(file_out, Mload_sum, Mload_dev, Nload, Nload);

  // Synonimous, mutation load
  fprintf(file_out, " %.3f %.4f ", num_syn_subst/num_aa_subst,
	  1.-(num_syn_subst+num_aa_subst)/it_sum);
  fprintf(file_out, " %.0f  ", it_sum);

  // base content in DNA
  for(i=0; i<4; i++)
    for(j=0; j<3; j++)
      nuc_count[i][j]=0;
  j=0; length=len_dna/3;
  for(i=0; i<len_dna; i++){
    i_nuc=Code_nuc(dna_seq[i]);
    nuc_count[i_nuc][j]++; j++;
    if(j==3)j=0;
  }
  for(i=0; i<3; i++){
    fprintf(file_out," ");
    for(j=0; j<3; j++){
      fprintf(file_out," %.3f", nuc_count[i][j]/(float)length);
    }
  }
  fprintf(file_out, "\n");
  fclose(file_out);
}


/************************* Print_final_AA *************************/
void Print_final_AA (char *name_file, double it_sum, 
		     float TEMP, float s0, int N_pop, double f_ave, double f_dev,
		     double E_ave, double E_dev, double DG_ave, double DG_dev, float seq_entr, double seq_entr_dev, double Tload_sum, double Tload_dev, 
		     double Mload_sum, double Mload_dev, int Nload, double num_syn_subst, double num_aa_subst, 
		     short *aa_seq, int len_amm, int NEUTRAL)
{
  FILE *file_out; char name_out[200];
  /*short i, j, i_nuc, nuc_count[4][3], length;*/
//   float t_indep=num_aa_subst/10;
  float t_indep=1.0;

  sprintf(name_out, "%s_final.dat", name_file);
  if (noisy > 2)
  	fprintf (fpmpi,"Writing %s\n", name_out);
  file_out=fopen(name_out, "w");

  // Headers
  /*fprintf(file_out, "# TEMP S0 Npop GC  ");*/
  fprintf(file_out, "# TEMP S0 Npop  ");
  fprintf(file_out, " fitness (sd) E_nat (sd) DG (sd) seq_entr (sd)");
  fprintf(file_out, " Trans.load   (sd)  Mut.load  (sd)");
  fprintf(file_out, " reject samples");
  /*for(i=0; i<3; i++)
	{
    fprintf(file_out, "  ");
    for(j=0; j<3; j++)
		fprintf(file_out, "%c%d ", NUC_CODE[i], j+1);
  	}*/
  fprintf(file_out, "\n#\n");

  // Parameters
  fprintf(file_out, "%.2f %.3f ", TEMP, s0);
  if(NEUTRAL){
    fprintf(file_out, "Neutral ");
  }else{
    fprintf(file_out, "%3d ",N_pop);
  }

  /*fprintf(file_out, " %.2f", freq_nuc[Code_nuc('G')]+freq_nuc[Code_nuc('C')]);*/

  // Results
  Print_mean(file_out, f_ave, f_dev, it_sum, t_indep);
  Print_mean(file_out, E_ave, E_dev, it_sum, t_indep);
  Print_mean(file_out, DG_ave, DG_dev, it_sum, t_indep);
  fprintf(file_out, " %7.4g %7.4g ", seq_entr, seq_entr_dev);
  Print_mean(file_out, Tload_sum, Tload_dev, Nload, Nload);
  Print_mean(file_out, Mload_sum, Mload_dev, Nload, Nload);

  // Synonimous, mutation load
  /*fprintf(file_out, " %.3f %.4f ", num_syn_subst/num_aa_subst, 1.-(num_syn_subst+num_aa_subst)/it_sum);*/
  fprintf(file_out, " %.4f ", 1.-(num_syn_subst+num_aa_subst)/it_sum);
  fprintf(file_out, " %.0f  ", it_sum);

  // base content in DNA
  /*for(i=0; i<4; i++)
    for(j=0; j<3; j++)
      nuc_count[i][j]=0;
  j=0; length=len_dna/3;
  for(i=0; i<len_dna; i++)
	{
    i_nuc=Code_nuc(dna_seq[i]);
    nuc_count[i_nuc][j]++; j++;
    if(j==3)j=0;
  	}
  for(i=0; i<3; i++)
	{
    fprintf(file_out," ");
    for(j=0; j<3; j++)
		{
        fprintf(file_out," %.3f", nuc_count[i][j]/(float)length);
    	}
  	}*/

  fprintf(file_out, "\n");
  fclose(file_out);
}


/************************* Read_ene_new *************************/
int Read_ene_new(char *file_ene, float **interactions)
{
  FILE *file_in=fopen(file_ene,"r");
  int i, j, n=0; /*double norm=0;*/ float ene;
  char string[200], aa1[8], aa2[8];

  if(file_in==NULL){
    fprintf (fpmpi,"ERROR, energy parameter file %s not found\n", file_ene);
    exit(8);
  }
  while(fgets(string, sizeof(string), file_in)!=NULL){
    sscanf(string, "%s%s%f", aa1, aa2, &ene); n++;
    i=Code_AA(aa1[0]); j=Code_AA(aa2[0]);
    interactions[i][j]=ene; interactions[j][i]=ene;
  }
  return(n);
}

/************************* Read_ene_par *************************/
void Read_ene_par(char *file_ene, float **interactions)
{
  FILE *file_in=fopen(file_ene,"r");
  int i/*, j*/; /*double norm=0;*/
  char string[200];
  if(file_in==NULL){
    fprintf (fpmpi,"ERROR, energy parameter file %s not found\n", file_ene);
    exit(8);
  }
  
  for(i=0; i<20; i ++){
    float *MAT=interactions[i];
    fgets(string, sizeof(string), file_in);
    sscanf(string, 
	   "%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f", 
	   &MAT[0],&MAT[1],&MAT[2],&MAT[3],&MAT[4],
	   &MAT[5],&MAT[6],&MAT[7],&MAT[8],&MAT[9],&MAT[10],
	   &MAT[11],&MAT[12],&MAT[13],&MAT[14],&MAT[15],
	   &MAT[16],&MAT[17],&MAT[18],&MAT[19]);
  }
  /*fgets(string, sizeof(string), matrix); // Disulfide bonds
    sscanf(string, "%f", &interactions[210]);
    interactions[210]-=interactions[label[17][17]];*/
  (void)fclose(file_in);
  return;
}


/************************* Read_sequence *************************/
/*char *Read_sequence(int *len_dna, char *inputseq)
{  
  char string[1000], *ptr;
  FILE *file_in=fopen(inputseq, "r");
  char *sequence, name[N_CHAR];
  int i=0, j=0, amm, i_nuc;

  if(file_in==NULL){
    printf("WARNING, sequence file %s does not exist\n", inputseq);
    return(NULL);
  }

  printf("Reading %s\n",inputseq);
  fgets(string, sizeof(string), file_in);
  sscanf(string,"%s", seq_name); seq_name[0]=' ';
  printf("DNA sequence %s", seq_name);
  while(fgets(string, sizeof(string), file_in)!=NULL){
    ptr=string;
    while((ptr!=NULL)&&(*ptr!='\n')){
      if((*ptr=='a')||(*ptr=='A')||(*ptr=='t')||(*ptr=='T')||
	 (*ptr=='g')||(*ptr=='G')||(*ptr=='c')||(*ptr=='C')){
	(*len_dna)++;
      }else if((*ptr!=' ')&&(*ptr!='\0')){
	printf("Wrong character %d in DNA sequence %s: %c\n",
	       *len_dna, file, *ptr);
	exit(8);
      }
      ptr++;
    }
  }
  fclose(file_in);

  if(*len_dna==0)return(NULL);

  // Reading
  sequence=(char *)malloc(*len_dna *sizeof(char));
  file_in=fopen(inputseq, "r");
  fgets(string, sizeof(string), file_in);
  while(fgets(string, sizeof(string), file_in)!=NULL){
    ptr=string;
    while((ptr!=NULL)&&(*ptr!='\n')){
      if((*ptr!=' ')&&(*ptr!='\0')){
	*ptr=Maiuscule(*ptr); sequence[i]=*ptr;
	i_nuc=Code_nuc(*ptr); i++;
      }
      ptr++;
    }
  }
  fclose(file_in);
  
  
  return(sequence);
}*/


/************************* open_file *************************/
FILE *open_file(char *name_file, char *ext, short *seq, int lf, char *fit_def)
{
  FILE *file_out; char name[N_CHAR];
  int i, j; float gc=0;
  sprintf(name, "%s%s", name_file, ext); // \0
  file_out=fopen(name, "w");
  if (noisy > 2)
  	printf("Writing %s\n", name);

  fprintf(file_out, "# File %s, sequence %s,  PDB %s,  length=%d\n",
	  name_file, seq_name, target.name, len_amm);
  fprintf(file_out, "# fitness: %s\n", fit_def);
  fprintf(file_out, "# %ld iterations, random seed: %ld\n", IT_MAX, iran);
  fprintf(file_out, "# Stationary frequencies: ");
  for(i=0; i<4; i++)fprintf(file_out, "%c %.3f ", NUC_CODE[i], freq_nuc[i]);
  /*fprintf(file_out, "\n# Transition-transversion ratio= %.2f\n", tt_ratio);*/
  for(i=0; i<4; i++)if((NUC_CODE[i]=='G')||(NUC_CODE[i]=='C'))gc+=freq_nuc[i];
  fprintf(file_out, "# GC bias: %.3f\n", gc);
  fprintf(file_out, "# T= %.3f\n", TEMP);
  fprintf(file_out, "# Configurational entropy per residue: %.3f\n", s0);
  if(NEUTRAL){
    fprintf(file_out, "# Neutral\n#");
  }else{
    fprintf(file_out, "# N_pop= %d\n#", N_pop);
  }
  for(i=0; i<len_amm; i++){
    if(i==(i/60)*60)fprintf(file_out,"\n# ");
    fprintf(file_out,"%c", AMIN_CODE[seq[i]]);
  }
  fprintf(file_out,"\n");

  if(lf==1){
    fprintf(file_out,
	    "# site aa  Enat DG fitness syn_subst attempt\n"); //D(0,n)
  }else if(lf==2){
    fprintf(file_out, "# iter [GC]_3");
    for(i=0; i<3; i++){
      fprintf(file_out, " ");
      for(j=0; j<3; j++)fprintf(file_out, "%c_%d ", NUC_CODE[i], j+1);
    }
    fprintf(file_out, "\n\n");
    /*fprintf(file_out, "  Energy alpha\n");*/
  }
  
  fflush(file_out);
  return(file_out);
}


/************************* open_file_AA *************************/
FILE *open_file_AA (char *name_file, char *ext, short *seq, int lf, char *fit_def)
{
  FILE *file_out; char name[N_CHAR];
  int i, j; /*float gc=0;*/
  sprintf(name, "%s%s", name_file, ext); // \0
  file_out=fopen(name, "w");
  if (noisy > 2)
  	printf("Writing %s\n", name);
  fprintf(file_out, "# File %s, sequence %s,  PDB %s,  length=%d\n",
	  name_file, seq_name, target.name, len_amm);
  fprintf(file_out, "# fitness: %s\n", fit_def);
  fprintf(file_out, "# %ld iterations, random seed: %ld\n", IT_MAX, iran);
  fprintf(file_out, "# Stationary frequencies: ");
  for(i=0; i<20; i++)fprintf(file_out, "%c %.3f ", AMIN_CODE[i], AA_EM_Pi_PopEvol[i]);
 /* for(i=0; i<4; i++)if((NUC_CODE[i]=='G')||(NUC_CODE[i]=='C'))gc+=freq_nuc[i];
  fprintf(file_out, "# GC bias: %.3f\n", gc);*/
  fprintf(file_out, "\n# T= %.3f\n", TEMP);
  fprintf(file_out, "# Configurational entropy per residue: %.3f\n", s0);
  if(NEUTRAL){
    fprintf(file_out, "# Neutral\n#");
  }else{
    fprintf(file_out, "# N_pop= %d\n#", N_pop);
  }

  for(i=0; i<len_amm; i++){
    if(i==(i/60)*60)fprintf(file_out,"\n# ");
    fprintf(file_out,"%c", AMIN_CODE[seq[i]]);
  }
  fprintf(file_out,"\n");
  
  if(lf==1)
	{
    fprintf(file_out,
	    "# site aa  Enat DG fitness syn_subst attempt\n"); //D(0,n)
	}
  else if (lf==2)
	{
    fprintf(file_out, "# iter ");
    for(i=0; i<18; i++)
		{
        fprintf(file_out, " ");
        for(j=0; j<18; j++)
			fprintf(file_out, "%c_%d ", AMIN_CODE[i], j+1);
    	}
    fprintf(file_out, "\n\n");
    /*fprintf(file_out, "  Energy alpha\n");*/
  	}
  
  fflush(file_out);
  return(file_out);
}





/************************* Print_dna *************************/
int Print_dna(char *seq, FILE *file_out, int iter)
{
  short i, j, i_nuc, nuc_count[4][3];
  float length=(float)len_amm, gc3=0;

  for(i=0; i<4; i++)
    for(j=0; j<3; j++)
      nuc_count[i][j]=0;

  j=0;
  for(i=0; i<len_dna; i++){
    i_nuc=Code_nuc(seq[i]);
    nuc_count[i_nuc][j]++; j++;
    if(j==3)j=0;
  }

  /* GC3 */
  for(i=0; i<4; i++)
    if((NUC_CODE[i]=='G')||(NUC_CODE[i]=='C'))gc3+=nuc_count[i][2];
  fprintf(file_out,"%3d  %.3f ", iter, (gc3)/length);
  for(i=0; i<3; i++){
    fprintf(file_out," ");
    for(j=0; j<3; j++){
      fprintf(file_out," %.3f", nuc_count[i][j]/length);
    }
  }
  fprintf(file_out, "\n");
  fflush(file_out);

  return(0);
}


/************************* Get_name *************************/
int Get_name(char *name, char *name_seq, int N)
{
  int i;
  for(i=0; i<N; i++){
    if(strncmp(name_seq+i, ".dna", 4)==0){
       name[i]='\0'; 
       return(0);
    }
    name[i]=name_seq[i];
  }
  fprintf (fpmpi,"ERROR in file %s, dot not found\n", name_seq);
  exit(8);
}


/************************* Output_name *************************/
void Output_name(char *file_name, char *dir_out, char *prot_name,
		 float TEMP, float S0, int N_pop, float *freq_nuc, char *dirStability, char *file_seq, int NEUTRAL)
{
  char name[400];
  if(dir_out[0]!='\0'){sprintf(name, "%s/%s", dir_out, prot_name);}
  else{sprintf(name, "%s", prot_name);}
  if(NEUTRAL){
    sprintf(file_name, "%s%s_%s_T%.2f_S0%.2f_Neutral_GC%.2f", dirStability, file_seq,
	    name, TEMP, s0, freq_nuc[Code_nuc('G')]+freq_nuc[Code_nuc('C')]);
  }else{
    sprintf(file_name, "%s%s_%s_T%.2f_S0%.2f_N%d_GC%.2f", dirStability, file_seq,
	    name, TEMP, s0, N_pop,
	    freq_nuc[Code_nuc('G')]+freq_nuc[Code_nuc('C')]);
  }
}

/************************* Output_name_AA *************************/
void Output_name_AA (char *file_name, char *dir_out, char *prot_name,
		float TEMP, float S0, int N_pop, char *dirStability, char *file_seq, int NEUTRAL)
{
  char name[400];
  if(dir_out[0]!='\0'){sprintf(name, "%s/%s", dir_out, prot_name);}
  else{sprintf(name, "%s", prot_name);}
  if(NEUTRAL){
    sprintf(file_name, "%s%s_%s_T%.2f_S0%.2f_Neutral", dirStability, file_seq,
	    name, TEMP, s0);
  }else{
    sprintf(file_name, "%s%s_%s_T%.2f_S0%.2f_N%d", dirStability, file_seq,
	    name, TEMP, s0, N_pop);
  }
}



/************************* Sequence_entropy *************************/
float Sequence_entropy(int **aa_distr, int L)
{
  int i, j; float S_sum=0, S, p; float norm=0;

  for(j=0; j<20; j++)norm+=aa_distr[0][j];
  for(i=0; i<L; i++){
    S=0;
    for(j=0; j<20; j++){
      if(aa_distr[i][j]){
	p=aa_distr[i][j]/norm; S-=p*log(p);
      }
    }
    S_sum+=S;
  }
  return(S_sum/L);
}


/************************* Compute_freq_codons *************************/
void Compute_freq_codons(float *freq_nuc, float *freq_aa,
			 char **codon, char *coded_aa)
{
  int i, i_aa; float w;
  for(i_aa=0; i_aa<20; i_aa++)freq_aa[i_aa]=0;
  for(i=0; i<64; i++){
    w=freq_nuc[Code_nuc(codon[i][0])];
    w*=freq_nuc[Code_nuc(codon[i][1])];
    w*=freq_nuc[Code_nuc(codon[i][2])];
    i_aa=Code_AA(coded_aa[i]);
    if(i_aa<0)continue;
    freq_aa[i_aa]+=w;
  }
}



/************************* Sequence_entropy_mut *************************/
float Sequence_entropy_mut(float *freq_nuc, char **codon, char *coded_aa)
{
  float freq_aa[20]; int i; float norm=0, S=0, p;

  // Calculating amino acid distribution under mutation alone
  Compute_freq_codons(freq_nuc, freq_aa, codon, coded_aa);

  // Compute entropy
  for(i=0; i<20; i++)norm+=freq_aa[i];
  for(i=0; i<20; i++){
    if(freq_aa[i]){p=freq_aa[i]/norm; S-=p*log(p);}
  }
  return(S);
}


/************************* Sequence_entropy_mut_AA *************************/
float Sequence_entropy_mut_AA ()
{
  float freq_aa[20]; int i; float norm=0, S=0, p;

  // Calculating amino acid distribution under mutation alone
  /*Compute_freq_codons(freq_nuc, freq_aa, codon, coded_aa);*/
  for(i=0; i<20; i++)
	freq_aa[i] = AA_EM_Pi_PopEvol[i];

  // Compute entropy
  for(i=0; i<20; i++)norm+=freq_aa[i];
  for(i=0; i<20; i++){
    if(freq_aa[i]){p=freq_aa[i]/norm; S-=p*log(p);}
  }
  return(S);
}



/************************* Compute_load *************************/
void Compute_load (double *translation_load, double *mutation_load,
		  short *aa_seq, int len_amm, char *dna_seq, int len_dna,
		  float fitness_wt,  double E_nat_wt, double E1_wt,
		  double E2_wt, double E23_wt, double E3_wt,
		  float Conf_entropy, char **codon, char *coded_aa)
{
  // Mutations
  int nuc_mut=0, nuc_wt, base, pos=2, j;
  int res_mut=-1, aa_new, aa_old='X';
  char *codon_nat=dna_seq, codon_mut[3];
  // Folding thermodynamics
  float fitness, DeltaG;
  double sum_mut=0, sum_trans=0, p;
  double H_wt=E_nat_wt-Conf_entropy;
  double E_nat, E1, E2, E23=E23, E3;

  /*
    Load=Sum_j P(nat->Seq_j)[finess(nat)-fitness(Seq_j)]
    P(nat->Seq_j) is non zero only if sequence j is one base mutation from
    the native sequence.
    Translation load: P(nat->Seq_j)=1
    Mutation load: P(nat->Seq_j)=Mutation probability,
    i.e. f(new base) times 1 if transversion, times tt_ratio if transition    
   */

  *translation_load=0; *mutation_load=0;

  for(nuc_mut=0; nuc_mut<len_dna; nuc_mut++){
    
    pos++;
    if(pos==3){
      pos=0; res_mut++; codon_nat=dna_seq+res_mut*3;
      aa_old=Coded_aaf(codon_nat, codon, coded_aa);
    }
    for(j=0; j<3; j++)codon_mut[j]=codon_nat[j];
    nuc_wt=Code_nuc(dna_seq[nuc_mut]);

    for(base=0; base<4; base++){

      // Mutate amino acid
      if(base==nuc_wt)continue;
      codon_mut[pos]=NUC_CODE[base];
      aa_new=Coded_aaf(codon_mut, codon, coded_aa);
	  /*fprintf (fpmpi,"\n aa_new = %d, aa_old=%d \n", aa_new, aa_old);*/
      if(aa_new==aa_old)continue;         // Synonymous
      if(aa_new<0){fitness=0; goto load;} // Stop codon

      // Folding thermodynamics
      E_nat=H_wt; E1=E1_wt; E2=E2_wt;
      if(REM3){
	E23=E23_wt; E3=E3_wt;
	DeltaG=Mutate_DG_REM3(aa_seq, len_amm, res_mut, aa_new,
				  &E_nat, &E1, &E2, &E23, &E3);
      }else{
	DeltaG=
	  Mutate_DG_REM2(aa_seq, len_amm, res_mut, aa_new, &E_nat, &E1, &E2);
      }
      fitness=1./(1+exp(DeltaG));
      
    load:
      // Translation load
      sum_trans++;
      *translation_load+=fitness;

      // Mutation load
      p=freq_nuc[base];
	  if (doGTR == NO && doGTnR == NO)
		{
      	if(base==Transition(NUC_CODE[nuc_wt]))
			p*=tt_ratio;
		}
	 
	if (doGTR == YES) /* A = 0; T = 1; G = 2; C = 3 */
		{
 		if (base == 0) /* A: AC (0) AG (1) AT (2) */
			{
			if (nuc_wt == 1) /* AT(2) */			
				p*=Rmat[2];
			if (nuc_wt == 2) /* AG(1) */			
				p*=Rmat[1];
			if (nuc_wt == 3) /* AC(0) */			
				p*=Rmat[0];
			}
		if (base == 1) /* T: AT (2) CT (4) GT (5) */
			{
			if (nuc_wt == 0) /* TA(2) */			
				p*=Rmat[2];
			if (nuc_wt == 2) /* TG(5) */			
				p*=Rmat[5];
			if (nuc_wt == 3) /* TC(4) */			
				p*=Rmat[4];
			}
		if (base == 2) /* G: AG (1) CG (3) GT (5) */
			{
			if (nuc_wt == 0) /* GA(1) */			
				p*=Rmat[1];
			if (nuc_wt == 1) /* GT(5) */			
				p*=Rmat[5];
			if (nuc_wt == 3) /* GC(3) */			
				p*=Rmat[3];
			}
		if (base == 3) /* C: AC (0) CG (3) CT (4) */
			{
			if (nuc_wt == 0) /* CA(0) */			
				p*=Rmat[0];
			if (nuc_wt == 1) /* CT(4) */			
				p*=Rmat[4];
			if (nuc_wt == 2) /* CG(3) */			
				p*=Rmat[3];
			}
		}

	if (doGTnR == YES) /* A = 0; T = 1; G = 2; C = 3 */
		{
    	if (base == 0) /* A: AC (0) AG (2) AT (4) */
			{
			if (nuc_wt == 1) /* AT(4) */			
				p*=NRmat[4];
			if (nuc_wt == 2) /* AG(2) */			
				p*=NRmat[2];
			if (nuc_wt == 3) /* AC(0) */			
				p*=NRmat[0];
			}
		if (base == 1) /* T: TA (5) TC (9) TG (11) */
			{
			if (nuc_wt == 0) /* TA(5) */			
				p*=NRmat[5];
			if (nuc_wt == 2) /* TG(11) */			
				p*=NRmat[11];
			if (nuc_wt == 3) /* TC(9) */			
				p*=NRmat[9];
			}
		if (base == 2) /* G: GA (3) GC (7) GT (10) */
			{
			if (nuc_wt == 0) /* GA(3) */			
				p*=NRmat[3];
			if (nuc_wt == 1) /* GT(10) */			
				p*=NRmat[10];
			if (nuc_wt == 3) /* GC(7) */			
				p*=NRmat[7];
			}
		if (base == 3) /* C: CA (1) CG (6) CT (8) */
			{
			if (nuc_wt == 0) /* CA(1) */			
				p*=NRmat[1];
			if (nuc_wt == 1) /* CT(8) */			
				p*=NRmat[8];
			if (nuc_wt == 2) /* CG(6) */			
				p*=NRmat[6];
			}
		}

      sum_mut+=p;
      *mutation_load+=fitness*p;
    }
  }

  *translation_load = fitness_wt-(*translation_load)/sum_trans;
  *mutation_load = fitness_wt-(*mutation_load)/sum_mut;

}






/************************* Compute_load_AA *************************/
void Compute_load_AA (double *translation_load, double *mutation_load,
		  short *aa_seq, int len_amm, float fitness_wt,  double E_nat_wt, double E1_wt,
		  double E2_wt, double E23_wt, double E3_wt, float Conf_entropy)
{
  // Mutations
  int aa_mut=0, /*nuc_wt,*/ aminoa, pos=2/*, j*/;
  int res_mut=-1, aa_new, aa_old='X';
  /*char *codon_nat=dna_seq, codon_mut[3];*/
  // Folding thermodynamics
  float fitness, DeltaG;
  double sum_mut=0, sum_trans=0, p;
  double H_wt=E_nat_wt-Conf_entropy;
  double E_nat, E1, E2, E23=E23, E3;

  /*
    Load=Sum_j P(nat->Seq_j)[finess(nat)-fitness(Seq_j)]
    P(nat->Seq_j) is non zero only if sequence j is one base mutation from
    the native sequence.
    Translation load: P(nat->Seq_j)=1
    Mutation load: P(nat->Seq_j)=Mutation probability,
    i.e. f(new base) times 1 if transversion, times tt_ratio if transition    
   */

  *translation_load=0; *mutation_load=0;

  for(aa_mut=0; aa_mut<len_amm; aa_mut++)
	{
    
    pos++;
	res_mut++;
	aa_old=aa_seq[aa_mut];

    /*if(pos==3)
		{
      	pos=0; res_mut++; codon_nat=dna_seq+res_mut*3;
      	aa_old=Coded_aaf(codon_nat, codon, coded_aa);
    	}
    for(j=0; j<3; j++)
		codon_mut[j]=codon_nat[j];
    nuc_wt=Code_nuc(dna_seq[nuc_mut]);*/

    for(aminoa=0; aminoa<20; aminoa++)
	  {

      // Mutate amino acid
      if(aminoa==aa_mut)continue;
      /*codon_mut[pos]=NUC_CODE[base];
      aa_new=Coded_aaf(codon_mut, codon, coded_aa);*/
	  aa_new=aminoa;
	  /*fprintf (fpmpi,"\n aa_new = %d, aa_old=%d \n", aa_new, aa_old);*/
      if(aa_new==aa_old)continue;         // Synonymous
      if(aa_new<0){fitness=0; goto load;} // Stop codon.. but never should be here now..

      // Folding thermodynamics
      E_nat=H_wt; E1=E1_wt; E2=E2_wt;
      if(REM3){
	E23=E23_wt; E3=E3_wt;
	DeltaG=Mutate_DG_REM3(aa_seq, len_amm, res_mut, aa_new,
				  &E_nat, &E1, &E2, &E23, &E3);
      }else{
	DeltaG=
	  Mutate_DG_REM2(aa_seq, len_amm, res_mut, aa_new, &E_nat, &E1, &E2);
      }
      fitness=1./(1+exp(DeltaG));
      
    load:
      // Translation load
      sum_trans++;
      *translation_load+=fitness;

      // Mutation load
      p=AA_EM_Pi_PopEvol[aminoa];
		/*fprintf (fpmpi,"\n->p(%d) = %lf", aminoa, p);*/
	  p*= Qij_AA_PopEvol[aminoa][aa_old];

      sum_mut+=p;
      *mutation_load+=fitness*p;
    }
  }

  *translation_load = fitness_wt-(*translation_load)/sum_trans;
  *mutation_load = fitness_wt-(*mutation_load)/sum_mut;

}








/************************* Selection *************************/
int Selection(float fitness, float fitness_old, int N_pop)
{
  // Moran's process:
  /* P_fix = (1-exp(-Df))/(1-exp(-N*Df)) */
  double f_ratio, x;
  if((int)N_pop==1)return(1);
  if(fitness<=0)return(0);
  f_ratio= fitness_old / fitness;
  x= (1.-f_ratio)/(1.-pow(f_ratio, N_pop));
  if(RandomFloating() < x)return(1); return(0);
}


/************************* Read_mut_mat *************************/
/*void Read_mut_mat(char *file_mut_mat, float **nuc_mut_mat)
{
  FILE *file_in=Open_file_r(file_mut_mat, CODE_NAME, "mutation matrix");
  int line, i_nuc[4], i, j; float f[4], sum=0, rate;
  char string[200], nuc[4][3];

  printf("Reading mutation matrix in %s\n", file_mut_mat);
  fgets(string, sizeof(string), file_in);
  sscanf(string, "%s%s%s%s", nuc[0], nuc[1], nuc[3], nuc[4]);
  for(i=0; i<4; i++){
    i_nuc[i]=Code_nuc(nuc[i][0]); printf("%s ", nuc[i]);
  }
  printf("\n");
  for(line=0; line<4; line++){
    fgets(string, sizeof(string), file_in);
    sscanf(string, "%s %f%f%f%f", nuc[0], &f[0], &f[1], &f[2], &f[3]);
    j=Code_nuc(nuc[0][0]);
    if(j!=i_nuc[line]){
      printf("Error, different order in lines and columns\n"); exit(8);
    }
    printf("%s ", nuc[0]);
    for(i=0; i<4; i++){
      nuc_mut_mat[j][i_nuc[i]]=f[i]; printf("%.3f", f[i]);
    }
    printf("\n");
  }
  fgets(string, sizeof(string), file_in);
  sscanf(string, "%f", &rate);
  fclose(file_in);

  for(i=0; i<4; i++){
    sum=0;
    for(j=0; j<4; j++)if(j!=i)sum+=nuc_mut_mat[i][j];
    if(nuc_mut_mat[i][i]!=0)
      printf("Warning, wrong matrix format, M[%d][%d] expected zero\n",
	     i, i);
    for(j=0; j<4; j++)if(i!=j)nuc_mut_mat[i][j]*=rate;
    nuc_mut_mat[i][i]=1.-rate*sum;
    if(nuc_mut_mat[i][i]<0){
      printf("Error in %s, rate too large\n", CODE_NAME); exit(8);
    }
  }
} */   


/************************* Coded_aaf *************************/
int Coded_aaf(char *i_codon, char **codon, char *coded_aa)
{
  int i;
  for(i=0; i<64; i++){
    char *cod=codon[i];
    if((i_codon[0]==cod[0])&&
       (i_codon[1]==cod[1])&&
       (i_codon[2]==cod[2]))return(Code_AA(coded_aa[i]));
  }
  fprintf (fpmpi,"ERROR, codon %c%c%c does not exist\n",
	 i_codon[0], i_codon[1], i_codon[2]);
  exit(8);
}


/************************* Codon_num *************************/
int Codon_num(char *cod, char **codon)
{
  int i_codon;
  for(i_codon=0; i_codon<64; i_codon++)
    if(strncmp(cod, codon[i_codon], 3)==0)return(i_codon);
  fprintf (fpmpi,"Warning, codon %c%c%c not found\n", cod[0], cod[1], cod[2]);
  return(-1);
}


/************************* Empty_matrix *************************/
void Empty_matrix_f(float **matrix, int N){
  int i;
  if(matrix==NULL)return;
  for(i=0; i<N; i++)free(matrix[i]);
  free(matrix);
}

void Empty_matrix_d(double **matrix, int N){
  int i;
  if(matrix==NULL)return;
  for(i=0; i<N; i++)free(matrix[i]);
  free(matrix);
}


void Empty_matrix_i(int **matrix, int N){
  int i;
  if(matrix==NULL)return;
  for(i=0; i<N; i++)free(matrix[i]);
  free(matrix);
}

/************************* Allocate_mat2 *************************/
float **Allocate_mat2_f(int n1, int n2){
  int i, j;
  float **matrix=malloc(n1*sizeof(float *));
  for(i=0; i<n1; i++){
    matrix[i]=malloc(n2*sizeof(float));
    for(j=0; j<n2; j++)matrix[i][j]=0;
  }
  return(matrix);
}


int ** Allocate_mat2_i(int n1, int n2){
  int i, j;
  int **matrix=malloc(n1*sizeof(int *));
  for(i=0; i<n1; i++){
    matrix[i]=malloc(n2*sizeof(int));
    for(j=0; j<n2; j++)matrix[i][j]=0;
  }
  return(matrix);
}

double **Allocate_mat2_d(int n1, int n2){
  int i, j;
  double **matrix=malloc(n1*sizeof(double *));
  for(i=0; i<n1; i++){
    matrix[i]=malloc(n2*sizeof(double));
    for(j=0; j<n2; j++)matrix[i][j]=(double)0;
  }
  return(matrix);
}



/********************************** Read_coord ***********************************/
int Read_coord(char *pdb_name, int *nmr, struct residue *seq, atom *atoms,
	       char *chain_to_read, int *ANISOU)
{
  int N_res=0, n_exo=0, Compression=0, read_atom=0, start=0;
  FILE *file_in;
  char string[200], command[200]/*, pdbid[12]*/;
  atom *atom_ptr=atoms, *first_atom=atoms;

  short i_atom=0, alternative=0;
  int hetatm=0, hetatm_old=0/*, label=0*/;
  int i, j, res_num, res_num_old=10000;
  char altloc, altloc_sel=' '/*, altalt='\0'*/;
  char chain_old='#', chain=' ';
  char res_type[5], res_type_old[5], icode=' ', icode_old='#';
  float x, y, z;
  char file_name[500];
  int nchains=1, ic, ichain=0, ini_chain=0;
  n_atom=0;

  /* Open file */
  if(Verbose)fprintf (fpmpi,"Reading %s ", pdb_name);
  Compression=Get_compression(pdb_name); 
  if(Compression){
    sprintf(command, "%s %s > %s\n", PDBCAT, pdb_name, PDBTMP);
    system(command); strcpy(file_name, PDBTMP);
  }else{
    sprintf(file_name, "%s", pdb_name); // \0
  }
  file_in=fopen(file_name, "r");
  if(file_in==NULL){
    fprintf (fpmpi,"\nWARNING, file %s not found\n", file_name); return(0);
  }
  //printf("Reading %s\n", file_name);

  // Count chains to read
  for(i=0; i<sizeof(chain_to_read); i++){
    nchains=i;
    if((chain_to_read[i]=='\0')||(chain_to_read[i]==' '))break;
    /*printf("%c", chain_to_read[i]);*/    
  }
  if(nchains==0)nchains=1;
  /*printf(" %d chains to read\n", nchains);*/

  *nmr=0;
  strcpy(res_type_old,"xxx");
  while(fgets(string, sizeof(string), file_in)!=NULL){

    if(strncmp(string,"ATOM", 4)==0){
      /* Standard residue or DNA basis */
      hetatm=0; if(ini_chain==0)ini_chain=1;
    }else if(strncmp(string,"HETATM", 6)==0){
      if(ini_chain==0)continue;
      hetatm=1;
      /* Cofactor or exotic residue */

    }else if(strncmp(string,"EXPDTA", 6)==0){
      if(strncmp(string+10, "NMR", 3)==0)*nmr=1; continue;
      /* NMR structure */

    }else if((strncmp(string,"TER",3)==0)&&(N_res>0)){
      Next_residue(&N_res, &start, seq, first_atom, &i_atom,
		   res_type_old, &res_num_old, &icode_old,
		   &chain_old, &hetatm_old, n_exo,
		   res_type, res_num, icode, chain, hetatm);
      ini_chain=0;
      continue;

    }else if(strncmp(string,"MODRES", 6)==0){
      res_exo[n_exo][0]=string[12]; res_std[n_exo][0]=string[24];
      res_exo[n_exo][1]=string[13]; res_std[n_exo][1]=string[25];
      res_exo[n_exo][2]=string[14]; res_std[n_exo][2]=string[26];
      for(j=0; j<n_exo; j++){
	if(strncmp(res_exo[j],res_exo[n_exo],3)==0)break;
      }
      if(j==n_exo)n_exo++; continue;
 
    }else if(strncmp(string,"ENDMDL", 6)==0){
      break;                                    /* end model */
    }else if((strncmp(string,"ANISOU", 6)==0)&&(read_atom)){
      // Anisotropic structure factor
      int i, j; /*float B=0;*/
      if(*ANISOU==0)*ANISOU=1;
      sscanf(string+28, "%f %f %f %f %f %f",
	     &(atom_ptr->anisou[0][0]), &(atom_ptr->anisou[1][1]),
	     &(atom_ptr->anisou[2][2]), &(atom_ptr->anisou[0][1]),
	     &(atom_ptr->anisou[0][2]), &(atom_ptr->anisou[1][2]));
      for(i=0; i<3; i++){
	for(j=i; j<3; j++){
	  atom_ptr->anisou[i][j]*=0.0001;
	  if(j!=i)atom_ptr->anisou[j][i]=atom_ptr->anisou[i][j];
	}
      }
      // Check
      //for(i=0; i<3; i++)B+=aniso[i][i]; B*=26.319; // 8pi^2/2
      //printf("B= %.2f %.2f %d\n", atom_ptr->B_factor, B, n_atom);
      continue;

      /*}else if(strncmp(string,"HELIX ", 6)==0){
	Read_sec_str(string, chain, 'H'); continue;
	}else if(strncmp(string,"SHEET ", 6)==0){
	Read_sec_str(string, chain, 'E'); continue;
	}else if(strncmp(string,"TURN ", 5)==0){
	Read_sec_str(string, chain, 'T'); continue;*/
    }else{
      continue;
    }

    read_atom=0;
    chain=string[21];
    if(*chain_to_read!='*'){
      if((*chain_to_read==' ')||(*chain_to_read=='\0'))*chain_to_read=chain;
      for(ic=0; ic<nchains; ic++)if(chain==chain_to_read[ic])goto read;
      continue;
    }

  read:
    /* Read atom name */
    if((string[13]=='H')||(string[12]=='H') ||
       (string[13]=='D') ||(string[12]=='D'))continue;

    /* Read residue; check if water molecule */
    res_type[0]=string[17]; res_type[1]=string[18]; res_type[2]=string[19];
    res_type[3]='\0';
    if((hetatm==1)&&((strncmp(res_type,"HOH",3)==0)||
		     (strncmp(res_type,"DOD",3)==0)))continue;
    
    icode=string[26]; string[26]=' ';


    /* Read coordinates */
    sscanf(string+22,"%d %f %f %f", &res_num, &x, &y, &z);
    
    /* Check if alternative conformation */
    if((string[72]=='A')&&(string[73]=='L')&&(string[74]=='T')&&
       (string[75]!='1')&&(string[75]!=' '))continue;

    altloc=string[16];
    if(altloc!=' '){
      if(altloc_sel==' ')altloc_sel=altloc; if(altloc!=altloc_sel)continue;
    }

    if((icode!=icode_old)&&(res_num==res_num_old)){
      if(alternative==1){
	continue;
      }else{
	atom *atom_old=first_atom;
	float dx, dy, dz;
	dx=x-atom_old->r[0]; dy=y-atom_old->r[1]; dz=z-atom_old->r[2];
	if((dx*dx+dy*dy+dz*dz)<.5){
	  alternative=1; continue;  
	}
      }         
    }

    /* New residue */
    if((res_num!=res_num_old)||(icode!=icode_old)||
       (strncmp(res_type, res_type_old, 3)!=0)){
      Next_residue(&N_res, &start, seq, first_atom, &i_atom,
		   res_type_old, &res_num_old, &icode_old,
		   &chain_old, &hetatm_old, n_exo,
		   res_type, res_num, icode, chain, hetatm);
    }
    read_atom=1;
    atom_ptr=atoms+n_atom;
    
    if(i_atom==0)first_atom=atom_ptr;
    i_atom++; n_atom++;
    atom_ptr->r[0] = x;
    atom_ptr->r[1] = y;
    atom_ptr->r[2] = z;
    if(string[12]!=' '){ // Hydrogen atoms
      for(ic=0; ic<4; ic++)atom_ptr->name[ic]=string[12+ic];
    }else{
      for(ic=0; ic<3; ic++)atom_ptr->name[ic]=string[13+ic];
      atom_ptr->name[3]=' ';
    }
    sscanf(string+56, "%f", &atom_ptr->occupancy);
    sscanf(string+60, "%f", &atom_ptr->B_factor);
    atom_ptr->chain=ichain;
  }
  Next_residue(&N_res, &start, seq, first_atom, &i_atom,
	       res_type_old, &res_num_old, &icode_old,
	       &chain_old, &hetatm_old, n_exo,
	       res_type, res_num, icode, chain, hetatm);
  if(N_res >= L_MAX){
    fprintf (fpmpi,"\n ERROR, more than %d residues found\n", L_MAX); exit(8);
  }
  fclose(file_in);
  if(Verbose)fprintf (fpmpi,"%3d residues\n", N_res);
  if(Compression){
    sprintf(command, "rm -f %s\n", PDBTMP); system(command);
  }
  return(N_res);
}



/********************************** Write_residue ***********************************/
static short Write_residue(char *res_type_old, atom *first_atom, short i_atom,
			   struct residue *ptr_tmp, int n_exo, int res_num,
			   char icode, char chain, int hetatm)
{
  short i, het=1, exo;
  char amm, pdbres[6];

  /* Check amino acid type */
  amm=Code_3_1(res_type_old);
  if(amm != 'X'){
    // Standard residue
    if(hetatm){het=1; goto discard;} // Standard res. and HETATM => cofactor
    het=0; exo=0;
  }else{
    // Non-standard residue
    exo=1;
    for(i=n_exo-1; i>=0; i--){
      if(strncmp(res_type_old,res_exo[i],3)==0){
	amm=Code_3_1(res_std[i]); het=0; break;
      }
    }
  }

  /* Check backbone */
  if(het && (i_atom >=3)){
    // If backbone atoms exist: Modified residue
    int i_N=0, i_CA=0, i_C=0, i;
    atom *atom_ptr=first_atom;
    for(i=0; i<i_atom; i++){
      if(strncmp(atom_ptr->name, "N ", 2)==0){
	i_N=1;
      }else if(strncmp(atom_ptr->name, "CA", 2)==0){
	i_CA=1;
      }else if(strncmp(atom_ptr->name, "C ", 2)==0){
	i_C=1;
      }
      if(i_C && i_CA && i_C){het=0; break;}
      atom_ptr++;
    }
  }

  if(het==0){
    ptr_tmp->atom_ptr=first_atom;
    ptr_tmp->n_atom=i_atom;
    ptr_tmp->amm=amm; ptr_tmp->exo=exo;
    ptr_tmp->i_aa=Code_AA2(amm);
    if(ptr_tmp->i_aa<0){
      fprintf (fpmpi,"Unknown residue %s %d%c\n", res_type_old, res_num, icode);
      ptr_tmp->i_aa=0;
    }
    ptr_tmp->chain=chain;
    sprintf(pdbres, "%4d%c", res_num, icode); // \0
    strcpy(ptr_tmp->pdbres, pdbres);
    return(het);
  }

  //printf("%s %d%c  %d %d\n", res_type_old, res_num, icode, hetatm, het);

 discard:

  if(het)
    fprintf (fpmpi,"Group %s %d%c  %c (%d atoms) not a residue\n",
	   res_type_old, res_num, icode, amm, i_atom);

  return(het);
}


/********************************** Next_residue ***********************************/
int Next_residue(int *N_res, int *start, struct residue *seq,
		 atom *first_atom, short *i_atom,
		 char *res_type_old, int *res_num_old, char *icode_old,
		 char *chain_old, int *hetatm_old, int n_exo,
		 char *res_type, int res_num, char icode, char chain,
		 int hetatm)
{
  if((*start)==0){
    *start=1;
  }else if(*i_atom){
    int het=Write_residue(res_type_old, first_atom, *i_atom, seq+*N_res, n_exo, *res_num_old, *icode_old, *chain_old, *hetatm_old);
    if(het==0){(*N_res)++;}else{n_atom-=(*i_atom);} (*i_atom)=0;
  }
  strcpy(res_type_old,res_type); *icode_old=icode;
  *res_num_old=res_num; *chain_old=chain; *hetatm_old=hetatm;
  
  return(0);
}


/********************************** Code_3_1 ***********************************/
char Code_3_1(char *res)
{
  char code;

  if(strncmp(res,"ALA",3)==0){ code='A';
  }else if(strncmp(res,"GLU",3)==0){ code='E';
  }else if(strncmp(res,"GLN",3)==0){ code='Q';
  }else if(strncmp(res,"ASP",3)==0){ code='D';
  }else if(strncmp(res,"ASN",3)==0){ code='N';
  }else if(strncmp(res,"LEU",3)==0){ code='L';
  }else if(strncmp(res,"GLY",3)==0){ code='G';
  }else if(strncmp(res,"LYS",3)==0){ code='K';
  }else if(strncmp(res,"SER",3)==0){ code='S';
  }else if(strncmp(res,"VAL",3)==0){ code='V';
  }else if(strncmp(res,"ARG",3)==0){ code='R';
  }else if(strncmp(res,"THR",3)==0){ code='T';
  }else if(strncmp(res,"PRO",3)==0){ code='P';
  }else if(strncmp(res,"ILE",3)==0){ code='I';
  }else if(strncmp(res,"MET",3)==0){ code='M';
  }else if(strncmp(res,"PHE",3)==0){ code='F';
  }else if(strncmp(res,"TYR",3)==0){ code='Y';
  }else if(strncmp(res,"CYS",3)==0){ code='C';
  }else if(strncmp(res,"TRP",3)==0){ code='W';
  }else if(strncmp(res,"HIS",3)==0){ code='H';
  }else if(strncmp(res,"ASX",3)==0){ code='N';
  }else if(strncmp(res,"GLX",3)==0){ code='Q';
  }else{ return('X');
  }
  return(code);
}




/********************************** Get_compression ***********************************/
int Get_compression (char *pdb_name)
{
  char *tmp=pdb_name;
  while(*tmp!='\0'){
    if((*tmp=='.')&&(*(tmp+1)=='g')&&(*(tmp+2)=='z'))return(1);
    tmp++;
  }
  return(0);
}






/********************************** SimulateDataForSite_Nucleotide_RECURSIVE_NET_Pop_Evol ***********************************/
/* Simulates the nucleotide substitution process for a given nucleotide */
void SimulateDataForSite_Nucleotide_RECURSIVE_NET_Pop_Evol (TreeNode *p, int siteNucleotide, int numSites, double m, double kappa, long int *seed, int dataSetNum, char *dirStability)
	{
	int			i, k, step, control, NOcontinueNode, doCombineMaterial, pLeft, qLeft;
	/*double		ran, cumProb[4], Pij[4][4];
	double 		a, b, varRate;*/ /* varRate does not make sense here, is not used */
	double 		branchLength;
	char		*current_seq, *output_seq;
	int 		Labelbranch, AlmostRootNode;
	TreeNode *q;
	
	TreeSegment *s;
//	TreeNode *q, *r;

	q = NULL;
/*	a = 0;
	b = 0;*/
	step = 0;
	k = 0;
	control = 0;
   /* varRate = 1;*/
	NOcontinueNode = 0;
	doCombineMaterial = NO;

	branchLength = 0;
	current_seq = NULL;
	output_seq = NULL;
	Labelbranch = -1;
	AlmostRootNode = 0;

	if (numRE == 0) /*** NO REC ***/
		{

		if (p != NULL)
			{

			/*fprintf (fpmpi, "\n\n--Pasa por p->label = %d--\n", p->label);*/
			if (p->anc1 != NULL) // todos aquellos nodos que no son el GMRCA
				{
				/*fprintf (fpmpi, "\n COAL p->anc1 != NULL.. p->label = %d\n", p->label);*/
				if (p->anc1->anc1 == NULL)
					{
					/*fprintf (fpmpi, "\n-> NODE p->label = %d is AlmostRootNode\n", p->label);*/
					AlmostRootNode = 1;
					}
				else
					{
					AlmostRootNode = 0;
					}
		
				if (p->isOutgroup == YES) // llegada al nodo outgroup
					{
					branchLength = p->length * m;
					AlmostRootNode = 1;
					/*SubstitutionMatrix (Pij, p->length * m, kappa, varRate, p_i);*/ /* This computes Pij given branch length.. */
					}
				else //llegada a cualquier nodo que no es outgroup
					{
					branchLength = (p->anc1->time - p->time) * m;
					/*SubstitutionMatrix (Pij, (p->anc1->time - p->time) * m, kappa, varRate, p_i);*/
					}
			

 				/*printf("\nInput seq1\n");*/
				output_seq = (char *) calloc((numNuc+1), sizeof(char)); 
				if (!output_seq)
					{
					fprintf (stderr, "Could not allocate output_seq (%lu bytes)\n", (numNuc+1)  * (long) sizeof(char));
					exit (-1);
					}
				current_seq = (char *) calloc((numNuc+1), sizeof(char)); 
				if (!current_seq)
					{
					fprintf (stderr, "Could not allocate current_seq (%lu bytes)\n", (numNuc+1)  * (long) sizeof(char));
					exit (-1);
					}
				for (i=1; i<=numSites; i++) /* initializations */
					output_seq[i-1] = WhichNuc(5);
				for (i=1; i<=numSites; i++)
					current_seq[i-1] = WhichNuc(5);


				/* input sequence */
				for (i=1; i<=numSites; i++)
					current_seq[i-1] = WhichNuc(matrix[pos(p->anc1->label,i,numSites)]);
				/*printf("current_seq: /%s/\n", current_seq);
				printf("current_seq[0]: /%c/\n", current_seq[0]);
				printf("current_seq[1]: /%c/\n", current_seq[1]);*/


				/* Introduce mutacions or substitutions, here with Pop_Evol */
				Labelbranch = p->label;
   				/*printf("\nBranch length: %lf Labelbranch: %d \n", branchLength, Labelbranch);*/

				output_seq = Pop_evolDNA (branchLength, current_seq, numSites, dataSetNum, Labelbranch, dirStability, AlmostRootNode, seed); /* input: branchLength, input DNAseq, numSites and Replicate/branch; Output: DNAseq (and AAseq?) */

				/*printf("output_seq: /%s/\n", output_seq);
				printf("output_seq[0]: /%c/\n", output_seq[0]);
				printf("output_seq[1]: /%c/\n", output_seq[1]);
				printf("output_seq[764]: /%c/\n", output_seq[764]);*/

				for(i=0; i<numSites; i++) /* apply the output sequence */
					matrix[pos(p->label,i+1,numSites)] = WhichNucNumber(output_seq[i]);

				/*printf("WhichNucNumber(output_seq[0]): /%d/\n", WhichNucNumber(output_seq[0]));
				printf("WhichNucNumber(output_seq[1]): /%d/\n", WhichNucNumber(output_seq[1]));
				printf("WhichNucNumber(output_seq[764]): /%d/\n", WhichNucNumber(output_seq[764]));	*/		

				/*cumProb[0] = Pij[matrix[pos(p->anc1->label,siteNucleotide,numSites)]][0];
				for (i=1; i<4; i++)
					cumProb[i] = cumProb[i-1] + Pij[matrix[pos(p->anc1->label,siteNucleotide,numSites)]][i];
				ran = RandomUniform(seed);

				if (ran >= 0.0 && ran <= cumProb[0])
					matrix[pos(p->label,siteNucleotide,numSites)] = 0; 
				else if (ran > cumProb[0] && ran <= cumProb[1])
					matrix[pos(p->label,siteNucleotide,numSites)] = 1; 
				else if (ran > cumProb[1] && ran <= cumProb[2])
					matrix[pos(p->label,siteNucleotide,numSites)] = 2; 
				else
					matrix[pos(p->label,siteNucleotide,numSites)] = 3;*/
			
				for(i=1; i<=numSites; i++)
					{
					if (matrix[pos(p->label,i,numSites)] != matrix[pos(p->anc1->label,i,numSites)])
						{
						numMU++;	
						/*fprintf(stderr,"\n < MUT (no rec), numMU = %d \n", numMU);*/
						}
					}
			
				/*exit (7);*/	
				/*fprintf (stderr, " matrix[pos(p->label,siteNucleotide,numSites)] = %d, matrix[pos(p->anc1->label,siteNucleotide,numSites)] = %d, numMU = %d \n", matrix[pos(p->label,siteNucleotide,numSites)], matrix[pos(p->anc1->label,siteNucleotide,numSites)], numMU);
				fprintf (stderr, " (p->anc1->time - p->time) = %lf \n", (p->anc1->time - p->time));*/
				/* fin Mutacion */

				free(current_seq); /**/
				free(output_seq);
				}
			

			/* It crosses the tree */
			SimulateDataForSite_Nucleotide_RECURSIVE_NET_Pop_Evol (p->left, siteNucleotide, numSites, m, kappa, seed, dataSetNum, dirStability);
			SimulateDataForSite_Nucleotide_RECURSIVE_NET_Pop_Evol (p->right, siteNucleotide, numSites, m, kappa, seed, dataSetNum, dirStability);	
			if (thereisOutgroup == YES)
				SimulateDataForSite_Nucleotide_RECURSIVE_NET_Pop_Evol (p->outgroup, siteNucleotide, numSites, m, kappa, seed, dataSetNum, dirStability);	
			}
		}
	else  /*** there are recombination events ***/
		{
		NOcontinueNode = 0;

		if (p != NULL)
			{
			/*fprintf (fpmpi, "\n\n--->>>>Pasa por p->label = %d, p->index = %d--\n", p->label, p->index);*/
			/*fprintf (fpmpi, "\n siteNucleotide = %d \n", siteNucleotide);*/ /* = 1 */

			k = 0;
			if (p->anc1 != NULL && p->isOutgroup == YES) /* pasa el outgroup si lo hay */
				k++;
			for (step = 0; step < p->numSegNode; step++)	/* pasan aquellos nodos que contienen toda la secuencia */			
				{
				s = segments + post(step,p->index,distance);
				
				for (i = 1; i <= numSites; i++)	
					{			
					if (s->sStart <= i && s->sEnd >= i) 
						{
						k++;
						break;
						}
					}
				}


			if (p->breakp != NO) /* Special recombinant node */
				{
						
				q = p->sib;

				if (p->passNumber == 0)
					NOcontinueNode = 1;
				if (p->passNumber > 0) /* esta llegando por segunda vez */
					{
					NOcontinueNode = 0;
					doCombineMaterial = YES;
					/*fprintf (fpmpi, " p->passNumber = %d", p->passNumber);*/
					}
					
				/*p->passNumber++;*/ /* MA add: hoy borre esto. july 2009 */
				q->passNumber++;
						
				/*fprintf (fpmpi, "\n** The nodo p->label = %d (p->index = %d) is recombinant with breakpoint in %d \n", p->label, p->index, p->breakp);
				fprintf (fpmpi, " its Sib is, p->passNumber = %d, q->label = %d (q->index = %d) **\n", p->passNumber, q->label, q->index);*/
				}




			if (p->anc1 != NULL && k > 0) // todos aquellos nodos que no son el GMRCA
				{
				/*fprintf (fpmpi, "\n-->>Entra en BETWEEN p->anc1 != NULL.. p->label = %d, p->index = %d\n", p->label, p->index);*/	


				if (matrix[pos(p->anc1->label,siteNucleotide,numSites)] > -1) /* va por anc1 */
					{
					if (p->anc1->anc1 == NULL)
						{
						/*fprintf (fpmpi, "\n-> NODE p->label = %d is AlmostRootNode\n", p->label);*/
						AlmostRootNode = 1;
						}
					else
						{
						AlmostRootNode = 0;
						}
					}
				else /* va por anc2 */
					{
					if (p->anc2->anc1 == NULL)
						{
						/*fprintf (fpmpi, "\n-> NODE p->label = %d is AlmostRootNode\n", p->label);*/
						AlmostRootNode = 1;
						}
					else
						{
						AlmostRootNode = 0;
						}
					}


				if (p->isOutgroup == YES) // llegada al nodo outgroup
					{
					branchLength = p->length * m;
					AlmostRootNode = 1;
					/*SubstitutionMatrix (Pij, p->length * m, kappa, varRate, p_i);*/ /* This computes Pij given branch length.. */
					}
				else //llegada a cualquier nodo que no es outgroup
					{
					if (matrix[pos(p->anc1->label,siteNucleotide,numSites)] > -1) /* va por anc1 */
						branchLength = (p->anc1->time - p->time) * m;
					else /* va por anc2 */
						branchLength = (p->anc2->time - p->time) * m;

					/*SubstitutionMatrix (Pij, (p->anc1->time - p->time) * m, kappa, varRate, p_i);*/
					}


				/*printf("\nInput seq1\n");*/
				output_seq = (char *) calloc((numNuc+1), sizeof(char)); 
				if (!output_seq)
					{
					fprintf (stderr, "Could not allocate output_seq (%lu bytes)\n", (numNuc+1)  * (long) sizeof(char));
					exit (-1);
					}
				current_seq = (char *) calloc((numNuc+1), sizeof(char)); 
				if (!current_seq)
					{
					fprintf (stderr, "Could not allocate current_seq (%lu bytes)\n", (numNuc+1)  * (long) sizeof(char));
					exit (-1);
					}
				for (i=1; i<=numSites; i++) /* initializations */
					output_seq[i-1] = WhichNuc(5);
				for (i=1; i<=numSites; i++)
					current_seq[i-1] = WhichNuc(5);


				/* input sequence */
				if (matrix[pos(p->anc1->label,siteNucleotide,numSites)] > -1) /* va por anc1 */
					{
					for (i=1; i<=numSites; i++)
						current_seq[i-1] = WhichNuc(matrix[pos(p->anc1->label,i,numSites)]);
					}
				else /* va por anc2 */
					{
					for (i=1; i<=numSites; i++)
						current_seq[i-1] = WhichNuc(matrix[pos(p->anc2->label,i,numSites)]);
					}
				/*printf("current_seq: /%s/\n", current_seq);*/
				/*printf("current_seq[0]: /%c/\n", current_seq[0]);
				printf("current_seq[1]: /%c/\n", current_seq[1]);*/


				/* Introduce mutacions or substitutions, here with Pop_Evol */
				Labelbranch = p->label;
   				/*printf("\nBranch length: %lf Labelbranch: %d \n", branchLength, Labelbranch);*/

				output_seq = Pop_evolDNA (branchLength, current_seq, numSites, dataSetNum, Labelbranch, dirStability, AlmostRootNode, seed); /* input: branchLength, input DNAseq, numSites and Replicate/branch; Output: DNAseq (and AAseq?) */

				/*printf("output_seq: /%s/\n", output_seq);
				printf("output_seq[0]: /%c/\n", output_seq[0]);
				printf("output_seq[1]: /%c/\n", output_seq[1]);
				printf("output_seq[764]: /%c/\n", output_seq[764]);*/

				for(i=0; i<numSites; i++) /* apply the output sequence */
					matrix[pos(p->label,i+1,numSites)] = WhichNucNumber(output_seq[i]);

				/*printf("WhichNucNumber(output_seq[0]): /%d/\n", WhichNucNumber(output_seq[0]));
				printf("WhichNucNumber(output_seq[1]): /%d/\n", WhichNucNumber(output_seq[1]));
				printf("WhichNucNumber(output_seq[764]): /%d/\n", WhichNucNumber(output_seq[764]));	*/


				if (matrix[pos(p->anc1->label,siteNucleotide,numSites)] > -1) /* va por anc1 */
					{
					for(i=1; i<=numSites; i++)
						{
						if (matrix[pos(p->label,i,numSites)] != matrix[pos(p->anc1->label,i,numSites)])
							{
							numMU++;	
							/*fprintf(stderr,"\n < MUT (no rec), numMU = %d \n", numMU);*/
							}
						}
					}
				else /* va por anc2 */
					{
					for(i=1; i<=numSites; i++)
						{
						if (matrix[pos(p->label,i,numSites)] != matrix[pos(p->anc2->label,i,numSites)])
							{
							numMU++;	
							/*fprintf(stderr,"\n < MUT (no rec), numMU = %d \n", numMU);*/
							}
						}
					}


				/* Combining material of these recombinant nodes */
				if (doCombineMaterial == YES) 
					{
					/*fprintf (fpmpi, "\n -- In doCombineMaterial --\n");

					fprintf (fpmpi, "\n Sequence p: ");
					for(i=1; i<=numSites; i++)
						fprintf (fpmpi, "%c", WhichNuc(matrix[pos(p->label,i,numSites)]));
					fprintf (fpmpi, "\n Sequence q: ");
					for(i=1; i<=numSites; i++)
						fprintf (fpmpi, "%c", WhichNuc(matrix[pos(q->label,i,numSites)]));*/

					pLeft = 0;
					qLeft = 0;

					for (step = 0; step < p->numSegNode; step++)	/* note that p->breakp = q->breakp */			
						{
						s = segments + post(step,p->index,distance);
				
						if (p->breakp >= s->sStart && p->breakp >= s->sEnd)
							{
							pLeft = 1;
							}
						}
					for (step = 0; step < q->numSegNode; step++)	/* note that p->breakp = q->breakp */			
						{
						s = segments + post(step,q->index,distance);
				
						if (q->breakp >= s->sStart && q->breakp >= s->sEnd)
							{
							qLeft = 1;
							}
						}
					if (pLeft == qLeft) /* checking.. */
						{
						/*fprintf (stderr, "\nWarning in SimulateDataForSite_Nucleotide_RECURSIVE_NET_Pop_Evol when combining regions (pLeft = %d, qLeft = %d)!\n", pLeft, qLeft);

						fprintf (stderr, "\n Breapoint at, p: %d, q: %d\n", p->breakp, q->breakp);
						fprintf (stderr, "\n Segments p:");
						for (step = 0; step < p->numSegNode; step++)			
							{
							s = segments + post(step,p->index,distance);
							fprintf (stderr, "\n s->sIndex: %d, s->sStart: %d, s->sEnd: %d", s->sIndex, s->sStart, s->sEnd);
							}
						fprintf (stderr, "\n Segments q:");
						for (step = 0; step < q->numSegNode; step++)				
							{
							s = segments + post(step,q->index,distance);
							fprintf (stderr, "\n s->sIndex: %d, s->sStart: %d, s->sEnd: %d", s->sIndex, s->sStart, s->sEnd);
							}*/
						fprintf (stderr, " ");
						}


					if (pLeft == 1) /* left material from p. right material from q. */
						{
						for(i=1; i<=numSites; i++) /* apply the output sequence */
							{
							if (i <= p->breakp) /* left side */
								{
								matrix[pos(q->label,i,numSites)] = matrix[pos(p->label,i,numSites)];
								}
							else /* right side */
								{
								matrix[pos(p->label,i,numSites)] = matrix[pos(q->label,i,numSites)];
								}
							}
						
						}
					if (qLeft == 1) /* left material from q. right material from p. */
						{
						for(i=1; i<=numSites; i++) /* apply the output sequence */
							{
							if (i <= q->breakp) /* left side */
								{
								matrix[pos(p->label,i,numSites)] = matrix[pos(q->label,i,numSites)];
								}
							else /* right side */
								{
								matrix[pos(q->label,i,numSites)] = matrix[pos(p->label,i,numSites)];
								}
							}
						
						}

					/*fprintf (stderr, "\n NEW FOR!!: p->label = %d, q->label = %d, matrix[pos(p->label,siteNucleotide,numSites)] = %d, numMU = %d \n\n", p->label, q->label, matrix[pos(p->label,siteNucleotide,numSites)], numMU);*/
					/*fprintf (fpmpi, "\n New sequence p: ");
					for(i=1; i<=numSites; i++)
						fprintf (fpmpi, "%c", WhichNuc(matrix[pos(p->label,i,numSites)]));
					fprintf (fpmpi, "\n New sequence q: ");
					for(i=1; i<=numSites; i++)
						fprintf (fpmpi, "%c", WhichNuc(matrix[pos(q->label,i,numSites)]));*/
					} /* end of combining */


				free(current_seq); /**/
				free(output_seq);
				
				}
			/* fin Mutacion */

			/* It crosses the tree */
			if (NOcontinueNode == 0 && k > 0)
				{
				SimulateDataForSite_Nucleotide_RECURSIVE_NET_Pop_Evol (p->left, siteNucleotide, numSites, m, kappa, seed, dataSetNum, dirStability);
				SimulateDataForSite_Nucleotide_RECURSIVE_NET_Pop_Evol (p->right, siteNucleotide, numSites, m, kappa, seed, dataSetNum, dirStability);
				}
			else
				NOcontinueNode = 0;
			if (thereisOutgroup == YES)
				SimulateDataForSite_Nucleotide_RECURSIVE_NET_Pop_Evol (p->outgroup, siteNucleotide, numSites, m, kappa, seed, dataSetNum, dirStability);	
			}
				
		}
		
	}





/********************************** SimulateDataForSite_UserTrees_Nt_Pop_Evol ***********************************/
/* Simulates the nucleotide substitution process for a given site */

void SimulateDataForSite_UserTrees_Nt_Pop_Evol (Treetnode *p, int siteNum, int numSites, int numNuc, 
							double kappa, double p_i[4], double siteRate, long int *seed, char *MRCAsequence, int dataSetNum, char *dirStability)
{
	int			i, k;
	double		ran; /*cumPi[4], cumProb[4], Pij[4][4];*/
	int			*codonMRCASeq;
	double		cumFreq[64];
	int			nucX[3];
	double 		branchLength;
	char		*current_seq, *output_seq;
	int 		Labelbranch, AlmostRootNode;

	branchLength = 0;
	current_seq = NULL;
	output_seq = NULL;
	Labelbranch = -1;
	AlmostRootNode = 0;


	if (p != NULL)
		{

		/*fprintf (fpmpi, "\n - In SimulateDataForSite_UserTrees_Nt_Pop_Evol (p->label = %d)- \n", p->label);*/

		if (p->parent == NULL) /* root */
			{

			if (doMRCAFile == YES) /* MRCA from File */
				{
				/*fprintf (fpmpi, "\nMRCAsequence:\n");
				for (i = 0; i < numNuc; i++)
					fprintf (fpmpi, "%d", WhichNucNumber(MRCAsequence[i]));
				fprintf (fpmpi, "\n");*/

				for (i=0; i<numSites; i++)
					{		
					matrix[pos(p->label,i,numNuc)] = WhichNucNumber(MRCAsequence[i]); /* from MRCA input file */
					/*fprintf (fpmpi, "\n ROOT matrix[pos(p->label(%d),%d,numNuc)]: %d", p->label, i, matrix[pos(p->label,i,numNuc)]);*/
					}
				}
			else /* MRCA from nucleotide frequencies */
				{		
				codonMRCASeq = (int *)calloc((numSites/3+3),(long) sizeof(int));
				if (!codonMRCASeq)
					{
					fprintf (fpmpi, "Could not allocate codonMRCASeq (%lu bytes)\n", (numSites/3+3)  * (long) sizeof(int));		
					exit (1);
					}

				k=0;
				for (i = 0; i < 3; i++) /* here we assume equal freqs for the 3 nt positions in the codon */
					{
					p_i_codon[i+k] = p_i[0];
					k++;
					p_i_codon[i+k] = p_i[1];
					k++;
					p_i_codon[i+k] = p_i[2];
					k++;
					p_i_codon[i+k] = p_i[3];
					}
				/*fprintf (fpmpi, "\n p_i_codon[%d] = %lf, p_i_codon[%d] = %lf, p_i_codon[%d] = %lf, p_i_codon[%d] = %lf", 0, p_i_codon[0], 1, p_i_codon[1], 2, p_i_codon[2], 3, p_i_codon[3]);
				fprintf (fpmpi, "\n p_i_codon[%d] = %lf, p_i_codon[%d] = %lf, p_i_codon[%d] = %lf, p_i_codon[%d] = %lf", 4, p_i_codon[4], 5, p_i_codon[5], 6, p_i_codon[6], 7, p_i_codon[7]);
				fprintf (fpmpi, "\n p_i_codon[%d] = %lf, p_i_codon[%d] = %lf, p_i_codon[%d] = %lf, p_i_codon[%d] = %lf", 8, p_i_codon[8], 9, p_i_codon[9], 10, p_i_codon[10], 11, p_i_codon[11]);*/


				cumFreq[0] = codonTable_frequencies_MRCA(0);
				for (i = 1; i <= 63; i++)
					cumFreq[i] = cumFreq[i-1] + codonTable_frequencies_MRCA(i);				

				for (i = 1; i <= 63; i++)
					cumFreq[i] = cumFreq[i]/cumFreq[63];
		
		
				for (i=1; i <= numNuc/3; i++)
					{
					ran = RandomUniform(seed);
					codonMRCASeq[i] = bbin_EnterMRCA(ran, cumFreq); /* codon MRCA sequence */
					/*fprintf (fpmpi, "\n ran = %lf", ran);
					fprintf (fpmpi, " codonMRCASeq[%d] = %d \n", i, codonMRCASeq[i]);*/
							
					if (codonMRCASeq[i] == 48 || codonMRCASeq[i] == 50 || codonMRCASeq[i] == 56) /* Cheking stop codons */
						{
						fprintf (fpmpi, "\n Warning by stop codons in EvolveSequenceOnTree_Codon (%d, %d)", i, codonMRCASeq[i]);
						exit (-2);
						}
					}

				k=0;
				for (i=1; i <= numNuc/3; i++)
					{
					number_to_codon_MRCA(codonMRCASeq[i], nucX);

					matrix[pos(p->label,i+k-1,numSites)] = nucX[0];
					k++;
					matrix[pos(p->label,i+k-1,numSites)] = nucX[1];
					k++;
					matrix[pos(p->label,i+k-1,numSites)] = nucX[2];
					/*fprintf (fpmpi, "Loop2. codonMRCASeq[%d] = %d; nucX[0] = %d, nucX[1] = %d, nucX[2] = %d \n", i, codonMRCASeq[i], nucX[0], nucX[1], nucX[2]);*/
					}
			
				free (codonMRCASeq);

				/*cumPi[0] = p_i[0];
				for (i = 1; i < 4; i++)
					cumPi[i] = cumPi[i-1] + p_i[i];
			
				ran = RandomUniform(seed);
	
				if (ran >= 0.0 && ran <= cumPi[0])
					matrix[pos(p->label,siteNum,numSites)] = 0;
				else if (ran > cumPi[0] && ran <= cumPi[1])
					matrix[pos(p->label,siteNum,numSites)] = 1;
				else if (ran > cumPi[1] && ran <= cumPi[2])
					matrix[pos(p->label,siteNum,numSites)] = 2;
				else
					matrix[pos(p->label,siteNum,numSites)] = 3;*/

				}

			}
		else
			{
			branchLength = p->length;

			if (p->parent->parent == NULL)
				{
				/*fprintf (fpmpi, "\n-> NODE p->label = %d is AlmostRootNode\n", p->label);*/
				AlmostRootNode = 1;
				}
			else
				{
				AlmostRootNode = 0;
				}

			/*printf("\nInput seq1\n");*/
			output_seq = (char *) calloc((numNuc+1), sizeof(char)); 
			if (!output_seq)
				{
				fprintf (stderr, "Could not allocate output_seq (%lu bytes)\n", (numNuc+1)  * (long) sizeof(char));
				exit (-1);
				}
			current_seq = (char *) calloc((numNuc+1), sizeof(char)); 
			if (!current_seq)
				{
				fprintf (stderr, "Could not allocate current_seq (%lu bytes)\n", (numNuc+1)  * (long) sizeof(char));
				exit (-1);
				}
			for (i=1; i<=numSites; i++) /* initializations */
				output_seq[i-1] = WhichNuc(5);
			for (i=1; i<=numSites; i++)
				current_seq[i-1] = WhichNuc(5);


			/* input sequence */
			for (i=0; i<numSites; i++)
				current_seq[i] = WhichNuc(matrix[pos(p->parent->label,i,numSites)]);
			/*printf("current_seq: /%s/\n", current_seq);
			printf("current_seq[0]: /%c/\n", current_seq[0]);
			printf("current_seq[1]: /%c/\n", current_seq[1]);
			printf("current_seq[764]: /%c/\n", current_seq[764]);*/

			/* Introduce mutacions or substitutions, here with Pop_Evol */
			Labelbranch = p->label;
   			/*printf("\nBranch length: %lf Labelbranch: %d \n", branchLength, Labelbranch);	*/		


			output_seq = Pop_evolDNA (branchLength, current_seq, numSites, dataSetNum, Labelbranch, dirStability, AlmostRootNode, seed); /* input: branchLength, input DNAseq, numSites and Replicate/branch; Output: DNAseq (and AAseq?) */

			/*printf("output_seq: /%s/\n", output_seq);
			printf("output_seq[0]: /%c/\n", output_seq[0]);
			printf("output_seq[1]: /%c/\n", output_seq[1]);
			printf("output_seq[764]: /%c/\n", output_seq[764]);*/

			for(i=0; i<numSites; i++) /* apply the output sequence */
				matrix[pos(p->label,i,numSites)] = WhichNucNumber(output_seq[i]);

			/*printf("WhichNucNumber(output_seq[0]): /%d/\n", WhichNucNumber(output_seq[0]));
			printf("WhichNucNumber(output_seq[1]): /%d/\n", WhichNucNumber(output_seq[1]));
			printf("WhichNucNumber(output_seq[764]): /%d/\n", WhichNucNumber(output_seq[764]));*/


			/*SubstitutionMatrix (Pij, p->length, kappa, siteRate, p_i); 
			cumProb[0] = Pij[matrix[pos(p->parent->label,siteNum,numSites)]][0];
			for (i=1; i<4; i++)
				cumProb[i] = cumProb[i-1] + Pij[matrix[pos(p->parent->label,siteNum,numSites)]][i];
			ran = RandomUniform(seed);
			if (ran >= 0.0 && ran <= cumProb[0])
				matrix[pos(p->label,siteNum,numSites)] = 0;
			else if (ran > cumProb[0] && ran <= cumProb[1])
				matrix[pos(p->label,siteNum,numSites)] = 1;
			else if (ran > cumProb[1] && ran <= cumProb[2])
				matrix[pos(p->label,siteNum,numSites)] = 2;
			else
				matrix[pos(p->label,siteNum,numSites)] = 3; */

			/*fprintf (fperr, "\nsite %d tnode %d (%s), its parent is: tnode %d (%s)", siteNum+1, p->index, p->name, p->parent->index, p->parent->name);*/
/*			if (matrix[pos(p->label,siteNum,numSites)] != matrix[pos(p->parent->label,siteNum,numSites)])
				fprintf (fpmpi, " %c>%c", WhichNuc(matrix[pos(p->parent->label,siteNum,numSites)]), WhichNuc(matrix[pos(p->label,siteNum,numSites)]));
*/

			for(i=0; i<numSites; i++)
				{
				if (matrix[pos(p->label,i,numSites)] != matrix[pos(p->parent->label,i,numSites)])
					{
					numMU++;	
					/*fprintf(stderr,"\n < MUT (no rec), numMU = %d \n", numMU);*/
					}
				}
			/*if (matrix[pos(p->label,siteNum,numSites)] != matrix[pos(p->parent->label,siteNum,numSites)])
					{
					numMU++;	
					}*/


			free(current_seq); /**/
			free(output_seq);
			}
		
		for (k=0; k<p->numChildren; k++)
			SimulateDataForSite_UserTrees_Nt_Pop_Evol (p->child[k], siteNum, numSites, numNuc, kappa, p_i, siteRate, seed, MRCAsequence, dataSetNum, dirStability);		

		}
}




/********************************** SimulateDataForSite_AA_RECURSIVE_NET_Pop_Evol ***********************************/
/* Simulates the aa substitution process for a given aa and considers PopEvol */

void SimulateDataForSite_AA_RECURSIVE_NET_Pop_Evol (TreeNode *p, int siteNucleotide, int numSites, double m, long int *seed, int dataSetNum, char *dirStability)
	{
	int			i, k, step, control, NOcontinueNode, doCombineMaterial, pLeft, qLeft;
	/*double		ran, cumProb[20], Pij[20][20];
	double 		a, b;*/
	double 		branchLength;
	char		*current_seq, *output_seq;
	int 		Labelbranch, AlmostRootNode;
	TreeNode *q;
	TreeSegment *s;
	
//	TreeNode *q, *r;

	q = NULL;
	/*a = 0;
	b = 0;*/
	step = 0;
	k = 0;
	control = 0;
	NOcontinueNode = 0;
	doCombineMaterial = NO;

	branchLength = 0;
	current_seq = NULL;
	output_seq = NULL;
	Labelbranch = -1;
	AlmostRootNode = 0;
	
	
	if (numRE == 0) /*** NO HAY NINGUNA REC ***/
		{
		if (p != NULL)
			{
			/*fprintf (fpmpi, "\n\n--Pasa por p->label = %d--\n", p->label);*/
			if (p->anc1 != NULL) // todos aquellos nodos que no son el GMRCA
				{
				/*fprintf (fpmpi, "\n COAL p->anc1 != NULL.. p->label = %d\n", p->label);*/	
				if (p->anc1->anc1 == NULL)
					{
					/*fprintf (fpmpi, "\n-> NODE p->label = %d is AlmostRootNode\n", p->label);*/
					AlmostRootNode = 1;
					}
				else
					{
					AlmostRootNode = 0;
					}

	
				if (p->isOutgroup == YES) // llegada al nodo outgroup
					{
					branchLength = p->length * m;
					AlmostRootNode = 1;
					/*AAevolModel (Pij, p->length * m, varRate);*/
					}
				else //llegada a cualquier nodo que no es outgroup
					{
					branchLength = (p->anc1->time - p->time) * m;
					/*AAevolModel (Pij, (p->anc1->time - p->time) * m, varRate);*/
					}
			

				/*printf("\nInput seq1\n");*/
				output_seq = (char *) calloc((numSites+1), sizeof(char)); 
				if (!output_seq)
					{
					fprintf (stderr, "Could not allocate output_seq (%lu bytes)\n", (numSites+1)  * (long) sizeof(char));
					exit (-1);
					}
				current_seq = (char *) calloc((numSites+1), sizeof(char)); 
				if (!current_seq)
					{
					fprintf (stderr, "Could not allocate current_seq (%lu bytes)\n", (numSites+1)  * (long) sizeof(char));
					exit (-1);
					}

				for (i=1; i<=numSites; i++) /* initializations */
					output_seq[i-1] = WhichAA(21);
				for (i=1; i<=numSites; i++)
					current_seq[i-1] = WhichAA(21);


				/* input sequence */
				for (i=1; i<=numSites; i++)
					current_seq[i-1] = WhichAA(matrix[pos(p->anc1->label,i,numSites)]);

				/*printf("current_seq: /%s/\n", current_seq);*/
				/*printf("current_seq[0]: /%c/\n", current_seq[0]);
				printf("current_seq[1]: /%c/\n", current_seq[1]);*/
				
				/* Introduce mutacions or substitutions, here with Pop_Evol */
				Labelbranch = p->label;
   				/*printf("\nBranch length: %lf Labelbranch: %d \n", branchLength, Labelbranch);*/

				output_seq = Pop_evolAA (branchLength, current_seq, numSites, dataSetNum, Labelbranch, dirStability, AlmostRootNode, seed); /* input: branchLength, input AAseq, numSites and Replicate/branch; Output: DNAseq (and AAseq?) */

				/*printf("output_seq: /%s/\n", output_seq);
				printf("output_seq[0]: /%c/\n", output_seq[0]);
				printf("output_seq[1]: /%c/\n", output_seq[1]);
				printf("output_seq[764]: /%c/\n", output_seq[764]);*/
				
				for(i=0; i<numSites; i++) /* apply the output sequence */
					matrix[pos(p->label,i+1,numSites)] = WhichAANumber(output_seq[i]);

				/*printf("WhichAANumber(output_seq[0]): /%d/\n", WhichAANumber(output_seq[0]));
				printf("WhichAANumber(output_seq[1]): /%d/\n", WhichAANumber(output_seq[1]));
				printf("WhichAANumber(output_seq[764]): /%d/\n", WhichAANumber(output_seq[764]));	*/


				/* Introduce Mutacion */
				/*cumProb[0] = Pij[matrix[pos(p->anc1->label,siteNucleotide,numSites)]][0];
				for (i=1; i<20; i++)
					cumProb[i] = cumProb[i-1] + Pij[matrix[pos(p->anc1->label,siteNucleotide,numSites)]][i];
				ran = RandomUniform(seed);*/

				/*if (p->label == 1)
					{
					fprintf(stderr,"\n ***** p->label = %d, p->index = %d,  p->time = %lf, (p->anc1->time - p->time) = %lf, sitioNum = %d, deme = %d, node_original = %d \n", p->label, p->index,  p->time, (p->anc1->time - p->time), siteNum, p->indexOldMigPop, p->NetIndex);
					}*/
				/*if (ran >= 0.0 && ran <= cumProb[0])
					matrix[pos(p->label,siteNucleotide,numSites)] = 0; 
				else if (ran > cumProb[0] && ran <= cumProb[1])
					matrix[pos(p->label,siteNucleotide,numSites)] = 1; 
				else if (ran > cumProb[1] && ran <= cumProb[2])
					matrix[pos(p->label,siteNucleotide,numSites)] = 2;
				else if (ran > cumProb[2] && ran <= cumProb[3])
					matrix[pos(p->label,siteNucleotide,numSites)] = 3; 
				else if (ran > cumProb[3] && ran <= cumProb[4])
					matrix[pos(p->label,siteNucleotide,numSites)] = 4;
				else if (ran > cumProb[4] && ran <= cumProb[5])
					matrix[pos(p->label,siteNucleotide,numSites)] = 5; 
				else if (ran > cumProb[5] && ran <= cumProb[6])
					matrix[pos(p->label,siteNucleotide,numSites)] = 6;
				else if (ran > cumProb[6] && ran <= cumProb[7])
					matrix[pos(p->label,siteNucleotide,numSites)] = 7; 
				else if (ran > cumProb[7] && ran <= cumProb[8])
					matrix[pos(p->label,siteNucleotide,numSites)] = 8;
				else if (ran > cumProb[8] && ran <= cumProb[9])
					matrix[pos(p->label,siteNucleotide,numSites)] = 9; 
				else if (ran > cumProb[9] && ran <= cumProb[10])
					matrix[pos(p->label,siteNucleotide,numSites)] = 10;
				else if (ran > cumProb[10] && ran <= cumProb[11])
					matrix[pos(p->label,siteNucleotide,numSites)] = 11; 
				else if (ran > cumProb[11] && ran <= cumProb[12])
					matrix[pos(p->label,siteNucleotide,numSites)] = 12;
				else if (ran > cumProb[12] && ran <= cumProb[13])
					matrix[pos(p->label,siteNucleotide,numSites)] = 13; 
				else if (ran > cumProb[13] && ran <= cumProb[14])
					matrix[pos(p->label,siteNucleotide,numSites)] = 14;
				else if (ran > cumProb[14] && ran <= cumProb[15])
					matrix[pos(p->label,siteNucleotide,numSites)] = 15; 
				else if (ran > cumProb[15] && ran <= cumProb[16])
					matrix[pos(p->label,siteNucleotide,numSites)] = 16;
				else if (ran > cumProb[16] && ran <= cumProb[17])
					matrix[pos(p->label,siteNucleotide,numSites)] = 17; 
				else if (ran > cumProb[17] && ran <= cumProb[18])
					matrix[pos(p->label,siteNucleotide,numSites)] = 18;
				else
					matrix[pos(p->label,siteNucleotide,numSites)] = 19;*/ 
			

				/*if (matrix[pos(p->label,siteNucleotide,numSites)] != matrix[pos(p->anc1->label,siteNucleotide,numSites)])
					{
					numMU++;*/
					/*fprintf(stderr,"\n < MUT (no rec), numMU = %d \n", numMU);*/
					/*}*/
				for(i=1; i<=numSites; i++)
					{
					if (matrix[pos(p->label,i,numSites)] != matrix[pos(p->anc1->label,i,numSites)])
						{
						numMU++;	
						/*fprintf(stderr,"\n < MUT (no rec), numMU = %d \n", numMU);*/
						}
					}
			

				/*fprintf (stderr, " matrix[pos(p->label,siteNucleotide,numSites)] = %d, matrix[pos(p->anc1->label,siteNucleotide,numSites)] = %d, numMU = %d \n", matrix[pos(p->label,siteNucleotide,numSites)], matrix[pos(p->anc1->label,siteNucleotide,numSites)], numMU);
				fprintf (stderr, " (p->anc1->time - p->time) = %lf \n", (p->anc1->time - p->time));*/
				/* fin Mutacion */

				free(current_seq); /**/
				free(output_seq);
				}


			/* It crosses the tree */
			SimulateDataForSite_AA_RECURSIVE_NET_Pop_Evol (p->left, siteNucleotide, numSites, m, seed, dataSetNum, dirStability);
			SimulateDataForSite_AA_RECURSIVE_NET_Pop_Evol (p->right, siteNucleotide, numSites, m, seed, dataSetNum, dirStability);	
			if (thereisOutgroup == YES)
				SimulateDataForSite_AA_RECURSIVE_NET_Pop_Evol (p->outgroup, siteNucleotide, numSites, m, seed, dataSetNum, dirStability);	
			}
		}
	else   /*** there are recombination events ***/
		{
		NOcontinueNode = 0;

		if (p != NULL)
			{
			/*fprintf (fpmpi, "\n\n--Pasa por p->label = %d, p->index = %d--\n", p->label, p->index);*/

			k = 0;
			if (p->anc1 != NULL && p->isOutgroup == YES) /* pasa el outgroup si lo hay */
				k++;
			for (step = 0; step < p->numSegNode; step++)	/* pasan aquellos nodos que contienen toda la secuencia */			
				{
				s = segments + post(step,p->index,distance);
				
				for (i = 1; i <= numSites; i++)	
					{			
					if (s->sStart <= i && s->sEnd >= i) 
						{
						k++;
						break;
						}
					}
				}

			
			if (p->breakp != NO) /* Special recombinant node */
				{
						
				q = p->sib;

				if (p->passNumber == 0)
					NOcontinueNode = 1;
				if (p->passNumber > 0) /* esta llegando por segunda vez */
					{
					NOcontinueNode = 0;
					doCombineMaterial = YES;
					/*fprintf (fpmpi, " p->passNumber = %d", p->passNumber);*/
					}
					
				/*p->passNumber++;*/ /* MA add: hoy borre esto. july 2009 */
				q->passNumber++;
						
				/*fprintf (fpmpi, "\n** The nodo p->label = %d (p->index = %d) is recombinant with breakpoint in %d \n", p->label, p->index, p->breakp);
				fprintf (fpmpi, " its Sib is, p->passNumber = %d, q->label = %d (q->index = %d) **\n", p->passNumber, q->label, q->index);*/
				}



			if (p->anc1 != NULL && k > 0) // todos aquellos nodos que no son el GMRCA
				{
				/*fprintf (fpmpi, "\n-->>Entra en BETWEEN p->anc1 != NULL.. p->label = %d, p->index = %d\n", p->label, p->index);*/	

				if (matrix[pos(p->anc1->label,siteNucleotide,numSites)] > -1) /* va por anc1 */
					{
					if (p->anc1->anc1 == NULL)
						{
						/*fprintf (fpmpi, "\n-> NODE p->label = %d is AlmostRootNode\n", p->label);*/
						AlmostRootNode = 1;
						}
					else
						{
						AlmostRootNode = 0;
						}
					}
				else /* va por anc2 */
					{
					if (p->anc2->anc1 == NULL)
						{
						/*fprintf (fpmpi, "\n-> NODE p->label = %d is AlmostRootNode\n", p->label);*/
						AlmostRootNode = 1;
						}
					else
						{
						AlmostRootNode = 0;
						}
					}


				if (p->isOutgroup == YES) // llegada al nodo outgroup
					{
					branchLength = p->length * m;
					AlmostRootNode = 1;
					/*AAevolModel (Pij, p->length * m, varRate);*/ /* This computes Pij given branch length.. */
					}
				else //llegada a cualquier nodo que no es outgroup
					{
					if (matrix[pos(p->anc1->label,siteNucleotide,numSites)] > -1) /* va por anc1 */
						branchLength = (p->anc1->time - p->time) * m;
					else /* va por anc2 */
						branchLength = (p->anc2->time - p->time) * m;
					/*AAevolModel (Pij, (p->anc1->time - p->time) * m, varRate);*/
					}


				/*printf("\nInput seq1\n");*/
				output_seq = (char *) calloc((numSites+1), sizeof(char)); 
				if (!output_seq)
					{
					fprintf (stderr, "Could not allocate output_seq (%lu bytes)\n", (numSites+1)  * (long) sizeof(char));
					exit (-1);
					}
				current_seq = (char *) calloc((numSites+1), sizeof(char)); 
				if (!current_seq)
					{
					fprintf (stderr, "Could not allocate current_seq (%lu bytes)\n", (numSites+1)  * (long) sizeof(char));
					exit (-1);
					}

				for (i=1; i<=numSites; i++) /* initializations */
					output_seq[i-1] = WhichAA(21);
				for (i=1; i<=numSites; i++)
					current_seq[i-1] = WhichAA(21);


				/* input sequence */
				if (matrix[pos(p->anc1->label,siteNucleotide,numSites)] > -1) /* va por anc1 */
					{
					for (i=1; i<=numSites; i++)
						current_seq[i-1] = WhichAA(matrix[pos(p->anc1->label,i,numSites)]);
					}
				else /* va por anc2 */
					{
					for (i=1; i<=numSites; i++)
						current_seq[i-1] = WhichAA(matrix[pos(p->anc2->label,i,numSites)]);
					}

				/*printf("current_seq: /%s/\n", current_seq);*/
				/*printf("current_seq[0]: /%c/\n", current_seq[0]);
				printf("current_seq[1]: /%c/\n", current_seq[1]);*/
				
				/* Introduce mutacions or substitutions, here with Pop_Evol */
				Labelbranch = p->label;
   				/*printf("\nBranch length: %lf Labelbranch: %d \n", branchLength, Labelbranch);*/

				output_seq = Pop_evolAA (branchLength, current_seq, numSites, dataSetNum, Labelbranch, dirStability, AlmostRootNode, seed); /* input: branchLength, input AAseq, numSites and Replicate/branch; Output: DNAseq (and AAseq?) */

				/*printf("output_seq: /%s/\n", output_seq);
				printf("output_seq[0]: /%c/\n", output_seq[0]);
				printf("output_seq[1]: /%c/\n", output_seq[1]);
				printf("output_seq[764]: /%c/\n", output_seq[764]);*/
				
				for(i=0; i<numSites; i++) /* apply the output sequence */
					matrix[pos(p->label,i+1,numSites)] = WhichAANumber(output_seq[i]);

				/*printf("WhichAANumber(output_seq[0]): /%d/\n", WhichAANumber(output_seq[0]));
				printf("WhichAANumber(output_seq[1]): /%d/\n", WhichAANumber(output_seq[1]));
				printf("WhichAANumber(output_seq[764]): /%d/\n", WhichAANumber(output_seq[764]));	*/


				if (matrix[pos(p->anc1->label,siteNucleotide,numSites)] > -1) /* va por anc1 */
					{
					for(i=1; i<=numSites; i++)
						{
						if (matrix[pos(p->label,i,numSites)] != matrix[pos(p->anc1->label,i,numSites)])
							{
							numMU++;	
							/*fprintf(stderr,"\n < MUT (no rec), numMU = %d \n", numMU);*/
							}
						}
					}
				else /* va por anc2 */
					{
					for(i=1; i<=numSites; i++)
						{
						if (matrix[pos(p->label,i,numSites)] != matrix[pos(p->anc2->label,i,numSites)])
							{
							numMU++;	
							/*fprintf(stderr,"\n < MUT (no rec), numMU = %d \n", numMU);*/
							}
						}
					}


				/* Combining material of these recombinant nodes */
				if (doCombineMaterial == YES) 
					{
					/*fprintf (fpmpi, "\n -- In doCombineMaterial --\n");

					fprintf (fpmpi, "\n Sequence p: ");
					for(i=1; i<=numSites; i++)
						fprintf (fpmpi, "%c", WhichAA(matrix[pos(p->label,i,numSites)]));
					fprintf (fpmpi, "\n Sequence q: ");
					for(i=1; i<=numSites; i++)
						fprintf (fpmpi, "%c", WhichAA(matrix[pos(q->label,i,numSites)]));*/

					pLeft = 0;
					qLeft = 0;

					for (step = 0; step < p->numSegNode; step++)	/* note that p->breakp = q->breakp */			
						{
						s = segments + post(step,p->index,distance);
				
						if (p->breakp >= s->sStart && p->breakp >= s->sEnd)
							{
							pLeft = 1;
							}
						}
					for (step = 0; step < q->numSegNode; step++)	/* note that p->breakp = q->breakp */			
						{
						s = segments + post(step,q->index,distance);
				
						if (q->breakp >= s->sStart && q->breakp >= s->sEnd)
							{
							qLeft = 1;
							}
						}
					if (pLeft == qLeft) /* checking.. */
						{
						/*fprintf (stderr, "\nWarning in SimulateDataForSite_AA_RECURSIVE_NET_Pop_Evol when combining regions (pLeft = %d, qLeft = %d)!\n", pLeft, qLeft);

						fprintf (stderr, "\n Breapoint at, p: %d, q: %d\n", p->breakp, q->breakp);
						fprintf (stderr, "\n Segments p:");
						for (step = 0; step < p->numSegNode; step++)			
							{
							s = segments + post(step,p->index,distance);
							fprintf (stderr, "\n s->sIndex: %d, s->sStart: %d, s->sEnd: %d", s->sIndex, s->sStart, s->sEnd);
							}
						fprintf (stderr, "\n Segments q:");
						for (step = 0; step < q->numSegNode; step++)				
							{
							s = segments + post(step,q->index,distance);
							fprintf (stderr, "\n s->sIndex: %d, s->sStart: %d, s->sEnd: %d", s->sIndex, s->sStart, s->sEnd);
							}
						fprintf (stderr, "\n\n");*/
						fprintf (stderr, " ");
						}


					if (pLeft == 1) /* left material from p. right material from q. */
						{
						for(i=1; i<=numSites; i++) /* apply the output sequence */
							{
							if (i <= p->breakp) /* left side */
								{
								matrix[pos(q->label,i,numSites)] = matrix[pos(p->label,i,numSites)];
								}
							else /* right side */
								{
								matrix[pos(p->label,i,numSites)] = matrix[pos(q->label,i,numSites)];
								}
							}
						
						}
					if (qLeft == 1) /* left material from q. right material from p. */
						{
						for(i=1; i<=numSites; i++) /* apply the output sequence */
							{
							if (i <= q->breakp) /* left side */
								{
								matrix[pos(p->label,i,numSites)] = matrix[pos(q->label,i,numSites)];
								}
							else /* right side */
								{
								matrix[pos(q->label,i,numSites)] = matrix[pos(p->label,i,numSites)];
								}
							}
						
						}

					/*fprintf (stderr, "\n NEW FOR!!: p->label = %d, q->label = %d, matrix[pos(p->label,siteNucleotide,numSites)] = %d, numMU = %d \n\n", p->label, q->label, matrix[pos(p->label,siteNucleotide,numSites)], numMU);*/
					/*fprintf (fpmpi, "\n New sequence p: ");
					for(i=1; i<=numSites; i++)
						fprintf (fpmpi, "%c", WhichAA(matrix[pos(p->label,i,numSites)]));
					fprintf (fpmpi, "\n New sequence q: ");
					for(i=1; i<=numSites; i++)
						fprintf (fpmpi, "%c", WhichAA(matrix[pos(q->label,i,numSites)]));*/
					} /* end of combining */
			
				free(current_seq); /**/
				free(output_seq);


				/* fin Mutacion */
				}
		
			/* It crosses the tree */
			if (NOcontinueNode == 0 && k > 0)
				{
				SimulateDataForSite_AA_RECURSIVE_NET_Pop_Evol (p->left, siteNucleotide, numSites, m, seed, dataSetNum, dirStability);
				SimulateDataForSite_AA_RECURSIVE_NET_Pop_Evol (p->right, siteNucleotide, numSites, m, seed, dataSetNum, dirStability);
				}
			else
				NOcontinueNode = 0;
			if (thereisOutgroup == YES)
				SimulateDataForSite_AA_RECURSIVE_NET_Pop_Evol (p->outgroup, siteNucleotide, numSites, m, seed, dataSetNum, dirStability);
			}
				
				
		}
		
	}



/********************************** SimulateDataForSite_UserTrees_AA_Pop_Evol ***********************************/
/* Simulates the amino acid substitution process for a given site */

void SimulateDataForSite_UserTrees_AA_Pop_Evol (Treetnode *p, int siteNum, int numSites, int numNuc, 
							double p_i_aa[20], long int *seed, char *MRCAsequence, int dataSetNum, char *dirStability)
{
	int			i, k;
	double		ran, cumPi[20]/*, cumProb[20], Pij[20][20]*/;
	double 		branchLength;
	char		*current_seq, *output_seq;
	int 		Labelbranch, AlmostRootNode;

	branchLength = 0;
	current_seq = NULL;
	output_seq = NULL;
	Labelbranch = -1;
	AlmostRootNode = 0;

	if (p != NULL)
		{
		if (p->parent == NULL) /* root */
			{

			if (doMRCAFile == YES) /* MRCA from File */
				{

				for (i=0; i<numSites; i++)
					{		
					matrix[pos(p->label,i,numNuc)] = WhichAANumber(MRCAsequence[i]); /* from MRCA input file */
					//fprintf (fpmpi, "\n ROOT matrix[pos(p->label(%d),%d,numNuc)]: %d", p->label, i, matrix[pos(p->label,i,numNuc)]);
					}

				//matrix[pos(p->label,siteNum,numNuc)] = WhichAANumber(MRCAsequence[siteNum]); /* from MRCA input file */
				}
			else /* MRCA from amino acid frequencies */
				{
				cumPi[0] = p_i_aa[0];
				for (i = 1; i < 20; i++)
					cumPi[i] = cumPi[i-1] + p_i_aa[i];

				for (k=0; k<numSites; k++)
					{
					ran = RandomUniform(seed);

					if (ran >= 0.0 && ran <= cumPi[0])
						matrix[pos(p->label,k,numSites)] = 0;
					else if (ran > cumPi[0] && ran <= cumPi[1])
						matrix[pos(p->label,k,numSites)] = 1;
					else if (ran > cumPi[1] && ran <= cumPi[2])
						matrix[pos(p->label,k,numSites)] = 2;
					else if (ran > cumPi[2] && ran <= cumPi[3])
						matrix[pos(p->label,k,numSites)] = 3;
					else if (ran > cumPi[3] && ran <= cumPi[4])
						matrix[pos(p->label,k,numSites)] = 4;
					else if (ran > cumPi[4] && ran <= cumPi[5])
						matrix[pos(p->label,k,numSites)] = 5;
					else if (ran > cumPi[5] && ran <= cumPi[6])
						matrix[pos(p->label,k,numSites)] = 6;
					else if (ran > cumPi[6] && ran <= cumPi[7])
						matrix[pos(p->label,k,numSites)] = 7;
					else if (ran > cumPi[7] && ran <= cumPi[8])
						matrix[pos(p->label,k,numSites)] = 8;
					else if (ran > cumPi[8] && ran <= cumPi[9])
						matrix[pos(p->label,k,numSites)] = 9;
					else if (ran > cumPi[9] && ran <= cumPi[10])
						matrix[pos(p->label,k,numSites)] = 10;
					else if (ran > cumPi[10] && ran <= cumPi[11])
						matrix[pos(p->label,k,numSites)] = 11;
					else if (ran > cumPi[11] && ran <= cumPi[12])
						matrix[pos(p->label,k,numSites)] = 12;
					else if (ran > cumPi[12] && ran <= cumPi[13])
						matrix[pos(p->label,k,numSites)] = 13;
					else if (ran > cumPi[13] && ran <= cumPi[14])
						matrix[pos(p->label,k,numSites)] = 14;
					else if (ran > cumPi[14] && ran <= cumPi[15])
						matrix[pos(p->label,k,numSites)] = 15;
					else if (ran > cumPi[15] && ran <= cumPi[16])
						matrix[pos(p->label,k,numSites)] = 16;
					else if (ran > cumPi[16] && ran <= cumPi[17])
						matrix[pos(p->label,k,numSites)] = 17;
					else if (ran > cumPi[17] && ran <= cumPi[18])
						matrix[pos(p->label,k,numSites)] = 18;
					else
						matrix[pos(p->label,k,numSites)] = 19;
					}


				}
                
			/*fprintf (fpmpi, "\nsite %d root %d (%s) ", siteNum+1, p->index, p->name);
			fprintf (fpmpi, "%c", WhichNuc(matrix[pos(p->label,siteNum,numSites)]));
            fprintf (fpmpi, "\n\n");*/

			}
		else
			{
//			AAevolModel (Pij, p->length, siteRate); /* Ok = */
			branchLength = p->length;

			if (p->parent->parent == NULL)
				{
				/*fprintf (fpmpi, "\n-> NODE p->label = %d is AlmostRootNode\n", p->label);*/
				AlmostRootNode = 1;
				}
			else
				{
				AlmostRootNode = 0;
				}

			/*printf("\nInput seq1\n");*/
			output_seq = (char *) calloc((numNuc+1), sizeof(char)); 
			if (!output_seq)
				{
				fprintf (stderr, "Could not allocate output_seq (%lu bytes)\n", (numNuc+1)  * (long) sizeof(char));
				exit (-1);
				}
			current_seq = (char *) calloc((numNuc+1), sizeof(char)); 
			if (!current_seq)
				{
				fprintf (stderr, "Could not allocate current_seq (%lu bytes)\n", (numNuc+1)  * (long) sizeof(char));
				exit (-1);
				}
			for (i=1; i<=numSites; i++) /* initializations */
				output_seq[i-1] = WhichAA(21);
			for (i=1; i<=numSites; i++)
				current_seq[i-1] = WhichAA(21);
			

			/* input sequence */
			for (i=0; i<numSites; i++)
				current_seq[i] = WhichAA(matrix[pos(p->parent->label,i,numSites)]);
			//printf("current_seq (in node %d): %s\n", p->parent->label, current_seq);
			/*printf("current_seq[0]: /%c/\n", current_seq[0]);
			printf("current_seq[1]: /%c/\n", current_seq[1]);
			printf("current_seq[764]: /%c/\n", current_seq[764]);*/

			/* Introduce mutacions or substitutions, here with Pop_Evol */
			Labelbranch = p->label;
   			/*printf("\nBranch length: %lf Labelbranch: %d \n", branchLength, Labelbranch);	*/	

			output_seq = Pop_evolAA (branchLength, current_seq, numSites, dataSetNum, Labelbranch, dirStability, AlmostRootNode, seed); /* input: branchLength, input AAseq, numSites and Replicate/branch; Output: DNAseq (and AAseq?) */

			//printf("\noutput_seq (in node (Labelbranch) %d): %s\n\n\n\n\n\n", p->label, output_seq);
			/*printf("output_seq[0]: /%c/\n", output_seq[0]);
			printf("output_seq[1]: /%c/\n", output_seq[1]);
			printf("output_seq[254]: /%c/\n", output_seq[254]);*/
			
			for(i=0; i<numSites; i++) /* apply the output sequence */
				matrix[pos(p->label,i,numSites)] = WhichAANumber(output_seq[i]);

			/*printf("WhichAANumber(output_seq[0]): /%d/\n", WhichAANumber(output_seq[0]));
			printf("WhichAANumber(output_seq[1]): /%d/\n", WhichAANumber(output_seq[1]));
			printf("WhichAANumber(output_seq[254]): /%d/\n", WhichAANumber(output_seq[254]));*/
			

			/*cumProb[0] = Pij[matrix[pos(p->parent->label,siteNum,numSites)]][0];
			for (i=1; i<20; i++)
				cumProb[i] = cumProb[i-1] + Pij[matrix[pos(p->parent->label,siteNum,numSites)]][i];
			ran = RandomUniform(seed);
							
			if (ran >= 0.0 && ran <= cumProb[0])
				matrix[pos(p->label,siteNum,numSites)] = 0; 
			else if (ran > cumProb[0] && ran <= cumProb[1])
				matrix[pos(p->label,siteNum,numSites)] = 1; 
			else if (ran > cumProb[1] && ran <= cumProb[2])
				matrix[pos(p->label,siteNum,numSites)] = 2;
			else if (ran > cumProb[2] && ran <= cumProb[3])
				matrix[pos(p->label,siteNum,numSites)] = 3; 
			else if (ran > cumProb[3] && ran <= cumProb[4])
				matrix[pos(p->label,siteNum,numSites)] = 4;
			else if (ran > cumProb[4] && ran <= cumProb[5])
				matrix[pos(p->label,siteNum,numSites)] = 5; 
			else if (ran > cumProb[5] && ran <= cumProb[6])
				matrix[pos(p->label,siteNum,numSites)] = 6;
			else if (ran > cumProb[6] && ran <= cumProb[7])
				matrix[pos(p->label,siteNum,numSites)] = 7; 
			else if (ran > cumProb[7] && ran <= cumProb[8])
				matrix[pos(p->label,siteNum,numSites)] = 8;
			else if (ran > cumProb[8] && ran <= cumProb[9])
				matrix[pos(p->label,siteNum,numSites)] = 9; 
			else if (ran > cumProb[9] && ran <= cumProb[10])
				matrix[pos(p->label,siteNum,numSites)] = 10;
			else if (ran > cumProb[10] && ran <= cumProb[11])
				matrix[pos(p->label,siteNum,numSites)] = 11; 
			else if (ran > cumProb[11] && ran <= cumProb[12])
				matrix[pos(p->label,siteNum,numSites)] = 12;
			else if (ran > cumProb[12] && ran <= cumProb[13])
				matrix[pos(p->label,siteNum,numSites)] = 13; 
			else if (ran > cumProb[13] && ran <= cumProb[14])
				matrix[pos(p->label,siteNum,numSites)] = 14;
			else if (ran > cumProb[14] && ran <= cumProb[15])
				matrix[pos(p->label,siteNum,numSites)] = 15; 
			else if (ran > cumProb[15] && ran <= cumProb[16])
				matrix[pos(p->label,siteNum,numSites)] = 16;
			else if (ran > cumProb[16] && ran <= cumProb[17])
				matrix[pos(p->label,siteNum,numSites)] = 17; 
			else if (ran > cumProb[17] && ran <= cumProb[18])
				matrix[pos(p->label,siteNum,numSites)] = 18;
			else
				matrix[pos(p->label,siteNum,numSites)] = 19; */
			

			/*fprintf (fpmpi, "\nsite %d tnode %d (%s), its parent is: tnode %d (%s)", siteNum+1, p->index, p->name, p->parent->index, p->parent->name);*/
/*			if (matrix[pos(p->label,siteNum,numSites)] != matrix[pos(p->parent->label,siteNum,numSites)])
				fprintf (fpmpi, " %c>%c", WhichAA(matrix[pos(p->parent->label,siteNum,numSites)]), WhichAA(matrix[pos(p->label,siteNum,numSites)]));
*/

/*			if (matrix[pos(p->label,siteNum,numSites)] != matrix[pos(p->parent->label,siteNum,numSites)])
				{
				numMU++;*/	
				/*fprintf(stderr,"\n < MUT, numMU = %d [%c>%c]\n", numMU, WhichAA(matrix[pos(p->parent->label,siteNum,numSites)]), WhichAA(matrix[pos(p->label,siteNum,numSites)]));*/
/*				}*/
			for(i=0; i<numSites; i++)
				{
				if (matrix[pos(p->label,i,numSites)] != matrix[pos(p->parent->label,i,numSites)])
					{
					numMU++;	
					/*fprintf(stderr,"\n < MUT (no rec), numMU = %d \n", numMU);*/
					}
				}

			free(current_seq); /**/
			free(output_seq);
			}
		
		for (i=0; i<p->numChildren; i++)
			SimulateDataForSite_UserTrees_AA_Pop_Evol (p->child[i], siteNum, numSites, numNuc, p_i_aa, seed, MRCAsequence, dataSetNum, dirStability);	
		}
}







/************************************************************/
/************************************************************/
/********************* RandomExponential ********************/
/* Generates a random number from a Poisson distibution with
  mean lambda. 
*/

double RandomExponential (double lambda, long int *seed)
{

	double 	exponentialNumber, U;

	do
		U = RandomUniform (seed);
	while (U == 0);

	exponentialNumber = -log (U) / lambda;

	return exponentialNumber;
}


/***************************** RandomUniform **********************************/
/* It returns a random uniform variate in range 0..1. It is described in
  	Park, S. K. and K. W. Miller. 1988. Random number generators: good
   ones are hard to find. Communications of the ACM, 31(10):1192-1201.
*/

double RandomUniform (long int *seed)
{

	long int	lo, hi, test;
	
	hi = (*seed) / 127773;
	lo = (*seed) % 127773;
	test = 16807 * lo - 2836 * hi;
	if (test > 0)
		*seed = test;
	else
		*seed = test + 2147483647;
	return (double)(*seed) / (double)2147483647;

}




/* Gamma functions written by Ziheng Yang */
double RndGamma (double s, long int *seed)
{
	double r=0.0;
	
	if (s <= 0.0)     
		puts ("jgl gamma..");
	else if (s < 1.0) 
		r = RndGamma1 (s, seed);
	else if (s > 1.0) 
		r = RndGamma2 (s, seed);
	else
        {
		// r =- log(RandomUniform(seed));
        r = -log(RandomUniform(seed));
        }
	return (r);
}

double RndGamma1 (double s, long int *seed)
{
	double			r, x=0.0, smal=1e-37, w;
	static double  a, p, uf, ss=10.0, d;
	
	if (s!=ss) 
		{
		a = 1.0-s;
		p = a/(a+s*exp(-a));
		uf = p*pow(smal/a,s);
		d = a*log(a);
		ss = s;
		}
	for (;;) 
		{
		r = RandomUniform(seed);
		if (r > p)       
			x = a-log((1.0-r)/(1.0-p)), w=a*log(x)-d;
		else if (r>uf) 
			x = a*pow(r/p,1/s), w=x;
		else           
			return (0.0);
		r = RandomUniform(seed);
		if (1.0-r <= w && r > 0.0)
		if (r*(w+1.0) >= 1.0 || -log(r) <= w) 
			continue;
		break;
		}
	return (x);
}

double RndGamma2 (double s, long int *seed)
{
	double			r ,d, f, g, x;
	static double	b, h, ss=0;
	
	if (s!=ss) 
		{
		b = s-1.0;
		h = sqrt(3.0*s-0.75);
		ss = s;
		}
	for (;;) 
		{
		r = RandomUniform(seed);
		g = r-r*r;
		f = (r-0.5)*h/sqrt(g);
		x = b+f;
		if (x <= 0.0) 
			continue;
		r = RandomUniform(seed);
		d = 64*r*r*g*g*g;
		if (d*x < x-2.0*f*f || log(d) < 2*(b*log(x/b)-f)) 
			break;
		}
	return (x);
}




/*
	Program: SimulateBeta
	Purpose: To simulate random beta variables 
 	Author: David Posada 
 	Started: October 08
*/
/*** Thanks David! ***/

/**************************** RandomBeta*************************/
/*	Generates a beta number 
	Beta (p,q) = gamma (1,p) / [ gamma (1,p) + gamma (1,q)]
	Here  gamma (scale, shape)


	Proof-> In R, type: mean(rbeta(1000,0.3,0.5)) to get the mean of 1000 beta variables
	var(rbeta(1000,0.3,0.5)) to get the variance.
	repeat with 1000000 to get more accuracy.


*/

double	RandomBeta (double p, double q, long int *seed)
{
	double betaNumber = 0;
	double gammaNumber1, gammaNumber2;
	
	/* Note RandomGamm function already assumes a scale=1 */
	gammaNumber1 = RandomGamma (p, seed); /* I think we should not divide by p here */
	gammaNumber2 = RandomGamma (q, seed); /* I think we should not divide by q here */
	betaNumber = gammaNumber1 / (gammaNumber1 + gammaNumber2);
	
	return (betaNumber);
}




/**************************** RandomGamma *************************/
/*	Generates a gamma number using routines in Ziheng's
	Yang tools.h in PAML

	Random standard gamma (Mean=Var=s,  with shape par=s, scale par=1)
	r^(s-1)*exp(-r)
	
	J. Dagpunar (1988) Principles of random variate generation,
	Clarendon Press, Oxford
	
	Calling rndgamma1() if s<1 or rndgamma2() if s>1 or exponential if s=1
*/	

double	RandomGamma (double shape, long int *seed)
{
	double gammaNumber = 0;
	
	if (shape <= 0)
		fprintf (stderr, "ERROR: problems with gamma variable generation, shape < 0");
	else if (shape < 1)
		gammaNumber = RandomGamma1 (shape, seed);
	else if (shape > 1)
		gammaNumber = RandomGamma2 (shape, seed);
	else
		gammaNumber = -log (RandomUniform(seed));
	
	return (gammaNumber);


}

/*************** RandomGamma1 ***************/
double RandomGamma1 (double s, long int *seed)
{
/* Random standard gamma for s<1
   switching method
*/
	double		r, x = 0.0, small2 = 1e-37, w;
	static double	a, p, uf, ss2 = 10.0, d;
	
	if (s != ss2) 
		{
		a  = 1.0 - s;
		p  = a/(a+s*exp(-a));
		uf = p*pow(small2/a,s);
		d  = a*log(a);
		ss2 = s;
		}
	for (;;) 
		{
		r = RandomUniform(seed);
		if (r > p)        
			x = a-log((1.0-r)/(1.0-p)), w=a*log(x)-d;
		else if (r>uf)  
			x = a*pow(r/p,1/s), w=x;
		else            
			return (0.0);
		r = RandomUniform(seed);
		if (1.0-r <= w && r > 0.0)
		if (r*(w+1.0) >= 1.0 || -log(r) <= w)  
			continue;
		break;
		}
	return (x);
}


/*************** RandomGamma2 ***************/
double RandomGamma2 (double s, long int *seed)
{
/* Random standard gamma for s>1
   Best's (1978) t distribution method
*/
	double		r ,d, f, g, x;
	static double	b, h, ss=0;
	
	if (s!=ss) 
		{
		b  = s-1.0;
		h  = sqrt(3.0*s-0.75);
		ss = s;
		}
	for (;;) 
		{
		r = RandomUniform(seed);
		g = r-r*r;
		f = (r-0.5)*h/sqrt(g);
		x = b+f;
		if (x <= 0.0) 
			continue;
		r = RandomUniform(seed);
		d = 64*r*r*g*g*g;
		if (d*x < x-2.0*f*f || log(d) < 2*(b*log(x/b)-f))  
			break;
		}
	return (x);
}





/********************** RandomUniformTo ****************************/
/* it returns random uniform in range 0...max-1          */

static int RandomUniformTo (int max, long int *seed)
{
	double	rd;
	rd = RandomUniform (seed);
	return (floor(rd*max));
}




/********************* RandomPoisson ********************/
/* Generates a random number from a Poisson distibution with
   mean lambda. 
*/

/*int RandomPoisson (double lambda, long int *seed)
{
	int		poissonNumber;
	double	sum;
	
	sum = 0;
	poissonNumber = -1;
	
	while (sum <= 1.0)
		{
		sum += RandomExponential (lambda, seed);
		poissonNumber++;
		}

	return poissonNumber;

}*/




/********************* RandomNormal ********************/
/*	Generates a normal number using the Box-Mueller scheme 
	(Press et al. 1986 , 202)
*/

double RandomNormal (double mean, double variance, long int *seed)
{

	double 	pi = 3.141592653589793238462643;
	double 	normalNumber, U1, U2, Z;

	U1 = RandomUniform(seed);
	U2 = RandomUniform(seed);
	
	Z = sqrt (-2 * log (U1)) * cos (2*pi*U2);

	normalNumber = mean + sqrt(variance)*Z;

	return normalNumber;
}





/*void SetMatrix(double Pij[4][4], double len)
{	
	int i,j,k;
	double expt[4];*/
	
/* P(t)ij = SUM Cijk * exp{Root*t}
*/
/*	if (len<1e-6) 
		{ 
		for (i=0; i<4; i++) 
			for (j=0; j<4; j++) 
				{
				if (i==j)
					Pij[i][j] = 1.0;
				else 	
					Pij[i][j] = 0.0;
				}
		return; 
		}
	
	for (k=1; k<4; k++) 
		expt[k]=exp(len*Root[k]);
	for (i=0; i<4; i++) 
		for (j=0; j<4; j++) 
			{
			Pij[i][j]=Cijk[i*4*4+j*4+0];
			for (k=1; k<4; k++)
				Pij[i][j]+=Cijk[i*4*4+j*4+k]*expt[k];
			}*/
	 
	
/* the rows are cumulative to help with picking one using
  a random number */ /*matrix = Pij */
/*	matrix[1]+=matrix[0];
	matrix[2]+=matrix[1];
	matrix[3]+=matrix[2];*/ /* This should always be 1.0... 

	matrix[5]+=matrix[4];
	matrix[6]+=matrix[5];
	matrix[7]+=matrix[6];*/ /* ...but it is easier to spot bugs... 
	
	matrix[9]+=matrix[8];
	matrix[10]+=matrix[9];
	matrix[11]+=matrix[10];*/ /* ...though less efficient... 
	
	matrix[13]+=matrix[12];
	matrix[14]+=matrix[13];
	matrix[15]+=matrix[14];*/ /* ...but probably not much. 
*/
/*}*/


/*void SetVector(double *vector, short base, double len)
{	
	int i,j,k;
	double expt[4];
	double *P;

	P=vector;
	if (len<1e-6) 
		{ 
		for (i=0; i<4; i++) 
			{
			if (i==base)
				*P=1.0;
			else 	
				*P=0.0;
			P++;
			}
		return; 
		}
	for (k=1; k<4; k++) 
		expt[k]=exp(len*Root[k]);

	for (j=0; j<4; j++)
		{
		(*P)=Cijk[base*4*4+j*4+0];
		for (k=1; k<4; k++)
			(*P)+=Cijk[base*4*4+j*4+k]*expt[k];
		P++;
		}
		vector[1]+=vector[0];
		vector[2]+=vector[1];
		vector[3]+=vector[2];
}*/




/* Everything below is shamelessly taken from Yang's Paml package */

int abyx (double a, double x[], int n);
int xtoy (double x[], double y[], int n);
int matinv( double x[], int n, int m, double space[]);
int eigen(int job, double A[], int n, double rr[], double ri[],
         double vr[], double vi[], double w[]);
void balance(double mat[], int n, int *low, int *hi, double scale[]);
void unbalance(int n, double vr[], double vi[], int low, int hi,
              double scale[]);
int realeig(int job, double mat[], int n,int low, int hi, double valr[],
           double vali[], double vr[], double vi[]);
void elemhess(int job, double mat[], int n, int low, int hi, 
           double vr[], double vi[], int work[]);

typedef struct { double re, im; } complex;
#define csize(a) (fabs(a.re)+fabs(a.im))

complex compl (double re,double im);
complex cconj (complex a);
complex cplus (complex a, complex b);
complex cminus (complex a, complex b);
complex cby (complex a, complex b);
complex cdiv (complex a,complex b);
complex ccexp (complex a);
complex cfactor (complex x, double a);
int cxtoy (complex x[], complex y[], int n);
int cmatby (complex a[], complex b[], complex c[], int n,int m,int k);
int cmatout (FILE * fout, complex x[], int n, int m);
int cmatinv( complex x[], int n, int m, double space[]);


/* Eigen function for codon models */
int EigenREV_Codon (double Root_C[], double Cijk_C[])
{

	int i,j,k;
	double U[NUMCOD*NUMCOD], V[NUMCOD*NUMCOD], T1[NUMCOD*NUMCOD], T2[NUMCOD*NUMCOD];
	
	
	nDIGITS = 40; /* no. of digits to the base BASE in the fraction */
	abyx (1/mr, Qij_CC, NUMCOD*NUMCOD);
	
	if ((k=eigen (1, Qij_CC, NUMCOD, Root_C, T1, U, V, T2))!=0) {
		fprintf(stderr, "\ncomplex roots in EigenREV_Codon (k = %d)", k);
		exit(0);
	}
	xtoy (U, V, NUMCOD*NUMCOD);
	matinv (V, NUMCOD, NUMCOD, T1);
	
	for (i=0; i<NUMCOD; i++) 
   		for (j=0; j<NUMCOD; j++) 
   			for (k=0; k<NUMCOD; k++)
   				Cijk_C[i*NUMCOD*NUMCOD+j*NUMCOD+k] = U[i*NUMCOD+k]*V[k*NUMCOD+j];
	
	/*fprintf(stderr, "\nCijk_C[10*NUMCOD*NUMCOD+10*NUMCOD+10] = %d\n", Cijk_C[10*NUMCOD*NUMCOD+10*NUMCOD+10]);
	fprintf(stderr, "\nCijk_C[5*NUMCOD*NUMCOD+5*NUMCOD+5] = %d\n", Cijk_C[5*NUMCOD*NUMCOD+5*NUMCOD+5]);*/			
			
	return (0);
}



/* Eigen function for amino acid models */
int EigenREV_AA (double Root_AA[], double Cijk_AA[])
{

	int i,j,k;
	double U[NUMAA*NUMAA], V[NUMAA*NUMAA], T1[NUMAA*NUMAA], T2[NUMAA*NUMAA];
	
	
	nDIGITS = 53; /* no. of digits to the base BASE in the fraction. In case it fails, try 40 and 30 */
	abyx (1/mr, Qij_AAa, NUMAA*NUMAA);
	
	if ((k=eigen (1, Qij_AAa, NUMAA, Root_AA, T1, U, V, T2))!=0) {
		fprintf(stderr, "\ncomplex roots in EigenREV_AA (k = %d)", k);
		exit(0);
	}
	xtoy (U, V, NUMAA*NUMAA);
	matinv (V, NUMAA, NUMAA, T1);
	
	for (i=0; i<NUMAA; i++) 
   		for (j=0; j<NUMAA; j++) 
   			for (k=0; k<NUMAA; k++)
   				Cijk_AA[i*NUMAA*NUMAA+j*NUMAA+k] = U[i*NUMAA+k]*V[k*NUMAA+j];
	
	/*fprintf(stderr, "\nCijk_AA[10*NUMAA*NUMAA+10*NUMAA+10] = %d\n", Cijk_AA[10*NUMAA*NUMAA+10*NUMAA+10]);
	fprintf(stderr, "\nCijk_AA[5*NUMAA*NUMAA+5*NUMAA+5] = %d\n", Cijk_AA[5*NUMAA*NUMAA+5*NUMAA+5]);*/			
			
	return (0);
}





/* Eigen function for nucleotide models */
int EigenREV (double Root[], double Cijk[])
{

	int i,j,k;
	double U[16], V[16], T1[16], T2[16];
	
	nDIGITS = 53; /* no. of digits to the base BASE in the fraction */
	abyx (1/mr, Qij, 16);

	if ((k=eigen (1, Qij, 4, Root, T1, U, V, T2))!=0) 
		{
		fprintf(fpmpi, "\ncomplex roots in EigenREV");
		exit(0);
		}
	xtoy (U, V, 16);
	matinv (V, 4, 4, T1);
	for (i=0; i<4; i++) 
   		for (j=0; j<4; j++) 
   			for (k=0; k<4; k++)
   				Cijk[i*4*4+j*4+k] = U[i*4+k]*V[k*4+j];
				
	return (0);
}





int abyx (double a, double x[], int n)
{ int i; for (i=0; i<n; x[i]*=a,i++) ; return(0); }
int xtoy (double x[], double y[], int n)
{ int i; for (i=0; i<n; y[i]=x[i],i++) ; return(0); }
int matinv( double x[], int n, int m, double space[])
{
/* x[n*m] ... m>=n
*/
  register int i,j,k;
  int *irow=(int*) space;
  double ee=1.0e-20, t,t1,xmax;
  double det=1.0;

  for (i=0; i<n; i++) {
     xmax = 0.;
     for (j=i; j<n; j++) {
	 if (xmax < fabs(x[j*m+i])) {
	   xmax = fabs( x[j*m+i] );
	   irow[i] = j;
	 }
     }
     det *= xmax;
     if (xmax < ee)  {
	 
	 #ifdef MPI
		fprintf (stderr, "\nDet becomes zero at %3d!\t\n", i+1);
	 #else
		fprintf (stderr, "\nDet becomes zero at %3d!\t\n", i+1);
	 #endif
	 return(-1);
     }
     if (irow[i] != i) {
	 for (j=0; j<m; j++) {
	   t = x[i*m+j];
	   x[i*m+j] = x[irow[i] * m + j];
	   x[ irow[i] * m + j] = t;
	 }
     }
     t = 1./x[i*m+i];
     for (j=0; j<n; j++) {
	 if (j == i) continue;
	 t1 = t*x[j*m+i];
	 for (k=0; k<n; k++) x[j*m+k] -= t1*x[i*m+k];
	 x[j*m+i] = -t1;
     }
     for (j=0; j<m; j++)  x[i*m+j] *= t;
     x[i*m+i] = t;
  }                           /* i */
  for (i=n-1; i>=0; i--) {
     if (irow[i] == i) continue;
     for (j=0; j<n; j++) {
	 t = x[j*m+i];
	 x[j*m+i] = x[ j*m + irow[i] ];
	 x[ j*m + irow[i] ] = t;
     }
  }
  return (0);
}





/***********************************************************
* This eigen() works for eigenvalue/vector analysis
*        for real general square matrix A
*        A will be destroyed
*        rr,ri are vectors containing eigenvalues
*        vr,vi are matrices containing (right) eigenvectors
*
*             A*[vr+vi*i] = [vr+vi*i] * diag{rr+ri*i}
*
* Algorithm: Handbook for Automatic Computation, vol 2
*            by Wilkinson and Reinsch, 1971
*            most of source codes were taken from a public domain
*            solftware called MATCALC.
* Credits:  to the authors of MATCALC
*
* return    -1 not converged
*             0 no complex eigenvalues/vectors
*             1 complex eigenvalues/vectors
* Tianlin Wang at University of Illinois
* Thu May 6 15:22:31 CDT 1993
***************************************************************/

#define FOR(i,n) for(i=0; i<n; i++)
#define FPN(file) fputc('\n', file)
#define MIN(a,b) ((a)<(b)?(a):(b))
#define MAX(a,b) ((a)>(b)?(a):(b))

#define pos(i,j,n)     ((i)*(n)+(j))

#define BASE       2   /* base of floating point arithmetic */
#define MAXITER   30   /* max. no. of iterations to converge */	
	
int eigen(int job, double A[], int n, double rr[], double ri[], 
         double vr[], double vi[], double work[])
{   
/* double work[n*2]: working space
*/
   int low,hi,i,j,k, it, istate=0;
   double tiny=sqrt(pow((double)BASE,(double)(1-nDIGITS))), t; 
	
   balance(A,n,&low,&hi,work);
   elemhess(job,A,n,low,hi,vr,vi, (int*)(work+n));

	if (-1 == realeig(job,A,n,low,hi,rr,ri,vr,vi)) return (-1);
	if (job) unbalance(n,vr,vi,low,hi,work);

/* sort, added by Z. Yang */
  for (i=0; i<n; i++) {
      for (j=i+1,it=i,t=rr[i]; j<n; j++)
          if (t<rr[j]) { t=rr[j]; it=j; }
      rr[it]=rr[i];  rr[i]=t;
      t=ri[it];      ri[it]=ri[i]; ri[i]=t;
      for (k=0; k<n; k++) {
         t=vr[k*n+it]; vr[k*n+it]=vr[k*n+i]; vr[k*n+i]=t;
         t=vi[k*n+it]; vi[k*n+it]=vi[k*n+i]; vi[k*n+i]=t;
      }
      if (fabs(ri[i])>tiny) istate=1;
  }

   return (istate) ;
}

/* complex funcctions
*/

complex compl (double re,double im)
{
   complex r;

   r.re = re;
   r.im = im;
   return(r);
}

complex cconj (complex a)
{
   a.im = -a.im;
   return(a);
}

#define csize(a) (fabs(a.re)+fabs(a.im))

complex cplus (complex a, complex b)
{
  complex c;
  c.re = a.re+b.re; 
  c.im = a.im+b.im;  
  return (c);
}

complex cminus (complex a, complex b)
{
  complex c;
  c.re = a.re-b.re; 
  c.im = a.im-b.im;  
  return (c);
}

complex cby (complex a, complex b)
{
  complex c;
  c.re = a.re*b.re-a.im*b.im ;
  c.im = a.re*b.im+a.im*b.re ;
  return (c);
}

complex cdiv (complex a,complex b)
{
   double ratio, den;
   complex c;

   if (fabs(b.re) <= fabs(b.im)) {
       ratio = b.re / b.im;
       den = b.im * (1 + ratio * ratio);
       c.re = (a.re * ratio + a.im) / den;
       c.im = (a.im * ratio - a.re) / den;
   }
   else {
       ratio = b.im / b.re;
       den = b.re * (1 + ratio * ratio);
       c.re = (a.re + a.im * ratio) / den;
       c.im = (a.im - a.re * ratio) / den;
   }
   return(c);
}

complex ccexp (complex a)
{
  complex c;
  c.re = exp(a.re);
  if (fabs(a.im)==0) c.im = 0; 
  else { c.im = c.re*sin(a.im); c.re*=cos(a.im); }
  return (c);
}

complex cfactor (complex x, double a)
{
  complex c;
  c.re = a*x.re; 
  c.im = a*x.im;
  return (c);
}

int cxtoy (complex x[], complex y[], int n)
{
  int i;
  FOR (i,n) y[i]=x[i];
  return (0);
}

int cmatby (complex a[], complex b[], complex c[], int n,int m,int k)
/* a[n*m], b[m*k], c[n*k] ...... c = a*b
*/
{
  int i,j,i1;
  complex t;

  FOR (i,n) FOR(j,k) {
      for (i1=0,t=compl(0,0); i1<m; i1++) 
          t = cplus (t, cby(a[i*m+i1],b[i1*k+j]));
      c[i*k+j] = t;
  }
  return (0);
}

int cmatout (FILE * fout, complex x[], int n, int m)
{
  int i,j;
  for (i=0,FPN(fout); i<n; i++,FPN(fout)) 
       FOR(j,m) fprintf(fout, "%7.3f%7.3f ", x[i*m+j].re, x[i*m+j].im);
  return (0);
}

int cmatinv( complex x[], int n, int m, double space[])
{
/* x[n*m] ... m>=n
*/
  int i,j,k, *irow=(int*) space;
  double xmaxsize, ee=1e-20;
  complex xmax, t,t1;

  FOR(i,n) {
      xmaxsize = 0.;
      for (j=i; j<n; j++) {
         if ( xmaxsize < csize (x[j*m+i])) {
              xmaxsize = csize (x[j*m+i]);
              xmax = x[j*m+i];
              irow[i] = j;
         }
      }
      if (xmaxsize < ee)  {
			
			#ifdef MPI
				fprintf (stderr, "\nDet goes to zero at %8d!\t\n", i+1);
			#else
				fprintf (stderr, "\nDet goes to zero at %8d!\t\n", i+1);
			#endif
          return(-1);
      }
      if (irow[i] != i) {
          FOR(j,m) {
               t = x[i*m+j];
               x[i*m+j] = x[irow[i]*m+j];
               x[ irow[i]*m+j] = t;
          }
      }
      t = cdiv (compl(1,0), x[i*m+i]);
      FOR(j,n) {
          if (j == i) continue;
          t1 = cby (t,x[j*m+i]);
          FOR(k,m) x[j*m+k] = cminus (x[j*m+k], cby(t1,x[i*m+k]));
          x[j*m+i] = cfactor (t1, -1);
      }
      FOR(j,m)  x[i*m+j] = cby (x[i*m+j], t);
      x[i*m+i] = t;
  }                        
  for (i=n-1; i>=0; i--) {
       if (irow[i] == i) continue;
       FOR(j,n) {
          t = x[j*m+i];
          x[j*m+i] = x[j*m+irow[i]];
          x[ j*m+irow[i]] = t;
       }
  }
  return (0);
}


void balance(double mat[], int n,int *low, int *hi, double scale[])
{
/* Balance a matrix for calculation of eigenvalues and eigenvectors
*/
   double c,f,g,r,s;
   int i,j,k,l,done;
       /* search for rows isolating an eigenvalue and push them down */
   for (k = n - 1; k >= 0; k--) {
       for (j = k; j >= 0; j--) {
           for (i = 0; i <= k; i++) {
               if (i != j && fabs(mat[pos(j,i,n)]) != 0) break;
           }

           if (i > k) {
               scale[k] = j;

               if (j != k) {
                   for (i = 0; i <= k; i++) {
                      c = mat[pos(i,j,n)];
                      mat[pos(i,j,n)] = mat[pos(i,k,n)];
                      mat[pos(i,k,n)] = c;
                   }

                   for (i = 0; i < n; i++) {
                      c = mat[pos(j,i,n)];
                      mat[pos(j,i,n)] = mat[pos(k,i,n)];
                      mat[pos(k,i,n)] = c;
                   }
               }
               break;
           }
       }
       if (j < 0) break;
   }

   /* search for columns isolating an eigenvalue and push them left */

   for (l = 0; l <= k; l++) {
       for (j = l; j <= k; j++) {
           for (i = l; i <= k; i++) {
               if (i != j && fabs(mat[pos(i,j,n)]) != 0) break;
           }
           if (i > k) {
               scale[l] = j;
               if (j != l) {
                   for (i = 0; i <= k; i++) {
                      c = mat[pos(i,j,n)];
                      mat[pos(i,j,n)] = mat[pos(i,l,n)];
                      mat[pos(i,l,n)] = c;
                   }

                   for (i = l; i < n; i++) {
                      c = mat[pos(j,i,n)];
                      mat[pos(j,i,n)] = mat[pos(l,i,n)];
                      mat[pos(l,i,n)] = c;
                   }
               }

               break;
           }
       }

       if (j > k) break;
   }

   *hi = k;
   *low = l;

   /* balance the submatrix in rows l through k */

   for (i = l; i <= k; i++) {
       scale[i] = 1;
   }

   do {
       for (done = 1,i = l; i <= k; i++) {
           for (c = 0,r = 0,j = l; j <= k; j++) {
               if (j != i) {
                   c += fabs(mat[pos(j,i,n)]);
                   r += fabs(mat[pos(i,j,n)]);
               }
           }

           if (c != 0 && r != 0) {
               g = r / BASE;
               f = 1;
               s = c + r;

               while (c < g) {
                   f *= BASE;
                   c *= BASE * BASE;
               }

               g = r * BASE;

               while (c >= g) {
                   f /= BASE;
                   c /= BASE * BASE;
               }

               if ((c + r) / f < 0.95 * s) {
                   done = 0;
                   g = 1 / f;
                   scale[i] *= f;

                   for (j = l; j < n; j++) {
                       mat[pos(i,j,n)] *= g;
                   }

                   for (j = 0; j <= k; j++) {
                       mat[pos(j,i,n)] *= f;
                   }
               }
           }
       }
   } while (!done);
}


/*
 * Transform back eigenvectors of a balanced matrix
 * into the eigenvectors of the original matrix
 */
void unbalance(int n,double vr[],double vi[], int low, int hi, double scale[])
{
   int i,j,k;
   double tmp;

   for (i = low; i <= hi; i++) {
       for (j = 0; j < n; j++) {
           vr[pos(i,j,n)] *= scale[i];
           vi[pos(i,j,n)] *= scale[i];
       }
   }

   for (i = low - 1; i >= 0; i--) {
       if ((k = (int)scale[i]) != i) {
           for (j = 0; j < n; j++) {
               tmp = vr[pos(i,j,n)];
               vr[pos(i,j,n)] = vr[pos(k,j,n)];
               vr[pos(k,j,n)] = tmp;

               tmp = vi[pos(i,j,n)];
               vi[pos(i,j,n)] = vi[pos(k,j,n)];
               vi[pos(k,j,n)] = tmp;       
           }
       }
   }

   for (i = hi + 1; i < n; i++) {
       if ((k = (int)scale[i]) != i) {
           for (j = 0; j < n; j++) {
               tmp = vr[pos(i,j,n)];
               vr[pos(i,j,n)] = vr[pos(k,j,n)];
               vr[pos(k,j,n)] = tmp;

               tmp = vi[pos(i,j,n)];
               vi[pos(i,j,n)] = vi[pos(k,j,n)];
               vi[pos(k,j,n)] = tmp;       
           }
       }
   }
}

/*
 * Reduce the submatrix in rows and columns low through hi of real matrix mat to
 * Hessenberg form by elementary similarity transformations
 */
void elemhess(int job,double mat[],int n,int low,int hi, double vr[],
             double vi[], int work[])
{
/* work[n] */
   int i,j,m;
   double x,y;

   for (m = low + 1; m < hi; m++) {
       for (x = 0,i = m,j = m; j <= hi; j++) {
           if (fabs(mat[pos(j,m-1,n)]) > fabs(x)) {
               x = mat[pos(j,m-1,n)];
               i = j;
           }
       }

       if ((work[m] = i) != m) {
           for (j = m - 1; j < n; j++) {
              y = mat[pos(i,j,n)];
              mat[pos(i,j,n)] = mat[pos(m,j,n)];
              mat[pos(m,j,n)] = y;
           }

           for (j = 0; j <= hi; j++) {
              y = mat[pos(j,i,n)];
              mat[pos(j,i,n)] = mat[pos(j,m,n)];
              mat[pos(j,m,n)] = y;
           }
       }

       if (x != 0) {
           for (i = m + 1; i <= hi; i++) {
               if ((y = mat[pos(i,m-1,n)]) != 0) {
                   y = mat[pos(i,m-1,n)] = y / x;

                   for (j = m; j < n; j++) {
                       mat[pos(i,j,n)] -= y * mat[pos(m,j,n)];
                   }

                   for (j = 0; j <= hi; j++) {
                       mat[pos(j,m,n)] += y * mat[pos(j,i,n)];
                   }
               }
           }
       }
   }
   if (job) {
      for (i=0; i<n; i++) {
         for (j=0; j<n; j++) {
            vr[pos(i,j,n)] = 0.0; vi[pos(i,j,n)] = 0.0;
         }
         vr[pos(i,i,n)] = 1.0;
      }

      for (m = hi - 1; m > low; m--) {
         for (i = m + 1; i <= hi; i++) {
            vr[pos(i,m,n)] = mat[pos(i,m-1,n)];
         }

        if ((i = work[m]) != m) {
           for (j = m; j <= hi; j++) {
              vr[pos(m,j,n)] = vr[pos(i,j,n)];
              vr[pos(i,j,n)] = 0.0;
           }
           vr[pos(i,m,n)] = 1.0;
        }
     }
  }
}

/*
 * Calculate eigenvalues and eigenvectors of a real upper Hessenberg matrix
 * Return 1 if converges successfully and 0 otherwise
 */
 
int realeig(int job,double mat[],int n,int low, int hi, double valr[],
     double vali[], double vr[],double vi[])
{
  complex v;
  double p=0,q=0,r=0,s=0,t,w,x,y,z=0,ra,sa,norm,eps;
  int niter,en,i,j,k,l,m;
  double precision = pow((double)BASE,(double)(1-nDIGITS));

  eps = precision;
  for (i=0; i<n; i++) {
     valr[i]=0.0;
     vali[i]=0.0;
  }
     /* store isolated roots and calculate norm */
  for (norm = 0,i = 0; i < n; i++) {
     for (j = MAX(0,i-1); j < n; j++) {
        norm += fabs(mat[pos(i,j,n)]);
     }
     if (i < low || i > hi) valr[i] = mat[pos(i,i,n)];
  }
  t = 0;
  en = hi;

  while (en >= low) {
     niter = 0;
     for (;;) {

      /* look for single small subdiagonal element */

        for (l = en; l > low; l--) {
           s = fabs(mat[pos(l-1,l-1,n)]) + fabs(mat[pos(l,l,n)]);
           if (s == 0) s = norm;
           if (fabs(mat[pos(l,l-1,n)]) <= eps * s) break;
        }

        /* form shift */

        x = mat[pos(en,en,n)];

        if (l == en) {            /* one root found */
           valr[en] = x + t;
           if (job) mat[pos(en,en,n)] = x + t;
           en--;
           break;
        }

        y = mat[pos(en-1,en-1,n)];
        w = mat[pos(en,en-1,n)] * mat[pos(en-1,en,n)];

        if (l == en - 1) {               /* two roots found */
           p = (y - x) / 2;
           q = p * p + w;
           z = sqrt(fabs(q));
           x += t;
           if (job) {
              mat[pos(en,en,n)] = x;
              mat[pos(en-1,en-1,n)] = y + t;
           }
           if (q < 0) {               /* complex pair */
              valr[en-1] = x+p;
              vali[en-1] = z;
              valr[en] = x+p;
              vali[en] = -z;
           }
           else {                     /* real pair */
              z = (p < 0) ? p - z : p + z;
              valr[en-1] = x + z;
              valr[en] = (z == 0) ? x + z : x - w / z;
              if (job) {
                 x = mat[pos(en,en-1,n)];
                 s = fabs(x) + fabs(z);
                 p = x / s;
                 q = z / s;
                 r = sqrt(p*p+q*q);
                 p /= r;
                 q /= r;
                 for (j = en - 1; j < n; j++) {
                    z = mat[pos(en-1,j,n)];
                    mat[pos(en-1,j,n)] = q * z + p *
                    mat[pos(en,j,n)];
                    mat[pos(en,j,n)] = q * mat[pos(en,j,n)] - p*z;
                 }
                 for (i = 0; i <= en; i++) {
                    z = mat[pos(i,en-1,n)];
                    mat[pos(i,en-1,n)] = q * z + p * mat[pos(i,en,n)];
                    mat[pos(i,en,n)] = q * mat[pos(i,en,n)] - p*z;
                 }
                 for (i = low; i <= hi; i++) {
                    z = vr[pos(i,en-1,n)];
                    vr[pos(i,en-1,n)] = q*z + p*vr[pos(i,en,n)];
                    vr[pos(i,en,n)] = q*vr[pos(i,en,n)] - p*z;
                 }
              }
           }
           en -= 2;
           break;
        }
        if (niter == MAXITER) return(-1);
        if (niter != 0 && niter % 10 == 0) {
           t += x;
           for (i = low; i <= en; i++) mat[pos(i,i,n)] -= x;
           s = fabs(mat[pos(en,en-1,n)]) + fabs(mat[pos(en-1,en-2,n)]);
           x = y = 0.75 * s;
           w = -0.4375 * s * s;
        }
        niter++;
          /* look for two consecutive small subdiagonal elements */
        for (m = en - 2; m >= l; m--) {
           z = mat[pos(m,m,n)];
           r = x - z;
           s = y - z;
           p = (r * s - w) / mat[pos(m+1,m,n)] + mat[pos(m,m+1,n)];
           q = mat[pos(m+1,m+1,n)] - z - r - s;
           r = mat[pos(m+2,m+1,n)];
           s = fabs(p) + fabs(q) + fabs(r);
           p /= s;
           q /= s;
           r /= s;
           if (m == l || fabs(mat[pos(m,m-1,n)]) * (fabs(q)+fabs(r)) <=
               eps * (fabs(mat[pos(m-1,m-1,n)]) + fabs(z) +
               fabs(mat[pos(m+1,m+1,n)])) * fabs(p)) break;
        }
        for (i = m + 2; i <= en; i++) mat[pos(i,i-2,n)] = 0;
        for (i = m + 3; i <= en; i++) mat[pos(i,i-3,n)] = 0;
            /* double QR step involving rows l to en and columns m to en */
        for (k = m; k < en; k++) {
           if (k != m) {
              p = mat[pos(k,k-1,n)];
              q = mat[pos(k+1,k-1,n)];
              r = (k == en - 1) ? 0 : mat[pos(k+2,k-1,n)];
              if ((x = fabs(p) + fabs(q) + fabs(r)) == 0) continue;
              p /= x;
              q /= x;
              r /= x;
           }
           s = sqrt(p*p+q*q+r*r);
           if (p < 0) s = -s;
           if (k != m) {
              mat[pos(k,k-1,n)] = -s * x;
           }
           else if (l != m) {
              mat[pos(k,k-1,n)] = -mat[pos(k,k-1,n)];
           }
           p += s;
           x = p / s;
           y = q / s;
           z = r / s;
           q /= p;
           r /= p;
               /* row modification */
           for (j = k; j <= (!job ? en : n-1); j++){
              p = mat[pos(k,j,n)] + q * mat[pos(k+1,j,n)];
              if (k != en - 1) {
                 p += r * mat[pos(k+2,j,n)];
                 mat[pos(k+2,j,n)] -= p * z;
              }
              mat[pos(k+1,j,n)] -= p * y;
              mat[pos(k,j,n)] -= p * x;
           }
           j = MIN(en,k+3);
             /* column modification */
           for (i = (!job ? l : 0); i <= j; i++) {
              p = x * mat[pos(i,k,n)] + y * mat[pos(i,k+1,n)];
              if (k != en - 1) {
                 p += z * mat[pos(i,k+2,n)];
                 mat[pos(i,k+2,n)] -= p*r;
              }
              mat[pos(i,k+1,n)] -= p*q;
              mat[pos(i,k,n)] -= p;
           }
           if (job) {            /* accumulate transformations */
              for (i = low; i <= hi; i++) {
                 p = x * vr[pos(i,k,n)] + y * vr[pos(i,k+1,n)];
                 if (k != en - 1) {
                    p += z * vr[pos(i,k+2,n)];
                    vr[pos(i,k+2,n)] -= p*r;
                 }
                 vr[pos(i,k+1,n)] -= p*q;
                 vr[pos(i,k,n)] -= p;
              }
           }
        }
     }
  }

  if (!job) return(0);
  if (norm != 0) {
      /* back substitute to find vectors of upper triangular form */
     for (en = n-1; en >= 0; en--) {
        p = valr[en];
        if ((q = vali[en]) < 0) {           /* complex vector */
           m = en - 1;
           if (fabs(mat[pos(en,en-1,n)]) > fabs(mat[pos(en-1,en,n)])) {
              mat[pos(en-1,en-1,n)] = q / mat[pos(en,en-1,n)];
              mat[pos(en-1,en,n)] = (p - mat[pos(en,en,n)]) /
                    mat[pos(en,en-1,n)];
           }
           else {
              v = cdiv(compl(0.0,-mat[pos(en-1,en,n)]),
                   compl(mat[pos(en-1,en-1,n)]-p,q));
              mat[pos(en-1,en-1,n)] = v.re;
              mat[pos(en-1,en,n)] = v.im;
           }
           mat[pos(en,en-1,n)] = 0;
           mat[pos(en,en,n)] = 1;
           for (i = en - 2; i >= 0; i--) {
              w = mat[pos(i,i,n)] - p;
              ra = 0;
              sa = mat[pos(i,en,n)];
              for (j = m; j < en; j++) {
                 ra += mat[pos(i,j,n)] * mat[pos(j,en-1,n)];
                 sa += mat[pos(i,j,n)] * mat[pos(j,en,n)];
              }
              if (vali[i] < 0) {
                 z = w;
                 r = ra;
                 s = sa;
              }
              else {
                 m = i;
                 if (vali[i] == 0) {
                    v = cdiv(compl(-ra,-sa),compl(w,q));
                    mat[pos(i,en-1,n)] = v.re;
                    mat[pos(i,en,n)] = v.im;
                 }
                 else {                     /* solve complex equations */
                    x = mat[pos(i,i+1,n)];
                    y = mat[pos(i+1,i,n)];
                    v.re = (valr[i]- p)*(valr[i]-p) + vali[i]*vali[i] - q*q;
                    v.im = (valr[i] - p)*2*q;
                    if ((fabs(v.re) + fabs(v.im)) == 0) {
                       v.re = eps * norm * (fabs(w) +
                               fabs(q) + fabs(x) + fabs(y) + fabs(z));
                    }
                    v = cdiv(compl(x*r-z*ra+q*sa,x*s-z*sa-q*ra),v);
                    mat[pos(i,en-1,n)] = v.re;
                    mat[pos(i,en,n)] = v.im;
                    if (fabs(x) > fabs(z) + fabs(q)) {
                       mat[pos(i+1,en-1,n)] = 
                            (-ra - w * mat[pos(i,en-1,n)] +
                            q * mat[pos(i,en,n)]) / x;
                       mat[pos(i+1,en,n)] = (-sa - w * mat[pos(i,en,n)] -
                            q * mat[pos(i,en-1,n)]) / x;
                    }
                    else {
                       v = cdiv(compl(-r-y*mat[pos(i,en-1,n)],
                            -s-y*mat[pos(i,en,n)]),compl(z,q));
                       mat[pos(i+1,en-1,n)] = v.re;
                       mat[pos(i+1,en,n)] = v.im;
                    }
                 }
              }
           }
        }
        else if (q == 0) {                            /* real vector */
           m = en;
           mat[pos(en,en,n)] = 1;
           for (i = en - 1; i >= 0; i--) {
              w = mat[pos(i,i,n)] - p;
              r = mat[pos(i,en,n)];
              for (j = m; j < en; j++) {
                 r += mat[pos(i,j,n)] * mat[pos(j,en,n)];
              }
              if (vali[i] < 0) {
                 z = w;
                 s = r;
              }
              else {
                 m = i;
                 if (vali[i] == 0) {
                    if ((t = w) == 0) t = eps * norm;
                    mat[pos(i,en,n)] = -r / t;
                 }
                 else {           /* solve real equations */
                    x = mat[pos(i,i+1,n)];
                    y = mat[pos(i+1,i,n)];
                    q = (valr[i] - p) * (valr[i] - p) + vali[i]*vali[i];
                    t = (x * s - z * r) / q;
                    mat[pos(i,en,n)] = t;
                    if (fabs(x) <= fabs(z)) {
                       mat[pos(i+1,en,n)] = (-s - y * t) / z;
                    }
                    else {
                       mat[pos(i+1,en,n)] = (-r - w * t) / x;
                    }
                 }
              }
           }
        }
     }
            /* vectors of isolated roots */
     for (i = 0; i < n; i++) {
        if (i < low || i > hi) {
           for (j = i; j < n; j++) {
              vr[pos(i,j,n)] = mat[pos(i,j,n)];
           }
        }
     }
      /* multiply by transformation matrix */

     for (j = n-1; j >= low; j--) {
        m = MIN(j,hi);
        for (i = low; i <= hi; i++) {
           for (z = 0,k = low; k <= m; k++) {
              z += vr[pos(i,k,n)] * mat[pos(k,j,n)];
           }
           vr[pos(i,j,n)] = z;
        }
     }
  }
   /* rearrange complex eigenvectors */
  for (j = 0; j < n; j++) {
     if (vali[j] != 0) {
        for (i = 0; i < n; i++) {
           vi[pos(i,j,n)] = vr[pos(i,j+1,n)];
           vr[pos(i,j+1,n)] = vr[pos(i,j,n)];
           vi[pos(i,j+1,n)] = -vi[pos(i,j,n)];
        }
        j++;
     }
  }
  return(0);
}
							/* End of Eigen */
/***********************************************************************/






/************************** gammasCalculate **********************************************/
/* Discrete Gamma's from an alpha (hetereogeneous rate) 
Purpose: sample mean (or median) values from a discrete gamma distribution
		 given an alpha and a number of equally-probable categories
*/

#define POINTGAMMA(prob_d,alpha_d,beta_d) 		PointChi2(prob_d,2.0*(alpha_d))/(2.0*(beta_d))

int		DiscreteGamma (double *rK, double alfa_d, double beta_d, int K_d, int median);
double 	IncompleteGamma (double x_d, double alpha_d, double LnGamma_alpha);
double 	PointChi2 (double prob_d, double v_d);
double	LnGamma (double alp);
double 	PointNormal (double prob_d);


int gammasCalculate (double alpha_d, int numCategories)
{
	/*int			i;*/

	DiscreteGamma (gammaRates, alpha_d, alpha_d, numCategories, 0); /* 0=means 1=medians */

	/*fprintf (stderr, "alpha = %.2f\nnumCategories = %d\nrates =",alpha_d, numCategories);
	for (i=0; i<numCategories; i++)
		 fprintf (stderr, " %.4f", gammaRates[i]);*/
	
	return(0);
}


// code below from Ziheng Yang's PAML (if I remember well)

/*---------------------------------------------------------------------------------
|
|  DiscreteGamma
|
|  Discretization of gamma distribution with equal proportions in each
|  category.
|
---------------------------------------------------------------------------------*/
int DiscreteGamma (double *rK, double alfa_d, double beta_d, int K_d, int median)

{

	int 			i;
	double 		gap05 = 1.0/(2.0*K_d), t, factor = alfa_d/beta_d*K_d, lnga1;

	if (median) 
		{
		for (i=0; i<K_d; i++) 
			rK[i] = POINTGAMMA((i*2.0+1.0)*gap05, alfa_d, beta_d);
		for (i=0,t=0; i<K_d; i++) 
			t += rK[i];
		for (i=0; i<K_d; i++)    
			rK[i] *= factor / t;
		}
	else 
		{
		lnga1 = LnGamma(alfa_d+1);
		/* calculate the points in the gamma distribution */
		for (i=0; i<K_d-1; i++) 
			rK[i] = POINTGAMMA((i+1.0)/K_d, alfa_d, beta_d);
		/* calculate the cumulative values */
		for (i=0; i<K_d-1; i++) 
			rK[i] = IncompleteGamma(rK[i] * beta_d, alfa_d + 1.0, lnga1);
		rK[K_d-1] = 1.0;
		/* calculate the relative values and rescale */
		for (i=K_d-1; i>0; i--)
			{
			rK[i] -= rK[i-1];
			rK[i] *= factor;
			}
		rK[0] *= factor;
		}

	return (0);
	
}


/*---------------------------------------------------------------------------------
|
|  IncompleteGamma
|
|  Returns the incomplete gamma ratio I(x_d,alpha) where x_d is the upper
|  limit of the integration and alpha is the shape parameter. Returns (-1)
|  if in error.  
|
|  Bhattacharjee, G. P. 1970. The incomplete gamma integral. Applied
|     Statistics, 19:285-287 (AS32)
|
---------------------------------------------------------------------------------*/
double IncompleteGamma (double x_d, double alpha_d, double LnGamma_alpha)

{

	int 			i;
	double 		p = alpha_d, g = LnGamma_alpha,
					accurate = 1e-8, overflow = 1e30,
					factor, gin = 0.0, rn = 0.0, a = 0.0, b = 0.0, an = 0.0, 
					dif = 0.0, term = 0.0, pn[6];

	if (x_d == 0.0) 
		return (0.0);
	if (x_d < 0 || p <= 0) 
		return (-1.0);

	factor = exp(p*log(x_d)-x_d-g);  
	if (x_d>1 && x_d>=p) 
		goto l30;
	gin = 1.0; 
	term = 1.0; 
	rn = p;
	l20:
		rn++;
		term *= x_d/rn;  
		gin += term;
		if (term > accurate) 
			goto l20;
		gin *= factor/p;
		goto l50;
	l30:
		a = 1.0-p;  
		b = a+x_d+1.0; 
		term = 0.0;
		pn[0] = 1.0; 
		pn[1] = x_d; 
		pn[2] = x_d+1; 
		pn[3] = x_d*b;
		gin = pn[2]/pn[3];
	l32:
		a++; 
		b += 2.0; 
		term++;  
		an = a*term;
		for (i=0; i<2; i++) 
			pn[i+4] = b*pn[i+2]-an*pn[i];
		if (pn[5] == 0) 
			goto l35;
		rn = pn[4]/pn[5];  
		dif = fabs(gin-rn);
		if (dif>accurate) 
			goto l34;
		if (dif<=accurate*rn) 
			goto l42;
	l34:
		gin = rn;
	l35:
		for (i=0; i<4; i++) 
			pn[i] = pn[i+2];
		if (fabs(pn[4]) < overflow) 
			goto l32;
		for (i=0; i<4; i++) 
			pn[i] /= overflow;
		goto l32;
	l42:
		gin = 1.0-factor*gin;
	l50:
		return (gin);

}



/*---------------------------------------------------------------------------------
|
|  PointChi2
|
|  Returns z so that Prob(x < z) = prob where x is Chi2 distributed with df=v. 
|  Returns -1 if in error.  0.000002 < prob < 0.999998.
|
---------------------------------------------------------------------------------*/
double PointChi2 (double prob_d, double v_d)

{

	double 		e = 0.5e-6, aa = 0.6931471805, p = prob_d, g,
					xx, c, ch, a = 0.0, q = 0.0, p1 = 0.0, p2 = 0.0, t = 0.0, 
					x_d = 0.0, b = 0.0, s1, s2, s3, s4, s5, s6;

	if (p < 0.000002 || p > 0.999998 || v_d <= 0.0) 
		return (-1.0);
	g = LnGamma (v_d/2.0);
	xx = v_d/2.0;  
	c = xx - 1.0;
	if (v_d >= -1.24*log(p)) 
		goto l1;
	ch = pow((p*xx*exp(g+xx*aa)), 1.0/xx);
	if (ch-e<0) 
		return (ch);
	goto l4;
	l1:
		if (v_d > 0.32) 
			goto l3;
		ch = 0.4;  
		a = log(1.0-p);
	l2:
		q = ch; 
		p1 = 1.0+ch*(4.67+ch); 
		p2 = ch*(6.73+ch*(6.66+ch));
		t = -0.5+(4.67+2.0*ch)/p1 - (6.73+ch*(13.32+3.0*ch))/p2;
		ch -= (1.0-exp(a+g+0.5*ch+c*aa)*p2/p1)/t;
		if (fabs(q/ch-1.0)-0.01 <= 0.0) 
			goto l4;
		else                      
			goto l2;
	l3: 
		x_d = PointNormal (p);
		p1 = 0.222222/v_d;  
		ch = v_d*pow((x_d*sqrt(p1)+1.0-p1), 3.0);
		if (ch > 2.2*v_d+6.0) 
			ch = -2.0*(log(1.0-p)-c*log(0.5*ch)+g);
	l4:
		q = ch;  
		p1 = 0.5*ch;
		if ((t = IncompleteGamma (p1, xx, g)) < 0.0) 
			{
			#ifdef MPI
			if (rank==root)
				fprintf (stderr, "%s  Error: Problem in PointChi2", " ");
			#else
			fprintf (stderr, "%s  Error: Problem in PointChi2", " ");
			#endif
			return (-1.0);
			}
		p2 = p-t;
		t = p2*exp(xx*aa+g+p1-c*log(ch));  
		b = t/ch; 
		a = 0.5*t-b*c;
		s1 = (210.0+a*(140.0+a*(105.0+a*(84.0+a*(70.0+60.0*a))))) / 420.0;
		s2 = (420.0+a*(735.0+a*(966.0+a*(1141.0+1278.0*a))))/2520.0;
		s3 = (210.0+a*(462.0+a*(707.0+932.0*a)))/2520.0;
		s4 = (252.0+a*(672.0+1182.0*a)+c*(294.0+a*(889.0+1740.0*a)))/5040.0;
		s5 = (84.0+264.0*a+c*(175.0+606.0*a)) / 2520.0;
		s6 = (120.0+c*(346.0+127.0*c)) / 5040.0;
		ch += t*(1+0.5*t*s1-b*c*(s1-b*(s2-b*(s3-b*(s4-b*(s5-b*s6))))));
		if (fabs(q/ch-1.0) > e) 
			goto l4;
		return (ch);

}



/*---------------------------------------------------------------------------------
|
|  LnGamma
|
|  Calculates the log of the gamma function. The Gamma function is equal
|  to:
|
|     Gamma(alp) = {integral from 0 to infinity} t^{alp-1} e^-t dt
|
|  The result is accurate to 10 decimal places. Stirling's formula is used
|  for the central polynomial part of the procedure.
|
|  Pike, M. C. and I. D. Hill. 1966. Algorithm 291: Logarithm of the gamma
|     function. Communications of the Association for Computing
|     Machinery, 9:684.
|     
---------------------------------------------------------------------------------*/
double LnGamma (double alp)

{

	double 		x_d = alp, f = 0.0, z;
	
	if (x_d < 7) 
		{
		f = 1.0; 
		z = x_d-1.0;
		while (++z < 7.0) 
			f *= z;
		x_d = z;  
		f = -log(f);
		}
	z = 1.0 / (x_d*x_d);
	return (f + (x_d-0.5)*log(x_d) - x_d + 0.918938533204673 + 
			(((-0.000595238095238*z+0.000793650793651)*z-0.002777777777778)*z +
			0.083333333333333)/x_d); 

}


/*---------------------------------------------------------------------------------
|
|  PointNormal
|
|  Returns z so That Prob{x<z} = prob where x ~ N(0,1) and
|  (1e-12) < prob < 1-(1e-12). Returns (-9999) if in error. 
|
|  Odeh, R. E. and J. O. Evans. 1974. The percentage points of the normal
|    distribution. Applied Statistics, 22:96-97 (AS70).
|
|  Newer methods:
|
|  Wichura, M. J. 1988. Algorithm AS 241: The percentage points of the
|     normal distribution. 37:477-484.
|  Beasley, JD & S. G. Springer. 1977. Algorithm AS 111: The percentage
|     points of the normal distribution. 26:118-121.
|
---------------------------------------------------------------------------------*/
double PointNormal (double prob_d)

{

	double 		a0 = -0.322232431088, a1 = -1.0, a2 = -0.342242088547, a3 = -0.0204231210245,
 					a4 = -0.453642210148e-4, b0 = 0.0993484626060, b1 = 0.588581570495,
 					b2 = 0.531103462366, b3 = 0.103537752850, b4 = 0.0038560700634,
 					y, z = 0, p = prob_d, p1;

	p1 = (p<0.5 ? p : 1-p);
	if (p1<1e-20) 
	  return (-9999);
	y = sqrt (log(1/(p1*p1)));  
	z = y + ((((y*a4+a3)*y+a2)*y+a1)*y+a0) / ((((y*b4+b3)*y+b2)*y+b1)*y+b0);
	
	return (p<0.5 ? -z : z);

}
						/* end of gamma's rate */
/**************************************************************************/









/******************************** CalcIndividualGi *********************************/
/* Calculates G, the number of potential locations in an active ancestral gamete 
  that a recombination event can take place */

static int CalcIndividualGi (int who, TreeNode *nodes, int *activeGametes, int numNuc, int *S_MRCA, int sizeNode)
{
	int			Gi, i, v, vv, position;
	int 		lessValue, MaxValue;
	/*int			*stud;*/
	TreeNode	*p;
	TreeSegment *s;
	lessValue = -1;
	MaxValue = -1;
	Gi = 0;
	position = 0;
	i = v = vv = 0;
		
	p = nodes + activeGametes[who];
	
	if (sizeNode != p->numSegNode)
		fprintf (fpmpi, "\n\nWarning in CalcIndividualGi, sizeNode != p->numSegNode");
	if (noisy == 4) 
		fprintf (fpmpi, "\nComputing Gi, node %d with %d fragment(s):",p->index,p->numSegNode);
	for (position = 0; position < p->numSegNode; position++)
		{
		s = segments + post(position,p->index,distance);
		if (noisy == 4)
			fprintf (fpmpi, "\nFragment %d, s->sStart = %d and s->sEnd = %d",s->sIndex, s->sStart, s->sEnd);
		}
			

	/* breakp between two fragments - trapped material*/
	for (position = 0; position < p->numSegNode; position++)
		{
		s = segments + post(position,p->index,distance);
			
		if (position == 0)
			{
			lessValue = s->sStart;
			MaxValue = s->sEnd;
			}			


		if (s->sStart < lessValue)
			{
			lessValue = s->sStart;
			}

		if (s->sEnd >= MaxValue)
			{
			MaxValue = s->sEnd;
			}
		}



	for (i = 1; i <= /*numSites*/numNuc; i++)
		{
		/*fprintf (fpmpi, "\n ******************* i = %d, MaxValue = %d, lessValue = %d, S_MRCA[i] = %d \n ", i, MaxValue, lessValue, S_MRCA[i]); */
		if (i > lessValue && i <= MaxValue && S_MRCA[i] > 1)	/* a segment with just one site cannot recombine */
			{
			Gi++;
			}
		}
	return Gi; 

}


/******************************** CalcIndividualGi_HotSpots *********************************/
/* Calculates G, the number of potential locations in an active ancestral gamete 
  that a recombination event can take place */
/*
static int CalcIndividualGi_HotSpots (int who, TreeNode *nodes, int *activeGametes, int numNuc, int *S_MRCA, int sizeNode)
{
	int			Gi, i, v, vv, position;
	int 		lessValue, MaxValue;
	int			init, last;
	TreeNode	*p;
	TreeSegment *s;

	lessValue = -1;
	MaxValue = -1;
	Gi = 0;
	position = 0;
	i = v = vv = init = last = 0;
	giBegin = 0;
	giEnd = 0;
	
	p = nodes + activeGametes[who];
	
	if (sizeNode != p->numSegNode)
		fprintf (fpmpi, "\n\nWarning in CalcIndividualGi, sizeNode != p->numSegNode");
	if (noisy == 4) 
		fprintf (fpmpi, "\nComputing Gi, node %d with %d fragment(s):",p->index,p->numSegNode);
	for (position = 0; position < p->numSegNode; position++)
		{
		s = segments + post(position,p->index,distance);
		if (noisy == 4)
			fprintf (fpmpi, "\nFragment %d, s->sStart = %d and s->sEnd = %d",s->sIndex, s->sStart, s->sEnd);
		}
*/			

	/* breakp between two fragments - trapped material*/
/*	for (position = 0; position < p->numSegNode; position++)
		{
		s = segments + post(position,p->index,distance);
			
		if (position == 0)
			{
			lessValue = s->sStart;
			MaxValue = s->sEnd;
			}			


		if (s->sStart < lessValue)
			{
			lessValue = s->sStart;
			}

		if (s->sEnd >= MaxValue)
			{
			MaxValue = s->sEnd;
			}
		}



	for (i = 1; i <= numNuc; i++)
		{*/
		/*fprintf (fpmpi, "\n ******************* i = %d, MaxValue = %d, lessValue = %d, S_MRCA[i] = %d \n ", i, MaxValue, lessValue, S_MRCA[i]); */
/*		if (i > lessValue && i <= MaxValue && S_MRCA[i] > 1)*/	/* a segment with just one site cannot recombine */
/*			{
			Gi++;
*/
			/* Begin - End for recombination hotspots */
/*			if (init == 0)
				giBegin = i;
			init++;
			last = i;				
			}
		}

	giEnd = last;*/ /* but this last can have sites with MRCA <= 0 before  */
	/*fprintf (stderr, "\n\nIn Gihotspfunct: giEnd (%d), giBegin (%d)", giEnd, giBegin);*/

/*	if (giEnd < giBegin)
		{
		fprintf (stderr, "\n\nERROR: giEnd (%d) < giBegin (%d)", giEnd, giBegin);
		exit(-1);
		}

	return Gi; 
}
*/








/******************************** IsValidBreakSite *********************************/
/* returns whether a site is potentially recombining: it has 
	  ancestral material non-MRCA before and after it */

static int 	IsValidBreakSite (int *activeGametes, TreeNode *nodes, int whichInd, int whichSite, int *S_MRCA) /* This function returns YES or NO about if the site is a potencial breakpoint (if it's in the ancestral material) or no */
{
	int			k, a, i, position;
	int 		lessValue, MaxValue;
	TreeNode	*p;
	TreeSegment *s;
	
	position = k = a = i = 0;
	lessValue = -1;
	MaxValue = -1;
	
	p = nodes + activeGametes[whichInd];
	for (position = 0; position < p->numSegNode; position++)
		{
		s = segments + post(position,p->index,distance);
		
		/* the breakpoint must to be in one or more segments & no S_MRCA (= 1) */
		if (s->sStart < whichSite && s->sEnd >= whichSite)	/* Ok, the breakpoint is in segments of this node */
			{
			k++;
			break;
			}
		}
	
	/* breakp between two fragments - trapped material*/
	if (k == 0)
		{
		for (position = 0; position < p->numSegNode; position++)
			{
			s = segments + post(position,p->index,distance);
			
			if (position == 0)
				{
				lessValue = s->sStart;
				MaxValue = s->sEnd;
				}			


			if (s->sStart < lessValue)
				{
				lessValue = s->sStart;
				}

			if (s->sEnd >= MaxValue)
				{
				MaxValue = s->sEnd;
				}
			}

		if (lessValue < whichSite && MaxValue >= whichSite)
			{
			k++;
			}	
		}

	

	if (whichSite < 0) /* Cheking */
		{
		k = 0;		
		fprintf (fpmpi, "\n Warning in IsValidBreakSite function, breakp = %d ", whichSite);
		exit (-1);
		}

	if (k != 0)
		if (S_MRCA[whichSite] > 1)	/* Ok, the breakpoint is not in the MRCA */
			a++;
				
								
	if (k > 0 && a > 0)
		return YES;
	else
		return NO;
}





/*********************************** CountsForExpNumRec **********************************/
/* Checks whether a recombination event should be counted in the expected number of 
  recombinations E(R). For E(R) count only events with breakpoints as X|X, X|0 or 0|X, 
  where X is ancestral material (i.e, 1), but that did not find yet its MRCA  */                                                                  

static int CountsForExpNumRec (int *activeGametes, int whichInd, int whichSite, TreeNode *nodes, int *S_MRCA, int sizeNode)
{
	int			k, j, a, i, position, FirstFragmentPos;
	TreeNode	*p;
	TreeSegment *s;
	int *initialVector, *endVector;

	position = 0;
	k = j = a = i = FirstFragmentPos = 0;
	
	initialVector = (int *)calloc(sizeNode,(long) sizeof(int));
	if (!initialVector)
		{
		fprintf (fpmpi, "Could not allocate initialVector (%lu bytes)\n", sizeNode *(long) sizeof(int));
		exit (1);
		}
	endVector = (int *)calloc(sizeNode,(long) sizeof(int));
	if (!endVector)
		{
		fprintf (fpmpi, "Could not allocate endVector (%lu bytes)\n", sizeNode *(long) sizeof(int));
		exit (1);
		}
	


	p = nodes + activeGametes[whichInd];
	if (p->numSegNode != sizeNode)
		fprintf (fpmpi, "Warning in CountsForExpNumRec function, p->numSegNode != sizeNode");		
		
	for (position = 0; position < p->numSegNode; position++)
		{
		s = segments + post(position,p->index,distance);
		initialVector[position] = s->sStart;
		endVector[position] = s->sEnd;
		}
		


	/* the breakpoint must to be in one or more segments (at first or into the segment) & no MRCA (> 1) */
	for (position = 0; position < p->numSegNode; position++)
		{
		if ((endVector[position] + 1) == whichSite)
			FirstFragmentPos++;
		}

	for (position = 0; position < p->numSegNode; position++)
		{		
		if (initialVector[position] < whichSite && endVector[position] >= whichSite)	/* Ok, the breakpoint is in these segments */
			k++;
		if (initialVector[position] == whichSite && FirstFragmentPos > 0) /* Ok, the breakpoint is in these segments */
			k++;
		}


	free (initialVector);
	free (endVector);
	if (whichSite < 0) /* Cheking */
		{
		k = 0;
		fprintf (fpmpi, "\n Warning in CountsForExpNumRec function ");
		exit (-1);
		}	
	if (k > 0)
		if (S_MRCA[whichSite] > 1 || S_MRCA[whichSite+1] > 1)	/* Ok, the breakpoint isn't S_MRCA */
			a++;
			
	if (k > 0 && a > 0)
		return YES;
	else
		return NO;
}




/********************* WhichNuc ************************/
/* Returns character representation for nucleotides */

char WhichNuc (int nucIeotide)
{
	if (nucIeotide == 0)
		return ('A');
	else if (nucIeotide == 1)
		return ('C');
	else if (nucIeotide == 2)
		return ('G');
	else if (nucIeotide == 3)
		return ('T');
	else
		return ('X');
}




/********************* WhichAA ************************/
/* Returns character representation for amino acids */
/* 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 */
	/* A R N D C Q E G H I L K M F P S T W Y V */ 
char WhichAA (int A_A)
{
	if (A_A == 0)
		return ('A');
	else if (A_A == 1)
		return ('R');
	else if (A_A == 2)
		return ('N');
	else if (A_A == 3)
		return ('D');
	else if (A_A == 4)
		return ('C');
	else if (A_A == 5)
		return ('Q');
	else if (A_A == 6)
		return ('E');
	else if (A_A == 7)
		return ('G');
	else if (A_A == 8)
		return ('H');
	else if (A_A == 9)
		return ('I');
	else if (A_A == 10)
		return ('L');
	else if (A_A == 11)
		return ('K');
	else if (A_A == 12)
		return ('M');
	else if (A_A == 13)
		return ('F');
	else if (A_A == 14)
		return ('P');
	else if (A_A == 15)
		return ('S');
	else if (A_A == 16)
		return ('T');
	else if (A_A == 17)
		return ('W');
	else if (A_A == 18)
		return ('Y');
	else if (A_A == 19)
		return ('V');
	else
		return ('X');
}










/********************* WhichNucNumber ************************/
/* Returns character representation for nucleotides */

int WhichNucNumber (char siteLetter)
{
	if (siteLetter == 'A')
		return (0);
	else if (siteLetter == 'C')
		return (1);
	else if (siteLetter == 'G')
		return (2);
	else if (siteLetter == 'T')
		return (3);
	else
		return (4);
}



/********************* WhichAANumber ************************/
/* Returns character representation for amino acids */
/* 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 */
	/* A R N D C Q E G H I L K M F P S T W Y V */ 

int WhichAANumber (char siteLetter)
{
	if (siteLetter == 'A')
		return (0);
	else if (siteLetter == 'R')
		return (1);
	else if (siteLetter == 'N')
		return (2);
	else if (siteLetter == 'D')
		return (3);
	else if (siteLetter == 'C')
		return (4);
	else if (siteLetter == 'Q')
		return (5);
	else if (siteLetter == 'E')
		return (6);
	else if (siteLetter == 'G')
		return (7);
	else if (siteLetter == 'H')
		return (8);
	else if (siteLetter == 'I')
		return (9);
	else if (siteLetter == 'L')
		return (10);
	else if (siteLetter == 'K')
		return (11);
	else if (siteLetter == 'M')
		return (12);
	else if (siteLetter == 'F')
		return (13);
	else if (siteLetter == 'P')
		return (14);
	else if (siteLetter == 'S')
		return (15);
	else if (siteLetter == 'T')
		return (16);
	else if (siteLetter == 'W')
		return (17);
	else if (siteLetter == 'Y')
		return (18);
	else if (siteLetter == 'V')
		return (19);
	else /* it never should be here */
		{
		fprintf (fpmpi, "\n Warning in WhichAANumber function ");
		exit (-1);
		}
}







/***************************** PrintSequences *******************************/
/* Prints sequences to alignment file */

static void PrintSequences (/*int replicate*/) 
{
	int		 i, j, m, dem, outgroupLabel;
	TreeNode	*f;
	
	dem = 0;
	outgroupLabel = 0;

    //fprintf(fpAlignment,"ReplicateN %d\n", NumReplicateABC);

    
    
	if (thereisOutgroup == YES)
		{
		fprintf(fpAlignment,"%d %d \n", numSequences+1, numNuc);
		/*fprintf(fpAlignment,"Dataset_%d %d %d \n", replicate+1, numSequences+1, numNuc);*/
		}
	else
		{
		/*fprintf(fpAlignment,"Dataset_%d %d %d \n", replicate+1, numSequences, numNuc);*/
		fprintf(fpAlignment,"%d %d \n", numSequences, numNuc);
		}
	
	if (doMigration == NO)
		{
		if(thereisOutgroup == YES)
			{
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 2)
					{
					outgroupLabel = f->label;
					break;
					}
				}
	
			for (i=0; i<numSequences+1; i++)
				{
				if (i == numSequences)
					fprintf(fpAlignment, "outgroup  ");
				else 
					fprintf (fpAlignment,"seq%05d  ", i+1);
				
				if (i == numSequences) /* outgroup */
					{
					for (j=1; j<=numNuc; j++)
						{
						fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(outgroupLabel,j,numNuc)]));
						}
					}
				else /* tip nodes */
					{
					for (j=1; j<=numNuc; j++)
						{
						fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
						}
					}
				fprintf (fpAlignment,"\n");
				}	
			fprintf (fpAlignment,"\n");
			/*fprintf(stderr,"\n sequence %d go with nodo of label %d \n", i+1, i+1);*/
			}
		else
			{
			for (i=0; i<numSequences; i++)
				{
				fprintf (fpAlignment,"seq%05d  ", i+1);

				for (j=1; j<=numNuc; j++)
					fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
				fprintf (fpAlignment,"\n");
				}	
			fprintf (fpAlignment,"\n");
			}
		}
	else /* migration */
		{
		if(thereisOutgroup == YES)
			{	

			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 2)
					{
					outgroupLabel = f->label;
					break;
					}
				}
			/*fprintf (stderr, "\n outgroupLabel = %d \n", outgroupLabel);*/


			for (i=0; i<numSequences+1; i++)
				{

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					if ((f->label == i) && (f->index < numSequences))
						{
						dem = f->indexOldMigPop;
						break;
						}
					}
				
				if (i == numSequences)
					fprintf(fpAlignment, "outgrp_p0 ");
				else 
					fprintf (fpAlignment,"s%05d_p%d ", i+1, dem);

				
				if (i == numSequences) /* outgroup */
					{
					for (j=1; j<=numNuc; j++)
						{
						fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(outgroupLabel,j,numNuc)]));
						}
					}
				else /* tip nodes */
					{
					for (j=1; j<=numNuc; j++)
						{
						fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
						}
					}

				fprintf (fpAlignment,"\n");
				}	
			fprintf (fpAlignment,"\n");
			}
		else
			{
			for (i=0; i<numSequences; i++)
				{
				/*for (m = 0; m < numNodex; m++)
					{
					f = nodex + m;
					if ((f->label == i) && (f->NetIndex < numSequences))
						{
						dem = f->indexOldMigPop;
						break;
						}
					}*/

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					if ((f->label == i) && (f->index < numSequences))
						{
						dem = f->indexOldMigPop;
						break;
						}
					}

				fprintf (fpAlignment,"s%05d_p%d ", i+1, dem);
				
				for (j=1; j<=numNuc; j++)
					{
					fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
					}
				
				fprintf (fpAlignment,"\n");
				}	
			fprintf (fpAlignment,"\n");
			}
		}
}
		


/***************************** PrintAncestralSequences *******************************/
/* Prints ancestral sequences to alignment file */

static void PrintAncestralSequences (/*int replicate*/)   
{
	int		 i, j, a, m, dem, outgroupLabel, rootLabel;
	TreeNode	*f;
	dem = 0;
	outgroupLabel = rootLabel = 0;

    //fprintf(fpAlignment,"ReplicateN %d\n", NumReplicateABC);

    
	if (numRE == 0) /* There are NOT recombinations */
		{
		if (thereisOutgroup == YES)
			{
			fprintf(fpAlignment,"%d %d\n", 2*numSequences, numNuc);
			/*fprintf(fpAlignment,"Dataset_%d %d %d\n", replicate+1, 2*numSequences, numNuc);*/
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 2)
					outgroupLabel = f->label;
				if (f->class == 5)
					rootLabel = f->label;
				}
			}
		else
			{
			fprintf(fpAlignment,"%d %d\n", 2*numSequences-1, numNuc);
			/*fprintf(fpAlignment,"Dataset_%d %d %d\n",replicate+1, 2*numSequences-1, numNuc);*/
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 5)
					rootLabel = f->label;
				}
			}


		
		if (doMigration == NO)
			{
			if(thereisOutgroup == YES)
				{	
				for (i=0; i<2*numSequences; i++)
					{
					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,"seq%05d  ", i+1);
					else if (i == numSequences)
						fprintf(fpAlignment, "outgroup  ");
					else if (i == 2*numSequences-1)
						fprintf (fpAlignment,"root      ");
					else
						fprintf (fpAlignment,"anc%05d  ", i+1);
		

					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
							}
						}
					else if (i == numSequences) /* is outgroup */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(outgroupLabel,j,numNuc)]));
							}
						}
					else if (i == 2*numSequences-1) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
					else  /* is ancestral */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i-1,j,numNuc)]));
							}
						}

					fprintf (fpAlignment,"\n");
					}
				fprintf (fpAlignment,"\n");
				}
			else
				{
				for (i=0; i<2*numSequences-1; i++)
					{
					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,"seq%05d  ", i+1);
					else if (i == 2*numSequences-2)
						fprintf (fpAlignment,"root      ");
					else
						fprintf (fpAlignment,"anc%05d  ", i+1);


					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
							}
						}
					else if (i == 2*numSequences-2) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
					else /* is ancestral */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
							}
						}
					fprintf (fpAlignment,"\n");
					}	
				fprintf (fpAlignment,"\n");
				}
			}
		else /* migration */
			{
			if(thereisOutgroup == YES)
				{	
				for (i=0; i<2*numSequences; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if ((f->label == i) && (f->index <= numSequences*2-2))
							{
							dem = f->indexOldMigPop;
							break;
							}
						}*/

					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;

						if (i < numSequences) /* tip */
							{
							if ((f->label == i) && (f->index <= numSequences*2-2)) 
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == 2*numSequences-1) /* root */
							{
							if (f->class == 5)
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == numSequences) /* outgroup */
							{
							dem = 0;
							break;
							}
						else /* ancestral */
							{
							if (f->label == i-1)
								{
								dem = f->indexOldMigPop;
								if (f->class != 4)
									{
									fprintf (stderr, "\n Warning in PrintAncestralSequences_C. f->label = %d, f->class = %d \n", f->label, f->class);
									exit(-1);
									}
								break;
								}
							}
						}
					
					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,"s%05d_p%d ", i+1, dem);
					else if (i == numSequences)
						fprintf(fpAlignment, "outgrp_p0 ");
					else if (i == 2*numSequences-1)
						fprintf (fpAlignment,"root_p%d   ", dem);
					else
						fprintf (fpAlignment,"a%05d_p%d ", i+1, dem);
		

					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
							}
						}
					else if (i == numSequences) /* is outgroup */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(outgroupLabel,j,numNuc)]));
							}
						}
					else if (i == 2*numSequences-1) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
					else  /* is ancestral */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i-1,j,numNuc)]));
							}
						}
					fprintf (fpAlignment,"\n");
					/*fprintf(stderr," \n\n sequence %d with label(in times file) %d", i+1, i+1);*/
					}	
				fprintf (fpAlignment,"\n");
				}
			else
				{
				for (i=0; i<2*numSequences-1; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if ((f->label == i) && (f->index <= numSequences*2-2))
							{
							dem = f->indexOldMigPop;
							break;
							}
						}*/

					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;

						if (i < numSequences) /* tip */
							{
							if ((f->label == i) && (f->index <= numSequences*2-2)) 
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == 2*numSequences-2) /* root */
							{
							if (f->class == 5)
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else /* ancestral */
							{
							if (f->label == i)
								{
								dem = f->indexOldMigPop;
								if (f->class != 4)
									{
									fprintf (stderr, "\n Warning in PrintAncestralSequences_C. f->label = %d, f->class = %d \n", f->label, f->class);
									exit(-1);
									}
								break;
								}
							}
						}
						
					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,"s%05d_p%d ", i+1, dem);
					else if (i == 2*numSequences-2)
						fprintf (fpAlignment,"root_p%d   ", dem);
					else
						fprintf (fpAlignment,"a%05d_p%d ", i+1, dem);

					
					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
							}
						}
					else if (i == 2*numSequences-2) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
					else /* is ancestral */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
							}
						}

					fprintf (fpAlignment,"\n");
					}	
				fprintf (fpAlignment,"\n");
				}
			}
		}
	else /* There are recombinations */
		{
		if (thereisOutgroup == YES)
			fprintf(fpAlignment,"%d %d \n", numSequences+2, numNuc);
			/*fprintf(fpAlignment,"Dataset_%d %d %d \n", replicate+1, numSequences+1, numNuc);*/
		else
			/*fprintf(fpAlignment,"Dataset_%d %d %d \n", replicate+1, numSequences, numNuc);*/
			fprintf(fpAlignment,"%d %d \n", numSequences+1, numNuc);
		
		if (doMigration == NO)
			{
			if(thereisOutgroup == YES)
				{	

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 2)
						outgroupLabel = f->label;
					if (f->class == 5)
						rootLabel = f->label;
					}		


				for (i=0; i<2*numSequences; i++)
					{
					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,"seq%05d  ", i+1);
						a++;
						}
					if (i == numSequences)
						{
						fprintf(fpAlignment, "outgroup  ");
						a++;
						}
					if (i == 2*numSequences-1)
						{
						fprintf (fpAlignment,"root      ");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{
						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == numSequences) /* is outgroup */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(outgroupLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-1) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}

						/*fprintf(stderr," \n\n sequence %d with label(in times file) %d", i+1, i+1);*/
						}
					}	
				fprintf (fpAlignment,"\n");
				}
			else
				{
				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 5)
						rootLabel = f->label;
					}


				for (i=0; i<2*numSequences-1; i++)
					{
					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,"seq%05d  ", i+1);
						a++;
						}
					if (i == 2*numSequences-2)
						{
						fprintf (fpAlignment,"root      ");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{

						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-2) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}


						}
					}	
				fprintf (fpAlignment,"\n");
				}
			}
		else /* migration */
			{
			if(thereisOutgroup == YES)
				{	
				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 2)
						outgroupLabel = f->label;
					if (f->class == 5)
						rootLabel = f->label;
					}	





				for (i=0; i<2*numSequences; i++)
					{					
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if (f->index < numSequences*/ /*|| i == 2*numSequences-1*//*)
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;*/
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
							/*	break;
								}
						}*/
					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;
						if (f->index < numSequences /*|| i == 2*numSequences-1*/)
							if (f->label == i)
								{
								dem = f->indexOldMigPop;
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								break;
								}
						}

					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,"s%05d_p%d ", i+1, dem);
						a++;
						}
					if (i == numSequences)
						{
						fprintf(fpAlignment, "outgrp_p0 ");
						a++;
						}
					if (i == 2*numSequences-1)
						{
						fprintf (fpAlignment,"root      ");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{

						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == numSequences) /* is outgroup */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(outgroupLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-1) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}

						}
					}	
				fprintf (fpAlignment,"\n");
				}
			else
				{

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 5)
						rootLabel = f->label;
					}


				for (i=0; i<2*numSequences-1; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if (f->index < numSequences*/ /*|| i == 2*numSequences-1*//*)
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;
								break;
								}
						}*/
					
					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;
						if (f->index < numSequences /*|| i == 2*numSequences-1*/)
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								break;
								}
						}


					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,"s%05d_p%d ", i+1, dem);
						a++;
						}
					if (i == 2*numSequences-2)
						{
						fprintf (fpAlignment,"root      ");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{
						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-2) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}

						}
					}	
				fprintf (fpAlignment,"\n");
				}

			}
		}
}
		








/***************************** PrintSequences_AA *******************************/
/* Prints sequences to alignment file */

static void PrintSequences_AA (/*int replicate*/) 
{
	int		 i, j, m, dem, outgroupLabel;
	TreeNode	*f;
	
	dem = 0;
	outgroupLabel = 0;


	if (thereisOutgroup == YES)
		{
		fprintf(fpAlignment,"%d %d \n", numSequences+1, numNuc);
		/*fprintf(fpAlignment,"Dataset_%d %d %d \n", replicate+1, numSequences+1, numNuc);*/
		}
	else
		{
		/*fprintf(fpAlignment,"Dataset_%d %d %d \n", replicate+1, numSequences, numNuc);*/
		fprintf(fpAlignment,"%d %d \n", numSequences, numNuc);
		}
	
	if (doMigration == NO)
		{
		if(thereisOutgroup == YES)
			{
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 2)
					{
					outgroupLabel = f->label;
					break;
					}
				}
	
			for (i=0; i<numSequences+1; i++)
				{
				if (i == numSequences)
					fprintf(fpAlignment, "outgroup  ");
				else 
					fprintf (fpAlignment,"seq%05d  ", i+1);
				
				if (i == numSequences) /* outgroup */
					{
					for (j=1; j<=numNuc; j++)
						{
						fprintf (fpAlignment, "%c", WhichAA(matrix[pos(outgroupLabel,j,numNuc)]));
						}
					}
				else /* tip nodes */
					{
					for (j=1; j<=numNuc; j++)
						{
						fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
						}
					}
				fprintf (fpAlignment,"\n");
				}	
			fprintf (fpAlignment,"\n");
			/*fprintf(stderr,"\n sequence %d go with nodo of label %d \n", i+1, i+1);*/
			}
		else
			{
			for (i=0; i<numSequences; i++)
				{
				fprintf (fpAlignment,"seq%05d  ", i+1);

				for (j=1; j<=numNuc; j++)
					fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
				fprintf (fpAlignment,"\n");
				}	
			fprintf (fpAlignment,"\n");
			}
		}
	else /* migration */
		{
		if(thereisOutgroup == YES)
			{	

			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 2)
					{
					outgroupLabel = f->label;
					break;
					}
				}
			/*fprintf (stderr, "\n outgroupLabel = %d \n", outgroupLabel);*/


			for (i=0; i<numSequences+1; i++)
				{

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					if ((f->label == i) && (f->index < numSequences))
						{
						dem = f->indexOldMigPop;
						break;
						}
					}
				
				if (i == numSequences)
					fprintf(fpAlignment, "outgrp_p0 ");
				else 
					fprintf (fpAlignment,"s%05d_p%d ", i+1, dem);

				
				if (i == numSequences) /* outgroup */
					{
					for (j=1; j<=numNuc; j++)
						{
						fprintf (fpAlignment, "%c", WhichAA(matrix[pos(outgroupLabel,j,numNuc)]));
						}
					}
				else /* tip nodes */
					{
					for (j=1; j<=numNuc; j++)
						{
						fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
						}
					}

				fprintf (fpAlignment,"\n");
				}	
			fprintf (fpAlignment,"\n");
			}
		else
			{
			for (i=0; i<numSequences; i++)
				{
				/*for (m = 0; m < numNodex; m++)
					{
					f = nodex + m;
					if ((f->label == i) && (f->NetIndex < numSequences))
						{
						dem = f->indexOldMigPop;
						break;
						}
					}*/

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					if ((f->label == i) && (f->index < numSequences))
						{
						dem = f->indexOldMigPop;
						break;
						}
					}

				fprintf (fpAlignment,"s%05d_p%d ", i+1, dem);
				
				for (j=1; j<=numNuc; j++)
					{
					fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
					}
				
				fprintf (fpAlignment,"\n");
				}	
			fprintf (fpAlignment,"\n");
			}
		}
}
		


/***************************** PrintAncestralSequences_AA *******************************/
/* Prints ancestral sequences to alignment file */

static void PrintAncestralSequences_AA (/*int replicate*/)   
{
	int		 i, j, a, m, dem, outgroupLabel, rootLabel;
	TreeNode	*f;
	dem = 0;
	outgroupLabel = rootLabel = 0;
    
    
	if (numRE == 0) /* There are NOT recombinations */
		{
		if (thereisOutgroup == YES)
			{
			fprintf(fpAlignment,"%d %d\n", 2*numSequences, numNuc);
			/*fprintf(fpAlignment,"Dataset_%d %d %d\n", replicate+1, 2*numSequences, numNuc);*/
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 2)
					outgroupLabel = f->label;
				if (f->class == 5)
					rootLabel = f->label;
				}
			}
		else
			{
			fprintf(fpAlignment,"%d %d\n", 2*numSequences-1, numNuc);
			/*fprintf(fpAlignment,"Dataset_%d %d %d\n",replicate+1, 2*numSequences-1, numNuc);*/
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 5)
					rootLabel = f->label;
				}
			}


		
		if (doMigration == NO)
			{
			if(thereisOutgroup == YES)
				{	
				for (i=0; i<2*numSequences; i++)
					{
					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,"seq%05d  ", i+1);
					else if (i == numSequences)
						fprintf(fpAlignment, "outgroup  ");
					else if (i == 2*numSequences-1)
						fprintf (fpAlignment,"root      ");
					else
						fprintf (fpAlignment,"anc%05d  ", i+1);
		

					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
							}
						}
					else if (i == numSequences) /* is outgroup */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(outgroupLabel,j,numNuc)]));
							}
						}
					else if (i == 2*numSequences-1) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
					else  /* is ancestral */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i-1,j,numNuc)]));
							}
						}

					fprintf (fpAlignment,"\n");
					}
				fprintf (fpAlignment,"\n");
				}
			else
				{
				for (i=0; i<2*numSequences-1; i++)
					{
					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,"seq%05d  ", i+1);
					else if (i == 2*numSequences-2)
						fprintf (fpAlignment,"root      ");
					else
						fprintf (fpAlignment,"anc%05d  ", i+1);


					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
							}
						}
					else if (i == 2*numSequences-2) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
					else /* is ancestral */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
							}
						}
					fprintf (fpAlignment,"\n");
					}	
				fprintf (fpAlignment,"\n");
				}
			}
		else /* migration */
			{
			if(thereisOutgroup == YES)
				{	
				for (i=0; i<2*numSequences; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if ((f->label == i) && (f->index <= numSequences*2-2))
							{
							dem = f->indexOldMigPop;
							break;
							}
						}*/

					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;

						if (i < numSequences) /* tip */
							{
							if ((f->label == i) && (f->index <= numSequences*2-2)) 
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == 2*numSequences-1) /* root */
							{
							if (f->class == 5)
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == numSequences) /* outgroup */
							{
							dem = 0;
							break;
							}
						else /* ancestral */
							{
							if (f->label == i-1)
								{
								dem = f->indexOldMigPop;
								if (f->class != 4)
									{
									fprintf (stderr, "\n Warning in PrintAncestralSequences_C. f->label = %d, f->class = %d \n", f->label, f->class);
									exit(-1);
									}
								break;
								}
							}
						}
					
					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,"s%05d_p%d ", i+1, dem);
					else if (i == numSequences)
						fprintf(fpAlignment, "outgrp_p0 ");
					else if (i == 2*numSequences-1)
						fprintf (fpAlignment,"root_p%d   ", dem);
					else
						fprintf (fpAlignment,"a%05d_p%d ", i+1, dem);
		

					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
							}
						}
					else if (i == numSequences) /* is outgroup */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(outgroupLabel,j,numNuc)]));
							}
						}
					else if (i == 2*numSequences-1) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
					else  /* is ancestral */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i-1,j,numNuc)]));
							}
						}
					fprintf (fpAlignment,"\n");
					/*fprintf(stderr," \n\n sequence %d with label(in times file) %d", i+1, i+1);*/
					}	
				fprintf (fpAlignment,"\n");
				}
			else
				{
				for (i=0; i<2*numSequences-1; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if ((f->label == i) && (f->index <= numSequences*2-2))
							{
							dem = f->indexOldMigPop;
							break;
							}
						}*/

					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;

						if (i < numSequences) /* tip */
							{
							if ((f->label == i) && (f->index <= numSequences*2-2)) 
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == 2*numSequences-2) /* root */
							{
							if (f->class == 5)
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else /* ancestral */
							{
							if (f->label == i)
								{
								dem = f->indexOldMigPop;
								if (f->class != 4)
									{
									fprintf (stderr, "\n Warning in PrintAncestralSequences_C. f->label = %d, f->class = %d \n", f->label, f->class);
									exit(-1);
									}
								break;
								}
							}
						}
						
					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,"s%05d_p%d ", i+1, dem);
					else if (i == 2*numSequences-2)
						fprintf (fpAlignment,"root_p%d   ", dem);
					else
						fprintf (fpAlignment,"a%05d_p%d ", i+1, dem);

					
					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
							}
						}
					else if (i == 2*numSequences-2) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
					else /* is ancestral */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
							}
						}

					fprintf (fpAlignment,"\n");
					}	
				fprintf (fpAlignment,"\n");
				}
			}
		}
	else /* There are recombinations */
		{
		if (thereisOutgroup == YES)
			fprintf(fpAlignment,"%d %d \n", numSequences+2, numNuc);
			/*fprintf(fpAlignment,"Dataset_%d %d %d \n", replicate+1, numSequences+1, numNuc);*/
		else
			/*fprintf(fpAlignment,"Dataset_%d %d %d \n", replicate+1, numSequences, numNuc);*/
			fprintf(fpAlignment,"%d %d \n", numSequences+1, numNuc);
		
		if (doMigration == NO)
			{
			if(thereisOutgroup == YES)
				{	

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 2)
						outgroupLabel = f->label;
					if (f->class == 5)
						rootLabel = f->label;
					}		


				for (i=0; i<2*numSequences; i++)
					{
					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,"seq%05d  ", i+1);
						a++;
						}
					if (i == numSequences)
						{
						fprintf(fpAlignment, "outgroup  ");
						a++;
						}
					if (i == 2*numSequences-1)
						{
						fprintf (fpAlignment,"root      ");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{
						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == numSequences) /* is outgroup */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichAA(matrix[pos(outgroupLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-1) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}

						/*fprintf(stderr," \n\n sequence %d with label(in times file) %d", i+1, i+1);*/
						}
					}	
				fprintf (fpAlignment,"\n");
				}
			else
				{
				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 5)
						rootLabel = f->label;
					}


				for (i=0; i<2*numSequences-1; i++)
					{
					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,"seq%05d  ", i+1);
						a++;
						}
					if (i == 2*numSequences-2)
						{
						fprintf (fpAlignment,"root      ");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{

						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-2) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}


						}
					}	
				fprintf (fpAlignment,"\n");
				}
			}
		else /* migration */
			{
			if(thereisOutgroup == YES)
				{	
				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 2)
						outgroupLabel = f->label;
					if (f->class == 5)
						rootLabel = f->label;
					}	


				for (i=0; i<2*numSequences; i++)
					{					
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if (f->index < numSequences*/ /*|| i == 2*numSequences-1*//*)
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;*/
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
							/*	break;
								}
						}*/
					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;
						if (f->index < numSequences /*|| i == 2*numSequences-1*/)
							if (f->label == i)
								{
								dem = f->indexOldMigPop;
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								break;
								}
						}

					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,"s%05d_p%d ", i+1, dem);
						a++;
						}
					if (i == numSequences)
						{
						fprintf(fpAlignment, "outgrp_p0 ");
						a++;
						}
					if (i == 2*numSequences-1)
						{
						fprintf (fpAlignment,"root      ");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{

						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == numSequences) /* is outgroup */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichAA(matrix[pos(outgroupLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-1) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}

						}
					}	
				fprintf (fpAlignment,"\n");
				}
			else
				{

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 5)
						rootLabel = f->label;
					}


				for (i=0; i<2*numSequences-1; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if (f->index < numSequences*/ /*|| i == 2*numSequences-1*//*)
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;
								break;
								}
						}*/
					
					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;
						if (f->index < numSequences /*|| i == 2*numSequences-1*/)
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								break;
								}
						}


					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,"s%05d_p%d ", i+1, dem);
						a++;
						}
					if (i == 2*numSequences-2)
						{
						fprintf (fpAlignment,"root      ");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{
						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-2) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}

						}
					}	
				fprintf (fpAlignment,"\n");
				}

			}
		}
}
		










/***************************** PrintSequences for codon Model *******************************/
/* Prints sequences to alignment file in phylip sequential format */

static void PrintSequences_C (/*int replicate*/)
{
	int		 i, j, k, m, dem, outgroupLabel;
	char codon[3];
	TreeNode	*f;
	dem = 0;
	outgroupLabel = 0;
	
	if (thereisOutgroup == YES)
		{
		fprintf(fpAlignment,"%d %d \n", numSequences+1, numNuc);
		/*fprintf(fpAlignment,"Dataset_%d %d %d \n", replicate+1, numSequences+1, numNuc);*/
		}
	else
		{
		/*fprintf(fpAlignment,"Dataset_%d %d %d \n", replicate+1, numSequences, numNuc);*/
		fprintf(fpAlignment,"%d %d \n", numSequences, numNuc);
		}
	
	if (doMigration == NO)
		{
		if(thereisOutgroup == YES)
			{
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 2)
					{
					outgroupLabel = f->label;
					break;
					}
				}
	
			for (i=0; i<numSequences+1; i++)
				{
				if (i == numSequences)
					fprintf(fpAlignment, "outgroup  ");
				else 
					fprintf (fpAlignment,"seq%05d  ", i+1);

				if (i == numSequences) /* outgroup */
					{
					for (j=1; j<=numSites; j++)
						{
						if (matrixC[pos(outgroupLabel,j,numSites)] > 60 || matrixC[pos(outgroupLabel,j,numSites)] > 60)
							{
							fprintf (stderr, "\n stop codon5 \n");
							exit(-1);
							}
						number_to_codon(matrixC[pos(outgroupLabel,j,numSites)], codon);
						for (k = 0; k < 3; k++)
							fprintf (fpAlignment, "%c", codon[k]);
						}
					}
				else /* tip nodes */
					{
					for (j=1; j<=numSites; j++)
						{
						if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
							{
							fprintf (stderr, "\n stop codon5 \n");
							exit(-1);
							}
						number_to_codon(matrixC[pos(i,j,numSites)], codon);
						for (k = 0; k < 3; k++)
							fprintf (fpAlignment, "%c", codon[k]);
						}
					}
				fprintf (fpAlignment,"\n");
				/*fprintf(stderr,"\n sequence %d go with nodo of label %d \n", i+1, i+1);*/
				}	
			fprintf (fpAlignment,"\n");
			}
		else
			{
			for (i=0; i<numSequences; i++)
				{
				fprintf (fpAlignment,"seq%05d  ", i+1);

				for (j=1; j<=numSites; j++)
					{
					if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
						{
						fprintf (stderr, "\n stop codon6 \n");
						exit(-1);
						}
					number_to_codon(matrixC[pos(i,j,numSites)], codon);
					for (k = 0; k < 3; k++)
						fprintf (fpAlignment, "%c", codon[k]);
					}
				fprintf (fpAlignment,"\n");
				}	
			fprintf (fpAlignment,"\n");
			}
		}
	else /* migration */
		{
		if(thereisOutgroup == YES)
			{
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 2)
					{
					outgroupLabel = f->label;
					break;
					}
				}
			/*fprintf (stderr, "\n outgroupLabel = %d \n", outgroupLabel);*/
			

			for (i=0; i<numSequences+1; i++)
				{
				/*for (m = 0; m < numNodex; m++)
					{
					f = nodex + m;
					if ((f->label == i) && (f->NetIndex < numSequences))
						{
						dem = f->indexOldMigPop;
						break;
						}
					}*/
				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					if ((f->label == i) && (f->index < numSequences))
						{
						dem = f->indexOldMigPop;
						break;
						}
					}		
		
				if (i == numSequences)
					fprintf(fpAlignment, "outgrp_p0 ");
				else 
					fprintf (fpAlignment,"s%05d_p%d ", i+1, dem);
				
				if (i == numSequences) /* outgroup */
					{
					for (j=1; j<=numSites; j++)
						{
						if (matrixC[pos(outgroupLabel,j,numSites)] > 60 || matrixC[pos(outgroupLabel,j,numSites)] > 60)
							{
							fprintf (stderr, "\n stop codon7 \n");
							exit(-1);
							}
						number_to_codon(matrixC[pos(outgroupLabel,j,numSites)], codon);
						for (k = 0; k < 3; k++)
							fprintf (fpAlignment, "%c", codon[k]);
						}
					}
				else /* tip nodes */
					{
					for (j=1; j<=numSites; j++)
						{
						if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
							{
							fprintf (stderr, "\n stop codon7 \n");
							exit(-1);
							}
						number_to_codon(matrixC[pos(i,j,numSites)], codon);
						for (k = 0; k < 3; k++)
							fprintf (fpAlignment, "%c", codon[k]);
						}
					}

				fprintf (fpAlignment,"\n");
				/*fprintf(stderr,"\n sequence %d go with node label(times file label) %d \n", i+1, i+1);*/
				}	
			fprintf (fpAlignment,"\n");
			}
		else
			{
			for (i=0; i<numSequences; i++)
				{
				/*for (m = 0; m < numNodex; m++)
					{
					f = nodex + m;
					if ((f->label == i) && (f->NetIndex < numSequences))
						{
						dem = f->indexOldMigPop;
						break;
						}
					}*/
				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					if ((f->label == i) && (f->index < numSequences))
						{
						dem = f->indexOldMigPop;
						break;
						}
					}
					
				fprintf (fpAlignment,"s%05d_p%d ", i+1, dem);

				for (j=1; j<=numSites; j++)
					{
					if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
						{
						fprintf (stderr, "\n stop codon8 \n");
						exit(-1);
						}
					number_to_codon(matrixC[pos(i,j,numSites)], codon);
					for (k = 0; k < 3; k++)
						fprintf (fpAlignment, "%c", codon[k]);
					}
				fprintf (fpAlignment,"\n");
				}	
			fprintf (fpAlignment,"\n");
			}
		}
}
		


/***************************** PrintAncestralSequences for Codon Model *******************************/
/* Prints ancestral sequences to alignment file for codon Model */

static void PrintAncestralSequences_C (/*int replicate*/)
{
	int		 i, j, k, a, m, dem, outgroupLabel, rootLabel;
	char codon[3];
	TreeNode	*f;
	dem = 0;
	outgroupLabel = rootLabel = 0;	

    //fprintf(fpAlignment,"ReplicateN %d\n", NumReplicateABC);
    
    
	if (numRE == 0) /* There are NOT recombinations */
		{
		if (thereisOutgroup == YES)
			{
			fprintf(fpAlignment,"%d %d\n", 2*numSequences, numNuc);
			/*fprintf(fpAlignment,"Dataset_%d %d %d\n", replicate+1, 2*numSequences, numNuc);*/
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 2)
					outgroupLabel = f->label;
				if (f->class == 5)
					rootLabel = f->label;
				}
			}
		else
			{
			fprintf(fpAlignment,"%d %d\n", 2*numSequences-1, numNuc);
			/*fprintf(fpAlignment,"Dataset_%d %d %d\n",replicate+1, 2*numSequences-1, numNuc);*/
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 5)
					rootLabel = f->label;
				}
			}
		

		if (doMigration == NO)
			{
			if (thereisOutgroup == YES)
				{	
				for (i=0; i<2*numSequences; i++)
					{
					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,"seq%05d  ", i+1);
					else if (i == numSequences)
						fprintf(fpAlignment, "outgroup  ");
					else if (i == 2*numSequences-1)
						fprintf (fpAlignment,"root      ");
					else
						fprintf (fpAlignment,"anc%05d  ", i+1);


					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon10 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(i,j,numSites)], codon);
							for (k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}
					else if (i == numSequences) /* is outgroup */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(outgroupLabel,j,numSites)] > 60 || matrixC[pos(outgroupLabel,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon10 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(outgroupLabel,j,numSites)], codon);
							for (k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}
					else if (i == 2*numSequences-1) /* is root */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon10 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
							for (k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}
					else  /* is ancestral */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(i-1,j,numSites)] > 60 || matrixC[pos(i-1,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon10 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(i-1,j,numSites)], codon);
							for (k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}

					fprintf (fpAlignment,"\n");
					}	
				fprintf (fpAlignment,"\n");
				}
			else
				{
				for (i=0; i<2*numSequences-1; i++)
					{
					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,"seq%05d  ", i+1);
					else if (i == 2*numSequences-2)
						fprintf (fpAlignment,"root      ");
					else
						fprintf (fpAlignment,"anc%05d  ", i+1);

					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon11 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(i,j,numSites)], codon);
							for	(k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}
					else if (i == 2*numSequences-2) /* is root */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon11 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
							for	(k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}
					else /* is ancestral */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon11 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(i,j,numSites)], codon);
							for	(k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}

					fprintf (fpAlignment,"\n");
					}	
				fprintf (fpAlignment,"\n");
				}
			}
		else /* migration */
			{
			if (thereisOutgroup == YES)
				{	
				for (i=0; i<2*numSequences; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodex + m;
						if ((f->label == i) && (f->NetIndex <= numSequences*2-2))
							{
							dem = f->indexOldMigPop;
							break;
							}
						}*/
					
					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;

						if (i < numSequences) /* tip */
							{
							if ((f->label == i) && (f->index <= numSequences*2-2)) 
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == 2*numSequences-1) /* root */
							{
							if (f->class == 5)
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == numSequences) /* outgroup */
							{
							dem = 0;
							break;
							}
						else /* ancestral */
							{
							if (f->label == i-1)
								{
								dem = f->indexOldMigPop;
								if (f->class != 4)
									{
									fprintf (stderr, "\n Warning in PrintAncestralSequences_C. f->label = %d, f->class = %d \n", f->label, f->class);
									exit(-1);
									}
								break;
								}
							}
						}



					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,"s%05d_p%d ", i+1, dem);
					else if (i == numSequences)
						fprintf(fpAlignment, "outgrp_p0 ");
					else if (i == 2*numSequences-1)
						fprintf (fpAlignment,"root_p%d   ",dem);
					else
						fprintf (fpAlignment,"a%05d_p%d ", i+1, dem);
		


					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon10 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(i,j,numSites)], codon);
							for (k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}
					else if (i == numSequences) /* is outgroup */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(outgroupLabel,j,numSites)] > 60 || matrixC[pos(outgroupLabel,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon10 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(outgroupLabel,j,numSites)], codon);
							for (k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}
					else if (i == 2*numSequences-1) /* is root */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon10 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
							for (k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}
					else  /* is ancestral */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(i-1,j,numSites)] > 60 || matrixC[pos(i-1,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon10 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(i-1,j,numSites)], codon);
							for (k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}


					fprintf (fpAlignment,"\n");
					}	
				fprintf (fpAlignment,"\n");
				}
			else
				{
				for (i=0; i<2*numSequences-1; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodex + m;
						if ((f->label == i) && (f->NetIndex <= numSequences*2-2))
							{
							dem = f->indexOldMigPop;
							break;
							}
						}*/
					
					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;

						if (i < numSequences) /* tip */
							{
							if ((f->label == i) && (f->index <= numSequences*2-2)) 
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == 2*numSequences-2) /* root */
							{
							if (f->class == 5)
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else /* ancestral */
							{
							if (f->label == i)
								{
								dem = f->indexOldMigPop;
								if (f->class != 4)
									{
									fprintf (stderr, "\n Warning in PrintAncestralSequences_C. f->label = %d, f->class = %d \n", f->label, f->class);
									exit(-1);
									}
								break;
								}
							}
						}



					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,"s%05d_p%d ", i+1, dem);
					else if (i == 2*numSequences-2)
						fprintf (fpAlignment,"root_p%d   ", dem);
					else
						fprintf (fpAlignment,"a%05d_p%d ", i+1, dem);


					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon11 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(i,j,numSites)], codon);
							for	(k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}
					else if (i == 2*numSequences-2) /* is root */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon11 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
							for	(k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}
					else /* is ancestral */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon11 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(i,j,numSites)], codon);
							for	(k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}

					fprintf (fpAlignment,"\n");

					}	
				}
			fprintf (fpAlignment,"\n");
			}
		}
	else /* There are recombinations */
		{
		if (thereisOutgroup == YES)
			fprintf(fpAlignment,"%d %d\n", numSequences+2, numNuc);
		else
			fprintf(fpAlignment,"%d %d\n", numSequences+1, numNuc);
		
		if (doMigration == NO)
			{
			if (thereisOutgroup == YES)
				{
				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 2)
						outgroupLabel = f->label;
					if (f->class == 5)
						rootLabel = f->label;
					}				
	
				for (i=0; i<2*numSequences; i++)
					{
					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,"seq%05d  ", i+1);
						a++;
						}
					if (i == numSequences)
						{
						fprintf(fpAlignment, "outgroup  ");
						a++;
						}
					if (i == 2*numSequences-1)
						{
						fprintf (fpAlignment,"root      ");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{
						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon14 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(i,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpAlignment, "%c", codon[k]);
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == numSequences) /* is outgroup */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(outgroupLabel,j,numSites)] > 60 || matrixC[pos(outgroupLabel,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon14 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(outgroupLabel,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpAlignment, "%c", codon[k]);
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-1) /* is root */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon14 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpAlignment, "%c", codon[k]);
								}
							fprintf (fpAlignment,"\n");
							}

						}
					}	
				fprintf (fpAlignment,"\n");
				}
			else
				{

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 5)
						rootLabel = f->label;
					}

				for (i=0; i<2*numSequences-1; i++)
					{
					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,"seq%05d  ", i+1);
						a++;
						}
					if (i == 2*numSequences-2)
						{
						fprintf (fpAlignment,"root      ");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{
						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon15 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(i,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpAlignment, "%c", codon[k]);
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-2) /* is root */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon15 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpAlignment, "%c", codon[k]);
								}
							fprintf (fpAlignment,"\n");
							}

						}
					}	
				fprintf (fpAlignment,"\n");
				}
			}
		else /* migration */
			{
			if (thereisOutgroup == YES)
				{	

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 2)
						outgroupLabel = f->label;
					if (f->class == 5)
						rootLabel = f->label;
					}	


				for (i=0; i<2*numSequences; i++)
					{

					/*for (m = 0; m < numNodex; m++)
						{
						f = nodex + m;
						if (f->NetIndex < numSequences*/ /*|| i == 2*numSequences-1*//*
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;*/
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								/*break;
								}
						}*/

					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;
						if (f->index < numSequences /*|| i == 2*numSequences-1*/)
							if (f->label == i)
								{
								dem = f->indexOldMigPop;
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								break;
								}
						}



					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,"s%05d_p%d ", i+1, dem);
						a++;
						}
					if (i == numSequences)
						{
						fprintf(fpAlignment, "outgrp_p0 ");
						a++;
						}
					if (i == 2*numSequences-1)
						{
						fprintf (fpAlignment,"root      ");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{

						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon16 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(i,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpAlignment, "%c", codon[k]);
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == numSequences) /* is outgroup */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(outgroupLabel,j,numSites)] > 60 || matrixC[pos(outgroupLabel,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon16 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(outgroupLabel,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpAlignment, "%c", codon[k]);
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-1) /* is root */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon16 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpAlignment, "%c", codon[k]);
								}
							fprintf (fpAlignment,"\n");
							}

						}
					}	
				fprintf (fpAlignment,"\n");
				}
			else
				{


				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 5)
						rootLabel = f->label;
					}

				for (i=0; i<2*numSequences-1; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodex + m;
						if (f->NetIndex < numSequences*/ /*|| i == 2*numSequences-1*//*)
							if (f->label == i)
								{
								dem = f->indexOldMigPop;*/
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								/*break;
								}
						}*/
					
					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;
						if (f->index < numSequences /*|| i == 2*numSequences-1*/)
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								break;
								}
						}



					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,"s%05d_p%d ", i+1, dem);
						a++;
						}
					if (i == 2*numSequences-2)
						{
						fprintf (fpAlignment,"root      ");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{
						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon17 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(i,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpAlignment, "%c", codon[k]);
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-2) /* is root */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon17 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpAlignment, "%c", codon[k]);
								}
							fprintf (fpAlignment,"\n");
							}


						}
					}	
				fprintf (fpAlignment,"\n");
				}
			}
		}
}






/***************************** PrintOutMRCAFiles (GMRCA) for nucleotide Model *******************************/
/* Prints just GMRCA files for nucleotide Model */
static void PrintOutMRCAFiles (/*int replicate*/)
{
int		 i, j, a, m, dem, outgroupLabel, rootLabel;
	TreeNode	*f;
	dem = 0;
	outgroupLabel = rootLabel = 0;

	if (numRE == 0) /* There are NOT recombinations */
		{
		if (thereisOutgroup == YES)
			{
			fprintf(fpMRCAprint,"%d %d\n", 1, numNuc);
			/*fprintf(fpMRCAprint,"Dataset_%d %d %d\n", replicate+1, 2*numSequences, numNuc);*/
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 2)
					outgroupLabel = f->label;
				if (f->class == 5)
					rootLabel = f->label;
				}
			}
		else
			{
			fprintf(fpMRCAprint,"%d %d\n", 1, numNuc);
			/*fprintf(fpMRCAprint,"Dataset_%d %d %d\n",replicate+1, 2*numSequences-1, numNuc);*/
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 5)
					rootLabel = f->label;
				}
			}


		
		if (doMigration == NO)
			{
			if(thereisOutgroup == YES)
				{	
				for (i=0; i<2*numSequences; i++)
					{
					if (i == 2*numSequences-1)
						fprintf (fpMRCAprint,"root      ");
							

					if (i == 2*numSequences-1) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpMRCAprint, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
					
					//fprintf (fpMRCAprint,"\n");
					}
			//	fprintf (fpMRCAprint,"\n");
				}
			else
				{
				for (i=0; i<2*numSequences-1; i++)
					{
					if (i == 2*numSequences-2)
						fprintf (fpMRCAprint,"root      ");
					

					if (i == 2*numSequences-2) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpMRCAprint, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
					
				//	fprintf (fpMRCAprint,"\n");
					}	
			//	fprintf (fpMRCAprint,"\n");
				}
			}
		else /* migration */
			{
			if(thereisOutgroup == YES)
				{	
				for (i=0; i<2*numSequences; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if ((f->label == i) && (f->index <= numSequences*2-2))
							{
							dem = f->indexOldMigPop;
							break;
							}
						}*/

					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;

						if (i < numSequences) /* tip */
							{
							if ((f->label == i) && (f->index <= numSequences*2-2)) 
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == 2*numSequences-1) /* root */
							{
							if (f->class == 5)
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == numSequences) /* outgroup */
							{
							dem = 0;
							break;
							}
						else /* ancestral */
							{
							if (f->label == i-1)
								{
								dem = f->indexOldMigPop;
								if (f->class != 4)
									{
									fprintf (stderr, "\n Warning in PrintAncestralSequences_C. f->label = %d, f->class = %d \n", f->label, f->class);
									exit(-1);
									}
								break;
								}
							}
						}
					
				
					if (i == 2*numSequences-1)
						fprintf (fpMRCAprint,"root      ");
					if (i == 2*numSequences-1) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpMRCAprint, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
					
				//	fprintf (fpMRCAprint,"\n");
					/*fprintf(stderr," \n\n sequence %d with label(in times file) %d", i+1, i+1);*/
					}	
			//	fprintf (fpMRCAprint,"\n");
				}
			else
				{
				for (i=0; i<2*numSequences-1; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if ((f->label == i) && (f->index <= numSequences*2-2))
							{
							dem = f->indexOldMigPop;
							break;
							}
						}*/

					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;

						if (i < numSequences) /* tip */
							{
							if ((f->label == i) && (f->index <= numSequences*2-2)) 
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == 2*numSequences-2) /* root */
							{
							if (f->class == 5)
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else /* ancestral */
							{
							if (f->label == i)
								{
								dem = f->indexOldMigPop;
								if (f->class != 4)
									{
									fprintf (stderr, "\n Warning in PrintAncestralSequences_C. f->label = %d, f->class = %d \n", f->label, f->class);
									exit(-1);
									}
								break;
								}
							}
						}
						
					
					if (i == 2*numSequences-2)
						fprintf (fpMRCAprint,"root      ");
										
					else if (i == 2*numSequences-2) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpMRCAprint, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
				
				//	fprintf (fpMRCAprint,"\n");
					}	
			//	fprintf (fpMRCAprint,"\n");
				}
			}
		}
	else /* There are recombinations */
		{
		if (thereisOutgroup == YES)
			fprintf(fpMRCAprint,"%d %d \n", 1, numNuc);
			/*fprintf(fpMRCAprint,"Dataset_%d %d %d \n", replicate+1, numSequences+1, numNuc);*/
		else
			/*fprintf(fpMRCAprint,"Dataset_%d %d %d \n", replicate+1, numSequences, numNuc);*/
			fprintf(fpMRCAprint,"%d %d \n", 1, numNuc);
		
		if (doMigration == NO)
			{
			if(thereisOutgroup == YES)
				{	

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 2)
						outgroupLabel = f->label;
					if (f->class == 5)
						rootLabel = f->label;
					}		


				for (i=0; i<2*numSequences; i++)
					{
					a = 0;
					if (i < numSequences) /* is tip */
						{
				//		fprintf (fpMRCAprint,"seq%05d  ", i+1);
						a++;
						}
					if (i == numSequences)
						{
				//		fprintf(fpMRCAprint, "outgroup  ");
						a++;
						}
					if (i == 2*numSequences-1)
						{
						fprintf (fpMRCAprint,"root      ");
						a++;
						}
					/*else
						fprintf (fpMRCAprint,"anc%05d  ", i+1);*/
					if (a != 0)
						{
						if (i == 2*numSequences-1) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpMRCAprint, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
								}
					//		fprintf (fpMRCAprint,"\n");
							}

						/*fprintf(stderr," \n\n sequence %d with label(in times file) %d", i+1, i+1);*/
						}
					}	
			//	fprintf (fpMRCAprint,"\n");
				}
			else
				{
				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 5)
						rootLabel = f->label;
					}


				for (i=0; i<2*numSequences-1; i++)
					{
					a = 0;
					if (i < numSequences) /* is tip */
						{
					//	fprintf (fpMRCAprint,"seq%05d  ", i+1);
						a++;
						}
					if (i == 2*numSequences-2)
						{
						fprintf (fpMRCAprint,"root      ");
						a++;
						}
					/*else
						fprintf (fpMRCAprint,"anc%05d  ", i+1);*/
					if (a != 0)
						{

						if (i == 2*numSequences-2) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpMRCAprint, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
								}
						//	fprintf (fpMRCAprint,"\n");
							}

						}
					}	
			//	fprintf (fpMRCAprint,"\n");
				}
			}
		else /* migration */
			{
			if(thereisOutgroup == YES)
				{	
				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 2)
						outgroupLabel = f->label;
					if (f->class == 5)
						rootLabel = f->label;
					}	

				for (i=0; i<2*numSequences; i++)
					{					
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if (f->index < numSequences*/ /*|| i == 2*numSequences-1*//*)
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;*/
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
							/*	break;
								}
						}*/
					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;
						if (f->index < numSequences /*|| i == 2*numSequences-1*/)
							if (f->label == i)
								{
								dem = f->indexOldMigPop;
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								break;
								}
						}

					a = 0;
					if (i < numSequences) /* is tip */
						{
					//	fprintf (fpMRCAprint,"s%05d_p%d ", i+1, dem);
						a++;
						}
					if (i == numSequences)
						{
					//	fprintf(fpMRCAprint, "outgrp_p0 ");
						a++;
						}
					if (i == 2*numSequences-1)
						{
						fprintf (fpMRCAprint,"root      ");
						a++;
						}
					/*else
						fprintf (fpMRCAprint,"anc%05d  ", i+1);*/
					if (a != 0)
						{

						if (i == 2*numSequences-1) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpMRCAprint, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
								}
						//	fprintf (fpMRCAprint,"\n");
							}

						}
					}	
		//		fprintf (fpMRCAprint,"\n");
				}
			else
				{

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 5)
						rootLabel = f->label;
					}


				for (i=0; i<2*numSequences-1; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if (f->index < numSequences*/ /*|| i == 2*numSequences-1*//*)
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;
								break;
								}
						}*/
					
					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;
						if (f->index < numSequences /*|| i == 2*numSequences-1*/)
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								break;
								}
						}


					a = 0;
					if (i < numSequences) /* is tip */
						{
					//	fprintf (fpMRCAprint,"s%05d_p%d ", i+1, dem);
						a++;
						}
					if (i == 2*numSequences-2)
						{
						fprintf (fpMRCAprint,"root      ");
						a++;
						}
					/*else
						fprintf (fpMRCAprint,"anc%05d  ", i+1);*/
					if (a != 0)
						{
						
						if (i == 2*numSequences-2) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpMRCAprint, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
								}
					//		fprintf (fpMRCAprint,"\n");
							}

						}
					}	
		//		fprintf (fpMRCAprint,"\n");
				}

			}
		}
}







/***************************** PrintOutMRCAFiles_Conc, it prints MRCAs for nucleotide Model *******************************/
/* Prints just MRCA files for nucleotide Model */

static void PrintOutMRCAFiles_Conc ()
{
	char	*MRCAseq_Array;		/* this array will contain the MRCA sequence from inputFile */

	/*char 	MRCAseq_Array[numNuc];*/
	/*int  	codon[3];*/
	int nucPosition, thisLabel, valueNuc, sss;

	nucPosition = 0;	

	MRCAseq_Array = (char *) calloc((numNuc+1), sizeof(char)); 
	if (!MRCAseq_Array)
		{
		#ifdef MPI
			fprintf (stderr, "%d: Could not allocate MRCAseq_Array (%lu bytes)\n", rank, (numNuc+1)  * (long) sizeof(char));
		#else
			fprintf (stderr, "Could not allocate MRCAseq_Array (%lu bytes)\n", (numNuc+1)  * (long) sizeof(char));
		#endif
		exit (-1);
		}


/*	matrix = (int *)calloc(((nextAvailable+1) * (numNuc+1)),(long) sizeof(int));		
		if (!matrix)
			{
			fprintf (fpmpi, "Could not allocate matrix (%lu bytes)\n", ((nextAvailable+1) * (numNuc+1))  * (long) sizeof(int));
			exit (1);
			}
		for (i = 0; i < (nextAvailable+1) * (numNuc+1); i++)
			matrix[i] = -1;	*/




	/* Writing the MRCA sequence in the array: MRCAseq_Array*/
	/*NodesMRCAposit[0]= -1;*/ /* en este vector se guardara: posicion 1 es el label (=index) del nodo MRCA del nuc 1, posicion 2... */
	/*fprintf (fpmpi, "\n\n Vector of MRCA: ");*/
	for (sss = 1; sss <= numNuc; sss++)
		{
		thisLabel = NodesMRCAposit[sss];
		valueNuc = matrix[pos(thisLabel,sss,numNuc)];
			
		/*fprintf (fpmpi, " %d", valueNuc);*/

		MRCAseq_Array[sss] = WhichNuc(valueNuc);
		}
	/*fprintf (fpmpi, "\n\n Nuc del Vector of MRCA: ");*/
		

	/* print in file */
	fprintf(fpConcMRCAprint,"%d %d\n", 1, numNuc);
	fprintf (fpConcMRCAprint,"root      ");
	
	for (sss = 1; sss <= numNuc; sss++)
		{
		/*fprintf (fpmpi, " %c", MRCAseq_Array[sss]);*/
		fprintf (fpConcMRCAprint, "%c", MRCAseq_Array[sss]);
		}

	free (MRCAseq_Array);
}







/***************************** PrintOutMRCAFiles_AA (GMRCA) for amino acid Model *******************************/
/* Prints just GMRCA files for amino acid Model */
static void PrintOutMRCAFiles_AA (/*int replicate*/)
{
int		 i, j, a, m, dem, outgroupLabel, rootLabel;
	TreeNode	*f;
	dem = 0;
	outgroupLabel = rootLabel = 0;

	if (numRE == 0) /* There are NOT recombinations */
		{
		if (thereisOutgroup == YES)
			{
			fprintf(fpMRCAprint,"%d %d\n", 1, numNuc);
			/*fprintf(fpMRCAprint,"Dataset_%d %d %d\n", replicate+1, 2*numSequences, numNuc);*/
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 2)
					outgroupLabel = f->label;
				if (f->class == 5)
					rootLabel = f->label;
				}
			}
		else
			{
			fprintf(fpMRCAprint,"%d %d\n", 1, numNuc);
			/*fprintf(fpMRCAprint,"Dataset_%d %d %d\n",replicate+1, 2*numSequences-1, numNuc);*/
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 5)
					rootLabel = f->label;
				}
			}


		
		if (doMigration == NO)
			{
			if(thereisOutgroup == YES)
				{	
				for (i=0; i<2*numSequences; i++)
					{
					if (i == 2*numSequences-1)
						fprintf (fpMRCAprint,"root      ");
							

					if (i == 2*numSequences-1) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpMRCAprint, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
					
					//fprintf (fpMRCAprint,"\n");
					}
			//	fprintf (fpMRCAprint,"\n");
				}
			else
				{
				for (i=0; i<2*numSequences-1; i++)
					{
					if (i == 2*numSequences-2)
						fprintf (fpMRCAprint,"root      ");
					

					if (i == 2*numSequences-2) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpMRCAprint, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
					
				//	fprintf (fpMRCAprint,"\n");
					}	
			//	fprintf (fpMRCAprint,"\n");
				}
			}
		else /* migration */
			{
			if(thereisOutgroup == YES)
				{	
				for (i=0; i<2*numSequences; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if ((f->label == i) && (f->index <= numSequences*2-2))
							{
							dem = f->indexOldMigPop;
							break;
							}
						}*/

					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;

						if (i < numSequences) /* tip */
							{
							if ((f->label == i) && (f->index <= numSequences*2-2)) 
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == 2*numSequences-1) /* root */
							{
							if (f->class == 5)
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == numSequences) /* outgroup */
							{
							dem = 0;
							break;
							}
						else /* ancestral */
							{
							if (f->label == i-1)
								{
								dem = f->indexOldMigPop;
								if (f->class != 4)
									{
									fprintf (stderr, "\n Warning in PrintAncestralSequences_C. f->label = %d, f->class = %d \n", f->label, f->class);
									exit(-1);
									}
								break;
								}
							}
						}
					
				
					if (i == 2*numSequences-1)
						fprintf (fpMRCAprint,"root      ");
					if (i == 2*numSequences-1) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpMRCAprint, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
					
				//	fprintf (fpMRCAprint,"\n");
					/*fprintf(stderr," \n\n sequence %d with label(in times file) %d", i+1, i+1);*/
					}	
			//	fprintf (fpMRCAprint,"\n");
				}
			else
				{
				for (i=0; i<2*numSequences-1; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if ((f->label == i) && (f->index <= numSequences*2-2))
							{
							dem = f->indexOldMigPop;
							break;
							}
						}*/

					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;

						if (i < numSequences) /* tip */
							{
							if ((f->label == i) && (f->index <= numSequences*2-2)) 
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == 2*numSequences-2) /* root */
							{
							if (f->class == 5)
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else /* ancestral */
							{
							if (f->label == i)
								{
								dem = f->indexOldMigPop;
								if (f->class != 4)
									{
									fprintf (stderr, "\n Warning in PrintAncestralSequences_C. f->label = %d, f->class = %d \n", f->label, f->class);
									exit(-1);
									}
								break;
								}
							}
						}
						
					
					if (i == 2*numSequences-2)
						fprintf (fpMRCAprint,"root      ");
										
					else if (i == 2*numSequences-2) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpMRCAprint, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
				
				//	fprintf (fpMRCAprint,"\n");
					}	
			//	fprintf (fpMRCAprint,"\n");
				}
			}
		}
	else /* There are recombinations */
		{
		if (thereisOutgroup == YES)
			fprintf(fpMRCAprint,"%d %d \n", 1, numNuc);
			/*fprintf(fpMRCAprint,"Dataset_%d %d %d \n", replicate+1, numSequences+1, numNuc);*/
		else
			/*fprintf(fpMRCAprint,"Dataset_%d %d %d \n", replicate+1, numSequences, numNuc);*/
			fprintf(fpMRCAprint,"%d %d \n", 1, numNuc);
		
		if (doMigration == NO)
			{
			if(thereisOutgroup == YES)
				{	

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 2)
						outgroupLabel = f->label;
					if (f->class == 5)
						rootLabel = f->label;
					}		


				for (i=0; i<2*numSequences; i++)
					{
					a = 0;
					if (i < numSequences) /* is tip */
						{
				//		fprintf (fpMRCAprint,"seq%05d  ", i+1);
						a++;
						}
					if (i == numSequences)
						{
				//		fprintf(fpMRCAprint, "outgroup  ");
						a++;
						}
					if (i == 2*numSequences-1)
						{
						fprintf (fpMRCAprint,"root      ");
						a++;
						}
					/*else
						fprintf (fpMRCAprint,"anc%05d  ", i+1);*/
					if (a != 0)
						{
						if (i == 2*numSequences-1) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpMRCAprint, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
								}
					//		fprintf (fpMRCAprint,"\n");
							}

						/*fprintf(stderr," \n\n sequence %d with label(in times file) %d", i+1, i+1);*/
						}
					}	
			//	fprintf (fpMRCAprint,"\n");
				}
			else
				{
				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 5)
						rootLabel = f->label;
					}


				for (i=0; i<2*numSequences-1; i++)
					{
					a = 0;
					if (i < numSequences) /* is tip */
						{
					//	fprintf (fpMRCAprint,"seq%05d  ", i+1);
						a++;
						}
					if (i == 2*numSequences-2)
						{
						fprintf (fpMRCAprint,"root      ");
						a++;
						}
					/*else
						fprintf (fpMRCAprint,"anc%05d  ", i+1);*/
					if (a != 0)
						{

						if (i == 2*numSequences-2) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpMRCAprint, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
								}
						//	fprintf (fpMRCAprint,"\n");
							}

						}
					}	
			//	fprintf (fpMRCAprint,"\n");
				}
			}
		else /* migration */
			{
			if(thereisOutgroup == YES)
				{	
				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 2)
						outgroupLabel = f->label;
					if (f->class == 5)
						rootLabel = f->label;
					}	

				for (i=0; i<2*numSequences; i++)
					{					
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if (f->index < numSequences*/ /*|| i == 2*numSequences-1*//*)
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;*/
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
							/*	break;
								}
						}*/
					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;
						if (f->index < numSequences /*|| i == 2*numSequences-1*/)
							if (f->label == i)
								{
								dem = f->indexOldMigPop;
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								break;
								}
						}

					a = 0;
					if (i < numSequences) /* is tip */
						{
					//	fprintf (fpMRCAprint,"s%05d_p%d ", i+1, dem);
						a++;
						}
					if (i == numSequences)
						{
					//	fprintf(fpMRCAprint, "outgrp_p0 ");
						a++;
						}
					if (i == 2*numSequences-1)
						{
						fprintf (fpMRCAprint,"root      ");
						a++;
						}
					/*else
						fprintf (fpMRCAprint,"anc%05d  ", i+1);*/
					if (a != 0)
						{

						if (i == 2*numSequences-1) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpMRCAprint, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
								}
						//	fprintf (fpMRCAprint,"\n");
							}

						}
					}	
		//		fprintf (fpMRCAprint,"\n");
				}
			else
				{

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 5)
						rootLabel = f->label;
					}


				for (i=0; i<2*numSequences-1; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if (f->index < numSequences*/ /*|| i == 2*numSequences-1*//*)
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;
								break;
								}
						}*/
					
					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;
						if (f->index < numSequences /*|| i == 2*numSequences-1*/)
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								break;
								}
						}


					a = 0;
					if (i < numSequences) /* is tip */
						{
					//	fprintf (fpMRCAprint,"s%05d_p%d ", i+1, dem);
						a++;
						}
					if (i == 2*numSequences-2)
						{
						fprintf (fpMRCAprint,"root      ");
						a++;
						}
					/*else
						fprintf (fpMRCAprint,"anc%05d  ", i+1);*/
					if (a != 0)
						{
						
						if (i == 2*numSequences-2) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpMRCAprint, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
								}
					//		fprintf (fpMRCAprint,"\n");
							}

						}
					}	
		//		fprintf (fpMRCAprint,"\n");
				}

			}
		}
}







/***************************** PrintOutMRCAFiles_AA_Conc, it prints MRCAs for amino acid Model *******************************/
/* Prints just MRCA files for amino acid Model */

static void PrintOutMRCAFiles_AA_Conc ()
{
	char	*MRCAseq_Array;		/* this array will contain the MRCA sequence from inputFile */

	/*char 	MRCAseq_Array[numNuc];*/
	/*int  	codon[3];*/
	int nucPosition, thisLabel, valueNuc, sss;

	nucPosition = 0;	

	MRCAseq_Array = (char *) calloc((numNuc+1), sizeof(char)); 
	if (!MRCAseq_Array)
		{
		#ifdef MPI
			fprintf (stderr, "%d: Could not allocate MRCAseq_Array (%lu bytes)\n", rank, (numNuc+1)  * (long) sizeof(char));
		#else
			fprintf (stderr, "Could not allocate MRCAseq_Array (%lu bytes)\n", (numNuc+1)  * (long) sizeof(char));
		#endif
		exit (-1);
		}


/*	matrix = (int *)calloc(((nextAvailable+1) * (numNuc+1)),(long) sizeof(int));		
		if (!matrix)
			{
			fprintf (fpmpi, "Could not allocate matrix (%lu bytes)\n", ((nextAvailable+1) * (numNuc+1))  * (long) sizeof(int));
			exit (1);
			}
		for (i = 0; i < (nextAvailable+1) * (numNuc+1); i++)
			matrix[i] = -1;	*/


	/* Writing the MRCA sequence in the array: MRCAseq_Array*/
	/*NodesMRCAposit[0]= -1;*/ /* en este vector se guardara: posicion 1 es el label (=index) del nodo MRCA del nuc 1, posicion 2... */
	/*fprintf (fpmpi, "\n\n Vector of MRCA: ");*/
	for (sss = 1; sss <= numNuc; sss++)
		{
		thisLabel = NodesMRCAposit[sss];
		valueNuc = matrix[pos(thisLabel,sss,numNuc)];
			
		/*fprintf (fpmpi, " %d", valueNuc);*/

		MRCAseq_Array[sss] = WhichAA(valueNuc);
		}
	/*fprintf (fpmpi, "\n\n Nuc del Vector of MRCA: ");*/
		

	/* print in file */
	fprintf(fpConcMRCAprint,"%d %d\n", 1, numNuc);
	fprintf (fpConcMRCAprint,"root      ");
	
	for (sss = 1; sss <= numNuc; sss++)
		{
		/*fprintf (fpmpi, " %c", MRCAseq_Array[sss]);*/
		fprintf (fpConcMRCAprint, "%c", MRCAseq_Array[sss]);
		}

	free (MRCAseq_Array);
}












/***************************** PrintMRCAfiles_C, it prints the GMRCAs for Codon Model *******************************/
/* Prints just GMRCA files for codon Model */

static void PrintOutMRCAFiles_C (/*int replicate*/)
{
	int		 i, j, k, a, m, dem, outgroupLabel, rootLabel;
	char codon[3];
	TreeNode	*f;
	dem = 0;
	outgroupLabel = rootLabel = 0;	

	if (numRE == 0) /* There are NOT recombinations */
		{
		if (thereisOutgroup == YES)
			{
			fprintf(fpMRCAprint,"%d %d\n", 1, numNuc);
			/*fprintf(fpMRCAprint,"Dataset_%d %d %d\n", replicate+1, 2*numSequences, numNuc);*/
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 2)
					outgroupLabel = f->label;
				if (f->class == 5)
					rootLabel = f->label;
				}
			}
		else
			{
			fprintf(fpMRCAprint,"%d %d\n", 1, numNuc);
			/*fprintf(fpMRCAprint,"Dataset_%d %d %d\n",replicate+1, 2*numSequences-1, numNuc);*/
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 5)
					{
					rootLabel = f->label;
					}
				}
			}
		

		if (doMigration == NO)
			{
			if (thereisOutgroup == YES)
				{	
				for (i=0; i<2*numSequences; i++)
					{
					if (i == 2*numSequences-1)
						fprintf (fpMRCAprint,"root      ");
					

					if (i == 2*numSequences-1) /* is root */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon10 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
							for (k = 0; k < 3; k++)
								fprintf (fpMRCAprint, "%c", codon[k]);
							}
						}

					//fprintf (fpMRCAprint,"\n");
					}	
			//	fprintf (fpMRCAprint,"\n");
				}
			else
				{
				for (i=0; i<2*numSequences-1; i++)
					{
					if (i == 2*numSequences-2)
						fprintf (fpMRCAprint,"root      ");
					
					
					if (i == 2*numSequences-2) /* is root */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon11 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
							for	(k = 0; k < 3; k++)
								fprintf (fpMRCAprint, "%c", codon[k]);
							}
						}

				//	fprintf (fpMRCAprint,"\n");
					}	
			//	fprintf (fpMRCAprint,"\n");
				}
			}
		else /* migration */
			{
			if (thereisOutgroup == YES)
				{	
				for (i=0; i<2*numSequences; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodex + m;
						if ((f->label == i) && (f->NetIndex <= numSequences*2-2))
							{
							dem = f->indexOldMigPop;
							break;
							}
						}*/
					
					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;

						if (i < numSequences) /* tip */
							{
							if ((f->label == i) && (f->index <= numSequences*2-2)) 
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == 2*numSequences-1) /* root */
							{
							if (f->class == 5)
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == numSequences) /* outgroup */
							{
							dem = 0;
							break;
							}
						else /* ancestral */
							{
							if (f->label == i-1)
								{
								dem = f->indexOldMigPop;
								if (f->class != 4)
									{
									fprintf (stderr, "\n Warning in PrintAncestralSequences_C. f->label = %d, f->class = %d \n", f->label, f->class);
									exit(-1);
									}
								break;
								}
							}
						}



					if (i == 2*numSequences-1)
						{
						fprintf (fpMRCAprint,"root      ");
						//fprintf (fpMRCAprint,"root_pop%d      ",dem);
						}


					if (i == 2*numSequences-1) /* is root */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon10 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
							for (k = 0; k < 3; k++)
								fprintf (fpMRCAprint, "%c", codon[k]);
							}
						}
					
				//	fprintf (fpMRCAprint,"\n");
					}	
			//	fprintf (fpMRCAprint,"\n");
				}
			else
				{
				for (i=0; i<2*numSequences-1; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodex + m;
						if ((f->label == i) && (f->NetIndex <= numSequences*2-2))
							{
							dem = f->indexOldMigPop;
							break;
							}
						}*/
					
					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;

						if (i < numSequences) /* tip */
							{
							if ((f->label == i) && (f->index <= numSequences*2-2)) 
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == 2*numSequences-2) /* root */
							{
							if (f->class == 5)
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else /* ancestral */
							{
							if (f->label == i)
								{
								dem = f->indexOldMigPop;
								if (f->class != 4)
									{
									fprintf (stderr, "\n Warning in PrintAncestralSequences_C. f->label = %d, f->class = %d \n", f->label, f->class);
									exit(-1);
									}
								break;
								}
							}
						}




					
					if (i == 2*numSequences-2)
						{
						fprintf (fpMRCAprint,"root      ");
						//fprintf (fpMRCAprint,"root_pop%d      ",dem);
						}

					
					if (i == 2*numSequences-2) /* is root */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon11 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
							for	(k = 0; k < 3; k++)
								fprintf (fpMRCAprint, "%c", codon[k]);
							}
						}
					
				//	fprintf (fpMRCAprint,"\n");

					}	
				}
			//fprintf (fpMRCAprint,"\n");
			}
		}
	else /* There are recombinations */
		{
		if (thereisOutgroup == YES)
			fprintf(fpMRCAprint,"%d %d\n", 1, numNuc);
		else
			fprintf(fpMRCAprint,"%d %d\n", 1, numNuc);
		
		if (doMigration == NO)
			{
			if (thereisOutgroup == YES)
				{
				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 2)
						outgroupLabel = f->label;
					if (f->class == 5)
						rootLabel = f->label;
					}				
	
				for (i=0; i<2*numSequences; i++)
					{
					a = 0;
					if (i < numSequences) /* is tip */
						{
						//fprintf (fpMRCAprint,"seq%05d  ", i+1);
						a++;
						}
					if (i == numSequences)
						{
						//fprintf(fpMRCAprint, "outgroup  ");
						a++;
						}
					if (i == 2*numSequences-1)
						{
						fprintf (fpMRCAprint,"root      ");
						a++;
						}
					/*else
						fprintf (fpMRCAprint,"anc%05d  ", i+1);*/
					if (a != 0)
						{
						if (i == 2*numSequences-1) /* is root */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon14 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpMRCAprint, "%c", codon[k]);
								}
						//	fprintf (fpMRCAprint,"\n");
							}

						}
					}	
			//	fprintf (fpMRCAprint,"\n");
				}
			else
				{

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 5)
						{
						rootLabel = f->label;
						}
					}

				for (i=0; i<2*numSequences-1; i++)
					{
					a = 0;
					if (i < numSequences) /* is tip */
						{
						//fprintf (fpMRCAprint,"seq%05d  ", i+1);
						a++;
						}
					if (i == 2*numSequences-2)
						{
						fprintf (fpMRCAprint,"root      ");
						a++;
						}
					/*else
						fprintf (fpMRCAprint,"anc%05d  ", i+1);*/
					if (a != 0)
						{
						if (i == 2*numSequences-2) /* is root */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon15 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpMRCAprint, "%c", codon[k]);
								}
						//	fprintf (fpMRCAprint,"\n");
							}

						}
					}	
			//	fprintf (fpMRCAprint,"\n");
				}
			}
		else /* migration */
			{
			if (thereisOutgroup == YES)
				{	

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 2)
						outgroupLabel = f->label;
					if (f->class == 5)
						rootLabel = f->label;
					}	


				for (i=0; i<2*numSequences; i++)
					{

					/*for (m = 0; m < numNodex; m++)
						{
						f = nodex + m;
						if (f->NetIndex < numSequences*/ /*|| i == 2*numSequences-1*//*
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;*/
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								/*break;
								}
						}*/

					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;
						if (f->index < numSequences /*|| i == 2*numSequences-1*/)
							if (f->label == i)
								{
								dem = f->indexOldMigPop;
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								break;
								}
						}



					a = 0;
					if (i < numSequences) /* is tip */
						{
						//fprintf (fpMRCAprint,"seq%05d_pop%d  ", i+1, dem);
						a++;
						}
					if (i == numSequences)
						{
						//fprintf(fpMRCAprint, "outgroup_pop0  ");
						a++;
						}
					if (i == 2*numSequences-1)
						{
						fprintf (fpMRCAprint,"root      ");
						a++;
						}
					/*else
						fprintf (fpMRCAprint,"anc%05d  ", i+1);*/
					if (a != 0)
						{

						if (i == 2*numSequences-1) /* is root */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon16 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpMRCAprint, "%c", codon[k]);
								}
						//	fprintf (fpMRCAprint,"\n");
							}

						}
					}	
			//	fprintf (fpMRCAprint,"\n");
				}
			else
				{


				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 5)
						rootLabel = f->label;
					}

				for (i=0; i<2*numSequences-1; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodex + m;
						if (f->NetIndex < numSequences*/ /*|| i == 2*numSequences-1*//*)
							if (f->label == i)
								{
								dem = f->indexOldMigPop;*/
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								/*break;
								}
						}*/
					
					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;
						if (f->index < numSequences /*|| i == 2*numSequences-1*/)
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								break;
								}
						}


					a = 0;
					if (i < numSequences) /* is tip */
						{
						//fprintf (fpMRCAprint,"seq%05d_pop%d  ", i+1, dem);
						a++;
						}
					if (i == 2*numSequences-2)
						{
						fprintf (fpMRCAprint,"root      ");
						a++;
						}
					/*else
						fprintf (fpMRCAprint,"anc%05d  ", i+1);*/
					if (a != 0)
						{
						
						if (i == 2*numSequences-2) /* is root */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon17 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpMRCAprint, "%c", codon[k]);
								}
						//	fprintf (fpMRCAprint,"\n");
							}


						}
					}	
				//fprintf (fpMRCAprint,"\n");
				}
			}
		}
}



/***************************** PrintMRCAfiles_C, it prints MRCAs for Codon Model *******************************/
/* Prints just MRCA files for codon Model */

static void PrintOutMRCAFiles_C_Conc (/*int replicate*/)
{
	int		 i, k;
	char	*MRCAseq_Array;		/* this array will contain the MRCA sequence from inputFile */

	/*char 	MRCAseq_Array[numNuc];*/
	int  	codon[3];
	int xx, yy, zz, nucPosition, thisLabel, valueNuc, sss;

	nucPosition = 0;	

	MRCAseq_Array = (char *) calloc((numNuc+1), sizeof(char)); 
	if (!MRCAseq_Array)
		{
		#ifdef MPI
			fprintf (stderr, "%d: Could not allocate MRCAseq_Array (%lu bytes)\n", rank, (numNuc+1)  * (long) sizeof(char));
		#else
			fprintf (stderr, "Could not allocate MRCAseq_Array (%lu bytes)\n", (numNuc+1)  * (long) sizeof(char));
		#endif
		exit (-1);
		}

	matrixCnuc = (int *)calloc(((nextAvailable+1) * (numNuc+2)),(long) sizeof(int));		/* New nuc matrix from codon matrix */
	if (!matrixCnuc)
		{
		fprintf (fpmpi, "Could not allocate matrixC (%lu bytes)\n", ((nextAvailable+1) * (numNuc+2))  * (long) sizeof(int));
		exit (1);
		}
	for (i = 0; i < (nextAvailable+1) * (numNuc+2); i++)
		matrixCnuc[i] = -1;



	/*fprintf(fpmpi,"Tamanho max de matrix: nextAvailable = %d \n", nextAvailable);*/ /* From Matrix Codon to Matrix nuc */ /* matrixC[pos(p->label,siteCodon,numSites)]; */
	for (xx=0; xx<=nextAvailable; xx++)
		{
		/*fprintf(fpmpi,"p->Label %d \n", xx);*/
		for (yy=1; yy<=numSites; yy++)
			{
			zz = matrixC[pos(xx,yy,numSites)];
			/*fprintf(fpmpi,"%d ", zz);*/ 				
			

			/* write the nuc */ /* void number_to_codon2(int ind, int out[])*/
			codon[0] = codon[1] = codon[2] = -1;
			if (zz > -1) /* this node do not have that codon */
				{
				number_to_codon2(zz, codon);
				}
			else
				{
				codon[0] = codon[1] = codon[2] = -1;
				}

			for (k = 0; k < 3; k++)
				{
				if (k == 0)
					{
					nucPosition = (yy*3)-2;
					}
				else if (k == 1)
					{
					nucPosition = (yy*3)-1;
					}
				else if (k == 2)
					{
					nucPosition = yy*3;
					}
				else
					{
					fprintf(fpmpi,"\n never here PrintOutMRCAFiles_C_Conc");
					exit(-1);
					}

				matrixCnuc[pos(xx,nucPosition,numNuc)] = codon[k];
				}
			}
		/*fprintf(fpmpi,"\n");*/
		}

	/* For see the new matrix */
	/*fprintf(fpmpi,"Tamanho max de matrix_NUC: nextAvailable = %d \n", nextAvailable);*/
	/*for (xx=0; xx<=nextAvailable; xx++)
		{
		fprintf(fpmpi,"\np->Label %d \n", xx);
		for (yy=1; yy<=numNuc; yy++)
			{
			zz = matrixCnuc[pos(xx,yy,numNuc)];
			fprintf(fpmpi,"%d ", zz); 				
			}
		}*/


	/* Writing the MRCA sequence in the array: MRCAseq_Array*/
	/*NodesMRCAposit[0]= -1;*/ /* en este vector se guardara: posicion 1 es el label (=index) del nodo MRCA del nuc 1, posicion 2... */
	/*fprintf (fpmpi, "\n\n Vector of MRCA: ");*/
	for (sss = 1; sss <= numNuc; sss++)
		{
		thisLabel = NodesMRCAposit[sss];
		valueNuc = matrixCnuc[pos(thisLabel,sss,numNuc)];
			
		/*fprintf (fpmpi, " %d", valueNuc);*/

		MRCAseq_Array[sss] = WhichNuc(valueNuc);
		}
	/*fprintf (fpmpi, "\n\n Nuc del Vector of MRCA: ");*/
		

	/* print in file */
	fprintf(fpConcMRCAprint,"%d %d\n", 1, numNuc);
	fprintf (fpConcMRCAprint,"root      ");
	
	for (sss = 1; sss <= numNuc; sss++)
		{
		/*fprintf (fpmpi, " %c", MRCAseq_Array[sss]);*/
		fprintf (fpConcMRCAprint, "%c", MRCAseq_Array[sss]);
		}

	free (MRCAseq_Array);
	free (matrixCnuc);
}





/***************************** PrintOutGMRCAFiles_Codon_AncestralMat, it prints the GMRCAs for the ancestral material in Codon Models *******************************/
/* Prints just GMRCA files for codon Model */

static void PrintOutGMRCAFiles_Codon_AncestralMat (/*int replicate*/)
{
	int		 j, k, m, rootLabel, Ok;
	char codon[3];
	TreeNode	*f;
	rootLabel = Ok = 0;	


	/*fprintf(fpmpi,"\n AT PrintOutGMRCAFiles_Codon_AncestralMat \n");*/

	fprintf(fpGMRCAancPrint,"%d %d\n", 1, numNuc);
	for (m = 0; m < nextAvailable; m++)
		{
		f = nodes + m;
		/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
		if (f->GMRCA_ancestral == YES)
			{
			rootLabel = f->label;
			/*fprintf(fpmpi,"This node is index = %d, label = %d \n", f->index, f->label);*/
			Ok++;
			}
		}
	if (Ok == 0)
		{
		for (m = 0; m < nextAvailable; m++)
			{
			f = nodes + m;
			/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
			if (f->class == 5)
				{
				rootLabel = f->label;
				/*fprintf(fpmpi,"Sp_This node is index = %d, label = %d \n", f->index, f->label);*/
				Ok++;
				}
			}

		}




	fprintf (fpGMRCAancPrint,"root      ");

	for (j=1; j<=numSites; j++)
		{
		if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
			{
			fprintf (stderr, "\n stop codonX1 \n");
			exit(-1);
			}
		number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
		for (k = 0; k < 3; k++)
			fprintf (fpGMRCAancPrint, "%c", codon[k]);
		}

}












/**** FASTA ****/
/***************************** PrintSequences_FASTA *******************************/
/* Prints sequences to alignment FASTA file */
static void PrintSequences_FASTA (/*int replicate*/) 
{
	int		 i, j, m, dem, outgroupLabel;
	TreeNode	*f;
	
	dem = 0;
	outgroupLabel = 0;


/*	if (thereisOutgroup == YES)
		fprintf(fpAlignment,"%d %d \n", numSequences+1, numNuc);*/
		/*fprintf(fpAlignment,"Dataset_%d %d %d \n", replicate+1, numSequences+1, numNuc);*/
/*	else*/
		/*fprintf(fpAlignment,"Dataset_%d %d %d \n", replicate+1, numSequences, numNuc);*/
/*		fprintf(fpAlignment,"%d %d \n", numSequences, numNuc);*/
	
	if (doMigration == NO)
		{
		if(thereisOutgroup == YES)
			{
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 2)
					{
					outgroupLabel = f->label;
					break;
					}
				}
	
			for (i=0; i<numSequences+1; i++)
				{
				if (i == numSequences)
					fprintf(fpAlignment, ">outgroup\n");
				else 
					fprintf (fpAlignment,">seq%05d\n", i+1);
				
				if (i == numSequences) /* outgroup */
					{
					for (j=1; j<=numNuc; j++)
						{
						fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(outgroupLabel,j,numNuc)]));
						}
					}
				else /* tip nodes */
					{
					for (j=1; j<=numNuc; j++)
						{
						fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
						}
					}
				fprintf (fpAlignment,"\n");
				}	
			fprintf (fpAlignment,"\n");
			/*fprintf(stderr,"\n sequence %d go with nodo of label %d \n", i+1, i+1);*/
			}
		else
			{
			for (i=0; i<numSequences; i++)
				{
				fprintf (fpAlignment,">seq%05d\n", i+1);

				for (j=1; j<=numNuc; j++)
					fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
				fprintf (fpAlignment,"\n");
				}	
			fprintf (fpAlignment,"\n");
			}
		}
	else /* migration */
		{
		if(thereisOutgroup == YES)
			{	

			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 2)
					{
					outgroupLabel = f->label;
					break;
					}
				}
			/*fprintf (stderr, "\n outgroupLabel = %d \n", outgroupLabel);*/


			for (i=0; i<numSequences+1; i++)
				{

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					if ((f->label == i) && (f->index < numSequences))
						{
						dem = f->indexOldMigPop;
						break;
						}
					}
				
				if (i == numSequences)
					fprintf(fpAlignment, ">outgrp_p0\n");
				else 
					fprintf (fpAlignment,">s%05d_p%d\n", i+1, dem);

				
				if (i == numSequences) /* outgroup */
					{
					for (j=1; j<=numNuc; j++)
						{
						fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(outgroupLabel,j,numNuc)]));
						}
					}
				else /* tip nodes */
					{
					for (j=1; j<=numNuc; j++)
						{
						fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
						}
					}

				fprintf (fpAlignment,"\n");
				}	
			fprintf (fpAlignment,"\n");
			}
		else
			{
			for (i=0; i<numSequences; i++)
				{
				/*for (m = 0; m < numNodex; m++)
					{
					f = nodex + m;
					if ((f->label == i) && (f->NetIndex < numSequences))
						{
						dem = f->indexOldMigPop;
						break;
						}
					}*/

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					if ((f->label == i) && (f->index < numSequences))
						{
						dem = f->indexOldMigPop;
						break;
						}
					}

				fprintf (fpAlignment,">s%05d_p%d\n", i+1, dem);
				
				for (j=1; j<=numNuc; j++)
					{
					fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
					}
				
				fprintf (fpAlignment,"\n");
				}	
			fprintf (fpAlignment,"\n");
			}
		}
}
		


/***************************** PrintAncestralSequences_FASTA *******************************/
/* Prints ancestral sequences to alignment FASTA file */
static void PrintAncestralSequences_FASTA (/*int replicate*/)   
{
	int		 i, j, a, m, dem, outgroupLabel, rootLabel;
	TreeNode	*f;
	dem = 0;
	outgroupLabel = rootLabel = 0;

	if (numRE == 0) /* There are NOT recombinations */
		{
		if (thereisOutgroup == YES)
			{
			/*fprintf(fpAlignment,"%d %d\n", 2*numSequences, numNuc);*/
			/*fprintf(fpAlignment,"Dataset_%d %d %d\n", replicate+1, 2*numSequences, numNuc);*/
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 2)
					outgroupLabel = f->label;
				if (f->class == 5)
					rootLabel = f->label;
				}
			}
		else
			{
			/*fprintf(fpAlignment,"%d %d\n", 2*numSequences-1, numNuc);*/
			/*fprintf(fpAlignment,"Dataset_%d %d %d\n",replicate+1, 2*numSequences-1, numNuc);*/
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 5)
					rootLabel = f->label;
				}
			}


		
		if (doMigration == NO)
			{
			if(thereisOutgroup == YES)
				{	
				for (i=0; i<2*numSequences; i++)
					{
					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,">seq%05d\n", i+1);
					else if (i == numSequences)
						fprintf(fpAlignment, ">outgroup\n");
					else if (i == 2*numSequences-1)
						fprintf (fpAlignment,">root\n");
					else
						fprintf (fpAlignment,">anc%05d\n", i+1);
		

					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
							}
						}
					else if (i == numSequences) /* is outgroup */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(outgroupLabel,j,numNuc)]));
							}
						}
					else if (i == 2*numSequences-1) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
					else  /* is ancestral */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i-1,j,numNuc)]));
							}
						}

					fprintf (fpAlignment,"\n");
					}
				fprintf (fpAlignment,"\n");
				}
			else
				{
				for (i=0; i<2*numSequences-1; i++)
					{
					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,">seq%05d\n", i+1);
					else if (i == 2*numSequences-2)
						fprintf (fpAlignment,">root\n");
					else
						fprintf (fpAlignment,">anc%05d\n", i+1);


					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
							}
						}
					else if (i == 2*numSequences-2) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
					else /* is ancestral */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
							}
						}
					fprintf (fpAlignment,"\n");
					}	
				fprintf (fpAlignment,"\n");
				}
			}
		else /* migration */
			{
			if(thereisOutgroup == YES)
				{	
				for (i=0; i<2*numSequences; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if ((f->label == i) && (f->index <= numSequences*2-2))
							{
							dem = f->indexOldMigPop;
							break;
							}
						}*/

					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;

						if (i < numSequences) /* tip */
							{
							if ((f->label == i) && (f->index <= numSequences*2-2)) 
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == 2*numSequences-1) /* root */
							{
							if (f->class == 5)
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == numSequences) /* outgroup */
							{
							dem = 0;
							break;
							}
						else /* ancestral */
							{
							if (f->label == i-1)
								{
								dem = f->indexOldMigPop;
								if (f->class != 4)
									{
									fprintf (stderr, "\n Warning in PrintAncestralSequences_C. f->label = %d, f->class = %d \n", f->label, f->class);
									exit(-1);
									}
								break;
								}
							}
						}
					
					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,">s%05d_p%d\n", i+1, dem);
					else if (i == numSequences)
						fprintf(fpAlignment, ">outgrp_p0\n");
					else if (i == 2*numSequences-1)
						fprintf (fpAlignment,">root_p%d\n", dem);
					else
						fprintf (fpAlignment,">a%05d_p%d\n", i+1, dem);
		

					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
							}
						}
					else if (i == numSequences) /* is outgroup */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(outgroupLabel,j,numNuc)]));
							}
						}
					else if (i == 2*numSequences-1) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
					else  /* is ancestral */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i-1,j,numNuc)]));
							}
						}
					fprintf (fpAlignment,"\n");
					/*fprintf(stderr," \n\n sequence %d with label(in times file) %d", i+1, i+1);*/
					}	
				fprintf (fpAlignment,"\n");
				}
			else
				{
				for (i=0; i<2*numSequences-1; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if ((f->label == i) && (f->index <= numSequences*2-2))
							{
							dem = f->indexOldMigPop;
							break;
							}
						}*/

					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;

						if (i < numSequences) /* tip */
							{
							if ((f->label == i) && (f->index <= numSequences*2-2)) 
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == 2*numSequences-2) /* root */
							{
							if (f->class == 5)
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else /* ancestral */
							{
							if (f->label == i)
								{
								dem = f->indexOldMigPop;
								if (f->class != 4)
									{
									fprintf (stderr, "\n Warning in PrintAncestralSequences_C. f->label = %d, f->class = %d \n", f->label, f->class);
									exit(-1);
									}
								break;
								}
							}
						}
						
					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,">s%05d_p%d\n", i+1, dem);
					else if (i == 2*numSequences-2)
						fprintf (fpAlignment,">root_p%d\n", dem);
					else
						fprintf (fpAlignment,">a%05d_p%d\n", i+1, dem);

					
					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
							}
						}
					else if (i == 2*numSequences-2) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
					else /* is ancestral */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
							}
						}

					fprintf (fpAlignment,"\n");
					}	
				fprintf (fpAlignment,"\n");
				}
			}
		}
	else /* There are recombinations */
		{
		/*if (thereisOutgroup == YES)
			fprintf(fpAlignment,"%d %d \n", numSequences+2, numNuc);*/
			/*fprintf(fpAlignment,"Dataset_%d %d %d \n", replicate+1, numSequences+1, numNuc);*/
		/*else*/
			/*fprintf(fpAlignment,"Dataset_%d %d %d \n", replicate+1, numSequences, numNuc);*/
			/*fprintf(fpAlignment,"%d %d \n", numSequences+1, numNuc);*/
		
		if (doMigration == NO)
			{
			if(thereisOutgroup == YES)
				{	

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 2)
						outgroupLabel = f->label;
					if (f->class == 5)
						rootLabel = f->label;
					}		


				for (i=0; i<2*numSequences; i++)
					{
					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,">seq%05d\n", i+1);
						a++;
						}
					if (i == numSequences)
						{
						fprintf(fpAlignment, ">outgroup\n");
						a++;
						}
					if (i == 2*numSequences-1)
						{
						fprintf (fpAlignment,">root\n");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{
						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == numSequences) /* is outgroup */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(outgroupLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-1) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}

						/*fprintf(stderr," \n\n sequence %d with label(in times file) %d", i+1, i+1);*/
						}
					}	
				fprintf (fpAlignment,"\n");
				}
			else
				{
				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 5)
						rootLabel = f->label;
					}


				for (i=0; i<2*numSequences-1; i++)
					{
					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,">seq%05d\n", i+1);
						a++;
						}
					if (i == 2*numSequences-2)
						{
						fprintf (fpAlignment,">root\n");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{

						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-2) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}


						}
					}	
				fprintf (fpAlignment,"\n");
				}
			}
		else /* migration */
			{
			if(thereisOutgroup == YES)
				{	
				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 2)
						outgroupLabel = f->label;
					if (f->class == 5)
						rootLabel = f->label;
					}	





				for (i=0; i<2*numSequences; i++)
					{					
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if (f->index < numSequences*/ /*|| i == 2*numSequences-1*//*)
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;*/
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
							/*	break;
								}
						}*/
					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;
						if (f->index < numSequences /*|| i == 2*numSequences-1*/)
							if (f->label == i)
								{
								dem = f->indexOldMigPop;
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								break;
								}
						}

					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,">s%05d_p%d\n", i+1, dem);
						a++;
						}
					if (i == numSequences)
						{
						fprintf(fpAlignment, ">outgrp_p0\n");
						a++;
						}
					if (i == 2*numSequences-1)
						{
						fprintf (fpAlignment,">root\n");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{

						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == numSequences) /* is outgroup */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(outgroupLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-1) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}

						}
					}	
				fprintf (fpAlignment,"\n");
				}
			else
				{

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 5)
						rootLabel = f->label;
					}


				for (i=0; i<2*numSequences-1; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if (f->index < numSequences*/ /*|| i == 2*numSequences-1*//*)
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;
								break;
								}
						}*/
					
					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;
						if (f->index < numSequences /*|| i == 2*numSequences-1*/)
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								break;
								}
						}


					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,">s%05d_p%d\n", i+1, dem);
						a++;
						}
					if (i == 2*numSequences-2)
						{
						fprintf (fpAlignment,">root\n");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{
						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-2) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}

						}
					}	
				fprintf (fpAlignment,"\n");
				}

			}
		}
}
		





/***************************** PrintSequences_AA_FASTA *******************************/
/* Prints sequences to alignment FASTA file */
static void PrintSequences_AA_FASTA (/*int replicate*/) 
{
	int		 i, j, m, dem, outgroupLabel;
	TreeNode	*f;
	
	dem = 0;
	outgroupLabel = 0;


/*	if (thereisOutgroup == YES)
		fprintf(fpAlignment,"%d %d \n", numSequences+1, numNuc);*/
		/*fprintf(fpAlignment,"Dataset_%d %d %d \n", replicate+1, numSequences+1, numNuc);*/
/*	else*/
		/*fprintf(fpAlignment,"Dataset_%d %d %d \n", replicate+1, numSequences, numNuc);*/
/*		fprintf(fpAlignment,"%d %d \n", numSequences, numNuc);*/
	
	if (doMigration == NO)
		{
		if(thereisOutgroup == YES)
			{
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 2)
					{
					outgroupLabel = f->label;
					break;
					}
				}
	
			for (i=0; i<numSequences+1; i++)
				{
				if (i == numSequences)
					fprintf(fpAlignment, ">outgroup\n");
				else 
					fprintf (fpAlignment,">seq%05d\n", i+1);
				
				if (i == numSequences) /* outgroup */
					{
					for (j=1; j<=numNuc; j++)
						{
						fprintf (fpAlignment, "%c", WhichAA(matrix[pos(outgroupLabel,j,numNuc)]));
						}
					}
				else /* tip nodes */
					{
					for (j=1; j<=numNuc; j++)
						{
						fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
						}
					}
				fprintf (fpAlignment,"\n");
				}	
			fprintf (fpAlignment,"\n");
			/*fprintf(stderr,"\n sequence %d go with nodo of label %d \n", i+1, i+1);*/
			}
		else
			{
			for (i=0; i<numSequences; i++)
				{
				fprintf (fpAlignment,">seq%05d\n", i+1);

				for (j=1; j<=numNuc; j++)
					fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
				fprintf (fpAlignment,"\n");
				}	
			fprintf (fpAlignment,"\n");
			}
		}
	else /* migration */
		{
		if(thereisOutgroup == YES)
			{	

			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 2)
					{
					outgroupLabel = f->label;
					break;
					}
				}
			/*fprintf (stderr, "\n outgroupLabel = %d \n", outgroupLabel);*/


			for (i=0; i<numSequences+1; i++)
				{

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					if ((f->label == i) && (f->index < numSequences))
						{
						dem = f->indexOldMigPop;
						break;
						}
					}
				
				if (i == numSequences)
					fprintf(fpAlignment, ">outgrp_p0\n");
				else 
					fprintf (fpAlignment,">s%05d_p%d\n", i+1, dem);

				
				if (i == numSequences) /* outgroup */
					{
					for (j=1; j<=numNuc; j++)
						{
						fprintf (fpAlignment, "%c", WhichAA(matrix[pos(outgroupLabel,j,numNuc)]));
						}
					}
				else /* tip nodes */
					{
					for (j=1; j<=numNuc; j++)
						{
						fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
						}
					}

				fprintf (fpAlignment,"\n");
				}	
			fprintf (fpAlignment,"\n");
			}
		else
			{
			for (i=0; i<numSequences; i++)
				{
				/*for (m = 0; m < numNodex; m++)
					{
					f = nodex + m;
					if ((f->label == i) && (f->NetIndex < numSequences))
						{
						dem = f->indexOldMigPop;
						break;
						}
					}*/

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					if ((f->label == i) && (f->index < numSequences))
						{
						dem = f->indexOldMigPop;
						break;
						}
					}

				fprintf (fpAlignment,">s%05d_p%d\n", i+1, dem);
				
				for (j=1; j<=numNuc; j++)
					{
					fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
					}
				
				fprintf (fpAlignment,"\n");
				}	
			fprintf (fpAlignment,"\n");
			}
		}
}
		


/***************************** PrintAncestralSequences_AA_FASTA *******************************/
/* Prints ancestral sequences to alignment FASTA file */
static void PrintAncestralSequences_AA_FASTA (/*int replicate*/)   
{
	int		 i, j, a, m, dem, outgroupLabel, rootLabel, otherLabel;
	TreeNode	*f;
	dem = 0;
	outgroupLabel = rootLabel = 0;

	if (numRE == 0) /* There are NOT recombinations */
		{
		if (thereisOutgroup == YES)
			{
			/*fprintf(fpAlignment,"%d %d\n", 2*numSequences, numNuc);*/
			/*fprintf(fpAlignment,"Dataset_%d %d %d\n", replicate+1, 2*numSequences, numNuc);*/
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 2)
					outgroupLabel = f->label;
				else if (f->class == 5)
					rootLabel = f->label;
                else
                    otherLabel = f->label;
				}
			}
		else
			{
			/*fprintf(fpAlignment,"%d %d\n", 2*numSequences-1, numNuc);*/
			/*fprintf(fpAlignment,"Dataset_%d %d %d\n",replicate+1, 2*numSequences-1, numNuc);*/
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 5)
					rootLabel = f->label;
                else
                    otherLabel = f->label;
				}
			}


		
		if (doMigration == NO)
			{
			if(thereisOutgroup == YES)
				{	
				for (i=0; i<2*numSequences; i++)
					{
					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,">seq%05d\n", i+1);
					else if (i == numSequences)
						fprintf(fpAlignment, ">outgroup\n");
					else if (i == 2*numSequences-1)
						fprintf (fpAlignment,">root\n");
					else
                        {
                        fprintf (stderr, "\n\ni = %d (no %d) \n", i, 2*numSequences-1);
                        for (m = 0; m < nextAvailable; m++)
                            {
                            f = nodes + m;
                            /*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
                            if (f->label == i)
                                {
                                otherLabel = f->index;
                                //fprintf (stderr, "\n f->label = %d   f->class = %d    f->index = %d    otherLabel = %d\n", f->label, f->class, f->index, otherLabel);
                                }
                            }
                            
						fprintf (fpAlignment,">anc%05d\n", otherLabel);
                        }
		

					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
							}
						}
					else if (i == numSequences) /* is outgroup */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(outgroupLabel,j,numNuc)]));
							}
						}
					else if (i == 2*numSequences-1) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
					else  /* is ancestral */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i-1,j,numNuc)]));
							}
						}

					fprintf (fpAlignment,"\n");
					}
				fprintf (fpAlignment,"\n");
				}
			else
				{
				for (i=0; i<2*numSequences-1; i++)
					{
					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,">seq%05d\n", i+1);
					else if (i == 2*numSequences-2)
						fprintf (fpAlignment,">root\n");
					else
						fprintf (fpAlignment,">anc%05d\n", i+1);


					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
							}
						}
					else if (i == 2*numSequences-2) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
					else /* is ancestral */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
							}
						}
					fprintf (fpAlignment,"\n");
					}	
				fprintf (fpAlignment,"\n");
				}
			}
		else /* migration */
			{
			if(thereisOutgroup == YES)
				{	
				for (i=0; i<2*numSequences; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if ((f->label == i) && (f->index <= numSequences*2-2))
							{
							dem = f->indexOldMigPop;
							break;
							}
						}*/

					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;

						if (i < numSequences) /* tip */
							{
							if ((f->label == i) && (f->index <= numSequences*2-2)) 
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == 2*numSequences-1) /* root */
							{
							if (f->class == 5)
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == numSequences) /* outgroup */
							{
							dem = 0;
							break;
							}
						else /* ancestral */
							{
							if (f->label == i-1)
								{
								dem = f->indexOldMigPop;
								if (f->class != 4)
									{
									fprintf (stderr, "\n Warning in PrintAncestralSequences_C. f->label = %d, f->class = %d \n", f->label, f->class);
									exit(-1);
									}
								break;
								}
							}
						}
					
					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,">s%05d_p%d\n", i+1, dem);
					else if (i == numSequences)
						fprintf(fpAlignment, ">outgrp_p0\n");
					else if (i == 2*numSequences-1)
						fprintf (fpAlignment,">root_p%d\n", dem);
					else
						fprintf (fpAlignment,">a%05d_p%d\n", i+1, dem);
		

					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
							}
						}
					else if (i == numSequences) /* is outgroup */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(outgroupLabel,j,numNuc)]));
							}
						}
					else if (i == 2*numSequences-1) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
					else  /* is ancestral */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i-1,j,numNuc)]));
							}
						}
					fprintf (fpAlignment,"\n");
					/*fprintf(stderr," \n\n sequence %d with label(in times file) %d", i+1, i+1);*/
					}	
				fprintf (fpAlignment,"\n");
				}
			else
				{
				for (i=0; i<2*numSequences-1; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if ((f->label == i) && (f->index <= numSequences*2-2))
							{
							dem = f->indexOldMigPop;
							break;
							}
						}*/

					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;

						if (i < numSequences) /* tip */
							{
							if ((f->label == i) && (f->index <= numSequences*2-2)) 
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == 2*numSequences-2) /* root */
							{
							if (f->class == 5)
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else /* ancestral */
							{
							if (f->label == i)
								{
								dem = f->indexOldMigPop;
								if (f->class != 4)
									{
									fprintf (stderr, "\n Warning in PrintAncestralSequences_C. f->label = %d, f->class = %d \n", f->label, f->class);
									exit(-1);
									}
								break;
								}
							}
						}
						
					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,">s%05d_p%d\n", i+1, dem);
					else if (i == 2*numSequences-2)
						fprintf (fpAlignment,">root_p%d\n", dem);
					else
						fprintf (fpAlignment,">a%05d_p%d\n", i+1, dem);

					
					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
							}
						}
					else if (i == 2*numSequences-2) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
					else /* is ancestral */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
							}
						}

					fprintf (fpAlignment,"\n");
					}	
				fprintf (fpAlignment,"\n");
				}
			}
		}
	else /* There are recombinations */
		{
		/*if (thereisOutgroup == YES)
			fprintf(fpAlignment,"%d %d \n", numSequences+2, numNuc);*/
			/*fprintf(fpAlignment,"Dataset_%d %d %d \n", replicate+1, numSequences+1, numNuc);*/
		/*else*/
			/*fprintf(fpAlignment,"Dataset_%d %d %d \n", replicate+1, numSequences, numNuc);*/
			/*fprintf(fpAlignment,"%d %d \n", numSequences+1, numNuc);*/
		
		if (doMigration == NO)
			{
			if(thereisOutgroup == YES)
				{	

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 2)
						outgroupLabel = f->label;
					if (f->class == 5)
						rootLabel = f->label;
					}		


				for (i=0; i<2*numSequences; i++)
					{
					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,">seq%05d\n", i+1);
						a++;
						}
					if (i == numSequences)
						{
						fprintf(fpAlignment, ">outgroup\n");
						a++;
						}
					if (i == 2*numSequences-1)
						{
						fprintf (fpAlignment,">root\n");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{
						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == numSequences) /* is outgroup */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichAA(matrix[pos(outgroupLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-1) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}

						/*fprintf(stderr," \n\n sequence %d with label(in times file) %d", i+1, i+1);*/
						}
					}	
				fprintf (fpAlignment,"\n");
				}
			else
				{
				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 5)
						rootLabel = f->label;
					}


				for (i=0; i<2*numSequences-1; i++)
					{
					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,">seq%05d\n", i+1);
						a++;
						}
					if (i == 2*numSequences-2)
						{
						fprintf (fpAlignment,">root\n");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{

						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-2) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}


						}
					}	
				fprintf (fpAlignment,"\n");
				}
			}
		else /* migration */
			{
			if(thereisOutgroup == YES)
				{	
				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 2)
						outgroupLabel = f->label;
					if (f->class == 5)
						rootLabel = f->label;
					}	

				for (i=0; i<2*numSequences; i++)
					{					
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if (f->index < numSequences*/ /*|| i == 2*numSequences-1*//*)
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;*/
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
							/*	break;
								}
						}*/
					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;
						if (f->index < numSequences /*|| i == 2*numSequences-1*/)
							if (f->label == i)
								{
								dem = f->indexOldMigPop;
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								break;
								}
						}

					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,">s%05d_p%d\n", i+1, dem);
						a++;
						}
					if (i == numSequences)
						{
						fprintf(fpAlignment, ">outgrp_p0\n");
						a++;
						}
					if (i == 2*numSequences-1)
						{
						fprintf (fpAlignment,">root\n");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{

						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == numSequences) /* is outgroup */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichAA(matrix[pos(outgroupLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-1) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}

						}
					}	
				fprintf (fpAlignment,"\n");
				}
			else
				{

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 5)
						rootLabel = f->label;
					}


				for (i=0; i<2*numSequences-1; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if (f->index < numSequences*/ /*|| i == 2*numSequences-1*//*)
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;
								break;
								}
						}*/
					
					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;
						if (f->index < numSequences /*|| i == 2*numSequences-1*/)
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								break;
								}
						}


					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,">s%05d_p%d\n", i+1, dem);
						a++;
						}
					if (i == 2*numSequences-2)
						{
						fprintf (fpAlignment,">root\n");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{
						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-2) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}

						}
					}	
				fprintf (fpAlignment,"\n");
				}

			}
		}
}
		












		

/***************************** PrintSequences for codon Model *******************************/
/* Prints sequences to alignment file in fasta sequential format */

static void PrintSequences_C_FASTA (/*int replicate*/)
{
	int		 i, j, k, m, dem, outgroupLabel;
	char codon[3];
	TreeNode	*f;
	dem = 0;
	outgroupLabel = 0;
	
	/*if (thereisOutgroup == YES)
		fprintf(fpAlignment,"%d %d \n", numSequences+1, numNuc);*/
		/*fprintf(fpAlignment,"Dataset_%d %d %d \n", replicate+1, numSequences+1, numNuc);*/
	/*else
		fprintf(fpAlignment,"%d %d \n", numSequences, numNuc);*/
		/*fprintf(fpAlignment,"Dataset_%d %d %d \n", replicate+1, numSequences, numNuc);*/

	if (doMigration == NO)
		{
		if(thereisOutgroup == YES)
			{
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 2)
					{
					outgroupLabel = f->label;
					break;
					}
				}
	
			for (i=0; i<numSequences+1; i++)
				{
				if (i == numSequences)
					fprintf(fpAlignment, ">outgroup\n");
				else 
					fprintf (fpAlignment,">seq%05d\n", i+1);

				if (i == numSequences) /* outgroup */
					{
					for (j=1; j<=numSites; j++)
						{
						if (matrixC[pos(outgroupLabel,j,numSites)] > 60 || matrixC[pos(outgroupLabel,j,numSites)] > 60)
							{
							fprintf (stderr, "\n stop codon5 \n");
							exit(-1);
							}
						number_to_codon(matrixC[pos(outgroupLabel,j,numSites)], codon);
						for (k = 0; k < 3; k++)
							fprintf (fpAlignment, "%c", codon[k]);
						}
					}
				else /* tip nodes */
					{
					for (j=1; j<=numSites; j++)
						{
						if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
							{
							fprintf (stderr, "\n stop codon5 \n");
							exit(-1);
							}
						number_to_codon(matrixC[pos(i,j,numSites)], codon);
						for (k = 0; k < 3; k++)
							fprintf (fpAlignment, "%c", codon[k]);
						}
					}
				fprintf (fpAlignment,"\n");
				/*fprintf(stderr,"\n sequence %d go with nodo of label %d \n", i+1, i+1);*/
				}	
			fprintf (fpAlignment,"\n");
			}
		else
			{
			for (i=0; i<numSequences; i++)
				{
				fprintf (fpAlignment,">seq%05d\n", i+1);

				for (j=1; j<=numSites; j++)
					{
					if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
						{
						fprintf (stderr, "\n stop codon6 \n");
						exit(-1);
						}
					number_to_codon(matrixC[pos(i,j,numSites)], codon);
					for (k = 0; k < 3; k++)
						fprintf (fpAlignment, "%c", codon[k]);
					}
				fprintf (fpAlignment,"\n");
				}	
			fprintf (fpAlignment,"\n");
			}
		}
	else /* migration */
		{
		if(thereisOutgroup == YES)
			{
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 2)
					{
					outgroupLabel = f->label;
					break;
					}
				}
			/*fprintf (stderr, "\n outgroupLabel = %d \n", outgroupLabel);*/
			

			for (i=0; i<numSequences+1; i++)
				{
				/*for (m = 0; m < numNodex; m++)
					{
					f = nodex + m;
					if ((f->label == i) && (f->NetIndex < numSequences))
						{
						dem = f->indexOldMigPop;
						break;
						}
					}*/
				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					if ((f->label == i) && (f->index < numSequences))
						{
						dem = f->indexOldMigPop;
						break;
						}
					}		
		
				if (i == numSequences)
					fprintf(fpAlignment, ">outgrp_p0\n");
				else 
					fprintf (fpAlignment,">s%05d_p%d\n", i+1, dem);
				
				if (i == numSequences) /* outgroup */
					{
					for (j=1; j<=numSites; j++)
						{
						if (matrixC[pos(outgroupLabel,j,numSites)] > 60 || matrixC[pos(outgroupLabel,j,numSites)] > 60)
							{
							fprintf (stderr, "\n stop codon7 \n");
							exit(-1);
							}
						number_to_codon(matrixC[pos(outgroupLabel,j,numSites)], codon);
						for (k = 0; k < 3; k++)
							fprintf (fpAlignment, "%c", codon[k]);
						}
					}
				else /* tip nodes */
					{
					for (j=1; j<=numSites; j++)
						{
						if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
							{
							fprintf (stderr, "\n stop codon7 \n");
							exit(-1);
							}
						number_to_codon(matrixC[pos(i,j,numSites)], codon);
						for (k = 0; k < 3; k++)
							fprintf (fpAlignment, "%c", codon[k]);
						}
					}

				fprintf (fpAlignment,"\n");
				/*fprintf(stderr,"\n sequence %d go with node label(times file label) %d \n", i+1, i+1);*/
				}	
			fprintf (fpAlignment,"\n");
			}
		else
			{
			for (i=0; i<numSequences; i++)
				{
				/*for (m = 0; m < numNodex; m++)
					{
					f = nodex + m;
					if ((f->label == i) && (f->NetIndex < numSequences))
						{
						dem = f->indexOldMigPop;
						break;
						}
					}*/
				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					if ((f->label == i) && (f->index < numSequences))
						{
						dem = f->indexOldMigPop;
						break;
						}
					}
					
				fprintf (fpAlignment,">s%05d_p%d\n", i+1, dem);

				for (j=1; j<=numSites; j++)
					{
					if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
						{
						fprintf (stderr, "\n stop codon8 \n");
						exit(-1);
						}
					number_to_codon(matrixC[pos(i,j,numSites)], codon);
					for (k = 0; k < 3; k++)
						fprintf (fpAlignment, "%c", codon[k]);
					}
				fprintf (fpAlignment,"\n");
				}	
			fprintf (fpAlignment,"\n");
			}
		}
}
		


/***************************** PrintAncestralSequences for Codon Model *******************************/
/* Prints ancestral sequences to alignment file for codon Model */
static void PrintAncestralSequences_C_FASTA (/*int replicate*/)
{
	int		 i, j, k, a, m, dem, outgroupLabel, rootLabel;
	char codon[3];
	TreeNode	*f;
	dem = 0;
	outgroupLabel = rootLabel = 0;	

	if (numRE == 0) /* There are NOT recombinations */
		{
		if (thereisOutgroup == YES)
			{
			/*fprintf(fpAlignment,"%d %d\n", 2*numSequences, numNuc);*/
			/*fprintf(fpAlignment,"Dataset_%d %d %d\n", replicate+1, 2*numSequences, numNuc);*/
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 2)
					outgroupLabel = f->label;
				if (f->class == 5)
					rootLabel = f->label;
				}
			}
		else
			{
			/*fprintf(fpAlignment,"%d %d\n", 2*numSequences-1, numNuc);*/
			/*fprintf(fpAlignment,"Dataset_%d %d %d\n",replicate+1, 2*numSequences-1, numNuc);*/
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 5)
					rootLabel = f->label;
				}
			}
		

		if (doMigration == NO)
			{
			if (thereisOutgroup == YES)
				{	
				for (i=0; i<2*numSequences; i++)
					{
					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,">seq%05d\n", i+1);
					else if (i == numSequences)
						fprintf(fpAlignment, ">outgroup\n");
					else if (i == 2*numSequences-1)
						fprintf (fpAlignment,">root\n");
					else
						fprintf (fpAlignment,">anc%05d\n", i+1);


					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon10 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(i,j,numSites)], codon);
							for (k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}
					else if (i == numSequences) /* is outgroup */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(outgroupLabel,j,numSites)] > 60 || matrixC[pos(outgroupLabel,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon10 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(outgroupLabel,j,numSites)], codon);
							for (k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}
					else if (i == 2*numSequences-1) /* is root */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon10 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
							for (k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}
					else  /* is ancestral */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(i-1,j,numSites)] > 60 || matrixC[pos(i-1,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon10 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(i-1,j,numSites)], codon);
							for (k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}

					fprintf (fpAlignment,"\n");
					}	
				fprintf (fpAlignment,"\n");
				}
			else
				{
				for (i=0; i<2*numSequences-1; i++)
					{
					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,">seq%05d\n", i+1);
					else if (i == 2*numSequences-2)
						fprintf (fpAlignment,">root\n");
					else
						fprintf (fpAlignment,">anc%05d\n", i+1);

					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon11 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(i,j,numSites)], codon);
							for	(k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}
					else if (i == 2*numSequences-2) /* is root */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon11 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
							for	(k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}
					else /* is ancestral */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon11 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(i,j,numSites)], codon);
							for	(k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}

					fprintf (fpAlignment,"\n");
					}	
				fprintf (fpAlignment,"\n");
				}
			}
		else /* migration */
			{
			if (thereisOutgroup == YES)
				{	
				for (i=0; i<2*numSequences; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodex + m;
						if ((f->label == i) && (f->NetIndex <= numSequences*2-2))
							{
							dem = f->indexOldMigPop;
							break;
							}
						}*/
					
					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;

						if (i < numSequences) /* tip */
							{
							if ((f->label == i) && (f->index <= numSequences*2-2)) 
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == 2*numSequences-1) /* root */
							{
							if (f->class == 5)
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == numSequences) /* outgroup */
							{
							dem = 0;
							break;
							}
						else /* ancestral */
							{
							if (f->label == i-1)
								{
								dem = f->indexOldMigPop;
								if (f->class != 4)
									{
									fprintf (stderr, "\n Warning in PrintAncestralSequences_C. f->label = %d, f->class = %d \n", f->label, f->class);
									exit(-1);
									}
								break;
								}
							}
						}



					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,">s%05d_p%d\n", i+1, dem);
					else if (i == numSequences)
						fprintf(fpAlignment, ">outgrp_p0\n");
					else if (i == 2*numSequences-1)
						fprintf (fpAlignment,">root_p%d\n",dem);
					else
						fprintf (fpAlignment,">a%05d_p%d\n", i+1, dem);
		


					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon10 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(i,j,numSites)], codon);
							for (k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}
					else if (i == numSequences) /* is outgroup */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(outgroupLabel,j,numSites)] > 60 || matrixC[pos(outgroupLabel,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon10 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(outgroupLabel,j,numSites)], codon);
							for (k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}
					else if (i == 2*numSequences-1) /* is root */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon10 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
							for (k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}
					else  /* is ancestral */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(i-1,j,numSites)] > 60 || matrixC[pos(i-1,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon10 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(i-1,j,numSites)], codon);
							for (k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}


					fprintf (fpAlignment,"\n");
					}	
				fprintf (fpAlignment,"\n");
				}
			else
				{
				for (i=0; i<2*numSequences-1; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodex + m;
						if ((f->label == i) && (f->NetIndex <= numSequences*2-2))
							{
							dem = f->indexOldMigPop;
							break;
							}
						}*/
					
					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;

						if (i < numSequences) /* tip */
							{
							if ((f->label == i) && (f->index <= numSequences*2-2)) 
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == 2*numSequences-2) /* root */
							{
							if (f->class == 5)
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else /* ancestral */
							{
							if (f->label == i)
								{
								dem = f->indexOldMigPop;
								if (f->class != 4)
									{
									fprintf (stderr, "\n Warning in PrintAncestralSequences_C. f->label = %d, f->class = %d \n", f->label, f->class);
									exit(-1);
									}
								break;
								}
							}
						}




					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,">s%05d_p%d\n", i+1, dem);
					else if (i == 2*numSequences-2)
						fprintf (fpAlignment,">root_p%d\n", dem);
					else
						fprintf (fpAlignment,">a%05d_p%d\n", i+1, dem);


					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon11 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(i,j,numSites)], codon);
							for	(k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}
					else if (i == 2*numSequences-2) /* is root */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon11 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
							for	(k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}
					else /* is ancestral */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon11 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(i,j,numSites)], codon);
							for	(k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}

					fprintf (fpAlignment,"\n");

					}	
				}
			fprintf (fpAlignment,"\n");
			}
		}
	else /* There are recombinations */
		{
		/*if (thereisOutgroup == YES)
			fprintf(fpAlignment,"%d %d\n", numSequences+2, numNuc);
		else
			fprintf(fpAlignment,"%d %d\n", numSequences+1, numNuc);*/
		
		if (doMigration == NO)
			{
			if (thereisOutgroup == YES)
				{
				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 2)
						outgroupLabel = f->label;
					if (f->class == 5)
						rootLabel = f->label;
					}				
	
				for (i=0; i<2*numSequences; i++)
					{
					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,">seq%05d\n", i+1);
						a++;
						}
					if (i == numSequences)
						{
						fprintf(fpAlignment, ">outgroup\n");
						a++;
						}
					if (i == 2*numSequences-1)
						{
						fprintf (fpAlignment,">root\n");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{
						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon14 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(i,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpAlignment, "%c", codon[k]);
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == numSequences) /* is outgroup */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(outgroupLabel,j,numSites)] > 60 || matrixC[pos(outgroupLabel,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon14 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(outgroupLabel,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpAlignment, "%c", codon[k]);
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-1) /* is root */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon14 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpAlignment, "%c", codon[k]);
								}
							fprintf (fpAlignment,"\n");
							}

						}
					}	
				fprintf (fpAlignment,"\n");
				}
			else
				{

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 5)
						rootLabel = f->label;
					}

				for (i=0; i<2*numSequences-1; i++)
					{
					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,">seq%05d\n", i+1);
						a++;
						}
					if (i == 2*numSequences-2)
						{
						fprintf (fpAlignment,">root\n");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{
						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon15 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(i,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpAlignment, "%c", codon[k]);
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-2) /* is root */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon15 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpAlignment, "%c", codon[k]);
								}
							fprintf (fpAlignment,"\n");
							}

						}
					}	
				fprintf (fpAlignment,"\n");
				}
			}
		else /* migration */
			{
			if (thereisOutgroup == YES)
				{	

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 2)
						outgroupLabel = f->label;
					if (f->class == 5)
						rootLabel = f->label;
					}	


				for (i=0; i<2*numSequences; i++)
					{

					/*for (m = 0; m < numNodex; m++)
						{
						f = nodex + m;
						if (f->NetIndex < numSequences*/ /*|| i == 2*numSequences-1*//*
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;*/
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								/*break;
								}
						}*/

					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;
						if (f->index < numSequences /*|| i == 2*numSequences-1*/)
							if (f->label == i)
								{
								dem = f->indexOldMigPop;
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								break;
								}
						}



					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,">s%05d_p%d\n", i+1, dem);
						a++;
						}
					if (i == numSequences)
						{
						fprintf(fpAlignment, ">outgrp_p0\n");
						a++;
						}
					if (i == 2*numSequences-1)
						{
						fprintf (fpAlignment,">root\n");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{

						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon16 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(i,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpAlignment, "%c", codon[k]);
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == numSequences) /* is outgroup */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(outgroupLabel,j,numSites)] > 60 || matrixC[pos(outgroupLabel,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon16 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(outgroupLabel,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpAlignment, "%c", codon[k]);
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-1) /* is root */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon16 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpAlignment, "%c", codon[k]);
								}
							fprintf (fpAlignment,"\n");
							}

						}
					}	
				fprintf (fpAlignment,"\n");
				}
			else
				{

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 5)
						rootLabel = f->label;
					}

				for (i=0; i<2*numSequences-1; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodex + m;
						if (f->NetIndex < numSequences*/ /*|| i == 2*numSequences-1*//*)
							if (f->label == i)
								{
								dem = f->indexOldMigPop;*/
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								/*break;
								}
						}*/
					
					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;
						if (f->index < numSequences /*|| i == 2*numSequences-1*/)
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								break;
								}
						}



					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,">s%05d_p%d\n", i+1, dem);
						a++;
						}
					if (i == 2*numSequences-2)
						{
						fprintf (fpAlignment,">root\n");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{
						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon17 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(i,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpAlignment, "%c", codon[k]);
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-2) /* is root */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon17 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpAlignment, "%c", codon[k]);
								}
							fprintf (fpAlignment,"\n");
							}


						}
					}	
				fprintf (fpAlignment,"\n");
				}
			}
		}
}






/**** NEXUS ****/
/***************************** PrintSequences_NEXUS *******************************/
/* Prints sequences to nexus alignment file */

static void PrintSequences_NEXUS (/*int replicate*/) 
{
	int		 i, j, m, dem, outgroupLabel;
	TreeNode	*f;
	
	dem = 0;
	outgroupLabel = 0;

	PrintNEXUS_initial();

	if (thereisOutgroup == YES)
		{
		fprintf(fpAlignment,"Dimensions ntax=%d nchar=%d;\n", numSequences+1, numNuc);
		/*fprintf(fpAlignment,"Dataset_%d %d %d \n", replicate+1, numSequences+1, numNuc);*/
		}
	else
		{
		/*fprintf(fpAlignment,"Dataset_%d %d %d \n", replicate+1, numSequences, numNuc);*/
		fprintf(fpAlignment,"Dimensions ntax=%d nchar=%d;\n", numSequences, numNuc);
		}

	fprintf(fpAlignment,"	Format datatype=nucleotide gap=- missing=? matchchar=.;\n");
	fprintf(fpAlignment,"	Matrix\n");

	
	if (doMigration == NO)
		{
		if(thereisOutgroup == YES)
			{
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 2)
					{
					outgroupLabel = f->label;
					break;
					}
				}
	
			for (i=0; i<numSequences+1; i++)
				{
				if (i == numSequences)
					fprintf(fpAlignment, "outgroup     ");
				else 
					fprintf (fpAlignment,"seq%05d     ", i+1);
				
				if (i == numSequences) /* outgroup */
					{
					for (j=1; j<=numNuc; j++)
						{
						fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(outgroupLabel,j,numNuc)]));
						}
					}
				else /* tip nodes */
					{
					for (j=1; j<=numNuc; j++)
						{
						fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
						}
					}
				fprintf (fpAlignment,"\n");
				}	
			/*fprintf (fpAlignment,"\n");*/
			/*fprintf(stderr,"\n sequence %d go with nodo of label %d \n", i+1, i+1);*/
			}
		else
			{
			for (i=0; i<numSequences; i++)
				{
				fprintf (fpAlignment,"seq%05d     ", i+1);

				for (j=1; j<=numNuc; j++)
					fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
				fprintf (fpAlignment,"\n");
				}	
			/*fprintf (fpAlignment,"\n");*/
			}
		}
	else /* migration */
		{
		if(thereisOutgroup == YES)
			{	

			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 2)
					{
					outgroupLabel = f->label;
					break;
					}
				}
			/*fprintf (stderr, "\n outgroupLabel = %d \n", outgroupLabel);*/


			for (i=0; i<numSequences+1; i++)
				{

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					if ((f->label == i) && (f->index < numSequences))
						{
						dem = f->indexOldMigPop;
						break;
						}
					}
				
				if (i == numSequences)
					fprintf(fpAlignment, "outgrp_p0    ");
				else 
					fprintf (fpAlignment,"s%05d_p%d    ", i+1, dem);

				
				if (i == numSequences) /* outgroup */
					{
					for (j=1; j<=numNuc; j++)
						{
						fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(outgroupLabel,j,numNuc)]));
						}
					}
				else /* tip nodes */
					{
					for (j=1; j<=numNuc; j++)
						{
						fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
						}
					}

				fprintf (fpAlignment,"\n");
				}	
			/*fprintf (fpAlignment,"\n");*/
			}
		else
			{
			for (i=0; i<numSequences; i++)
				{
				/*for (m = 0; m < numNodex; m++)
					{
					f = nodex + m;
					if ((f->label == i) && (f->NetIndex < numSequences))
						{
						dem = f->indexOldMigPop;
						break;
						}
					}*/

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					if ((f->label == i) && (f->index < numSequences))
						{
						dem = f->indexOldMigPop;
						break;
						}
					}

				fprintf (fpAlignment,"s%05d_p%d    ", i+1, dem);
				
				for (j=1; j<=numNuc; j++)
					{
					fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
					}
				
				fprintf (fpAlignment,"\n");
				}	
			/*fprintf (fpAlignment,"\n");*/
			}
		}
	PrintNEXUS_end();
}
		


/***************************** PrintAncestralSequences_NEXUS *******************************/
/* Prints ancestral sequences to nexus alignment file */

static void PrintAncestralSequences_NEXUS (/*int replicate*/)   
{
	int		 i, j, a, m, dem, outgroupLabel, rootLabel;
	TreeNode	*f;
	dem = 0;
	outgroupLabel = rootLabel = 0;

	PrintNEXUS_initial();

	if (numRE == 0) /* There are NOT recombinations */
		{
		if (thereisOutgroup == YES)
			{
			fprintf(fpAlignment,"Dimensions ntax=%d nchar=%d;\n", 2*numSequences, numNuc);
			/*fprintf(fpAlignment,"Dataset_%d %d %d\n", replicate+1, 2*numSequences, numNuc);*/
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 2)
					outgroupLabel = f->label;
				if (f->class == 5)
					rootLabel = f->label;
				}
			}
		else
			{
			fprintf(fpAlignment,"Dimensions ntax=%d nchar=%d;\n", 2*numSequences-1, numNuc);
			/*fprintf(fpAlignment,"Dataset_%d %d %d\n",replicate+1, 2*numSequences-1, numNuc);*/
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 5)
					rootLabel = f->label;
				}
			}
		
		fprintf(fpAlignment,"	Format datatype=nucleotide gap=- missing=? matchchar=.;\n");
		fprintf(fpAlignment,"	Matrix\n");

		
		if (doMigration == NO)
			{
			if(thereisOutgroup == YES)
				{	
				for (i=0; i<2*numSequences; i++)
					{
					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,"seq%05d     ", i+1);
					else if (i == numSequences)
						fprintf(fpAlignment, "outgroup     ");
					else if (i == 2*numSequences-1)
						fprintf (fpAlignment,"root         ");
					else
						fprintf (fpAlignment,"anc%05d     ", i+1);
		

					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
							}
						}
					else if (i == numSequences) /* is outgroup */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(outgroupLabel,j,numNuc)]));
							}
						}
					else if (i == 2*numSequences-1) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
					else  /* is ancestral */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i-1,j,numNuc)]));
							}
						}

					fprintf (fpAlignment,"\n");
					}
				/*fprintf (fpAlignment,"\n");*/
				}
			else
				{
				for (i=0; i<2*numSequences-1; i++)
					{
					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,"seq%05d     ", i+1);
					else if (i == 2*numSequences-2)
						fprintf (fpAlignment,"root         ");
					else
						fprintf (fpAlignment,"anc%05d     ", i+1);


					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
							}
						}
					else if (i == 2*numSequences-2) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
					else /* is ancestral */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
							}
						}
					fprintf (fpAlignment,"\n");
					}	
				/*fprintf (fpAlignment,"\n");*/
				}
			}
		else /* migration */
			{
			if(thereisOutgroup == YES)
				{	
				for (i=0; i<2*numSequences; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if ((f->label == i) && (f->index <= numSequences*2-2))
							{
							dem = f->indexOldMigPop;
							break;
							}
						}*/

					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;

						if (i < numSequences) /* tip */
							{
							if ((f->label == i) && (f->index <= numSequences*2-2)) 
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == 2*numSequences-1) /* root */
							{
							if (f->class == 5)
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == numSequences) /* outgroup */
							{
							dem = 0;
							break;
							}
						else /* ancestral */
							{
							if (f->label == i-1)
								{
								dem = f->indexOldMigPop;
								if (f->class != 4)
									{
									fprintf (stderr, "\n Warning in PrintAncestralSequences_C. f->label = %d, f->class = %d \n", f->label, f->class);
									exit(-1);
									}
								break;
								}
							}
						}
					
					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,"s%05d_p%d    ", i+1, dem);
					else if (i == numSequences)
						fprintf(fpAlignment, "outgrp_p0    ");
					else if (i == 2*numSequences-1)
						fprintf (fpAlignment,"root_p%d      ", dem);
					else
						fprintf (fpAlignment,"a%05d_p%d    ", i+1, dem);
		

					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
							}
						}
					else if (i == numSequences) /* is outgroup */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(outgroupLabel,j,numNuc)]));
							}
						}
					else if (i == 2*numSequences-1) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
					else  /* is ancestral */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i-1,j,numNuc)]));
							}
						}
					fprintf (fpAlignment,"\n");
					/*fprintf(stderr," \n\n sequence %d with label(in times file) %d", i+1, i+1);*/
					}	
				/*fprintf (fpAlignment,"\n");*/
				}
			else
				{
				for (i=0; i<2*numSequences-1; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if ((f->label == i) && (f->index <= numSequences*2-2))
							{
							dem = f->indexOldMigPop;
							break;
							}
						}*/

					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;

						if (i < numSequences) /* tip */
							{
							if ((f->label == i) && (f->index <= numSequences*2-2)) 
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == 2*numSequences-2) /* root */
							{
							if (f->class == 5)
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else /* ancestral */
							{
							if (f->label == i)
								{
								dem = f->indexOldMigPop;
								if (f->class != 4)
									{
									fprintf (stderr, "\n Warning in PrintAncestralSequences_C. f->label = %d, f->class = %d \n", f->label, f->class);
									exit(-1);
									}
								break;
								}
							}
						}
						
					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,"s%05d_p%d    ", i+1, dem);
					else if (i == 2*numSequences-2)
						fprintf (fpAlignment,"root_p%d      ", dem);
					else
						fprintf (fpAlignment,"a%05d_p%d    ", i+1, dem);

					
					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
							}
						}
					else if (i == 2*numSequences-2) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
					else /* is ancestral */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
							}
						}

					fprintf (fpAlignment,"\n");
					}	
				/*fprintf (fpAlignment,"\n");*/
				}
			}
		}
	else /* There are recombinations */
		{
		if (thereisOutgroup == YES)
			{
			fprintf(fpAlignment,"Dimensions ntax=%d nchar=%d;\n", numSequences+2, numNuc);
			/*fprintf(fpAlignment,"Dataset_%d %d %d \n", replicate+1, numSequences+1, numNuc);*/
			}
		else
			{
			/*fprintf(fpAlignment,"Dataset_%d %d %d \n", replicate+1, numSequences, numNuc);*/
			fprintf(fpAlignment,"Dimensions ntax=%d nchar=%d;\n", numSequences+1, numNuc);
			}
		
		if (doMigration == NO)
			{
			if(thereisOutgroup == YES)
				{	

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 2)
						outgroupLabel = f->label;
					if (f->class == 5)
						rootLabel = f->label;
					}		


				for (i=0; i<2*numSequences; i++)
					{
					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,"seq%05d     ", i+1);
						a++;
						}
					if (i == numSequences)
						{
						fprintf(fpAlignment, "outgroup     ");
						a++;
						}
					if (i == 2*numSequences-1)
						{
						fprintf (fpAlignment,"root         ");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{
						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == numSequences) /* is outgroup */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(outgroupLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-1) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}

						/*fprintf(stderr," \n\n sequence %d with label(in times file) %d", i+1, i+1);*/
						}
					}	
				/*fprintf (fpAlignment,"\n");*/
				}
			else
				{
				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 5)
						rootLabel = f->label;
					}


				for (i=0; i<2*numSequences-1; i++)
					{
					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,"seq%05d     ", i+1);
						a++;
						}
					if (i == 2*numSequences-2)
						{
						fprintf (fpAlignment,"root         ");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{

						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-2) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}

						}
					}	
				/*fprintf (fpAlignment,"\n");*/
				}
			}
		else /* migration */
			{
			if(thereisOutgroup == YES)
				{	
				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 2)
						outgroupLabel = f->label;
					if (f->class == 5)
						rootLabel = f->label;
					}	



				for (i=0; i<2*numSequences; i++)
					{					
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if (f->index < numSequences*/ /*|| i == 2*numSequences-1*//*)
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;*/
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
							/*	break;
								}
						}*/
					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;
						if (f->index < numSequences /*|| i == 2*numSequences-1*/)
							if (f->label == i)
								{
								dem = f->indexOldMigPop;
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								break;
								}
						}

					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,"s%05d_p%d    ", i+1, dem);
						a++;
						}
					if (i == numSequences)
						{
						fprintf(fpAlignment, "outgrp_p0    ");
						a++;
						}
					if (i == 2*numSequences-1)
						{
						fprintf (fpAlignment,"root         ");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{
						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == numSequences) /* is outgroup */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(outgroupLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-1) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}

						}
					}	
				/*fprintf (fpAlignment,"\n");*/
				}
			else
				{

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 5)
						rootLabel = f->label;
					}


				for (i=0; i<2*numSequences-1; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if (f->index < numSequences*/ /*|| i == 2*numSequences-1*//*)
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;
								break;
								}
						}*/
					
					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;
						if (f->index < numSequences /*|| i == 2*numSequences-1*/)
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								break;
								}
						}


					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,"s%05d_p%d    ", i+1, dem);
						a++;
						}
					if (i == 2*numSequences-2)
						{
						fprintf (fpAlignment,"root         ");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{
						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(i,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-2) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(rootLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}

						}
					}	
				/*fprintf (fpAlignment,"\n");*/
				}

			}
		}
	PrintNEXUS_end();
}
		






/***************************** PrintSequences_AA_NEXUS *******************************/
/* Prints sequences to nexus alignment file */

static void PrintSequences_AA_NEXUS (/*int replicate*/) 
{
	int		 i, j, m, dem, outgroupLabel;
	TreeNode	*f;
	
	dem = 0;
	outgroupLabel = 0;

	PrintNEXUS_initial();

	if (thereisOutgroup == YES)
		{
		fprintf(fpAlignment,"Dimensions ntax=%d nchar=%d;\n", numSequences+1, numNuc);
		/*fprintf(fpAlignment,"Dataset_%d %d %d \n", replicate+1, numSequences+1, numNuc);*/
		}
	else
		{
		/*fprintf(fpAlignment,"Dataset_%d %d %d \n", replicate+1, numSequences, numNuc);*/
		fprintf(fpAlignment,"Dimensions ntax=%d nchar=%d;\n", numSequences, numNuc);
		}

	fprintf(fpAlignment,"	Format datatype=protein gap=- missing=? matchchar=.;\n");
	fprintf(fpAlignment,"	Matrix\n");

	
	if (doMigration == NO)
		{
		if(thereisOutgroup == YES)
			{
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 2)
					{
					outgroupLabel = f->label;
					break;
					}
				}
	
			for (i=0; i<numSequences+1; i++)
				{
				if (i == numSequences)
					fprintf(fpAlignment, "outgroup     ");
				else 
					fprintf (fpAlignment,"seq%05d     ", i+1);
				
				if (i == numSequences) /* outgroup */
					{
					for (j=1; j<=numNuc; j++)
						{
						fprintf (fpAlignment, "%c", WhichAA(matrix[pos(outgroupLabel,j,numNuc)]));
						}
					}
				else /* tip nodes */
					{
					for (j=1; j<=numNuc; j++)
						{
						fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
						}
					}
				fprintf (fpAlignment,"\n");
				}	
			/*fprintf (fpAlignment,"\n");*/
			/*fprintf(stderr,"\n sequence %d go with nodo of label %d \n", i+1, i+1);*/
			}
		else
			{
			for (i=0; i<numSequences; i++)
				{
				fprintf (fpAlignment,"seq%05d     ", i+1);

				for (j=1; j<=numNuc; j++)
					fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
				fprintf (fpAlignment,"\n");
				}	
			/*fprintf (fpAlignment,"\n");*/
			}
		}
	else /* migration */
		{
		if(thereisOutgroup == YES)
			{	

			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 2)
					{
					outgroupLabel = f->label;
					break;
					}
				}
			/*fprintf (stderr, "\n outgroupLabel = %d \n", outgroupLabel);*/


			for (i=0; i<numSequences+1; i++)
				{

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					if ((f->label == i) && (f->index < numSequences))
						{
						dem = f->indexOldMigPop;
						break;
						}
					}
				
				if (i == numSequences)
					fprintf(fpAlignment, "outgrp_p0    ");
				else 
					fprintf (fpAlignment,"s%05d_p%d    ", i+1, dem);

				
				if (i == numSequences) /* outgroup */
					{
					for (j=1; j<=numNuc; j++)
						{
						fprintf (fpAlignment, "%c", WhichAA(matrix[pos(outgroupLabel,j,numNuc)]));
						}
					}
				else /* tip nodes */
					{
					for (j=1; j<=numNuc; j++)
						{
						fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
						}
					}

				fprintf (fpAlignment,"\n");
				}	
			/*fprintf (fpAlignment,"\n");*/
			}
		else
			{
			for (i=0; i<numSequences; i++)
				{
				/*for (m = 0; m < numNodex; m++)
					{
					f = nodex + m;
					if ((f->label == i) && (f->NetIndex < numSequences))
						{
						dem = f->indexOldMigPop;
						break;
						}
					}*/

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					if ((f->label == i) && (f->index < numSequences))
						{
						dem = f->indexOldMigPop;
						break;
						}
					}

				fprintf (fpAlignment,"s%05d_p%d    ", i+1, dem);
				
				for (j=1; j<=numNuc; j++)
					{
					fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
					}
				
				fprintf (fpAlignment,"\n");
				}	
			/*fprintf (fpAlignment,"\n");*/
			}
		}
	PrintNEXUS_end();
}
		


/***************************** PrintAncestralSequences_AA_NEXUS *******************************/
/* Prints ancestral sequences to nexus alignment file */

static void PrintAncestralSequences_AA_NEXUS (/*int replicate*/)   
{
	int		 i, j, a, m, dem, outgroupLabel, rootLabel;
	TreeNode	*f;
	dem = 0;
	outgroupLabel = rootLabel = 0;

	PrintNEXUS_initial();

	if (numRE == 0) /* There are NOT recombinations */
		{
		if (thereisOutgroup == YES)
			{
			fprintf(fpAlignment,"Dimensions ntax=%d nchar=%d;\n", 2*numSequences, numNuc);
			/*fprintf(fpAlignment,"Dataset_%d %d %d\n", replicate+1, 2*numSequences, numNuc);*/
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 2)
					outgroupLabel = f->label;
				if (f->class == 5)
					rootLabel = f->label;
				}
			}
		else
			{
			fprintf(fpAlignment,"Dimensions ntax=%d nchar=%d;\n", 2*numSequences-1, numNuc);
			/*fprintf(fpAlignment,"Dataset_%d %d %d\n",replicate+1, 2*numSequences-1, numNuc);*/
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 5)
					rootLabel = f->label;
				}
			}
		
		fprintf(fpAlignment,"	Format datatype=protein gap=- missing=? matchchar=.;\n");
		fprintf(fpAlignment,"	Matrix\n");

		
		if (doMigration == NO)
			{
			if(thereisOutgroup == YES)
				{	
				for (i=0; i<2*numSequences; i++)
					{
					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,"seq%05d     ", i+1);
					else if (i == numSequences)
						fprintf(fpAlignment, "outgroup     ");
					else if (i == 2*numSequences-1)
						fprintf (fpAlignment,"root         ");
					else
						fprintf (fpAlignment,"anc%05d     ", i+1);
		

					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
							}
						}
					else if (i == numSequences) /* is outgroup */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(outgroupLabel,j,numNuc)]));
							}
						}
					else if (i == 2*numSequences-1) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
					else  /* is ancestral */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i-1,j,numNuc)]));
							}
						}

					fprintf (fpAlignment,"\n");
					}
				/*fprintf (fpAlignment,"\n");*/
				}
			else
				{
				for (i=0; i<2*numSequences-1; i++)
					{
					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,"seq%05d     ", i+1);
					else if (i == 2*numSequences-2)
						fprintf (fpAlignment,"root         ");
					else
						fprintf (fpAlignment,"anc%05d     ", i+1);


					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
							}
						}
					else if (i == 2*numSequences-2) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
					else /* is ancestral */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
							}
						}
					fprintf (fpAlignment,"\n");
					}	
				/*fprintf (fpAlignment,"\n");*/
				}
			}
		else /* migration */
			{
			if(thereisOutgroup == YES)
				{	
				for (i=0; i<2*numSequences; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if ((f->label == i) && (f->index <= numSequences*2-2))
							{
							dem = f->indexOldMigPop;
							break;
							}
						}*/

					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;

						if (i < numSequences) /* tip */
							{
							if ((f->label == i) && (f->index <= numSequences*2-2)) 
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == 2*numSequences-1) /* root */
							{
							if (f->class == 5)
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == numSequences) /* outgroup */
							{
							dem = 0;
							break;
							}
						else /* ancestral */
							{
							if (f->label == i-1)
								{
								dem = f->indexOldMigPop;
								if (f->class != 4)
									{
									fprintf (stderr, "\n Warning in PrintAncestralSequences_C. f->label = %d, f->class = %d \n", f->label, f->class);
									exit(-1);
									}
								break;
								}
							}
						}
					
					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,"s%05d_p%d    ", i+1, dem);
					else if (i == numSequences)
						fprintf(fpAlignment, "outgrp_p0    ");
					else if (i == 2*numSequences-1)
						fprintf (fpAlignment,"root_p%d      ", dem);
					else
						fprintf (fpAlignment,"a%05d_p%d    ", i+1, dem);
		

					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
							}
						}
					else if (i == numSequences) /* is outgroup */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(outgroupLabel,j,numNuc)]));
							}
						}
					else if (i == 2*numSequences-1) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
					else  /* is ancestral */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i-1,j,numNuc)]));
							}
						}
					fprintf (fpAlignment,"\n");
					/*fprintf(stderr," \n\n sequence %d with label(in times file) %d", i+1, i+1);*/
					}	
				/*fprintf (fpAlignment,"\n");*/
				}
			else
				{
				for (i=0; i<2*numSequences-1; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if ((f->label == i) && (f->index <= numSequences*2-2))
							{
							dem = f->indexOldMigPop;
							break;
							}
						}*/

					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;

						if (i < numSequences) /* tip */
							{
							if ((f->label == i) && (f->index <= numSequences*2-2)) 
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == 2*numSequences-2) /* root */
							{
							if (f->class == 5)
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else /* ancestral */
							{
							if (f->label == i)
								{
								dem = f->indexOldMigPop;
								if (f->class != 4)
									{
									fprintf (stderr, "\n Warning in PrintAncestralSequences_C. f->label = %d, f->class = %d \n", f->label, f->class);
									exit(-1);
									}
								break;
								}
							}
						}
						
					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,"s%05d_p%d    ", i+1, dem);
					else if (i == 2*numSequences-2)
						fprintf (fpAlignment,"root_p%d      ", dem);
					else
						fprintf (fpAlignment,"a%05d_p%d    ", i+1, dem);

					
					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
							}
						}
					else if (i == 2*numSequences-2) /* is root */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
							}
						}
					else /* is ancestral */
						{
						for (j=1; j<=numNuc; j++)
							{
							fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
							}
						}

					fprintf (fpAlignment,"\n");
					}	
				/*fprintf (fpAlignment,"\n");*/
				}
			}
		}
	else /* There are recombinations */
		{
		if (thereisOutgroup == YES)
			{
			fprintf(fpAlignment,"Dimensions ntax=%d nchar=%d;\n", numSequences+2, numNuc);
			/*fprintf(fpAlignment,"Dataset_%d %d %d \n", replicate+1, numSequences+1, numNuc);*/
			}
		else
			{
			/*fprintf(fpAlignment,"Dataset_%d %d %d \n", replicate+1, numSequences, numNuc);*/
			fprintf(fpAlignment,"Dimensions ntax=%d nchar=%d;\n", numSequences+1, numNuc);
			}
		
		if (doMigration == NO)
			{
			if(thereisOutgroup == YES)
				{	

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 2)
						outgroupLabel = f->label;
					if (f->class == 5)
						rootLabel = f->label;
					}		


				for (i=0; i<2*numSequences; i++)
					{
					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,"seq%05d     ", i+1);
						a++;
						}
					if (i == numSequences)
						{
						fprintf(fpAlignment, "outgroup     ");
						a++;
						}
					if (i == 2*numSequences-1)
						{
						fprintf (fpAlignment,"root         ");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{
						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == numSequences) /* is outgroup */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichAA(matrix[pos(outgroupLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-1) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}

						/*fprintf(stderr," \n\n sequence %d with label(in times file) %d", i+1, i+1);*/
						}
					}	
				/*fprintf (fpAlignment,"\n");*/
				}
			else
				{
				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 5)
						rootLabel = f->label;
					}


				for (i=0; i<2*numSequences-1; i++)
					{
					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,"seq%05d     ", i+1);
						a++;
						}
					if (i == 2*numSequences-2)
						{
						fprintf (fpAlignment,"root         ");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{

						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-2) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}

						}
					}	
				/*fprintf (fpAlignment,"\n");*/
				}
			}
		else /* migration */
			{
			if(thereisOutgroup == YES)
				{	
				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 2)
						outgroupLabel = f->label;
					if (f->class == 5)
						rootLabel = f->label;
					}	



				for (i=0; i<2*numSequences; i++)
					{					
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if (f->index < numSequences*/ /*|| i == 2*numSequences-1*//*)
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;*/
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
							/*	break;
								}
						}*/
					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;
						if (f->index < numSequences /*|| i == 2*numSequences-1*/)
							if (f->label == i)
								{
								dem = f->indexOldMigPop;
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								break;
								}
						}

					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,"s%05d_p%d    ", i+1, dem);
						a++;
						}
					if (i == numSequences)
						{
						fprintf(fpAlignment, "outgrp_p0    ");
						a++;
						}
					if (i == 2*numSequences-1)
						{
						fprintf (fpAlignment,"root         ");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{
						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == numSequences) /* is outgroup */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichAA(matrix[pos(outgroupLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-1) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}

						}
					}	
				/*fprintf (fpAlignment,"\n");*/
				}
			else
				{

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 5)
						rootLabel = f->label;
					}


				for (i=0; i<2*numSequences-1; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodes + m;
						if (f->index < numSequences*/ /*|| i == 2*numSequences-1*//*)
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;
								break;
								}
						}*/
					
					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;
						if (f->index < numSequences /*|| i == 2*numSequences-1*/)
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								break;
								}
						}


					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,"s%05d_p%d    ", i+1, dem);
						a++;
						}
					if (i == 2*numSequences-2)
						{
						fprintf (fpAlignment,"root         ");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{
						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichAA(matrix[pos(i,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-2) /* is root */
							{
							for (j=1; j<=numNuc; j++)
								{
								fprintf (fpAlignment, "%c", WhichAA(matrix[pos(rootLabel,j,numNuc)]));
								}
							fprintf (fpAlignment,"\n");
							}

						}
					}	
				/*fprintf (fpAlignment,"\n");*/
				}

			}
		}

	PrintNEXUS_end();
}
		












/***************************** PrintSequences for codon Model *******************************/
/* Prints sequences to alignment file in nexus sequential format */

static void PrintSequences_C_NEXUS (/*int replicate*/)
{
	int		 i, j, k, m, dem, outgroupLabel;
	char codon[3];
	TreeNode	*f;
	dem = 0;
	outgroupLabel = 0;
	
	PrintNEXUS_initial();

	if (thereisOutgroup == YES)
		fprintf(fpAlignment,"Dimensions ntax=%d nchar=%d;\n", numSequences+1, numNuc);
		/*fprintf(fpAlignment,"Dataset_%d %d %d \n", replicate+1, numSequences+1, numNuc);*/
	else
		fprintf(fpAlignment,"Dimensions ntax=%d nchar=%d;\n", numSequences, numNuc);
		/*fprintf(fpAlignment,"Dataset_%d %d %d \n", replicate+1, numSequences, numNuc);*/
	
	fprintf(fpAlignment,"	Format datatype=nucleotide gap=- missing=? matchchar=.;\n");
	fprintf(fpAlignment,"	Matrix\n");

	if (doMigration == NO)
		{
		if(thereisOutgroup == YES)
			{
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 2)
					{
					outgroupLabel = f->label;
					break;
					}
				}
	
			for (i=0; i<numSequences+1; i++)
				{
				if (i == numSequences)
					fprintf(fpAlignment, "outgroup     ");
				else 
					fprintf (fpAlignment,"seq%05d     ", i+1);

				if (i == numSequences) /* outgroup */
					{
					for (j=1; j<=numSites; j++)
						{
						if (matrixC[pos(outgroupLabel,j,numSites)] > 60 || matrixC[pos(outgroupLabel,j,numSites)] > 60)
							{
							fprintf (stderr, "\n stop codon5 \n");
							exit(-1);
							}
						number_to_codon(matrixC[pos(outgroupLabel,j,numSites)], codon);
						for (k = 0; k < 3; k++)
							fprintf (fpAlignment, "%c", codon[k]);
						}
					}
				else /* tip nodes */
					{
					for (j=1; j<=numSites; j++)
						{
						if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
							{
							fprintf (stderr, "\n stop codon5 \n");
							exit(-1);
							}
						number_to_codon(matrixC[pos(i,j,numSites)], codon);
						for (k = 0; k < 3; k++)
							fprintf (fpAlignment, "%c", codon[k]);
						}
					}
				fprintf (fpAlignment,"\n");
				/*fprintf(stderr,"\n sequence %d go with nodo of label %d \n", i+1, i+1);*/
				}	
			/*fprintf (fpAlignment,"\n");*/
			}
		else
			{
			for (i=0; i<numSequences; i++)
				{
				fprintf (fpAlignment,"seq%05d     ", i+1);

				for (j=1; j<=numSites; j++)
					{
					if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
						{
						fprintf (stderr, "\n stop codon6 \n");
						exit(-1);
						}
					number_to_codon(matrixC[pos(i,j,numSites)], codon);
					for (k = 0; k < 3; k++)
						fprintf (fpAlignment, "%c", codon[k]);
					}
				fprintf (fpAlignment,"\n");
				}	
			/*fprintf (fpAlignment,"\n");*/
			}
		}
	else /* migration */
		{
		if(thereisOutgroup == YES)
			{
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 2)
					{
					outgroupLabel = f->label;
					break;
					}
				}
			/*fprintf (stderr, "\n outgroupLabel = %d \n", outgroupLabel);*/
			

			for (i=0; i<numSequences+1; i++)
				{
				/*for (m = 0; m < numNodex; m++)
					{
					f = nodex + m;
					if ((f->label == i) && (f->NetIndex < numSequences))
						{
						dem = f->indexOldMigPop;
						break;
						}
					}*/
				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					if ((f->label == i) && (f->index < numSequences))
						{
						dem = f->indexOldMigPop;
						break;
						}
					}		
		
				if (i == numSequences)
					fprintf(fpAlignment, "outgrp_p0    ");
				else 
					fprintf (fpAlignment,"s%05d_p%d    ", i+1, dem);
				
				if (i == numSequences) /* outgroup */
					{
					for (j=1; j<=numSites; j++)
						{
						if (matrixC[pos(outgroupLabel,j,numSites)] > 60 || matrixC[pos(outgroupLabel,j,numSites)] > 60)
							{
							fprintf (stderr, "\n stop codon7 \n");
							exit(-1);
							}
						number_to_codon(matrixC[pos(outgroupLabel,j,numSites)], codon);
						for (k = 0; k < 3; k++)
							fprintf (fpAlignment, "%c", codon[k]);
						}
					}
				else /* tip nodes */
					{
					for (j=1; j<=numSites; j++)
						{
						if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
							{
							fprintf (stderr, "\n stop codon7 \n");
							exit(-1);
							}
						number_to_codon(matrixC[pos(i,j,numSites)], codon);
						for (k = 0; k < 3; k++)
							fprintf (fpAlignment, "%c", codon[k]);
						}
					}

				fprintf (fpAlignment,"\n");
				/*fprintf(stderr,"\n sequence %d go with node label(times file label) %d \n", i+1, i+1);*/
				}	
			/*fprintf (fpAlignment,"\n");*/
			}
		else
			{
			for (i=0; i<numSequences; i++)
				{
				/*for (m = 0; m < numNodex; m++)
					{
					f = nodex + m;
					if ((f->label == i) && (f->NetIndex < numSequences))
						{
						dem = f->indexOldMigPop;
						break;
						}
					}*/
				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					if ((f->label == i) && (f->index < numSequences))
						{
						dem = f->indexOldMigPop;
						break;
						}
					}
					
				fprintf (fpAlignment,"s%05d_p%d    ", i+1, dem);

				for (j=1; j<=numSites; j++)
					{
					if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
						{
						fprintf (stderr, "\n stop codon8 \n");
						exit(-1);
						}
					number_to_codon(matrixC[pos(i,j,numSites)], codon);
					for (k = 0; k < 3; k++)
						fprintf (fpAlignment, "%c", codon[k]);
					}
				fprintf (fpAlignment,"\n");
				}	
			/*fprintf (fpAlignment,"\n");*/
			}
		}
	PrintNEXUS_end();
}
		


/***************************** PrintAncestralSequences for Codon Model *******************************/
/* Prints ancestral sequences to nexus alignment file for codon Model */

static void PrintAncestralSequences_C_NEXUS (/*int replicate*/)
{
	int		 i, j, k, a, m, dem, outgroupLabel, rootLabel;
	char codon[3];
	TreeNode	*f;
	dem = 0;
	outgroupLabel = rootLabel = 0;	

	PrintNEXUS_initial();

	if (numRE == 0) /* There are NOT recombinations */
		{
		if (thereisOutgroup == YES)
			{
			fprintf(fpAlignment,"Dimensions ntax=%d nchar=%d;\n", 2*numSequences, numNuc);
			/*fprintf(fpAlignment,"Dataset_%d %d %d\n", replicate+1, 2*numSequences, numNuc);*/
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 2)
					outgroupLabel = f->label;
				if (f->class == 5)
					rootLabel = f->label;
				}
			}
		else
			{
			fprintf(fpAlignment,"Dimensions ntax=%d nchar=%d;\n", 2*numSequences-1, numNuc);
			/*fprintf(fpAlignment,"Dataset_%d %d %d\n",replicate+1, 2*numSequences-1, numNuc);*/
			for (m = 0; m < nextAvailable; m++)
				{
				f = nodes + m;
				/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
				if (f->class == 5)
					rootLabel = f->label;
				}
			}

		fprintf(fpAlignment,"	Format datatype=nucleotide gap=- missing=? matchchar=.;\n");
		fprintf(fpAlignment,"	Matrix\n");

		if (doMigration == NO)
			{
			if (thereisOutgroup == YES)
				{	
				for (i=0; i<2*numSequences; i++)
					{
					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,"seq%05d     ", i+1);
					else if (i == numSequences)
						fprintf(fpAlignment, "outgroup     ");
					else if (i == 2*numSequences-1)
						fprintf (fpAlignment,"root         ");
					else
						fprintf (fpAlignment,"anc%05d     ", i+1);


					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon10 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(i,j,numSites)], codon);
							for (k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}
					else if (i == numSequences) /* is outgroup */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(outgroupLabel,j,numSites)] > 60 || matrixC[pos(outgroupLabel,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon10 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(outgroupLabel,j,numSites)], codon);
							for (k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}
					else if (i == 2*numSequences-1) /* is root */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon10 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
							for (k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}
					else  /* is ancestral */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(i-1,j,numSites)] > 60 || matrixC[pos(i-1,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon10 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(i-1,j,numSites)], codon);
							for (k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}

					fprintf (fpAlignment,"\n");
					}	
				/*fprintf (fpAlignment,"\n");*/
				}
			else
				{
				for (i=0; i<2*numSequences-1; i++)
					{
					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,"seq%05d     ", i+1);
					else if (i == 2*numSequences-2)
						fprintf (fpAlignment,"root         ");
					else
						fprintf (fpAlignment,"anc%05d     ", i+1);

					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon11 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(i,j,numSites)], codon);
							for	(k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}
					else if (i == 2*numSequences-2) /* is root */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon11 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
							for	(k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}
					else /* is ancestral */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon11 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(i,j,numSites)], codon);
							for	(k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}

					fprintf (fpAlignment,"\n");
					}	
				/*fprintf (fpAlignment,"\n");*/
				}
			}
		else /* migration */
			{
			if (thereisOutgroup == YES)
				{	
				for (i=0; i<2*numSequences; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodex + m;
						if ((f->label == i) && (f->NetIndex <= numSequences*2-2))
							{
							dem = f->indexOldMigPop;
							break;
							}
						}*/
					
					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;

						if (i < numSequences) /* tip */
							{
							if ((f->label == i) && (f->index <= numSequences*2-2)) 
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == 2*numSequences-1) /* root */
							{
							if (f->class == 5)
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == numSequences) /* outgroup */
							{
							dem = 0;
							break;
							}
						else /* ancestral */
							{
							if (f->label == i-1)
								{
								dem = f->indexOldMigPop;
								if (f->class != 4)
									{
									fprintf (stderr, "\n Warning in PrintAncestralSequences_C. f->label = %d, f->class = %d \n", f->label, f->class);
									exit(-1);
									}
								break;
								}
							}
						}



					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,"s%05d_p%d    ", i+1, dem);
					else if (i == numSequences)
						fprintf(fpAlignment, "outgrp_p0    ");
					else if (i == 2*numSequences-1)
						fprintf (fpAlignment,"root_p%d      ",dem);
					else
						fprintf (fpAlignment,"a%05d_p%d    ", i+1, dem);
		


					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon10 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(i,j,numSites)], codon);
							for (k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}
					else if (i == numSequences) /* is outgroup */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(outgroupLabel,j,numSites)] > 60 || matrixC[pos(outgroupLabel,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon10 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(outgroupLabel,j,numSites)], codon);
							for (k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}
					else if (i == 2*numSequences-1) /* is root */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon10 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
							for (k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}
					else  /* is ancestral */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(i-1,j,numSites)] > 60 || matrixC[pos(i-1,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon10 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(i-1,j,numSites)], codon);
							for (k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}


					fprintf (fpAlignment,"\n");
					}	
				/*fprintf (fpAlignment,"\n");*/
				}
			else
				{
				for (i=0; i<2*numSequences-1; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodex + m;
						if ((f->label == i) && (f->NetIndex <= numSequences*2-2))
							{
							dem = f->indexOldMigPop;
							break;
							}
						}*/
					
					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;

						if (i < numSequences) /* tip */
							{
							if ((f->label == i) && (f->index <= numSequences*2-2)) 
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else if (i == 2*numSequences-2) /* root */
							{
							if (f->class == 5)
								{
								dem = f->indexOldMigPop;
								break;
								}
							}
						else /* ancestral */
							{
							if (f->label == i)
								{
								dem = f->indexOldMigPop;
								if (f->class != 4)
									{
									fprintf (stderr, "\n Warning in PrintAncestralSequences_C. f->label = %d, f->class = %d \n", f->label, f->class);
									exit(-1);
									}
								break;
								}
							}
						}




					if (i < numSequences) /* is tip */
						fprintf (fpAlignment,"s%05d_p%d    ", i+1, dem);
					else if (i == 2*numSequences-2)
						fprintf (fpAlignment,"root_p%d      ", dem);
					else
						fprintf (fpAlignment,"a%05d_p%d    ", i+1, dem);


					if (i < numSequences) /* is tip */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon11 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(i,j,numSites)], codon);
							for	(k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}
					else if (i == 2*numSequences-2) /* is root */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon11 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
							for	(k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}
					else /* is ancestral */
						{
						for (j=1; j<=numSites; j++)
							{
							if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
								{
								fprintf (stderr, "\n stop codon11 \n");
								exit(-1);
								}
							number_to_codon(matrixC[pos(i,j,numSites)], codon);
							for	(k = 0; k < 3; k++)
								fprintf (fpAlignment, "%c", codon[k]);
							}
						}

					fprintf (fpAlignment,"\n");

					}	
				}
			/*fprintf (fpAlignment,"\n");*/
			}
		}
	else /* There are recombinations */
		{
		if (thereisOutgroup == YES)
			fprintf(fpAlignment,"Dimensions ntax=%d nchar=%d;\n", numSequences+2, numNuc);
		else
			fprintf(fpAlignment,"Dimensions ntax=%d nchar=%d;\n", numSequences+1, numNuc);
		
		fprintf(fpAlignment,"	Format datatype=nucleotide gap=- missing=? matchchar=.;\n");
		fprintf(fpAlignment,"	Matrix\n");

		if (doMigration == NO)
			{
			if (thereisOutgroup == YES)
				{
				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 2)
						outgroupLabel = f->label;
					if (f->class == 5)
						rootLabel = f->label;
					}				
	
				for (i=0; i<2*numSequences; i++)
					{
					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,"seq%05d     ", i+1);
						a++;
						}
					if (i == numSequences)
						{
						fprintf(fpAlignment, "outgroup     ");
						a++;
						}
					if (i == 2*numSequences-1)
						{
						fprintf (fpAlignment,"root         ");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{
						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon14 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(i,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpAlignment, "%c", codon[k]);
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == numSequences) /* is outgroup */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(outgroupLabel,j,numSites)] > 60 || matrixC[pos(outgroupLabel,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon14 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(outgroupLabel,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpAlignment, "%c", codon[k]);
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-1) /* is root */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon14 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpAlignment, "%c", codon[k]);
								}
							fprintf (fpAlignment,"\n");
							}

						}
					}	
				/*fprintf (fpAlignment,"\n");*/
				}
			else
				{

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 5)
						rootLabel = f->label;
					}

				for (i=0; i<2*numSequences-1; i++)
					{
					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,"seq%05d     ", i+1);
						a++;
						}
					if (i == 2*numSequences-2)
						{
						fprintf (fpAlignment,"root         ");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{
						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon15 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(i,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpAlignment, "%c", codon[k]);
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-2) /* is root */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon15 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpAlignment, "%c", codon[k]);
								}
							fprintf (fpAlignment,"\n");
							}

						}
					}	
				/*fprintf (fpAlignment,"\n");*/
				}
			}
		else /* migration */
			{
			if (thereisOutgroup == YES)
				{	

				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 2)
						outgroupLabel = f->label;
					if (f->class == 5)
						rootLabel = f->label;
					}	


				for (i=0; i<2*numSequences; i++)
					{

					/*for (m = 0; m < numNodex; m++)
						{
						f = nodex + m;
						if (f->NetIndex < numSequences*/ /*|| i == 2*numSequences-1*//*
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;*/
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								/*break;
								}
						}*/

					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;
						if (f->index < numSequences /*|| i == 2*numSequences-1*/)
							if (f->label == i)
								{
								dem = f->indexOldMigPop;
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								break;
								}
						}



					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,"s%05d_p%d    ", i+1, dem);
						a++;
						}
					if (i == numSequences)
						{
						fprintf(fpAlignment, "outgrp_p0    ");
						a++;
						}
					if (i == 2*numSequences-1)
						{
						fprintf (fpAlignment,"root         ");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{

						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon16 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(i,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpAlignment, "%c", codon[k]);
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == numSequences) /* is outgroup */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(outgroupLabel,j,numSites)] > 60 || matrixC[pos(outgroupLabel,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon16 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(outgroupLabel,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpAlignment, "%c", codon[k]);
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-1) /* is root */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon16 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpAlignment, "%c", codon[k]);
								}
							fprintf (fpAlignment,"\n");
							}

						}
					}	
				/*fprintf (fpAlignment,"\n");*/
				}
			else
				{


				for (m = 0; m < nextAvailable; m++)
					{
					f = nodes + m;
					/*fprintf (stderr, "\n f->label = %d   f->class = %d \n", f->label, f->class);*/
					if (f->class == 5)
						rootLabel = f->label;
					}

				for (i=0; i<2*numSequences-1; i++)
					{
					/*for (m = 0; m < numNodex; m++)
						{
						f = nodex + m;
						if (f->NetIndex < numSequences*/ /*|| i == 2*numSequences-1*//*)
							if (f->label == i)
								{
								dem = f->indexOldMigPop;*/
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								/*break;
								}
						}*/
					
					for (m = 0; m < nextAvailable; m++)
						{
						f = nodes + m;
						if (f->index < numSequences /*|| i == 2*numSequences-1*/)
							if ( f->label == i)
								{
								dem = f->indexOldMigPop;
								/*if (i == 2*numSequences-1)
									fprintf(stderr,"\n\n ****** f->label = %d,    f->NetIndex = %d,    f->indexOldMigPop = %d     \n", f->label, f->NetIndex, f->indexOldMigPop);*/
								break;
								}
						}



					a = 0;
					if (i < numSequences) /* is tip */
						{
						fprintf (fpAlignment,"s%05d_p%d    ", i+1, dem);
						a++;
						}
					if (i == 2*numSequences-2)
						{
						fprintf (fpAlignment,"root         ");
						a++;
						}
					/*else
						fprintf (fpAlignment,"anc%05d  ", i+1);*/
					if (a != 0)
						{
						if (i < numSequences) /* is tip */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(i,j,numSites)] > 60 || matrixC[pos(i,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon17 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(i,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpAlignment, "%c", codon[k]);
								}
							fprintf (fpAlignment,"\n");
							}
						if (i == 2*numSequences-2) /* is root */
							{
							for (j=1; j<=numSites; j++)
								{
								if (matrixC[pos(rootLabel,j,numSites)] > 60 || matrixC[pos(rootLabel,j,numSites)] > 60)
									{
									fprintf (stderr, "\n stop codon17 \n");
									exit(-1);
									}
								number_to_codon(matrixC[pos(rootLabel,j,numSites)], codon);
								for (k = 0; k < 3; k++)
									fprintf (fpAlignment, "%c", codon[k]);
								}
							fprintf (fpAlignment,"\n");
							}


						}
					}	
				/*fprintf (fpAlignment,"\n");*/
				}
			}
		}
	PrintNEXUS_end();
}










/***************************** PrintNexus1 *******************************/
/* Prints information header nexus output files*/
static void PrintNEXUS_initial ()
{
	char *date;				/* define date */
	time_t now;
	
	now=time(NULL);
	date= ctime(&now);

	fprintf(fpAlignment,"#NEXUS\n\n");
	fprintf(fpAlignment,"[\n\n");
	fprintf(fpAlignment,"Generated by %s on %s\n", PROGRAM_NAME, date);
	fprintf(fpAlignment,"%s - Simulation of protein evolution accouting for structural stability and under diverse evolutionary scenarios\n", PROGRAM_NAME);
	fprintf(fpAlignment, "Version %s", VERSION_NUMBER);
	fprintf(fpAlignment, "\nWritten by Miguel Arenas (miguelmmmab@gmail.com), David Posada (dposada@uvigo.es) and Ugo Bastolla (ubastolla@cbm.uam.es)");

	fprintf(fpAlignment,"]\n\n\n\n");
	fprintf(fpAlignment,"Begin data;\n");
}

/***************************** PrintNexus2 *******************************/
/* Prints information at the end of nexus output files*/
static void PrintNEXUS_end ()
{
	fprintf(fpAlignment,"	;\n");
	fprintf(fpAlignment,"End;\n");
}





/***************************** PrintSequences_UserTrees *******************************/
/* Prints sequences to alignment file */

static void PrintSequences_UserTrees ()
{
	int		 i, j;
	Treetnode *p;
			
	fprintf(fpAlignment,"%d %d\n",numSequences, numSites);

	for (i=0; i<2*numSequences; i++)
		{
		p = (Treetnode *)tree[0].tnode + i;
		if (p->parent != NULL && p->numChildren == 0) /* tip */	
			{
			fprintf (fpAlignment,"%-9s ",p->name);
			for (j=0; j<numSites; j++)
				fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(p->label,j,numSites)]));
			fprintf (fpAlignment,"\n");
			}
		}


/*
	fprintf (fperr, "\n\n");	
	for (i=0; i<2*numSequences; i++)
		{
		p = (Treetnode *)tree[0].tnode + i;
		if (p->parent != NULL &&  p->numChildren == 0)
			{
			fprintf (fperr,"%-12s(%d) ",p->name,p->index);
			for (j=0; j<numSites; j++)
				fprintf (fperr, "%c", WhichNuc(matrix[pos(p->label,j,numSites)]));
			fprintf (fperr,"\n");
			}
		}
*/		
		
/*
		else if (p->parent == NULL &&  p->numChildren > 1) 
			{
			fprintf (fperr,"%-12s(%d) ","root",p->index);
			for (j=0; j<numSites; j++)
				fprintf (fperr, "%c", WhichNuc(matrix[pos(p->label,j,numSites)]));
			fprintf (fperr,"\n");
			}
		else if (p->parent != NULL &&  p->numChildren > 1)
			{
			fprintf (fperr,"%-12s(%d) ","internal", p->index);
			for (j=0; j<numSites; j++)
				fprintf (fperr, "%c", WhichNuc(matrix[pos(p->label,j,numSites)]));
			fprintf (fperr,"\n");
			}
*/					


}




/***************************** PrintSequences_Ancestral_UserTrees *******************************/
/* Prints sequences to alignment file */

static void PrintSequences_Ancestral_UserTrees ()
{
	int		 i, j;
	char	r[4];
	Treetnode *p;
	
	strcpy(r, "root");		
	fprintf(fpAlignment,"%d %d\n",numSequences+1, numSites);

	for (i=0; i<2*numSequences; i++)
		{
		p = (Treetnode *)tree[0].tnode + i;
		if (p->parent != NULL && p->numChildren == 0) /* tip */	
			{
			fprintf (fpAlignment,"%-9s ",p->name);
			for (j=0; j<numSites; j++)
				fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(p->label,j,numSites)]));
			fprintf (fpAlignment,"\n");
			}
		}

	for (i=0; i<2*numSequences; i++)
		{
		p = (Treetnode *)tree[0].tnode + i;
		if (p->parent == NULL && p->numChildren > 1) /* root */	
			{
			fprintf (fpAlignment,"%-9s ", r);
			for (j=0; j<numSites; j++)
				fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(p->label,j,numSites)]));
			fprintf (fpAlignment,"\n");
			}
		}

}



/***************************** PrintSequences_UserTrees_FASTA *******************************/
/* Prints sequences to alignment file */

static void PrintSequences_UserTrees_FASTA ()
{
	int		 i, j;
	Treetnode *p;
			
	/*fprintf(fpAlignment,"%d %d\n",numSequences, numSites);*/

	for (i=0; i<2*numSequences; i++)
		{
		p = (Treetnode *)tree[0].tnode + i;
		if (p->parent != NULL && p->numChildren == 0) /* tip */	
			{
			fprintf (fpAlignment,">%-9s \n",p->name);
			for (j=0; j<numSites; j++)
				fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(p->label,j,numSites)]));
			fprintf (fpAlignment,"\n");
			}
		}
}


/***************************** PrintSequences_Ancestral_UserTrees_FASTA *******************************/
/* Prints sequences to alignment file */

static void PrintSequences_Ancestral_UserTrees_FASTA ()
{
	int		 i, j;
	char	r[4];
	Treetnode *p;
	
	strcpy(r, "root");		
	/*fprintf(fpAlignment,"%d %d\n",numSequences+1, numSites);*/

	for (i=0; i<2*numSequences; i++)
		{
		p = (Treetnode *)tree[0].tnode + i;
		if (p->parent != NULL && p->numChildren == 0) /* tip */	
			{
			fprintf (fpAlignment,">%-9s \n",p->name);
			for (j=0; j<numSites; j++)
				fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(p->label,j,numSites)]));
			fprintf (fpAlignment,"\n");
			}
		}

	for (i=0; i<2*numSequences; i++)
		{
		p = (Treetnode *)tree[0].tnode + i;
		if (p->parent == NULL && p->numChildren > 1) /* root */	
			{
			fprintf (fpAlignment,">%-9s \n",r);
			for (j=0; j<numSites; j++)
				fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(p->label,j,numSites)]));
			fprintf (fpAlignment,"\n");
			}
		}

}



/***************************** PrintSequences_UserTrees_NEXUS *******************************/
/* Prints sequences to alignment file */

static void PrintSequences_UserTrees_NEXUS ()
{
	int		 i, j;
	Treetnode *p;
	
	PrintNEXUS_initial();		
	/*fprintf(fpAlignment,"%d %d\n",numSequences, numSites);*/
	fprintf(fpAlignment,"Dimensions ntax=%d nchar=%d;\n", numSequences, numNuc);
	fprintf(fpAlignment,"	Format datatype=nucleotide gap=- missing=? matchchar=.;\n");
	fprintf(fpAlignment,"	Matrix\n");



	for (i=0; i<2*numSequences; i++)
		{
		p = (Treetnode *)tree[0].tnode + i;
		if (p->parent != NULL && p->numChildren == 0) /* tip */	
			{
			fprintf (fpAlignment,"%-9s ",p->name);
			for (j=0; j<numSites; j++)
				fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(p->label,j,numSites)]));
			fprintf (fpAlignment,"\n");
			}
		}

	PrintNEXUS_end();

}



/***************************** PrintSequences_Ancestral_UserTrees_NEXUS *******************************/
/* Prints sequences to alignment file */

static void PrintSequences_Ancestral_UserTrees_NEXUS ()
{
	int		 i, j;
	char	r[4];
	Treetnode *p;
	strcpy(r, "root");		

	PrintNEXUS_initial();		
	/*fprintf(fpAlignment,"%d %d\n",numSequences, numSites);*/
	fprintf(fpAlignment,"Dimensions ntax=%d nchar=%d;\n", numSequences+1, numNuc);
	fprintf(fpAlignment,"	Format datatype=nucleotide gap=- missing=? matchchar=.;\n");
	fprintf(fpAlignment,"	Matrix\n");

	for (i=0; i<2*numSequences; i++)
		{
		p = (Treetnode *)tree[0].tnode + i;
		if (p->parent != NULL && p->numChildren == 0) /* tip */	
			{
			fprintf (fpAlignment,"%-9s ",p->name);
			for (j=0; j<numSites; j++)
				fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(p->label,j,numSites)]));
			fprintf (fpAlignment,"\n");
			}
		}

	for (i=0; i<2*numSequences; i++)
		{
		p = (Treetnode *)tree[0].tnode + i;
		if (p->parent == NULL && p->numChildren > 1) /* root */	
			{
			fprintf (fpAlignment,"%-9s ",r);

			for (j=0; j<numSites; j++)
				fprintf (fpAlignment, "%c", WhichNuc(matrix[pos(p->label,j,numSites)]));
			fprintf (fpAlignment,"\n");
			}
		}

	PrintNEXUS_end();

}




/***************************** PrintOutMRCAFiles_userTrees (conc MRCA) for nucleotide Model *******************************/
/* Prints just GMRCA files for nucleotide Model */
static void PrintOutMRCAFiles_userTrees ()
	{
	int		 i, j;
	char	r[4];
	Treetnode *p;
	strcpy(r, "root");		

	fprintf(fpConcMRCAprint,"1 %d\n",numSites);
	
	for (i=0; i<2*numSequences; i++)
		{
		p = (Treetnode *)tree[0].tnode + i;
		if (p->parent == NULL && p->numChildren > 1) /* root */	
			{
			fprintf (fpConcMRCAprint,"%-9s ",r);

			for (j=0; j<numSites; j++)
				fprintf (fpConcMRCAprint, "%c", WhichNuc(matrix[pos(p->label,j,numSites)]));
			fprintf (fpConcMRCAprint,"\n");
			}
		}

}




/***************************** PrintSequences_UserTrees_AA *******************************/
/* Prints sequences to alignment file */

static void PrintSequences_UserTrees_AA ()
{
	int		 i, j;
	Treetnode *p;
			
	fprintf(fpAlignment,"%d %d\n",numSequences, numSites);

	for (i=0; i<2*numSequences; i++)
		{
		p = (Treetnode *)tree[0].tnode + i;
		if (p->parent != NULL && p->numChildren == 0) /* tip */	
			{
			fprintf (fpAlignment,"%-9s ",p->name);
			for (j=0; j<numSites; j++)
				fprintf (fpAlignment, "%c", WhichAA(matrix[pos(p->label,j,numSites)]));
			fprintf (fpAlignment,"\n");
			}
		}

}





/***************************** PrintSequences_Ancestral_UserTrees_AA *******************************/
/* Prints sequences to alignment file */

static void PrintSequences_Ancestral_UserTrees_AA ()
{
	int		 i, j;
	char	r[4];
	Treetnode *p;
	
	strcpy(r, "root");		
	fprintf(fpAlignment,"%d %d\n",numSequences+1, numSites);

	for (i=0; i<2*numSequences; i++)
		{
		p = (Treetnode *)tree[0].tnode + i;
		if (p->parent != NULL && p->numChildren == 0) /* tip */	
			{
			fprintf (fpAlignment,"%-9s ",p->name);
			for (j=0; j<numSites; j++)
				fprintf (fpAlignment, "%c", WhichAA(matrix[pos(p->label,j,numSites)]));
			fprintf (fpAlignment,"\n");
			}
		}

	for (i=0; i<2*numSequences; i++)
		{
		p = (Treetnode *)tree[0].tnode + i;
		if (p->parent == NULL && p->numChildren > 1) /* root */	
			{
			fprintf (fpAlignment,"%-9s ", r);
			for (j=0; j<numSites; j++)
				fprintf (fpAlignment, "%c", WhichAA(matrix[pos(p->label,j,numSites)]));
			fprintf (fpAlignment,"\n");
			}
		}

}



/***************************** PrintSequences_UserTrees_FASTA_AA *******************************/
/* Prints sequences to alignment file */

static void PrintSequences_UserTrees_FASTA_AA ()
{
	int		 i, j;
	Treetnode *p;
			
	/*fprintf(fpAlignment,"%d %d\n",numSequences, numSites);*/

	for (i=0; i<2*numSequences; i++)
		{
		p = (Treetnode *)tree[0].tnode + i;
		if (p->parent != NULL && p->numChildren == 0) /* tip */	
			{
			fprintf (fpAlignment,">%-9s \n",p->name);
			for (j=0; j<numSites; j++)
				fprintf (fpAlignment, "%c", WhichAA(matrix[pos(p->label,j,numSites)]));
			fprintf (fpAlignment,"\n");
			}
		}
}


/***************************** PrintSequences_Ancestral_UserTrees_FASTA_AA *******************************/
/* Prints sequences to alignment file */

static void PrintSequences_Ancestral_UserTrees_FASTA_AA ()
{
	int		 i, j;
	//char	r[4];
	Treetnode *p;
    
	//strcpy(r, "root");
	/*fprintf(fpAlignment,"%d %d\n",numSequences+1, numSites);*/
   // fprintf (fpmpi, "\n print output files 4b. \n\n");

	for (i=0; i<2*numSequences; i++)
		{
		p = (Treetnode *)tree[0].tnode + i;
            
       // fprintf (fpmpi, "\n p->name: %s\n", p->name);
            
		if (p->parent != NULL && p->numChildren == 0) /* tip */	
			{
			fprintf (fpAlignment,">%-9s \n",p->name);
			for (j=0; j<numSites; j++)
				fprintf (fpAlignment, "%c", WhichAA(matrix[pos(p->label,j,numSites)]));
			fprintf (fpAlignment,"\n");
			}
		}
    
  //  fprintf (fpmpi, "\n print output files 5. \n\n");
    
	for (i=0; i<2*numSequences; i++)
		{
		p = (Treetnode *)tree[0].tnode + i;
		if (p->parent == NULL && p->numChildren > 1) /* root */	
			{
			fprintf (fpAlignment,">root \n");
			for (j=0; j<numSites; j++)
				fprintf (fpAlignment, "%c", WhichAA(matrix[pos(p->label,j,numSites)]));
			fprintf (fpAlignment,"\n");
			}
		}
    
    
  //  fprintf (fpmpi, "\n print output files 6. \n\n");
    
    for (i=0; i<2*numSequences; i++)
    {
        p = (Treetnode *)tree[0].tnode + i;
        if (p->parent != NULL && p->numChildren > 1) /* anc */
        {
            fprintf (fpAlignment,">%d \n", Lab(p));
            for (j=0; j<numSites; j++)
            fprintf (fpAlignment, "%c", WhichAA(matrix[pos(p->label,j,numSites)]));
            fprintf (fpAlignment,"\n");
        }
    }
    
    
}



/***************************** PrintSequences_UserTrees_NEXUS_AA *******************************/
/* Prints sequences to alignment file */

static void PrintSequences_UserTrees_NEXUS_AA ()
{
	int		 i, j;
	Treetnode *p;
	
	PrintNEXUS_initial();		
	/*fprintf(fpAlignment,"%d %d\n",numSequences, numSites);*/
	fprintf(fpAlignment,"Dimensions ntax=%d nchar=%d;\n", numSequences, numNuc);
	fprintf(fpAlignment,"	Format datatype=nucleotide gap=- missing=? matchchar=.;\n");
	fprintf(fpAlignment,"	Matrix\n");



	for (i=0; i<2*numSequences; i++)
		{
		p = (Treetnode *)tree[0].tnode + i;
		if (p->parent != NULL && p->numChildren == 0) /* tip */	
			{
			fprintf (fpAlignment,"%-9s ",p->name);
			for (j=0; j<numSites; j++)
				fprintf (fpAlignment, "%c", WhichAA(matrix[pos(p->label,j,numSites)]));
			fprintf (fpAlignment,"\n");
			}
		}

	PrintNEXUS_end();

}



/***************************** PrintSequences_Ancestral_UserTrees_NEXUS_AA *******************************/
/* Prints sequences to alignment file */

static void PrintSequences_Ancestral_UserTrees_NEXUS_AA ()
{
	int		 i, j;
	char	r[4];
	Treetnode *p;
	strcpy(r, "root");		

	PrintNEXUS_initial();		
	/*fprintf(fpAlignment,"%d %d\n",numSequences, numSites);*/
	fprintf(fpAlignment,"Dimensions ntax=%d nchar=%d;\n", numSequences+1, numNuc);
	fprintf(fpAlignment,"	Format datatype=nucleotide gap=- missing=? matchchar=.;\n");
	fprintf(fpAlignment,"	Matrix\n");

	for (i=0; i<2*numSequences; i++)
		{
		p = (Treetnode *)tree[0].tnode + i;
		if (p->parent != NULL && p->numChildren == 0) /* tip */	
			{
			fprintf (fpAlignment,"%-9s ",p->name);
			for (j=0; j<numSites; j++)
				fprintf (fpAlignment, "%c", WhichAA(matrix[pos(p->label,j,numSites)]));
			fprintf (fpAlignment,"\n");
			}
		}

	for (i=0; i<2*numSequences; i++)
		{
		p = (Treetnode *)tree[0].tnode + i;
		if (p->parent == NULL && p->numChildren > 1) /* root */	
			{
			fprintf (fpAlignment,"%-9s ",r);

			for (j=0; j<numSites; j++)
				fprintf (fpAlignment, "%c", WhichAA(matrix[pos(p->label,j,numSites)]));
			fprintf (fpAlignment,"\n");
			}
		}

	PrintNEXUS_end();

}




/***************************** PrintOutMRCAFiles_userTrees_AA (conc MRCA) for amino acid Model *******************************/
/* Prints just GMRCA files for amino acid Model */
static void PrintOutMRCAFiles_userTrees_AA ()
	{
	int		 i, j;
	char	r[4];
	Treetnode *p;
	strcpy(r, "root");		

	fprintf(fpConcMRCAprint,"1 %d\n",numSites);
	
	for (i=0; i<2*numSequences; i++)
		{
		p = (Treetnode *)tree[0].tnode + i;
		if (p->parent == NULL && p->numChildren > 1) /* root */	
			{
			fprintf (fpConcMRCAprint,"%-9s ",r);

			for (j=0; j<numSites; j++)
				fprintf (fpConcMRCAprint, "%c", WhichAA(matrix[pos(p->label,j,numSites)]));
			fprintf (fpConcMRCAprint,"\n");
			}
		}

}






/***************************** PrintSequences_UserTrees_Cod *******************************/
/* Prints sequences to alignment file */

static void PrintSequences_UserTrees_Cod ()
{
	int		 i, j;
	Treetnode *p;
	int		k;
	char codon[3];
			
	fprintf(fpAlignment,"%d %d\n",numSequences, numNuc);

	for (i=0; i<2*numSequences; i++)
		{
		p = (Treetnode *)tree[0].tnode + i;
		if (p->parent != NULL && p->numChildren == 0) /* tip */	
			{
			fprintf (fpAlignment,"%-9s ",p->name);
			for (j=0; j<numSites; j++)
				{
				/*fprintf (fpAlignment, "%c", WhichAA(matrix[pos(p->label,j,numSites)]));*/

				if (matrixC[pos(p->label,j,numSites)] > 60 || matrixC[pos(p->label,j,numSites)] > 60)
					{
					fprintf (stderr, "\n stop codon_1 \n");
					exit(-1);
					}
				number_to_codon(matrixC[pos(p->label,j,numSites)], codon);
				for (k = 0; k < 3; k++)
					fprintf (fpAlignment, "%c", codon[k]);

				}
			fprintf (fpAlignment,"\n");
			}
		}

}






/***************************** PrintSequences_Ancestral_UserTrees_Cod *******************************/
/* Prints sequences to alignment file */

static void PrintSequences_Ancestral_UserTrees_Cod ()
{
	int		 i, j;
	char	r[4];
	Treetnode *p;
	int		k;
	char codon[3];
	
	strcpy(r, "root");		
	fprintf(fpAlignment,"%d %d\n",numSequences+1, numNuc);

	for (i=0; i<2*numSequences; i++)
		{
		p = (Treetnode *)tree[0].tnode + i;
		if (p->parent != NULL && p->numChildren == 0) /* tip */	
			{
			fprintf (fpAlignment,"%-9s ",p->name);
			for (j=0; j<numSites; j++)
				{

				if (matrixC[pos(p->label,j,numSites)] > 60 || matrixC[pos(p->label,j,numSites)] > 60)
					{
					fprintf (stderr, "\n stop codon_1 \n");
					exit(-1);
					}
				number_to_codon(matrixC[pos(p->label,j,numSites)], codon);
				for (k = 0; k < 3; k++)
					fprintf (fpAlignment, "%c", codon[k]);

				}			
			fprintf (fpAlignment,"\n");
			}
		}

	for (i=0; i<2*numSequences; i++)
		{
		p = (Treetnode *)tree[0].tnode + i;
		if (p->parent == NULL && p->numChildren > 1) /* root */	
			{
			fprintf (fpAlignment,"%-9s ", r);
			for (j=0; j<numSites; j++)
				{

				if (matrixC[pos(p->label,j,numSites)] > 60 || matrixC[pos(p->label,j,numSites)] > 60)
					{
					fprintf (stderr, "\n stop codon_1 \n");
					exit(-1);
					}
				number_to_codon(matrixC[pos(p->label,j,numSites)], codon);
				for (k = 0; k < 3; k++)
					fprintf (fpAlignment, "%c", codon[k]);

				}
			fprintf (fpAlignment,"\n");
			}
		}

}



/***************************** PrintSequences_UserTrees_FASTA_Cod *******************************/
/* Prints sequences to alignment file */

static void PrintSequences_UserTrees_FASTA_Cod ()
{
	int		 i, j;
	Treetnode *p;
	int		k;
	char codon[3];
			
	/*fprintf(fpAlignment,"%d %d\n",numSequences, numSites);*/

	for (i=0; i<2*numSequences; i++)
		{
		p = (Treetnode *)tree[0].tnode + i;
		if (p->parent != NULL && p->numChildren == 0) /* tip */	
			{
			fprintf (fpAlignment,">%-9s \n",p->name);
			for (j=0; j<numSites; j++)
				{

				if (matrixC[pos(p->label,j,numSites)] > 60 || matrixC[pos(p->label,j,numSites)] > 60)
					{
					fprintf (stderr, "\n stop codon_1 \n");
					exit(-1);
					}
				number_to_codon(matrixC[pos(p->label,j,numSites)], codon);
				for (k = 0; k < 3; k++)
					fprintf (fpAlignment, "%c", codon[k]);

				}
			fprintf (fpAlignment,"\n");
			}
		}
}


/***************************** PrintSequences_Ancestral_UserTrees_FASTA_Cod *******************************/
/* Prints sequences to alignment file */

static void PrintSequences_Ancestral_UserTrees_FASTA_Cod ()
{
	int		 i, j;
	char	r[4];
	Treetnode *p;
	int		k;
	char codon[3];
	
	strcpy(r, "root");		
	/*fprintf(fpAlignment,"%d %d\n",numSequences+1, numSites);*/

	for (i=0; i<2*numSequences; i++)
		{
		p = (Treetnode *)tree[0].tnode + i;
		if (p->parent != NULL && p->numChildren == 0) /* tip */	
			{
			fprintf (fpAlignment,">%-9s \n",p->name);
			for (j=0; j<numSites; j++)
				{

				if (matrixC[pos(p->label,j,numSites)] > 60 || matrixC[pos(p->label,j,numSites)] > 60)
					{
					fprintf (stderr, "\n stop codon_1 \n");
					exit(-1);
					}
				number_to_codon(matrixC[pos(p->label,j,numSites)], codon);
				for (k = 0; k < 3; k++)
					fprintf (fpAlignment, "%c", codon[k]);

				}
			fprintf (fpAlignment,"\n");
			}
		}

	for (i=0; i<2*numSequences; i++)
		{
		p = (Treetnode *)tree[0].tnode + i;
		if (p->parent == NULL && p->numChildren > 1) /* root */	
			{
			fprintf (fpAlignment,">%-9s \n",r);
			for (j=0; j<numSites; j++)
				{

				if (matrixC[pos(p->label,j,numSites)] > 60 || matrixC[pos(p->label,j,numSites)] > 60)
					{
					fprintf (stderr, "\n stop codon_1 \n");
					exit(-1);
					}
				number_to_codon(matrixC[pos(p->label,j,numSites)], codon);
				for (k = 0; k < 3; k++)
					fprintf (fpAlignment, "%c", codon[k]);

				}
			fprintf (fpAlignment,"\n");
			}
		}

}



/***************************** PrintSequences_UserTrees_NEXUS_Cod *******************************/
/* Prints sequences to alignment file */

static void PrintSequences_UserTrees_NEXUS_Cod ()
{
	int		 i, j;
	Treetnode *p;
	int		k;
	char codon[3];
	
	PrintNEXUS_initial();		
	/*fprintf(fpAlignment,"%d %d\n",numSequences, numSites);*/
	fprintf(fpAlignment,"Dimensions ntax=%d nchar=%d;\n", numSequences, numNuc);
	fprintf(fpAlignment,"	Format datatype=nucleotide gap=- missing=? matchchar=.;\n");
	fprintf(fpAlignment,"	Matrix\n");



	for (i=0; i<2*numSequences; i++)
		{
		p = (Treetnode *)tree[0].tnode + i;
		if (p->parent != NULL && p->numChildren == 0) /* tip */	
			{
			fprintf (fpAlignment,"%-9s ",p->name);
			for (j=0; j<numSites; j++)
				{

				if (matrixC[pos(p->label,j,numSites)] > 60 || matrixC[pos(p->label,j,numSites)] > 60)
					{
					fprintf (stderr, "\n stop codon_1 \n");
					exit(-1);
					}
				number_to_codon(matrixC[pos(p->label,j,numSites)], codon);
				for (k = 0; k < 3; k++)
					fprintf (fpAlignment, "%c", codon[k]);

				}
			fprintf (fpAlignment,"\n");
			}
		}

	PrintNEXUS_end();

}



/***************************** PrintSequences_Ancestral_UserTrees_NEXUS_Cod *******************************/
/* Prints sequences to alignment file */

static void PrintSequences_Ancestral_UserTrees_NEXUS_Cod ()
{
	int		 i, j;
	char	r[4];
	Treetnode *p;
	int		k;
	char codon[3];

	strcpy(r, "root");		

	PrintNEXUS_initial();		
	/*fprintf(fpAlignment,"%d %d\n",numSequences, numSites);*/
	fprintf(fpAlignment,"Dimensions ntax=%d nchar=%d;\n", numSequences+1, numNuc);
	fprintf(fpAlignment,"	Format datatype=nucleotide gap=- missing=? matchchar=.;\n");
	fprintf(fpAlignment,"	Matrix\n");

	for (i=0; i<2*numSequences; i++)
		{
		p = (Treetnode *)tree[0].tnode + i;
		if (p->parent != NULL && p->numChildren == 0) /* tip */	
			{
			fprintf (fpAlignment,"%-9s ",p->name);
			for (j=0; j<numSites; j++)
				{

				if (matrixC[pos(p->label,j,numSites)] > 60 || matrixC[pos(p->label,j,numSites)] > 60)
					{
					fprintf (stderr, "\n stop codon_1 \n");
					exit(-1);
					}
				number_to_codon(matrixC[pos(p->label,j,numSites)], codon);
				for (k = 0; k < 3; k++)
					fprintf (fpAlignment, "%c", codon[k]);

				}
			fprintf (fpAlignment,"\n");
			}
		}

	for (i=0; i<2*numSequences; i++)
		{
		p = (Treetnode *)tree[0].tnode + i;
		if (p->parent == NULL && p->numChildren > 1) /* root */	
			{
			fprintf (fpAlignment,"%-9s ",r);

			for (j=0; j<numSites; j++)
				{

				if (matrixC[pos(p->label,j,numSites)] > 60 || matrixC[pos(p->label,j,numSites)] > 60)
					{
					fprintf (stderr, "\n stop codon_1 \n");
					exit(-1);
					}
				number_to_codon(matrixC[pos(p->label,j,numSites)], codon);
				for (k = 0; k < 3; k++)
					fprintf (fpAlignment, "%c", codon[k]);

				}
			fprintf (fpAlignment,"\n");
			}
		}

	PrintNEXUS_end();

}




/***************************** PrintOutMRCAFiles_userTrees_Cod (conc MRCA) for codon Model *******************************/
/* Prints just GMRCA files for codon Model */
static void PrintOutMRCAFiles_userTrees_Cod ()
	{
	int		 i, j;
	char	r[4];
	Treetnode *p;
	int		k;
	char codon[3];

	strcpy(r, "root");		

	fprintf(fpConcMRCAprint,"1 %d\n", numNuc);
	
	for (i=0; i<2*numSequences; i++)
		{
		p = (Treetnode *)tree[0].tnode + i;
		if (p->parent == NULL && p->numChildren > 1) /* root */	
			{
			fprintf (fpConcMRCAprint,"%-9s ",r);

			for (j=0; j<numSites; j++)
				{

				if (matrixC[pos(p->label,j,numSites)] > 60 || matrixC[pos(p->label,j,numSites)] > 60)
					{
					fprintf (stderr, "\n stop codon_1 \n");
					exit(-1);
					}
				number_to_codon(matrixC[pos(p->label,j,numSites)], codon);
				for (k = 0; k < 3; k++)
					fprintf (fpConcMRCAprint, "%c", codon[k]);

				}
			fprintf (fpConcMRCAprint,"\n");
			}
		}

}








/***************************** PrintRunSettings *******************************/
/* Prints a summary of run settings */

static void	PrintRunSettings (FILE *filep, long int seed)
	{
		int i, j;
		double stdErrorErep, stdErrGMRCA, stdErrTrep;

		
		stdErrorErep = stdErrGMRCA = stdErrTrep = 0.0;		

		/* Anadido Miguel: Para que escriba por la pantalla del master */
		#ifdef MPI
			if (rank==root)
				{
		#endif
		
		if (doSettingsFile == YES)
			filep = fpSettings;
		/*fprintf(fpTrees, "Dataset %d \n", replicate+1);*/

		fprintf (filep, "\n\nRun settings\n-------------------------");
		fprintf (filep, "\n[Assumptions in brackets]");
		fprintf (filep, "\n\nSimulations");
		fprintf (filep, "\nSeed                                =  %-3ld", seed);
		fprintf (filep, "\nNumber replicate data sets          =  %-3d", numDataSets);
		fprintf (filep, "\nNumber of sequences                 =  %-3d", numSequences);
		fprintf (filep, "\nNumber of sites (bp, codons or aa)  =  %-3d", numSites);
		if (Nscaling == 1)
			{
			fprintf (filep, "\nHaploid data");
			}
		if (Nscaling == 2)
			{
			fprintf (filep, "\nDiploid data");
			}
		/*fprintf (filep, "\nEffective population size           =  %-3ld", N);*/
		if (doDatedTips == YES)
			{
			fprintf (filep, "\nDated tips");
			fprintf (filep, "\n Generation time                    =   %3.2f", generationTime);
			fprintf (filep, "\n Sample    Time    Size   Sequences");
			for (i=0; i<numTipDates; i++)
				fprintf (filep, "\n  %2d      %7.2f   %2d     %d-%d", 
				i+1, datedSample[i].time, datedSample[i].size, datedSample[i].member[0], datedSample[i].member[datedSample[i].size-1]);	
			}


		/* Global events */
		fprintf (filep, "\n\nGlobal Data Sets");
		j = cumNumCA+cumNumRE+cumNumMIG+cumNumCONV;
		for (i = 0; i < numDataSets; i++)
			{
			varEvent[i] = (varEvent[i]-(j/numDataSets))*(varEvent[i]-(j/numDataSets));
			varianceErep = varianceErep + (varEvent[i]*1.0);
			}
		varianceErep = varianceErep/numDataSets;
		stdErrorErep = sqrt (varianceErep/numDataSets);
		if (doMigration == YES)
			{
			if (doConvergDemes == YES)
				fprintf (filep, "\nTotal number of events \n (CA+RE+MI+CONV)                    =  %d \n Mean events per replicate          =  %d (stdErr = %3.2f)", j, j/numDataSets, stdErrorErep);
			else
				fprintf (filep, "\nTotal number of events (CA+RE+MI)   =  %d \n Mean events per replicate          =  %d (stdErr = %3.2f)", j, j/numDataSets, stdErrorErep);
			}
		else
			fprintf (filep, "\nTotal number of events (CA+RE)      =  %d \n Mean events per replicate          =  %d (stdErr = %3.2f)", j, j/numDataSets, stdErrorErep);
		/*fprintf (filep, "\nTotal number of recombinations      =  %d", cumNumRE);*/
		fprintf (filep, "\nMean number of coalescence events   =  %3.2f", meanNumCA);


		/* Recombination */
		fprintf (filep, "\n\nRecombination");
		if (doBlockRecombination == NO)
			{
			fprintf (filep, "\nRecombination rate                            =  %2.1e", recombinationRate);
			fprintf (filep, "\nRho (2*Nscaling*NrL)                          =  %3.2f", rho);
			fprintf (filep, "\nExpected number of countable rec events       =  %3.2f", expNumRE);
			fprintf (filep, "\n    [N=con, no mig]");
			fprintf (filep, "\nProportion of reps without recombination      =  %3.2f", zeroRec/(double)numDataSets);

			if (doCountsForExpNumRec == YES)
				fprintf (filep, "\nCountable recombination events      =  %3.2f", meanNumREtc);
			if (doFixNumRecEvents == NO)
				fprintf (filep, "\n#Reps with 0 rec events             =  %d", zeroRec);
			if (doFixNumRecEvents == YES)
				fprintf (filep, "\nFixed number of recombination events =  %-3d", fixedNumRecEvents);
			fprintf (filep, "\nMean number of recombination events =  %3.2f", meanNumRE);
			if (numDataSets > 1 && doBlockRecombination == YES)
				fprintf (filep, "\n Variance number of recombination events      =  %3.2f", varNumRE);
			}
		if (doBlockRecombination == YES)
			{
			fprintf (filep, "\nBackground recombination rate                 =  %2.1e", recombinationRate);
			fprintf (filep, "\nHotspot recombination rate                    =  %2.1e", blockRecombinationRate);
			fprintf (filep, "\nGlobal recombination rate                     =  %2.1e", globalRecombinationRate);

			fprintf (filep, "\nBackground Rho (2*Nscaling*NrL)               =  %3.5f", rho);
			fprintf (filep, "\nHotspot pop rec parameter (Rh=4Nr_bE(X))      =  %3.5f", tau);
			fprintf (filep, "\nPopulation recombination parameter (R=Rb+Rh)  =  %3.5f", rho + tau);
			fprintf (filep, "\nMean overall recombination rate (PDF C01)     =  %3.2f", meanC01);
			fprintf (filep, "\n Variance overall recombination rate          =  %3.2f", varC01);

			fprintf (filep, "\nMean number observed hotspots                 =  %3.2f", meanNumHotspots);
			if (fixedNumHotspots > 0)
				fprintf (filep, "\nFixed number hotspots                         =  %3.2f",  fixedNumHotspots);
			else
				fprintf (filep, "\nExpected number hotspots                      =  %3.2f",  expNumHotspots);
			if (numDataSets > 1)
				fprintf (filep, "\n Variance number observed hotspots            =  %3.2f", varNumHotspots);
			if (hotspotUniform == NO)
				fprintf (filep, "\nHotspot imprecision                           =  %2.1e", hotspotImprecision);
			else
				fprintf (filep, "\nHotspot width                                 =  %-3d", hotspotWidth);
			if (hotspotHeterogeneity == YES)
				fprintf (filep, "\nHotspot heterogeneity: gamma shape            =  %2.1e",  alpha);
			if (hotspotInterference == YES)
				fprintf (filep, "\nHotspot interference interval                 =  %-3d", interferenceInterval);


			fprintf (filep, "\nExpected number of countable rec events       =  %3.2f", expNumRE);
			fprintf (filep, "\n    [N=con, hotspot imprecision > 0, no mig]");
			fprintf (filep, "\n Variance countable rec events                =  %3.2f", varNumREtc);
			fprintf (filep, "\nProportion of reps without recombination      =  %3.2f", zeroRec/(double)numDataSets);

			if (doCountsForExpNumRec == YES)
				fprintf (filep, "\nCountable recombination events      =  %3.2f", meanNumREtc);
			if (doFixNumRecEvents == NO)
				fprintf (filep, "\n#Reps with 0 rec events             =  %d", zeroRec);
			if (doFixNumRecEvents == YES)
				fprintf (filep, "\nFixed number of recombination events =  %-3d", fixedNumRecEvents);
			fprintf (filep, "\nMean number of recombination events =  %3.2f", meanNumRE);
			if (numDataSets > 1 && doBlockRecombination == YES)
				fprintf (filep, "\n Variance number of recombination events      =  %3.2f", varNumRE);
			}


		if ((meanNumRE > 0.00) && (doCodonModel == YES))
			{
			fprintf (filep, "\n Countable Mean number of recombinations breaking codons              =  %3.2f", meanNumREbreakCod);
			fprintf (filep, "\n Countable Expected mean number of recombinations breaking codons     =  %3.2f", meanNumREtc*2/3);
			fprintf (filep, "\n Countable Mean of stop codons generated/restarted by IntraCodon Rec  =  %3.2f", meanNumStopCodonREC);
			
			/*fprintf (filep, "\n meanNumEqual2                      =  %3.2f", meanNumEqual2);
			fprintf (filep, "\n meanNumEqual1                      =  %3.2f", meanNumEqual1);
			fprintf (filep, "\n meanNumDifCodSameAA                =  %3.2f", meanNumDifCodSameAA);
			fprintf (filep, "\n meanNumDifCodDifAA                 =  %3.2f", meanNumDifCodDifAA);*/
			fprintf (filep, "\n Countable Mean number of recombinations with 0 nonsynonymous changes =  %3.2f (%3.2f%%)", meanNumNonSyn0, 1.00*meanNumNonSyn0*100/meanNumREtc);
			fprintf (filep, "\n Countable Mean number of recombinations with 1 nonsynonymous changes =  %3.2f (%3.2f%%)", meanNumNonSyn1, 1.00*meanNumNonSyn1*100/meanNumREtc);
			fprintf (filep, "\n Countable Mean number of recombinations with 2 nonsynonymous changes =  %3.2f (%3.2f%%)", meanNumNonSyn2, 1.00*meanNumNonSyn2*100/meanNumREtc);
			fprintf (filep, "\n Countable Total number of nonsynonymous changes by intracodon recombination =  %3.2f", 1.0*(meanNumNonSyn1+meanNumNonSyn2+meanNumNonSyn2));
			}

		if (doProtStabDNAFile == NO && doProtStabAAFile == NO)
			fprintf (filep, "\n\nMean number of substitution events  =  %3.2f", meanNumMU);
		if (doProtStabDNAFile == YES || doProtStabAAFile == YES)
			{
			fprintf (filep, "\n\nMean number of introduced substitution events           =  %3.2f", TotalCountDNAsubsRep/(double)numDataSets);
			if (doProtStabDNAFile == YES)
				fprintf (filep, "\n Mean number of introduced nonsynonymous substitution events =  %3.2f", TotalCountDNAsubsNSRep/(double)numDataSets);
			fprintf (filep, "\nMean number of observed substitution events (branches)  =  %3.2f", meanNumMU);
			fprintf (filep, "\nMean number of mutation attempts                        =  %3.2f", meanMutationAttempts);
			}


		if (doCodonModel == YES)
			{
			fprintf (filep, "\n  synonymous changes =  %3.2f (%3.2f%%)", meanNumMU_S, 1.00*meanNumMU_S*100/meanNumMU);
			fprintf (filep, "\n  nonsynonymous changes =  %3.2f (%3.2f%%)", meanNumMU_NS, 1.00*meanNumMU_NS*100/meanNumMU);
			}
		/* Average tMRCA and tGMRCA inter all replicates */
		for (i = 0; i < numDataSets; i++)
			{			
			#ifdef HUDSON_UNITS
				varTimeGMRCA[i] = (varTimeGMRCA[i]-(counterTime/(2*Nscaling*N*numDataSets)))*(varTimeGMRCA[i]-(counterTime/(2*Nscaling*N*numDataSets))); /* Hudson units(/2*Nscaling*N) */
			#else
				varTimeGMRCA[i] = (varTimeGMRCA[i]-(counterTime/numDataSets))*(varTimeGMRCA[i]-(counterTime/numDataSets)); 
			#endif
			varianceGMRCArep = varianceGMRCArep + (varTimeGMRCA[i]*1.0);
			}
		varianceGMRCArep = varianceGMRCArep/numDataSets;
		stdErrGMRCA = sqrt(varianceGMRCArep/numDataSets);
		for (i = 0; i < numDataSets; i++)
			{
			varTimeT[i] = (varTimeT[i]-(countTMRCAReps/numDataSets))*(varTimeT[i]-(countTMRCAReps/numDataSets));
			varianceTrep = varianceTrep + (varTimeT[i]*1.0);
			}
		varianceTrep = varianceTrep/numDataSets;
		stdErrTrep = sqrt(varianceTrep/numDataSets);
		#ifdef HUDSON_UNITS
			fprintf(filep, "\nAverage time to GMRCA               =  %3.2f (stdErr = %3.2f)  (Hd units, 1/2*Nscaling*N)", (counterTime/(numDataSets*2*Nscaling*N)), stdErrGMRCA);
		#else
			fprintf(filep, "\nAverage time to GMRCA               =  %3.2f (stdErr = %3.2f)", counterTime/numDataSets, stdErrGMRCA);
		#endif
		fprintf(filep, "\nAverage time to MRCA                =  %3.2f (stdErr = %3.2f)", countTMRCAReps/numDataSets, stdErrTrep);
		fprintf(filep, "\nExpected time to the MRCA           =  %3.2f (var = %3.2f)", expTMRCA, expVarTMRCA);
		fprintf(filep, "\n  [N=con, no rec, no mig]");
				

		/* Demographics */
		fprintf (filep, "\n\nDemographics");
		fprintf (filep, "\nEffective population size           =  %-3d", N);
		if (doExponential == YES)
			fprintf (filep, "\nExponential growth rate             =  %+2.1e", growthRate);
		if (doDemographics == YES)
			{
			fprintf (filep, "\nDemographic periods:");
			fprintf (filep, "\n Period  Nbegin    Nend   Duration   Growth rate");
			for (i=1; i<=numPeriods; i++)
				fprintf (filep, "\n  %d   %7d  %7d    %7d      %+2.1e", 
			i, Nbegin[i], Nend[i], cumDuration[i]-cumDuration[i-1], periodGrowth[i]);	
			}
			
		/* Migration */
		if (doMigration == YES)
			{
			fprintf (filep, "\n\nMigration");
			fprintf (filep, "\nInitial number of demes             =  %-3d", numPopulations);
			fprintf (filep, "\n Deme         size");
			for (i=1; i<=numPopulations; i++)
				fprintf (filep, "\n  %d            %-3d", i, initPopulation[i]);			

			if (doMigrationIsland == YES)
				fprintf (filep, "\nIsland migration model");
			if (doMigrationSTST == YES)
				fprintf (filep, "\nStepping-stone migration model");
			if (doMigrationIslCont == YES)
				fprintf (filep, "\nIsland-continent migration model");

			if (doMigRatePeriods == NO)
				{
				fprintf (filep, "\nMigration rate                      =  %2.1e", migrationRate);
				fprintf (filep, "\nExpected FST = 1/(2*Nscaling*Nm+1)  =  %2.1e", 1/(2.0*Nscaling*N*migrationRate+1));
				fprintf (filep, "\n  [N=con, no rec]");
				}
			else
				{
				fprintf (filep, "\nTemporal migration rates:");
				fprintf (filep, "\n Period  Tbegin    migration rate");
				for (i=1; i<=numMigRatePeriods; i++) /* t3 100 700 0.001 0.005 0.002 */
					{
					if (i == 1)
						fprintf (filep, "\n  %d   %7d         %+2.1e", i, 0, periodMigrationRate[i]);
					else
						fprintf (filep, "\n  %d   %7d         %+2.1e", i, MigTbegin[i-1], periodMigrationRate[i]);
					}
				}
			fprintf (filep, "\nMean number of migration events     =  %3.2f", meanNumMIG);

			if (doConvergDemes == YES) /* Convergence of demes */
				{
				fprintf (filep, "\n\nConvergence of demes");
				fprintf (filep, "\n Event    Time       Deme 1   Deme 2");
				for (i=1; i<=numConvergDemes; i++)
					{
					if (convDemTimes_old[i] < 100)
						fprintf (filep, "\n   %d      %3.2f        %-4d     %-2d", i, convDemTimes_old[i], deme_a_old[i], deme_b_old[i]);
					if (convDemTimes_old[i] < 1000 && convDemTimes_old[i] >= 100)
						fprintf (filep, "\n   %d      %3.2f       %-4d     %-2d", i, convDemTimes_old[i], deme_a_old[i], deme_b_old[i]);
					if (convDemTimes_old[i] < 10000 && convDemTimes_old[i] >= 1000)
						fprintf (filep, "\n   %d      %3.2f      %-4d     %-2d", i, convDemTimes_old[i], deme_a_old[i], deme_b_old[i]);
					if (convDemTimes_old[i] < 100000 && convDemTimes_old[i] >= 10000)
						fprintf (filep, "\n   %d      %3.2f     %-4d     %-2d", i, convDemTimes_old[i], deme_a_old[i], deme_b_old[i]);
					if (convDemTimes_old[i] >= 100000)
						fprintf (filep, "\n   %d      %3.2f    %-4d     %-2d", i, convDemTimes_old[i], deme_a_old[i], deme_b_old[i]);
					}
				fprintf (filep, "\nMean number of convergence demes\n events                             =  %3.2f", meanNumCONV);
				}
			}


		/* Other Settings */
			fprintf (filep, "\n\nOther Settings");
		if (thereisOutgroup == NO)
			fprintf (filep, "\nSimulate outgroup                   =  NO");
		else
			{
			fprintf (filep, "\nSimulate outgroup                   =  YES");
			fprintf (filep, "\n   branch length                    =  %3.2f", outgroupBranchLength);
			}	
	
		if (doPrintAncestralSequences == YES)
			fprintf (filep, "\nPrint ancestral states              =  YES");
		else
			fprintf (filep, "\nPrint ancestral states              =  NO");

		if (doMRCAFile == YES)
			fprintf (filep, "\nMRCA sequence                       =  specified by the user");
		else
			fprintf (filep, "\nMRCA sequence                       =  simulated");
		
		if (doBranchNetfiles == YES) 	
			fprintf(filep, "\nBranches of the network printed to files \"%s\"", networkOut);
		

		/* Substitution model */
		if (doCodonModel == YES)
			fprintf (filep, "\n\n\nCodon replacement model\n------------------------");
		else if (doAAmodel == YES)
			fprintf (filep, "\n\n\nAmino acid substitution model\n-----------------------------");
		else
			fprintf (filep, "\n\n\nNucleotide substitution model\n-----------------------------");
		fprintf (filep, "\nSubstitution rate                   =  %2.1e", mutationRate);
		fprintf (filep, "\nExpected theta (2*Nscaling*NuL) per site [ISM] =  %5.4f", 2.0 * Nscaling * N * mutationRate * numSites);
		
		if (doCodonModel == YES)
			{
			fprintf (filep, "\nBase frequencies (piA piC piG piT) for codon positions:");
			fprintf (filep, "\n   first  =   %3.2f %3.2f %3.2f %3.2f", p_i_codon[0], p_i_codon[1], p_i_codon[2], p_i_codon[3]);
			fprintf (filep, "\n   second =   %3.2f %3.2f %3.2f %3.2f", p_i_codon[4], p_i_codon[5], p_i_codon[6], p_i_codon[7]);
			fprintf (filep, "\n   third  =   %3.2f %3.2f %3.2f %3.2f", p_i_codon[8], p_i_codon[9], p_i_codon[10], p_i_codon[11]);
			
			if (doOmegaCat == NO && doM8 == NO && doM7 == NO && doM6 == NO && doM9 == NO && doM10 == NO && doMG94 == NO && doECM == NO)
				fprintf (filep, "\nOmega (dN/dS ratio)                 =  %3.2f", OmegaInit);
			if (doMG94 == YES)
				{
				fprintf (filep, "\nSynonymous rate                =  %3.2f", SynRate);
				fprintf (filep, "\nNon-Synonymous rate            =  %3.2f", NonSynRate);
				}
			if (doOmegaCat == YES)
				{
				if (doM1 == YES)
					{
					fprintf (filep, "\n\nM1 codon model:\n  P0 = %3.2f, Omega (P0) = %3.2f, P1 = %3.2f\n", M1_P0_omeg0, M1_omega0, M1_P1_omeg1);
					}
				else
					{
					fprintf (filep, "\nOmega (dN/dS ratio) in %d user-categories: \n Category      Omega      Probability", numOmegaCat);
					for (j=1; j<=numOmegaCat; j++)
						fprintf(filep, "\n    %d          %3.2f           %3.2f", j, omegaVal[j], omegaProb[j]);
					}
				}
			if (doOmegaRateHetCont == YES)
				fprintf (filep, "\nOmega variation among sites (M5)\n alpha                              =  %3.2f", OmegaRateHet);
			if (doOmegaRateHetDisc == YES)
				{
				fprintf (filep, "\nOmega discrete variation among sites (%d categories) (M5)\n alpha (gamma shape)                =  %3.2f", numOmegaCat, OmegaRateHet);
				fprintf (filep, "\n Category      Omega      Probability");
				for (j=1; j<=numOmegaCat; j++)
					fprintf(filep, "\n    %d          %3.2f           %3.2f", j, OmegaInit*gammaRates[j-1], (double)1/numOmegaCat);
				/*fprintf (filep, "\nGamma values obtained               =");*/ /* Active to see the gamma values for omega */
				/*for (j=1; j<=numOmegaCat; j++)
					fprintf(filep, "  %3.3f", gammaRates[j-1]);*/
				}
			if (doM6 == YES) /* M6_P0, M6_P1; OmegaRateHetM6_0 OmegaM6_0 OmegaInitM6_0; OmegaRateHetM6_1 OmegaM6_1 OmegaInitM6_1 [p0 p q, w] */
				{
				fprintf (filep, "\n\nM6 codon model (2gamma):\n  P0 = %3.2f P1 = %3.2f\n", M6_P0, M6_P1);
				fprintf (filep, "  Gamma distribution (P0) a = %3.2f b = %3.2f\n", OmegaRateHetM6_0, OmegaM6_0);
				fprintf (filep, "  Gamma distribution (P1) a = %3.2f b = %3.2f\n", OmegaRateHetM6_1, OmegaM6_1);
				}
			if (doM8 == YES)
				{
				fprintf (filep, "\n\nM8 codon model:\n  P0 = %3.2f P1 = %3.2f\n", M8_P0_beta, M8_P1_omega);
				fprintf (filep, "  Beta distribution (P0) p = %3.2f q = %3.2f; Omega (P1) = %3.2f\n", M8_p_beta, M8_q_beta, M8_omegaP1);
				}
			if (doM7 == YES)
				{
				fprintf (filep, "\n\nM7 codon model:\n  Beta distribution, p = %3.2f q = %3.2f\n", M7_p_beta, M7_q_beta);
				}
			if (doM9 == YES)
				{
				fprintf (filep, "\n\nM9 codon model:\n  Beta distribution, P0 = %3.2f, p = %3.2f q = %3.2f\n", M910_P0, M910_p_beta, M910_q_beta);
				fprintf (filep, "  Gamma distribution, a = %3.2f b = %3.2f\n", OmegaRateHetM910_1, OmegaM910_1);
				}
			if (doM10 == YES)
				{
				fprintf (filep, "\n\nM10 codon model:\n  Beta distribution, P0 = %3.2f, p = %3.2f q = %3.2f\n", M910_P0, M910_p_beta, M910_q_beta);
				fprintf (filep, "  Gamma distribution, a = %3.2f b = %3.2f\n", OmegaRateHetM910_1, OmegaM910_1);
				}
			if (doECM == YES) /* only empirical codon models */
				{
				fprintf (filep, "\n\nEmpirical codon model");
				if (doECMuser == YES)
					fprintf (filep, " from the input file: %s\n", ECodonModel);	
				else
					fprintf (filep, ": %s\n", ECodonModel);
				}
			if (doGY94xAAmodel == YES) 
				{
				fprintf (filep, "\nCodon model with amino acid contributions from");
				if (doGY94xEAAMUser == YES)
					fprintf (filep, " the input file: %s\n", GY94xAAmodel);	
				else
					fprintf (filep, ": %s\n", GY94xAAmodel);
				}

			if (doVariableDnDsBranches == YES) 
				{
				fprintf (filep, "\nCodon model with also variable dN/dS per branch");
				if (doBBM0 == YES)
					{
					fprintf (filep, " for a M0 codon model, variantion among branches: \n");
					if (BBmodelNumber == 1)
						{
						fprintf (filep, "Omega (dN/dS ratio) in %d user-categories for branches: \n Category      Omega      Probability", BBnumOmegaCat);
						for (j=1; j<=BBnumOmegaCat; j++)
							fprintf(filep, "\n    %d          %3.2f           %3.2f", j, BBomegaVal[j], BBomegaProb[j]);
						}
					if (BBmodelNumber == 2)
						{
						fprintf (filep, "Omega variation according to a gamma distribution: %3.2f, %3.2f", BBOmegaRateHet, BBomega);
						}
					if (BBmodelNumber == 3)
						{
						fprintf (filep, "Omega variation according to a beta distribution: %3.2f, %3.2f", BBM7_p_beta, BBM7_q_beta);
						}
					}	
				else
					fprintf (filep, "\n");
				fprintf (filep, "\n");
				}


			}
		else if (doAAmodel == YES)
			{ /* A R N D C Q E G H I L K M F P S T W Y V */
			fprintf (filep, "\nAmino acid frequencies:\n");
			if (NumberFrequencies == 20)
				{
				fprintf (filep, "   piA piR piN piD piC  =  %3.2f %3.2f %3.2f %3.2f %3.2f\n", 
        	          p_i_aa[0], p_i_aa[1], p_i_aa[2], p_i_aa[3], p_i_aa[4]);
				fprintf (filep, "   piQ piE piG piH piI  =  %3.2f %3.2f %3.2f %3.2f %3.2f\n", 
            	      p_i_aa[5], p_i_aa[6], p_i_aa[7], p_i_aa[8], p_i_aa[9]);
				fprintf (filep, "   piL piK piM piF piP  =  %3.2f %3.2f %3.2f %3.2f %3.2f\n", 
        	          p_i_aa[10], p_i_aa[11], p_i_aa[12], p_i_aa[13], p_i_aa[14]);
				fprintf (filep, "   piS piT piW piY piV  =  %3.2f %3.2f %3.2f %3.2f %3.2f\n", 
        	          p_i_aa[15], p_i_aa[16], p_i_aa[17], p_i_aa[18], p_i_aa[19]);
				}
			}
		else
			{
			fprintf (filep, "\nBase frequencies (piA piC piG piT)  =  %3.2f %3.2f %3.2f %3.2f", p_i[0], p_i[1], p_i[2], p_i[3]);
			}



		if (doAAmodel == NO)
			{ 
			if (doHKY == YES || doCodon_HKY == YES)
				fprintf (filep, "\nTransition/transversion ratio       =  %3.2f (kappa = %3.2f)", titv, kappa);
			if (doGTR == YES || doCodon_GTR == YES)
				fprintf (filep, "\nR-matrix                            =  %3.2f %3.2f %3.2f %3.2f %3.2f %3.2f", 
					Rmat[0], Rmat[1], Rmat[2], Rmat[3], Rmat[4], Rmat[5]);
			if (doGTnR == YES || doCodon_NGTR == YES)
				fprintf (filep, "\nnR-matrix                           =  %3.2f %3.2f %3.2f %3.2f %3.2f %3.2f\n                                       %3.2f %3.2f %3.2f %3.2f %3.2f %3.2f ", 
					NRmat[0], NRmat[1], NRmat[2], NRmat[3], NRmat[4], NRmat[5], NRmat[6], NRmat[7], NRmat[8], NRmat[9], NRmat[10], NRmat[11]);
			}

		fprintf (filep, "\nProportion of invariable sites      =  %3.2f ", pinv);
		if (doRateHet == YES)
			fprintf (filep, "\nRate variation among sites\n  alpha (gamma shape)               =  %3.2f ", alpha);
		else
			fprintf (filep, "\nNo rate variation among sites");
		if (doHetVectorFile == YES)
			fprintf (filep, "\nVector with rate variation among sites in the user-defined file =  %s ", HetVectorFile);

		sprintf(modelB," ");
		if (doCodonModel == YES)
			{
			if (doGY94xAAmodel == YES) 
				{
				sprintf(modelB," x %s(EAAM) ", GY94xAAmodel);
				}
			if (doVariableDnDsBranches == YES)
				{
				sprintf(modelB," x dN/dS variable per branch ");
				}			

			if (doECM == YES)
				{
				sprintf(model,"%s ECM", ECodonModel);
				}

			if (doCodon_HKY == YES)
				{
				if (freqNumber == 12 && doM0 == YES)
					{
					sprintf(model,"GY94xHKY_3x4 M0");
					/*fprintf(filep,"\nGY94xHKY_3x4 M0\n");*/
					}
				if (freqNumber == 12 && doM1 == YES)
					{
					sprintf(model,"GY94xHKY_3x4 M1");
					}
				if (freqNumber == 12 && doM7 == YES)
					{
					sprintf(model,"GY94xHKY_3x4 M7");
					}
				if (freqNumber == 12 && doM6 == YES)
					{
					sprintf(model,"GY94xHKY_3x4 M6");
					}
				if (freqNumber == 12 && doM8 == YES)
					{
					if (M8_omegaP1 > 1)
						sprintf(model,"GY94xHKY_3x4 M8");
					if (M8_omegaP1 == 1.0)
						sprintf(model,"GY94xHKY_3x4 M8a");
					if (M8_omegaP1 < 1)
						sprintf(model,"GY94xHKY_3x4 M8b");
					}
				if (freqNumber == 12 && doM9 == YES)
					{
					sprintf(model,"GY94xHKY_3x4 M9");
					}
				if (freqNumber == 12 && doM10 == YES)
					{
					sprintf(model,"GY94xHKY_3x4 M10");
					}
				if (freqNumber == 12 && doMG94 == YES)
					{
					sprintf(model,"MG94xHKY_3x4");
					}
				if (freqNumber == 12 && doOmegaCat == YES && doM1 == NO)
					{
					sprintf(model,"GY94xHKY_3x4 by categories");
					}
				if (freqNumber == 12 && doOmegaRateHetCont == YES)
					{
					sprintf(model,"GY94xHKY_3x4 with variable omega by continuous gamma distribution (M5)");
					}
				if (freqNumber == 12 && doOmegaRateHetDisc == YES)
					{
					sprintf(model,"GY94xHKY_3x4 with variable omega by discrete gamma distribution (M5)");
					}

				if (freqNumber == 4 && doM0 == YES)
					{
					sprintf(model,"GY94xHKY_1x4 M0");
					}
				if (freqNumber == 4 && doM1 == YES)
					{
					sprintf(model,"GY94xHKY_1x4 M1");
					}
				if (freqNumber == 4 && doM7 == YES)
					{
					sprintf(model,"GY94xHKY_1x4 M7");
					}
				if (freqNumber == 4 && doM6 == YES)
					{
					sprintf(model,"GY94xHKY_1x4 M6");
					}
				if (freqNumber == 4 && doM8 == YES)
					{
					if (M8_omegaP1 > 1)
						sprintf(model,"GY94xHKY_1x4 M8");
					if (M8_omegaP1 == 1.0)
						sprintf(model,"GY94xHKY_1x4 M8a");
					if (M8_omegaP1 < 1)
						sprintf(model,"GY94xHKY_1x4 M8b");
					}
				if (freqNumber == 4 && doM9 == YES)
					{
					sprintf(model,"GY94xHKY_1x4 M9");
					}
				if (freqNumber == 4 && doM10 == YES)
					{
					sprintf(model,"GY94xHKY_1x4 M10");
					}
				if (freqNumber == 4 && doMG94 == YES)
					{
					sprintf(model,"MG94xHKY_1x4");
					}
				if (freqNumber == 4 && doOmegaCat == YES && doM1 == NO)
					{
					sprintf(model,"GY94xHKY_1x4 by categories");
					}
				if (freqNumber == 4 && doOmegaRateHetCont == YES)
					{
					sprintf(model,"GY94xHKY_1x4 with variable omega by continuous gamma distribution (M5)");
					}
				if (freqNumber == 4 && doOmegaRateHetDisc == YES)
					{
					sprintf(model,"GY94xHKY_1x4 with variable omega by discrete gamma distribution (M5)");
					}

				}
			if (titv == 0.5)
				{
				if (freqNumber == 12 && doM0 == YES)
					{
					sprintf(model,"GY94xJC_3x4 M0");
					/*fprintf(filep,"\nGY94xJC_3x4 M0\n");*/
					}
				if (freqNumber == 12 && doM1 == YES)
					{
					sprintf(model,"GY94xJC_3x4 M1");
					}
				if (freqNumber == 12 && doM7 == YES)
					{
					sprintf(model,"GY94xJC_3x4 M7");
					}
				if (freqNumber == 12 && doM6 == YES)
					{
					sprintf(model,"GY94xJC_3x4 M6");
					}
				if (freqNumber == 12 && doM8 == YES)
					{
					if (M8_omegaP1 > 1)
						sprintf(model,"GY94xJC_3x4 M8");
					if (M8_omegaP1 == 1.0)
						sprintf(model,"GY94xJC_3x4 M8a");
					if (M8_omegaP1 < 1)
						sprintf(model,"GY94xJC_3x4 M8b");
					}
				if (freqNumber == 12 && doM9 == YES)
					{
					sprintf(model,"GY94xJC_3x4 M9");
					}
				if (freqNumber == 12 && doM10 == YES)
					{
					sprintf(model,"GY94xJC_3x4 M10");
					}
				if (freqNumber == 12 && doMG94 == YES)
					{
					sprintf(model,"MG94xJC_3x4");
					}
				if (freqNumber == 12 && doOmegaCat == YES && doM1 == NO)
					{
					sprintf(model,"GY94xJC_3x4 by categories");
					}
				if (freqNumber == 12 && doOmegaRateHetCont == YES)
					{
					sprintf(model,"GY94xJC_3x4 with variable omega by continuous gamma distribution (M5)");
					}
				if (freqNumber == 12 && doOmegaRateHetDisc == YES)
					{
					sprintf(model,"GY94xJC_3x4 with variable omega by discrete gamma distribution (M5)");
					}

				if (freqNumber == 4 && doM0 == YES)
					{
					sprintf(model,"GY94xJC_1x4 M0");
					}
				if (freqNumber == 4 && doM1 == YES)
					{
					sprintf(model,"GY94xJC_1x4 M1");
					}
				if (freqNumber == 4 && doM7 == YES)
					{
					sprintf(model,"GY94xJC_1x4 M7");
					}
				if (freqNumber == 4 && doM6 == YES)
					{
					sprintf(model,"GY94xJC_1x4 M6");
					}
				if (freqNumber == 4 && doM8 == YES)
					{
					if (M8_omegaP1 > 1)
						sprintf(model,"GY94xJC_1x4 M8");
					if (M8_omegaP1 == 1.0)
						sprintf(model,"GY94xJC_1x4 M8a");
					if (M8_omegaP1 < 1)
						sprintf(model,"GY94xJC_1x4 M8b");
					}
				if (freqNumber == 4 && doM9 == YES)
					{
					sprintf(model,"GY94xJC_1x4 M9");
					}
				if (freqNumber == 4 && doM10 == YES)
					{
					sprintf(model,"GY94xJC_1x4 M10");
					}
				if (freqNumber == 4 && doMG94 == YES)
					{
					sprintf(model,"MG94xJC_1x4");
					}
				if (freqNumber == 4 && doOmegaCat == YES && doM1 == NO)
					{
					sprintf(model,"GY94xJC_1x4 by categories");
					}
				if (freqNumber == 4 && doOmegaRateHetCont == YES)
					{
					sprintf(model,"GY94xJC_1x4 with variable omega by continuous gamma distribution (M5)");
					}
				if (freqNumber == 4 && doOmegaRateHetDisc == YES)
					{
					sprintf(model,"GY94xJC_1x4 with variable omega by discrete gamma distribution (M5)");
					}

				}
			if (doCodon_GTR == YES)
				{
				if (freqNumber == 12 && doM0 == YES)
					{
					sprintf(model,"GY94xGTR_3x4 M0");
					/*fprintf(filep,"\nGY94xGTR_3x4 M0\n");*/
					}
				if (freqNumber == 12 && doM1 == YES)
					{
					sprintf(model,"GY94xGTR_3x4 M1");
					}
				if (freqNumber == 12 && doM7 == YES)
					{
					sprintf(model,"GY94xGTR_3x4 M7");
					}
				if (freqNumber == 12 && doM6 == YES)
					{
					sprintf(model,"GY94xGTR_3x4 M6");
					}
				if (freqNumber == 12 && doM8 == YES)
					{
					if (M8_omegaP1 > 1)
						sprintf(model,"GY94xGTR_3x4 M8");
					if (M8_omegaP1 == 1.0)
						sprintf(model,"GY94xGTR_3x4 M8a");
					if (M8_omegaP1 < 1)
						sprintf(model,"GY94xGTR_3x4 M8b");
					}
				if (freqNumber == 12 && doM9 == YES)
					{
					sprintf(model,"GY94xGTR_3x4 M9");
					}
				if (freqNumber == 12 && doM10 == YES)
					{
					sprintf(model,"GY94xGTR_3x4 M10");
					}
				if (freqNumber == 12 && doMG94 == YES)
					{
					sprintf(model,"MG94xGTR_3x4");
					}
				if (freqNumber == 12 && doOmegaCat == YES && doM1 == NO)
					{
					sprintf(model,"GY94xGTR_3x4 by categories");
					}
				if (freqNumber == 12 && doOmegaRateHetCont == YES)
					{
					sprintf(model,"GY94xGTR_3x4 with variable omega by continuous gamma distribution (M5)");
					}
				if (freqNumber == 12 && doOmegaRateHetDisc == YES)
					{
					sprintf(model,"GY94xGTR_3x4 with variable omega by discrete gamma distribution (M5)");
					}

				if (freqNumber == 4 && doM0 == YES)
					{
					if (p_i[0] == p_i[1] && p_i[0] == p_i[2] && p_i[0] == p_i[3])
						{
						sprintf(model,"GY94xSYM_1x4 M0");
						}
					else
						sprintf(model,"GY94xGTR_1x4 M0");
					}
				if (freqNumber == 4 && doM1 == YES)
					{
					if (p_i[0] == p_i[1] && p_i[0] == p_i[2] && p_i[0] == p_i[3])
						{
						sprintf(model,"GY94xSYM_1x4 M1");
						}
					else
						sprintf(model,"GY94xGTR_1x4 M1");
					}
				if (freqNumber == 4 && doM7 == YES)
					{
					if (p_i[0] == p_i[1] && p_i[0] == p_i[2] && p_i[0] == p_i[3])
						{
						sprintf(model,"GY94xSYM_1x4 M7");
						}
					else
						sprintf(model,"GY94xGTR_1x4 M7");
					}
				if (freqNumber == 4 && doM6 == YES)
					{
					if (p_i[0] == p_i[1] && p_i[0] == p_i[2] && p_i[0] == p_i[3])
						{
						sprintf(model,"GY94xSYM_1x4 M6");
						}
					else
						sprintf(model,"GY94xGTR_1x4 M6");
					}
				if (freqNumber == 4 && doM9 == YES)
					{
					if (p_i[0] == p_i[1] && p_i[0] == p_i[2] && p_i[0] == p_i[3])
						{
						sprintf(model,"GY94xSYM_1x4 M9");
						}
					else
						sprintf(model,"GY94xGTR_1x4 M9");
					}
				if (freqNumber == 4 && doM10 == YES)
					{
					if (p_i[0] == p_i[1] && p_i[0] == p_i[2] && p_i[0] == p_i[3])
						{
						sprintf(model,"GY94xSYM_1x4 M10");
						}
					else
						sprintf(model,"GY94xGTR_1x4 M10");
					}
				if (freqNumber == 4 && doMG94 == YES)
					{
					if (p_i[0] == p_i[1] && p_i[0] == p_i[2] && p_i[0] == p_i[3])
						{
						sprintf(model,"MG94xSYM_1x4");
						}
					else
						sprintf(model,"MG94xGTR_1x4");
					}
				if (freqNumber == 4 && doM8 == YES)
					{
					if (M8_omegaP1 > 1)
						{
						if (p_i[0] == p_i[1] && p_i[0] == p_i[2] && p_i[0] == p_i[3])
							{
							sprintf(model,"GY94xSYM_1x4 M8");
							}
						else
							sprintf(model,"GY94xGTR_1x4 M8");
						}
					if (M8_omegaP1 == 1.0)
						{
						if (p_i[0] == p_i[1] && p_i[0] == p_i[2] && p_i[0] == p_i[3])
							{
							sprintf(model,"GY94xSYM_1x4 M8a");
							}
						else
							sprintf(model,"GY94xGTR_1x4 M8a");
						}
					if (M8_omegaP1 < 1)
						{
						if (p_i[0] == p_i[1] && p_i[0] == p_i[2] && p_i[0] == p_i[3])
							{
							sprintf(model,"GY94xSYM_1x4 M8b");
							}
						else
							sprintf(model,"GY94xGTR_1x4 M8b");
						}
					}
				if (freqNumber == 4 && doOmegaCat == YES && doM1 == NO)
					{
					if (p_i[0] == p_i[1] && p_i[0] == p_i[2] && p_i[0] == p_i[3])
						{
						sprintf(model,"GY94xSYM_1x4 by categories");
						}
					else
						sprintf(model,"GY94xGTR_1x4 by categories");
					}
				if (freqNumber == 4 && doOmegaRateHetCont == YES)
					{
					if (p_i[0] == p_i[1] && p_i[0] == p_i[2] && p_i[0] == p_i[3])
						{
						sprintf(model,"GY94xSYM_1x4 with variable omega by continuous gamma distribution (M5)");
						}
					else
						sprintf(model,"GY94xGTR_1x4 with variable omega by continuous gamma distribution (M5)");
					}
				if (freqNumber == 4 && doOmegaRateHetDisc == YES)
					{
					if (p_i[0] == p_i[1] && p_i[0] == p_i[2] && p_i[0] == p_i[3])
						{
						sprintf(model,"GY94xSYM_1x4 with variable omega by discrete gamma distribution (M5)");
						}
					else
						sprintf(model,"GY94xGTR_1x4 with variable omega by discrete gamma distribution (M5)");
					}
					
				}
			if (doCodon_NGTR == YES)
				{
				if (freqNumber == 12 && doM0 == YES)
					{
					sprintf(model,"GY94xGTnR_3x4 M0");
					/*fprintf(filep,"\nGY94xGTnR_3x4 M0\n");*/
					}
				if (freqNumber == 12 && doM1 == YES)
					{
					sprintf(model,"GY94xGTnR_3x4 M1");
					}
				if (freqNumber == 12 && doM7 == YES)
					{
					sprintf(model,"GY94xGTnR_3x4 M7");
					}
				if (freqNumber == 12 && doM6 == YES)
					{
					sprintf(model,"GY94xGTnR_3x4 M6");
					}
				if (freqNumber == 12 && doM8 == YES)
					{
					if (M8_omegaP1 > 1)
						sprintf(model,"GY94xGTnR_3x4 M8");
					if (M8_omegaP1 == 1.0)
						sprintf(model,"GY94xGTnR_3x4 M8a");
					if (M8_omegaP1 < 1)
						sprintf(model,"GY94xGTnR_3x4 M8b");
					}
				if (freqNumber == 12 && doM9 == YES)
					{
					sprintf(model,"GY94xGTnR_3x4 M9");
					}
				if (freqNumber == 12 && doM10 == YES)
					{
					sprintf(model,"GY94xGTnR_3x4 M10");
					}
				if (freqNumber == 12 && doMG94 == YES)
					{
					sprintf(model,"MG94xGTnR_3x4");
					}
				if (freqNumber == 12 && doOmegaCat == YES && doM1 == NO)
					{
					sprintf(model,"GY94xGTnR_3x4 by categories");
					}
				if (freqNumber == 12 && doOmegaRateHetCont == YES)
					{
					sprintf(model,"GY94xGTnR_3x4 with variable omega by continuous gamma distribution (M5)");
					}
				if (freqNumber == 12 && doOmegaRateHetDisc == YES)
					{
					sprintf(model,"GY94xGTnR_3x4 with variable omega by discrete gamma distribution (M5)");
					}

				if (freqNumber == 4 && doM0 == YES)
					{
					sprintf(model,"GY94xGTnR_1x4 M0");
					}
				if (freqNumber == 4 && doM1 == YES)
					{
					sprintf(model,"GY94xGTnR_1x4 M1");
					}
				if (freqNumber == 4 && doM7 == YES)
					{
					sprintf(model,"GY94xGTnR_1x4 M7");
					}
				if (freqNumber == 4 && doM6 == YES)
					{
					sprintf(model,"GY94xGTnR_1x4 M6");
					}
				if (freqNumber == 4 && doM8 == YES)
					{
					if (M8_omegaP1 > 1)
						sprintf(model,"GY94xGTnR_1x4 M8");
					if (M8_omegaP1 == 1.0)
						sprintf(model,"GY94xGTnR_1x4 M8a");
					if (M8_omegaP1 < 1)
						sprintf(model,"GY94xGTnR_1x4 M8b");
					}
				if (freqNumber == 4 && doM9 == YES)
					{
					sprintf(model,"GY94xGTnR_1x4 M9");
					}
				if (freqNumber == 4 && doM10 == YES)
					{
					sprintf(model,"GY94xGTnR_1x4 M10");
					}
				if (freqNumber == 4 && doMG94 == YES)
					{
					sprintf(model,"MG94xGTnR_1x4");
					}
				if (freqNumber == 4 && doOmegaCat == YES && doM1 == NO)
					{
					sprintf(model,"GY94xGTnR_1x4 by categories");
					}
				if (freqNumber == 4 && doOmegaRateHetCont == YES)
					{
					sprintf(model,"GY94xGTnR_1x4 with variable omega by continuous gamma distribution (M5)");
					}
				if (freqNumber == 4 && doOmegaRateHetDisc == YES)
					{
					sprintf(model,"GY94xGTnR_1x4 with variable omega by discrete gamma distribution (M5)");
					}
				}
			}
		else if (doAAmodel == YES)
			{
			if (doFreqGiven == NO || NumberFrequencies < 20)
				{
				fprintf (filep, "\nAmino acid frequencies were not provided by the user:");
				fprintf (filep, "\nFrequencies derived from the empirical model were applied\n");
				}

			if (doBlosum62 == YES)
				{
				sprintf(model," Blosum62");
				}
			if (doCpRev == YES)
				{
				sprintf(model," CpRev");
				}
			if (doDayhoff == YES)
				{
				sprintf(model," Dayhoff");
				}
			if (doDayhoffDCMUT == YES)
				{
				sprintf(model," DayhoffDCMUT");
				}
			if (doHIVb == YES)
				{
				sprintf(model," HIVb");
				}
			if (doHIVw == YES)
				{
				sprintf(model," HIVw");
				}
			if (doJTT == YES)
				{
				sprintf(model," JTT");
				}
			if (doJonesDCMUT == YES)
				{
				sprintf(model," JonesDCMUT");
				}
			if (doLG == YES)
				{
				sprintf(model," LG");
				}
			if (doMtart == YES)
				{
				sprintf(model," Mtart");
				}
			if (doMtmam == YES)
				{
				sprintf(model," Mtmam");
				}
			if (doMtrev24 == YES)
				{
				sprintf(model," Mtrev24");
				}
			if (doRtRev == YES)
				{
				sprintf(model," RtRev");
				}
			if (doVT == YES)
				{
				sprintf(model," VT");
				}
			if (doWAG == YES)
				{
				sprintf(model," WAG");
				}
			if (doEAAMUser == YES)
				{
				fprintf (filep, "\n\nEmpirical amino acid substitution model from input file: %s", AAmodel);
				sprintf(model,"user-given EAM");
				}
			
			if (doProtStabAAFile == YES)
				{
				fprintf (filep,"\n\nProtein stability substitution model:\n");
  				fprintf (filep," PDB file                               = %s\n", FILE_PDB);
  				fprintf (filep," chain                                  = %s\n", chain);
  				fprintf (filep," Contacts matrices file                 = %s\n", FILE_STR);
  				fprintf (filep," Temperature                            = %.2f\n", TEMP);
  				fprintf (filep," Entropy per residue (unfolded)         = %.3f\n", s0);
  				fprintf (filep," Entropy per residue (misfolded)        = %.3f\n", sC1);
  				fprintf (filep," Entropy per residue offset (misfolded) = %.3f\n", sC0);
  				fprintf (filep," Third cumulant in REM calculation      = %d\n", REM3);
				if(NEUTRAL){
				  fprintf (filep," Neutral fitness landscape\n");
				}else{
				  fprintf (filep," Population size (protein level)        = %d\n", N_pop);
				}
				if (doMutationalBranches == YES)
  					fprintf (filep," Branch length by mutations\n");
				else
  					fprintf (filep," Branch length by substitutions\n");

				sprintf (modelS," amino acid - protein stability x ");

				if (doBlosum62 == YES)
					sprintf(model,"Blosum62");
				if (doCpRev == YES)
					sprintf(model,"CpRev");
				if (doDayhoff == YES)
					sprintf(model,"Dayhoff");
				if (doDayhoffDCMUT == YES)
					sprintf(model,"DayhoffDCMUT");
				if (doHIVb == YES)
					sprintf(model,"HIVb");
				if (doHIVw == YES)
					sprintf(model,"HIVw");
				if (doJTT == YES)
					sprintf(model,"JTT");
				if (doJonesDCMUT == YES)
					sprintf(model,"JonesDCMUT");
				if (doLG == YES)
					sprintf(model,"LG");
				if (doMtart == YES)
					sprintf(model,"Mtart");
				if (doMtmam == YES)
					sprintf(model,"Mtmam");
				if (doMtrev24 == YES)
					sprintf(model,"Mtrev24");
				if (doRtRev == YES)
					sprintf(model,"RtRev");
				if (doVT == YES)
					sprintf(model,"VT");
				if (doWAG == YES)
					sprintf(model,"WAG");
				if (doEAAMUser == YES)
					{
					fprintf (filep, "\n\nEmpirical amino acid substitution model from input file: %s", AAmodel);
					sprintf(model,"user-given EAM");
					}

				}

			}
		else
			{
			sprintf (modelS," ");
			if (doProtStabDNAFile == YES)
				{
				fprintf (filep,"\n\n Structural protein stability substitution model:\n");
  				fprintf (filep," PDB file                               = %s\n", FILE_PDB);
  				fprintf (filep," chain                                  = %s\n", chain);
  				fprintf (filep," Contacts matrices file                 = %s\n", FILE_STR);
  				fprintf (filep," Temperature                            = %.2f\n", TEMP);
  				fprintf (filep," Entropy per residue (unfolded)         = %.3f\n", s0);
  				fprintf (filep," Entropy per residue (misfolded)        = %.3f\n", sC1);
  				fprintf (filep," Entropy per residue offset (misfolded) = %.3f\n", sC0);
  				fprintf (filep," Third cumulant in REM calculation      = %d\n", REM3);
				if(NEUTRAL){
				  fprintf (filep," Neutral fitness landscape\n");
				}else{
				  fprintf (filep," Population size (protein level)        = %d\n", N_pop);
				}
				if (doMutationalBranches == YES)
  					fprintf (filep," Branch length by mutations\n");
				else
  					fprintf (filep," Branch length by substitutions\n");

				sprintf (modelS," DNA - structural protein stability x ");
				}

			if (doGTR == YES)
				{
				if (p_i[0] == p_i[1] && p_i[0] == p_i[2] && p_i[0] == p_i[3])
					{
					sprintf (model,"SYM");
					}
				else
					sprintf (model,"GTR");
				}
			else if (doGTnR == YES)
				sprintf (model,"GTnR");
			else
				{
				if (equalBaseFreq == YES)
					{
					if (titv == 0.5)
						sprintf (model,"JC");
					else
						sprintf (model,"K80");
					}
				else
					{
					if (titv == 0.5)
						sprintf (model,"F81");
					else
						sprintf (model,"HKY");
					}
				}
			}
		
		if (doHetVectorFile == NO)
			{
			if (doRateHet == NO && pinv == 0)
				fprintf (filep,"\n\nThese settings correspond to the%s%s%smodel\n", modelS, model, modelB);
			if (doRateHet == NO && pinv != 0)
				fprintf (filep,"\n\nThese settings correspond to the%s%s%s+ I model\n", modelS, model, modelB);
			if (doRateHet == YES && pinv == 0)
				fprintf (filep,"\n\nThese settings correspond to the%s%s%s+ G model\n", modelS, model, modelB);
			if (doRateHet == YES && pinv != 0)
				fprintf (filep,"\n\nThese settings correspond to the%s%s%s+ G + I model\n", modelS, model, modelB);
			}
		else
			{
			if (doRateHet == NO && pinv == 0)
				fprintf (filep,"\n\nThese settings correspond to the%s%s%s+ heterogeneity by rates vector model\n", modelS, model, modelB);
			if (doRateHet == NO && pinv != 0)
				fprintf (filep,"\n\nThese settings correspond to the%s%s%s+ I + heterogeneity by rates vector model\n", modelS, model, modelB);
			if (doRateHet == YES && pinv == 0)
				fprintf (filep,"\n\nThese settings correspond to the%s%s%s+ G + heterogeneity by rates vector model\n", modelS, model, modelB);
			if (doRateHet == YES && pinv != 0)
				fprintf (filep,"\n\nThese settings correspond to the%s%s%s+ G + I + heterogeneity by rates vector model\n", modelS, model, modelB);
			}



	#ifdef MPI
			}
	#endif
	}



/***************************** PrintRunSettings *******************************/
/* Prints a summary of run settings */

static void	PrintRunSettings_userTrees (FILE *filep, long int seed)
	{
		int i, j;
		double stdErrorErep, stdErrGMRCA, stdErrTrep;

		
		stdErrorErep = stdErrGMRCA = stdErrTrep = 0.0;		

		/* Anadido Miguel: Para que escriba por la pantalla del master */
		#ifdef MPI
			if (rank==root)
				{
		#endif
		
		if (doSettingsFile == YES)
			filep = fpSettings;
		/*fprintf(fpTrees, "Dataset %d \n", replicate+1);*/

		fprintf (filep, "\nRun settings\n-------------------------");
		fprintf (filep, "\n[Assumptions in brackets]");
		fprintf (filep, "\n\nSimulations");
		fprintf (filep, "\nSeed                                =  %-3ld", seed);
		fprintf (filep, "\nNumber replicate data sets          =  %-3d", numDataSets);
		fprintf (filep, "\nNumber of sequences                 =  %-3d", numSequences);
		fprintf (filep, "\nNumber of sites (bp, codons or aa)  =  %-3d\n", numSites);

		fprintf (filep, "\nUser specified trees                =  %-3d\n", numTrees);
		for (i=0; i<numTrees; i++)
			{
			fprintf (filep, "%4d - %4d ", tree[i].begin, tree[i].end);
			WriteTree (filep, (Treetnode *)tree[i].tnode);	
			fprintf (filep,";\n");
			}

		/* Other Settings */
		if (doMRCAFile == YES)
			fprintf (filep, "\nMRCA sequence                       =  specified by the user");
		else
			fprintf (filep, "\nMRCA sequence                       =  simulated");
		if (doPrintAncestralSequences == YES)
			fprintf (filep, "\nPrint ancestral states              =  YES");
		else
			fprintf (filep, "\nPrint ancestral states              =  NO");


		/* Substitutions */
		if (doProtStabDNAFile == NO && doProtStabAAFile == NO)
			fprintf (filep, "\n\nMean number of substitution events  =  %3.2f", meanNumMU);
		if (doProtStabDNAFile == YES || doProtStabAAFile == YES)
			{
			fprintf (filep, "\n\nMean number of introduced substitution events          =  %3.2f", TotalCountDNAsubsRep/(double)numDataSets);
			if (doProtStabDNAFile == YES)
				fprintf (filep, "\n Mean number of introduced nonsynonymous substitution events =  %3.2f", TotalCountDNAsubsNSRep/(double)numDataSets);
			fprintf (filep, "\nMean number of observed substitution events (branches) =  %3.2f", meanNumMU);
			fprintf (filep, "\nMean number of mutation attempts                       =  %3.2f", meanMutationAttempts);
			}	
		if (doCodonModel == YES)
			{
			fprintf (filep, "\n  synonymous changes =  %3.2f (%3.2f%%)", meanNumMU_S, 1.00*meanNumMU_S*100/meanNumMU);
			fprintf (filep, "\n  nonsynonymous changes =  %3.2f (%3.2f%%)", meanNumMU_NS, 1.00*meanNumMU_NS*100/meanNumMU);
			}
					

		/* Substitution model */
		if (doCodonModel == YES)
			fprintf (filep, "\n\nCodon replacement model\n------------------------");
		else if (doAAmodel == YES)
			fprintf (filep, "\n\n\nAmino acid substitution model\n-----------------------------");
		else
			fprintf (filep, "\n\n\nNucleotide substitution model\n-----------------------------");
		
		if (doCodonModel == YES)
			{
			fprintf (filep, "\nBase frequencies (piA piC piG piT) for codon positions:");
			fprintf (filep, "\n   first  =   %3.2f %3.2f %3.2f %3.2f", p_i_codon[0], p_i_codon[1], p_i_codon[2], p_i_codon[3]);
			fprintf (filep, "\n   second =   %3.2f %3.2f %3.2f %3.2f", p_i_codon[4], p_i_codon[5], p_i_codon[6], p_i_codon[7]);
			fprintf (filep, "\n   third  =   %3.2f %3.2f %3.2f %3.2f", p_i_codon[8], p_i_codon[9], p_i_codon[10], p_i_codon[11]);
			
			if (doOmegaCat == NO && doM8 == NO && doM7 == NO && doM6 == NO && doM9 == NO && doM10 == NO && doMG94 == NO && doECM == NO)
				fprintf (filep, "\nOmega (dN/dS ratio)                 =  %3.2f", OmegaInit);
			if (doMG94 == YES)
				{
				fprintf (filep, "\nSynonymous rate                =  %3.2f", SynRate);
				fprintf (filep, "\nNon-Synonymous rate            =  %3.2f", NonSynRate);
				}
			if (doOmegaCat == YES)
				{
				if (doM1 == YES)
					{
					fprintf (filep, "\n\nM1 codon model:\n  P0 = %3.2f, Omega (P0) = %3.2f, P1 = %3.2f\n", M1_P0_omeg0, M1_omega0, M1_P1_omeg1);
					}
				else
					{
					fprintf (filep, "\nOmega (dN/dS ratio) in %d user-categories: \n Category      Omega      Probability", numOmegaCat);
					for (j=1; j<=numOmegaCat; j++)
						fprintf(filep, "\n    %d          %3.2f           %3.2f", j, omegaVal[j], omegaProb[j]);
					}
				}
			if (doOmegaRateHetCont == YES)
				fprintf (filep, "\nOmega variation among sites (M5)\n alpha                              =  %3.2f", OmegaRateHet);
			if (doOmegaRateHetDisc == YES)
				{
				fprintf (filep, "\nOmega discrete variation among sites (%d categories) (M5)\n alpha (gamma shape)                =  %3.2f", numOmegaCat, OmegaRateHet);
				fprintf (filep, "\n Category      Omega      Probability");
				for (j=1; j<=numOmegaCat; j++)
					fprintf(filep, "\n    %d          %3.2f           %3.2f", j, OmegaInit*gammaRates[j-1], (double)1/numOmegaCat);
				/*fprintf (filep, "\nGamma values obtained               =");*/ /* Active to see the gamma values for omega */
				/*for (j=1; j<=numOmegaCat; j++)
					fprintf(filep, "  %3.3f", gammaRates[j-1]);*/
				}
			if (doM6 == YES) /* M6_P0, M6_P1; OmegaRateHetM6_0 OmegaM6_0 OmegaInitM6_0; OmegaRateHetM6_1 OmegaM6_1 OmegaInitM6_1 [p0 p q, w] */
				{
				fprintf (filep, "\n\nM6 codon model (2gamma):\n  P0 = %3.2f P1 = %3.2f\n", M6_P0, M6_P1);
				fprintf (filep, "  Gamma distribution (P0) a = %3.2f b = %3.2f\n", OmegaRateHetM6_0, OmegaM6_0);
				fprintf (filep, "  Gamma distribution (P1) a = %3.2f b = %3.2f\n", OmegaRateHetM6_1, OmegaM6_1);
				}
			if (doM8 == YES)
				{
				fprintf (filep, "\n\nM8 codon model:\n  P0 = %3.2f P1 = %3.2f\n", M8_P0_beta, M8_P1_omega);
				fprintf (filep, "  Beta distribution (P0) p = %3.2f q = %3.2f; Omega (P1) = %3.2f\n", M8_p_beta, M8_q_beta, M8_omegaP1);
				}
			if (doM7 == YES)
				{
				fprintf (filep, "\n\nM7 codon model:\n  Beta distribution, p = %3.2f q = %3.2f\n", M7_p_beta, M7_q_beta);
				}
			if (doM9 == YES)
				{
				fprintf (filep, "\n\nM9 codon model:\n  Beta distribution, P0 = %3.2f, p = %3.2f q = %3.2f\n", M910_P0, M910_p_beta, M910_q_beta);
				fprintf (filep, "  Gamma distribution, a = %3.2f b = %3.2f\n", OmegaRateHetM910_1, OmegaM910_1);
				}
			if (doM10 == YES)
				{
				fprintf (filep, "\n\nM10 codon model:\n  Beta distribution, P0 = %3.2f, p = %3.2f q = %3.2f\n", M910_P0, M910_p_beta, M910_q_beta);
				fprintf (filep, "  Gamma distribution, a = %3.2f b = %3.2f\n", OmegaRateHetM910_1, OmegaM910_1);
				}
			if (doECM == YES) /* only empirical codon models */
				{
				fprintf (filep, "\n\nEmpirical codon model");
				if (doECMuser == YES)
					fprintf (filep, " from the input file: %s\n", ECodonModel);	
				else
					fprintf (filep, ": %s\n", ECodonModel);
				}
			if (doGY94xAAmodel == YES) 
				{
				fprintf (filep, "\nCodon model with amino acid contributions from");
				if (doGY94xEAAMUser == YES)
					fprintf (filep, " the input file: %s\n", GY94xAAmodel);	
				else
					fprintf (filep, ": %s\n", GY94xAAmodel);
				}

			if (doVariableDnDsBranches == YES) 
				{
				fprintf (filep, "\nCodon model with also variable dN/dS per branch");
				if (doBBM0 == YES)
					{
					fprintf (filep, " for a M0 codon model, variantion among branches: \n");
					if (BBmodelNumber == 1)
						{
						fprintf (filep, "Omega (dN/dS ratio) in %d user-categories for branches: \n Category      Omega      Probability", BBnumOmegaCat);
						for (j=1; j<=BBnumOmegaCat; j++)
							fprintf(filep, "\n    %d          %3.2f           %3.2f", j, BBomegaVal[j], BBomegaProb[j]);
						}
					if (BBmodelNumber == 2)
						{
						fprintf (filep, "Omega variation according to a gamma distribution: %3.2f, %3.2f", BBOmegaRateHet, BBomega);
						}
					if (BBmodelNumber == 3)
						{
						fprintf (filep, "Omega variation according to a beta distribution: %3.2f, %3.2f", BBM7_p_beta, BBM7_q_beta);
						}
					}	
				else
					fprintf (filep, "\n");
				fprintf (filep, "\n");
				}

			}
		else if (doAAmodel == YES)
			{ /* A R N D C Q E G H I L K M F P S T W Y V */
			fprintf (filep, "\nAmino acid frequencies:\n");
			if (NumberFrequencies == 20)
				{
				fprintf (filep, "   piA piR piN piD piC  =  %3.2f %3.2f %3.2f %3.2f %3.2f\n", 
    	              p_i_aa[0], p_i_aa[1], p_i_aa[2], p_i_aa[3], p_i_aa[4]);
				fprintf (filep, "   piQ piE piG piH piI  =  %3.2f %3.2f %3.2f %3.2f %3.2f\n", 
            	      p_i_aa[5], p_i_aa[6], p_i_aa[7], p_i_aa[8], p_i_aa[9]);
				fprintf (filep, "   piL piK piM piF piP  =  %3.2f %3.2f %3.2f %3.2f %3.2f\n", 
        	          p_i_aa[10], p_i_aa[11], p_i_aa[12], p_i_aa[13], p_i_aa[14]);
				fprintf (filep, "   piS piT piW piY piV  =  %3.2f %3.2f %3.2f %3.2f %3.2f\n", 
        	          p_i_aa[15], p_i_aa[16], p_i_aa[17], p_i_aa[18], p_i_aa[19]);
				}
			}
		else
			{
			fprintf (filep, "\nBase frequencies (piA piC piG piT)  =  %3.2f %3.2f %3.2f %3.2f", p_i[0], p_i[1], p_i[2], p_i[3]);
			}



		if (doAAmodel == NO)
			{ 
			if (doHKY == YES || doCodon_HKY == YES)
				fprintf (filep, "\nTransition/transversion ratio       =  %3.2f (kappa = %3.2f)", titv, kappa);
			if (doGTR == YES || doCodon_GTR == YES)
				fprintf (filep, "\nR-matrix                            =  %3.2f %3.2f %3.2f %3.2f %3.2f %3.2f", 
					Rmat[0], Rmat[1], Rmat[2], Rmat[3], Rmat[4], Rmat[5]);
			if (doGTnR == YES || doCodon_NGTR == YES)
				fprintf (filep, "\nnR-matrix                           =  %3.2f %3.2f %3.2f %3.2f %3.2f %3.2f\n                                       %3.2f %3.2f %3.2f %3.2f %3.2f %3.2f ", 
					NRmat[0], NRmat[1], NRmat[2], NRmat[3], NRmat[4], NRmat[5], NRmat[6], NRmat[7], NRmat[8], NRmat[9], NRmat[10], NRmat[11]);
			}

		fprintf (filep, "\nProportion of invariable sites      =  %3.2f ", pinv);
		if (doRateHet == YES)
			fprintf (filep, "\nRate variation among sites\n  alpha (gamma shape)               =  %3.2f ", alpha);
		else
			fprintf (filep, "\nNo rate variation among sites");
		if (doHetVectorFile == YES)
			fprintf (filep, "\nVector with rate variation among sites in the user-defined file =  %s ", HetVectorFile);



		sprintf(modelB," ");
		if (doCodonModel == YES)
			{
			if (doGY94xAAmodel == YES) 
				{
				sprintf(modelB," x %s(EAAM) ", GY94xAAmodel);
				}
			if (doVariableDnDsBranches == YES)
				{
				sprintf(modelB," x dN/dS variable per branch ");
				}			

			if (doECM == YES)
				{
				sprintf(model,"%s ECM", ECodonModel);
				}

			if (doCodon_HKY == YES)
				{
				if (freqNumber == 12 && doM0 == YES)
					{
					sprintf(model,"GY94xHKY_3x4 M0");
					/*fprintf(filep,"\nGY94xHKY_3x4 M0\n");*/
					}
				if (freqNumber == 12 && doM1 == YES)
					{
					sprintf(model,"GY94xHKY_3x4 M1");
					}
				if (freqNumber == 12 && doM7 == YES)
					{
					sprintf(model,"GY94xHKY_3x4 M7");
					}
				if (freqNumber == 12 && doM6 == YES)
					{
					sprintf(model,"GY94xHKY_3x4 M6");
					}
				if (freqNumber == 12 && doM8 == YES)
					{
					if (M8_omegaP1 > 1)
						sprintf(model,"GY94xHKY_3x4 M8");
					if (M8_omegaP1 == 1.0)
						sprintf(model,"GY94xHKY_3x4 M8a");
					if (M8_omegaP1 < 1)
						sprintf(model,"GY94xHKY_3x4 M8b");
					}
				if (freqNumber == 12 && doM9 == YES)
					{
					sprintf(model,"GY94xHKY_3x4 M9");
					}
				if (freqNumber == 12 && doM10 == YES)
					{
					sprintf(model,"GY94xHKY_3x4 M10");
					}
				if (freqNumber == 12 && doMG94 == YES)
					{
					sprintf(model,"MG94xHKY_3x4");
					}
				if (freqNumber == 12 && doOmegaCat == YES && doM1 == NO)
					{
					sprintf(model,"GY94xHKY_3x4 by categories");
					}
				if (freqNumber == 12 && doOmegaRateHetCont == YES)
					{
					sprintf(model,"GY94xHKY_3x4 with variable omega by continuous gamma distribution (M5)");
					}
				if (freqNumber == 12 && doOmegaRateHetDisc == YES)
					{
					sprintf(model,"GY94xHKY_3x4 with variable omega by discrete gamma distribution (M5)");
					}

				if (freqNumber == 4 && doM0 == YES)
					{
					sprintf(model,"GY94xHKY_1x4 M0");
					}
				if (freqNumber == 4 && doM1 == YES)
					{
					sprintf(model,"GY94xHKY_1x4 M1");
					}
				if (freqNumber == 4 && doM7 == YES)
					{
					sprintf(model,"GY94xHKY_1x4 M7");
					}
				if (freqNumber == 4 && doM6 == YES)
					{
					sprintf(model,"GY94xHKY_1x4 M6");
					}
				if (freqNumber == 4 && doM8 == YES)
					{
					if (M8_omegaP1 > 1)
						sprintf(model,"GY94xHKY_1x4 M8");
					if (M8_omegaP1 == 1.0)
						sprintf(model,"GY94xHKY_1x4 M8a");
					if (M8_omegaP1 < 1)
						sprintf(model,"GY94xHKY_1x4 M8b");
					}
				if (freqNumber == 4 && doM9 == YES)
					{
					sprintf(model,"GY94xHKY_1x4 M9");
					}
				if (freqNumber == 4 && doM10 == YES)
					{
					sprintf(model,"GY94xHKY_1x4 M10");
					}
				if (freqNumber == 4 && doMG94 == YES)
					{
					sprintf(model,"MG94xHKY_1x4");
					}
				if (freqNumber == 4 && doOmegaCat == YES && doM1 == NO)
					{
					sprintf(model,"GY94xHKY_1x4 by categories");
					}
				if (freqNumber == 4 && doOmegaRateHetCont == YES)
					{
					sprintf(model,"GY94xHKY_1x4 with variable omega by continuous gamma distribution (M5)");
					}
				if (freqNumber == 4 && doOmegaRateHetDisc == YES)
					{
					sprintf(model,"GY94xHKY_1x4 with variable omega by discrete gamma distribution (M5)");
					}

				}
			if (titv == 0.5)
				{
				if (freqNumber == 12 && doM0 == YES)
					{
					sprintf(model,"GY94xJC_3x4 M0");
					/*fprintf(filep,"\nGY94xJC_3x4 M0\n");*/
					}
				if (freqNumber == 12 && doM1 == YES)
					{
					sprintf(model,"GY94xJC_3x4 M1");
					}
				if (freqNumber == 12 && doM7 == YES)
					{
					sprintf(model,"GY94xJC_3x4 M7");
					}
				if (freqNumber == 12 && doM6 == YES)
					{
					sprintf(model,"GY94xJC_3x4 M6");
					}
				if (freqNumber == 12 && doM8 == YES)
					{
					if (M8_omegaP1 > 1)
						sprintf(model,"GY94xJC_3x4 M8");
					if (M8_omegaP1 == 1.0)
						sprintf(model,"GY94xJC_3x4 M8a");
					if (M8_omegaP1 < 1)
						sprintf(model,"GY94xJC_3x4 M8b");
					}
				if (freqNumber == 12 && doM9 == YES)
					{
					sprintf(model,"GY94xJC_3x4 M9");
					}
				if (freqNumber == 12 && doM10 == YES)
					{
					sprintf(model,"GY94xJC_3x4 M10");
					}
				if (freqNumber == 12 && doMG94 == YES)
					{
					sprintf(model,"MG94xJC_3x4");
					}
				if (freqNumber == 12 && doOmegaCat == YES && doM1 == NO)
					{
					sprintf(model,"GY94xJC_3x4 by categories");
					}
				if (freqNumber == 12 && doOmegaRateHetCont == YES)
					{
					sprintf(model,"GY94xJC_3x4 with variable omega by continuous gamma distribution (M5)");
					}
				if (freqNumber == 12 && doOmegaRateHetDisc == YES)
					{
					sprintf(model,"GY94xJC_3x4 with variable omega by discrete gamma distribution (M5)");
					}

				if (freqNumber == 4 && doM0 == YES)
					{
					sprintf(model,"GY94xJC_1x4 M0");
					}
				if (freqNumber == 4 && doM1 == YES)
					{
					sprintf(model,"GY94xJC_1x4 M1");
					}
				if (freqNumber == 4 && doM7 == YES)
					{
					sprintf(model,"GY94xJC_1x4 M7");
					}
				if (freqNumber == 4 && doM6 == YES)
					{
					sprintf(model,"GY94xJC_1x4 M6");
					}
				if (freqNumber == 4 && doM8 == YES)
					{
					if (M8_omegaP1 > 1)
						sprintf(model,"GY94xJC_1x4 M8");
					if (M8_omegaP1 == 1.0)
						sprintf(model,"GY94xJC_1x4 M8a");
					if (M8_omegaP1 < 1)
						sprintf(model,"GY94xJC_1x4 M8b");
					}
				if (freqNumber == 4 && doM9 == YES)
					{
					sprintf(model,"GY94xJC_1x4 M9");
					}
				if (freqNumber == 4 && doM10 == YES)
					{
					sprintf(model,"GY94xJC_1x4 M10");
					}
				if (freqNumber == 4 && doMG94 == YES)
					{
					sprintf(model,"MG94xJC_1x4");
					}
				if (freqNumber == 4 && doOmegaCat == YES && doM1 == NO)
					{
					sprintf(model,"GY94xJC_1x4 by categories");
					}
				if (freqNumber == 4 && doOmegaRateHetCont == YES)
					{
					sprintf(model,"GY94xJC_1x4 with variable omega by continuous gamma distribution (M5)");
					}
				if (freqNumber == 4 && doOmegaRateHetDisc == YES)
					{
					sprintf(model,"GY94xJC_1x4 with variable omega by discrete gamma distribution (M5)");
					}

				}
			if (doCodon_GTR == YES)
				{
				if (freqNumber == 12 && doM0 == YES)
					{
					sprintf(model,"GY94xGTR_3x4 M0");
					/*fprintf(filep,"\nGY94xGTR_3x4 M0\n");*/
					}
				if (freqNumber == 12 && doM1 == YES)
					{
					sprintf(model,"GY94xGTR_3x4 M1");
					}
				if (freqNumber == 12 && doM7 == YES)
					{
					sprintf(model,"GY94xGTR_3x4 M7");
					}
				if (freqNumber == 12 && doM6 == YES)
					{
					sprintf(model,"GY94xGTR_3x4 M6");
					}
				if (freqNumber == 12 && doM8 == YES)
					{
					if (M8_omegaP1 > 1)
						sprintf(model,"GY94xGTR_3x4 M8");
					if (M8_omegaP1 == 1.0)
						sprintf(model,"GY94xGTR_3x4 M8a");
					if (M8_omegaP1 < 1)
						sprintf(model,"GY94xGTR_3x4 M8b");
					}
				if (freqNumber == 12 && doM9 == YES)
					{
					sprintf(model,"GY94xGTR_3x4 M9");
					}
				if (freqNumber == 12 && doM10 == YES)
					{
					sprintf(model,"GY94xGTR_3x4 M10");
					}
				if (freqNumber == 12 && doMG94 == YES)
					{
					sprintf(model,"MG94xGTR_3x4");
					}
				if (freqNumber == 12 && doOmegaCat == YES && doM1 == NO)
					{
					sprintf(model,"GY94xGTR_3x4 by categories");
					}
				if (freqNumber == 12 && doOmegaRateHetCont == YES)
					{
					sprintf(model,"GY94xGTR_3x4 with variable omega by continuous gamma distribution (M5)");
					}
				if (freqNumber == 12 && doOmegaRateHetDisc == YES)
					{
					sprintf(model,"GY94xGTR_3x4 with variable omega by discrete gamma distribution (M5)");
					}

				if (freqNumber == 4 && doM0 == YES)
					{
					if (p_i[0] == p_i[1] && p_i[0] == p_i[2] && p_i[0] == p_i[3])
						{
						sprintf(model,"GY94xSYM_1x4 M0");
						}
					else
						sprintf(model,"GY94xGTR_1x4 M0");
					}
				if (freqNumber == 4 && doM1 == YES)
					{
					if (p_i[0] == p_i[1] && p_i[0] == p_i[2] && p_i[0] == p_i[3])
						{
						sprintf(model,"GY94xSYM_1x4 M1");
						}
					else
						sprintf(model,"GY94xGTR_1x4 M1");
					}
				if (freqNumber == 4 && doM7 == YES)
					{
					if (p_i[0] == p_i[1] && p_i[0] == p_i[2] && p_i[0] == p_i[3])
						{
						sprintf(model,"GY94xSYM_1x4 M7");
						}
					else
						sprintf(model,"GY94xGTR_1x4 M7");
					}
				if (freqNumber == 4 && doM6 == YES)
					{
					if (p_i[0] == p_i[1] && p_i[0] == p_i[2] && p_i[0] == p_i[3])
						{
						sprintf(model,"GY94xSYM_1x4 M6");
						}
					else
						sprintf(model,"GY94xGTR_1x4 M6");
					}
				if (freqNumber == 4 && doM9 == YES)
					{
					if (p_i[0] == p_i[1] && p_i[0] == p_i[2] && p_i[0] == p_i[3])
						{
						sprintf(model,"GY94xSYM_1x4 M9");
						}
					else
						sprintf(model,"GY94xGTR_1x4 M9");
					}
				if (freqNumber == 4 && doM10 == YES)
					{
					if (p_i[0] == p_i[1] && p_i[0] == p_i[2] && p_i[0] == p_i[3])
						{
						sprintf(model,"GY94xSYM_1x4 M10");
						}
					else
						sprintf(model,"GY94xGTR_1x4 M10");
					}
				if (freqNumber == 4 && doMG94 == YES)
					{
					if (p_i[0] == p_i[1] && p_i[0] == p_i[2] && p_i[0] == p_i[3])
						{
						sprintf(model,"MG94xSYM_1x4");
						}
					else
						sprintf(model,"MG94xGTR_1x4");
					}
				if (freqNumber == 4 && doM8 == YES)
					{
					if (M8_omegaP1 > 1)
						{
						if (p_i[0] == p_i[1] && p_i[0] == p_i[2] && p_i[0] == p_i[3])
							{
							sprintf(model,"GY94xSYM_1x4 M8");
							}
						else
							sprintf(model,"GY94xGTR_1x4 M8");
						}
					if (M8_omegaP1 == 1.0)
						{
						if (p_i[0] == p_i[1] && p_i[0] == p_i[2] && p_i[0] == p_i[3])
							{
							sprintf(model,"GY94xSYM_1x4 M8a");
							}
						else
							sprintf(model,"GY94xGTR_1x4 M8a");
						}
					if (M8_omegaP1 < 1)
						{
						if (p_i[0] == p_i[1] && p_i[0] == p_i[2] && p_i[0] == p_i[3])
							{
							sprintf(model,"GY94xSYM_1x4 M8b");
							}
						else
							sprintf(model,"GY94xGTR_1x4 M8b");
						}
					}
				if (freqNumber == 4 && doOmegaCat == YES && doM1 == NO)
					{
					if (p_i[0] == p_i[1] && p_i[0] == p_i[2] && p_i[0] == p_i[3])
						{
						sprintf(model,"GY94xSYM_1x4 by categories");
						}
					else
						sprintf(model,"GY94xGTR_1x4 by categories");
					}
				if (freqNumber == 4 && doOmegaRateHetCont == YES)
					{
					if (p_i[0] == p_i[1] && p_i[0] == p_i[2] && p_i[0] == p_i[3])
						{
						sprintf(model,"GY94xSYM_1x4 with variable omega by continuous gamma distribution (M5)");
						}
					else
						sprintf(model,"GY94xGTR_1x4 with variable omega by continuous gamma distribution (M5)");
					}
				if (freqNumber == 4 && doOmegaRateHetDisc == YES)
					{
					if (p_i[0] == p_i[1] && p_i[0] == p_i[2] && p_i[0] == p_i[3])
						{
						sprintf(model,"GY94xSYM_1x4 with variable omega by discrete gamma distribution (M5)");
						}
					else
						sprintf(model,"GY94xGTR_1x4 with variable omega by discrete gamma distribution (M5)");
					}
					
				}
			if (doCodon_NGTR == YES)
				{
				if (freqNumber == 12 && doM0 == YES)
					{
					sprintf(model,"GY94xGTnR_3x4 M0");
					/*fprintf(filep,"\nGY94xGTnR_3x4 M0\n");*/
					}
				if (freqNumber == 12 && doM1 == YES)
					{
					sprintf(model,"GY94xGTnR_3x4 M1");
					}
				if (freqNumber == 12 && doM7 == YES)
					{
					sprintf(model,"GY94xGTnR_3x4 M7");
					}
				if (freqNumber == 12 && doM6 == YES)
					{
					sprintf(model,"GY94xGTnR_3x4 M6");
					}
				if (freqNumber == 12 && doM8 == YES)
					{
					if (M8_omegaP1 > 1)
						sprintf(model,"GY94xGTnR_3x4 M8");
					if (M8_omegaP1 == 1.0)
						sprintf(model,"GY94xGTnR_3x4 M8a");
					if (M8_omegaP1 < 1)
						sprintf(model,"GY94xGTnR_3x4 M8b");
					}
				if (freqNumber == 12 && doM9 == YES)
					{
					sprintf(model,"GY94xGTnR_3x4 M9");
					}
				if (freqNumber == 12 && doM10 == YES)
					{
					sprintf(model,"GY94xGTnR_3x4 M10");
					}
				if (freqNumber == 12 && doMG94 == YES)
					{
					sprintf(model,"MG94xGTnR_3x4");
					}
				if (freqNumber == 12 && doOmegaCat == YES && doM1 == NO)
					{
					sprintf(model,"GY94xGTnR_3x4 by categories");
					}
				if (freqNumber == 12 && doOmegaRateHetCont == YES)
					{
					sprintf(model,"GY94xGTnR_3x4 with variable omega by continuous gamma distribution (M5)");
					}
				if (freqNumber == 12 && doOmegaRateHetDisc == YES)
					{
					sprintf(model,"GY94xGTnR_3x4 with variable omega by discrete gamma distribution (M5)");
					}

				if (freqNumber == 4 && doM0 == YES)
					{
					sprintf(model,"GY94xGTnR_1x4 M0");
					}
				if (freqNumber == 4 && doM1 == YES)
					{
					sprintf(model,"GY94xGTnR_1x4 M1");
					}
				if (freqNumber == 4 && doM7 == YES)
					{
					sprintf(model,"GY94xGTnR_1x4 M7");
					}
				if (freqNumber == 4 && doM6 == YES)
					{
					sprintf(model,"GY94xGTnR_1x4 M6");
					}
				if (freqNumber == 4 && doM8 == YES)
					{
					if (M8_omegaP1 > 1)
						sprintf(model,"GY94xGTnR_1x4 M8");
					if (M8_omegaP1 == 1.0)
						sprintf(model,"GY94xGTnR_1x4 M8a");
					if (M8_omegaP1 < 1)
						sprintf(model,"GY94xGTnR_1x4 M8b");
					}
				if (freqNumber == 4 && doM9 == YES)
					{
					sprintf(model,"GY94xGTnR_1x4 M9");
					}
				if (freqNumber == 4 && doM10 == YES)
					{
					sprintf(model,"GY94xGTnR_1x4 M10");
					}
				if (freqNumber == 4 && doMG94 == YES)
					{
					sprintf(model,"MG94xGTnR_1x4");
					}
				if (freqNumber == 4 && doOmegaCat == YES && doM1 == NO)
					{
					sprintf(model,"GY94xGTnR_1x4 by categories");
					}
				if (freqNumber == 4 && doOmegaRateHetCont == YES)
					{
					sprintf(model,"GY94xGTnR_1x4 with variable omega by continuous gamma distribution (M5)");
					}
				if (freqNumber == 4 && doOmegaRateHetDisc == YES)
					{
					sprintf(model,"GY94xGTnR_1x4 with variable omega by discrete gamma distribution (M5)");
					}
				}
			}
		else if (doAAmodel == YES)
			{
			if (doFreqGiven == NO || NumberFrequencies < 20)
				{
				fprintf (filep, "\nAmino acid frequencies were not provided by the user:");
				fprintf (filep, "\nFrequencies derived from the empirical model are applied\n");
				}

			if (doBlosum62 == YES)
				{
				sprintf(model," Blosum62");
				}
			if (doCpRev == YES)
				{
				sprintf(model," CpRev");
				}
			if (doDayhoff == YES)
				{
				sprintf(model," Dayhoff");
				}
			if (doDayhoffDCMUT == YES)
				{
				sprintf(model," DayhoffDCMUT");
				}
			if (doHIVb == YES)
				{
				sprintf(model," HIVb");
				}
			if (doHIVw == YES)
				{
				sprintf(model," HIVw");
				}
			if (doJTT == YES)
				{
				sprintf(model," JTT");
				}
			if (doJonesDCMUT == YES)
				{
				sprintf(model," JonesDCMUT");
				}
			if (doLG == YES)
				{
				sprintf(model," LG");
				}
			if (doMtart == YES)
				{
				sprintf(model," Mtart");
				}
			if (doMtmam == YES)
				{
				sprintf(model," Mtmam");
				}
			if (doMtrev24 == YES)
				{
				sprintf(model," Mtrev24");
				}
			if (doRtRev == YES)
				{
				sprintf(model," RtRev");
				}
			if (doVT == YES)
				{
				sprintf(model," VT");
				}
			if (doWAG == YES)
				{
				sprintf(model," WAG");
				}
			if (doEAAMUser == YES)
				{
				fprintf (filep, "\n\nEmpirical amino acid substitution model from input file: %s", AAmodel);
				sprintf(model,"user-given EAM");
				}

			if (doProtStabAAFile == YES)
				{
				fprintf (filep,"\n\nStructural protein stability substitution model:\n");
  				fprintf (filep," PDB file                               = %s\n", FILE_PDB);
  				fprintf (filep," chain                                  = %s\n", chain);
  				fprintf (filep," Contacts matrices file                 = %s\n", FILE_STR);
  				fprintf (filep," Temperature                            = %.2f\n", TEMP);
  				fprintf (filep," Entropy per residue (unfolded)         = %.3f\n", s0);
  				fprintf (filep," Entropy per residue (misfolded)        = %.3f\n", sC1);
  				fprintf (filep," Entropy per residue offset (misfolded) = %.3f\n", sC0);
  				fprintf (filep," Third cumulant in REM calculation      = %d\n", REM3);
				if(NEUTRAL){
				  fprintf (filep," Neutral fitness landscape\n");
				}else{
				  fprintf (filep," Population size (protein level)        = %d\n", N_pop);
				}
				if (doMutationalBranches == YES)
  					fprintf (filep," Branch length by mutations\n");
				else
  					fprintf (filep," Branch length by substitutions\n");

				sprintf (modelS," amino acid - structural protein stability x ");

				if (doBlosum62 == YES)
					sprintf(model,"Blosum62");
				if (doCpRev == YES)
					sprintf(model,"CpRev");
				if (doDayhoff == YES)
					sprintf(model,"Dayhoff");
				if (doDayhoffDCMUT == YES)
					sprintf(model,"DayhoffDCMUT");
				if (doHIVb == YES)
					sprintf(model,"HIVb");
				if (doHIVw == YES)
					sprintf(model,"HIVw");
				if (doJTT == YES)
					sprintf(model,"JTT");
				if (doJonesDCMUT == YES)
					sprintf(model,"JonesDCMUT");
				if (doLG == YES)
					sprintf(model,"LG");
				if (doMtart == YES)
					sprintf(model,"Mtart");
				if (doMtmam == YES)
					sprintf(model,"Mtmam");
				if (doMtrev24 == YES)
					sprintf(model,"Mtrev24");
				if (doRtRev == YES)
					sprintf(model,"RtRev");
				if (doVT == YES)
					sprintf(model,"VT");
				if (doWAG == YES)
					sprintf(model,"WAG");
				if (doEAAMUser == YES)
					{
					fprintf (filep, "\n\nEmpirical amino acid substitution model from input file: %s", AAmodel);
					sprintf(model,"user-given EAM");
					}
				}

			}
		else
			{
			sprintf (modelS," ");
			if (doProtStabDNAFile == YES)
				{
				fprintf (filep,"\n\nStructural protein stability substitution model:\n");
  				fprintf (filep," PDB file                               = %s\n", FILE_PDB);
  				fprintf (filep," chain                                  = %s\n", chain);
  				fprintf (filep," Contacts matrices file                 = %s\n", FILE_STR);
  				fprintf (filep," Temperature                            = %.2f\n", TEMP);
  				fprintf (filep," Entropy per residue (unfolded)         = %.3f\n", s0);
  				fprintf (filep," Entropy per residue (misfolded)        = %.3f\n", sC1);
  				fprintf (filep," Entropy per residue offset (misfolded) = %.3f\n", sC0);
  				fprintf (filep," Third cumulant in REM calculation      = %d\n", REM3);
				if(NEUTRAL){
				  fprintf (filep," Neutral fitness landscape\n");
				}else{
				  fprintf (filep," Population size (protein level)        = %d\n", N_pop);
				}
				if (doMutationalBranches == YES)
  					fprintf (filep," Branch length by mutations\n");
				else
  					fprintf (filep," Branch length by substitutions\n");

				sprintf (modelS," DNA - structural protein stability x ");
			}

			if (doGTR == YES)
				{
				if (p_i[0] == p_i[1] && p_i[0] == p_i[2] && p_i[0] == p_i[3])
					{
					sprintf (model,"SYM");
					}
				else
					sprintf (model,"GTR");
				}
			else if (doGTnR == YES)
				sprintf (model,"GTnR");
			else
				{
				if (equalBaseFreq == YES)
					{
					if (titv == 0.5)
						sprintf (model,"JC");
					else
						sprintf (model,"K80");
					}
				else
					{
					if (titv == 0.5)
						sprintf (model,"F81");
					else
						sprintf (model,"HKY");
					}
				}
			}

		if (doHetVectorFile == NO)
			{
			if (doRateHet == NO && pinv == 0)
				fprintf (filep,"\n\nThese settings correspond to the%s%s%smodel\n", modelS, model, modelB);
			if (doRateHet == NO && pinv != 0)
				fprintf (filep,"\n\nThese settings correspond to the%s%s%s+ I model\n", modelS, model, modelB);
			if (doRateHet == YES && pinv == 0)
				fprintf (filep,"\n\nThese settings correspond to the%s%s%s+ G model\n", modelS, model, modelB);
			if (doRateHet == YES && pinv != 0)
				fprintf (filep,"\n\nThese settings correspond to the%s%s%s+ G + I model\n", modelS, model, modelB);
			}
		else
			{
			if (doRateHet == NO && pinv == 0)
				fprintf (filep,"\n\nThese settings correspond to the%s%s%s+ heterogeneity by rates vector model\n", modelS, model, modelB);
			if (doRateHet == NO && pinv != 0)
				fprintf (filep,"\n\nThese settings correspond to the%s%s%s+ I + heterogeneity by rates vector model\n", modelS, model, modelB);
			if (doRateHet == YES && pinv == 0)
				fprintf (filep,"\n\nThese settings correspond to the%s%s%s+ G + heterogeneity by rates vector model\n", modelS, model, modelB);
			if (doRateHet == YES && pinv != 0)
				fprintf (filep,"\n\nThese settings correspond to the%s%s%s+ G + I + heterogeneity by rates vector model\n", modelS, model, modelB);
			}

	#ifdef MPI
			}
	#endif
	}







/******************** ReadParametersFromCommandLine *************************/
static void ReadParametersFromCommandLine (int argc,char **argv)
{
	int		i, j, k, h, l, modelNumber, RatesNumber;
	char	flagb, ch;
	int		to, from; 
 	float	argument;
	double	sumPi, sumPi_b, sumPi_Cod_first, sumPi_Cod_second, sumPi_Cod_third, sumPi_AA;
	int		sumPopul, yesHere, GrowthRate_or_DemographicPeriods;
	
	modelNumber = -1;
	yesHere = 0;
	GrowthRate_or_DemographicPeriods = -1;
	strcpy(alignmentFile, "sequences");
	
	for (i=1; i<argc; i++)
	{
		argv[i]++;
		flagb=*argv[i];
		argv[i]++;
		argument = -9999;
		

	/* Used: A B C D E F G H I J K L N M O P R S T U V W X Y Z ? # @ % $ * + = / _       next ideas _ l */

	   switch (toupper(flagb))
			{
			case '#':
				argument = atof(argv[i]);
				userSeed = (int) argument;
				if (userSeed < 0) 
					{
					fprintf (stderr, "PARAMETER ERROR: Bad user seed for random number (%lu bytes)\n\n", userSeed);
					PrintUsage();
					}
			break;
			case 'S':
				argument = atof(argv[i]);
				numSequences = (int) argument;
				if (numSequences < 1)
				 	{
					fprintf (stderr, "PARAMETER ERROR: Bad sample size (s) (%d)\n\n", numSequences);
					PrintUsage();
					}
				
				argument = atof(argv[++i]);
				numSites = (int) argument;
				if (numSites<1) 
					{
					fprintf (stderr, "PARAMETER ERROR: Bad number of sites (s) (%d)\n\n", numSites);
					PrintUsage();
					}
			break;
			case 'L':

				argument = atof(argv[i]);
				BBmodelNumber = (int) argument;
				if (BBmodelNumber < 1 || BBmodelNumber > 4)
				 	{
					fprintf (stderr, "PARAMETER ERROR: molde number (l, between 0-4) (%d)\n\n", BBmodelNumber);
					PrintUsage();
					}

				doVariableDnDsBranches = YES;
				

				sumPi = sumPi_b = 0.0;
				if (BBmodelNumber == 1) /* categories from the user */
					{
					doBBM0 = YES;

					argument = atof(argv[++i]);
					BBnumOmegaCat = (int) argument;
					if (BBnumOmegaCat<1) 
						{
						fprintf (stderr, "PARAMETER ERROR: Bad number of categories (l) (%d)\n\n", BBnumOmegaCat);
						PrintUsage();
						}

					BBomegaVal = (double *) calloc((BBnumOmegaCat+1),(long) sizeof(double));
					if (!BBomegaVal)
						{
						fprintf (stderr, "PARAMETER ERROR: Could not allocate omega values of categories (-l) (%lu bytes)\n", BBnumOmegaCat *(long) sizeof(double));
						exit (1);
						}
					BBomegaProb = (double *) calloc((BBnumOmegaCat+1),(long) sizeof(double));
					if (!BBomegaProb)
						{
						fprintf (stderr, "PARAMETER ERROR: Could not allocate omega probabilities of categories1 (-l) (%lu bytes)\n", BBnumOmegaCat *(long) sizeof(double));
						exit (1);
						}
					for (j=1; j<=BBnumOmegaCat; j++)
						{
						argument = atof(argv[++i]);
						BBomegaVal[j] = (double) argument;
						
						argument = atof(argv[++i]);
						BBomegaProb[j] = (double) argument;


						if (BBomegaProb[j] > 1 || BBomegaProb[j] < 0)
							{
							fprintf (stderr, "PARAMETER ERROR: Bad number of probabilities of omega categories2 (%3.2f)\n\n", BBomegaProb[j]);
							PrintUsage();
							}
						sumPi = sumPi + BBomegaProb[j];
						}
					if (sumPi != 1) /* update probabilities of categories */
						{
						if (BBnumOmegaCat == 1)
							BBomegaProb[1] = 1.0;
						else
							{
							for (j=1; j<=BBnumOmegaCat; j++)
								{
								BBomegaProb[j]/=sumPi;
								sumPi_b = sumPi_b + BBomegaProb[j];
								}
							if ((int)sumPi_b != 1)
								{
								fprintf (stderr, "\n ERROR in the sum of probabilities of omega categories (-l) \n");
								exit (-1);
								}
							}
						}
					}
				else if (BBmodelNumber == 2) /* gamma distribution */
					{
					doBBM0 = YES;					

					argument = atof(argv[++i]);
					BBOmegaRateHet = (double) argument;
					argument = atof(argv[++i]);
					BBomega = (double) argument;

					if (BBOmegaRateHet <= 0.0)
						{
						fprintf (stderr, "PARAMETER ERROR: Bad heterogeneous rate (%3.2f)\n\n", BBOmegaRateHet);
						PrintUsage();
						}
					if (BBomega < 0.0)
						{
						fprintf (stderr, "PARAMETER ERROR: Bad heterogeneous rate (%3.2f)\n\n", BBomega);
						PrintUsage();
						}
					BBOmegaInit = BBomega;
					}
				else if (BBmodelNumber == 3) /* beta distribution */
					{
					doBBM0 = YES;				

					argument = atof(argv[++i]);
					BBM7_p_beta = (double) argument;
					argument = atof(argv[++i]);
					BBM7_q_beta = (double) argument;


					if (BBM7_p_beta < 0.0)
						{
						fprintf (stderr, "PARAMETER ERROR: Bad p in beta distribution (%3.2f)\n\n", BBM7_p_beta);
						PrintUsage();
						}
					
					if (BBM7_q_beta < 0.0)
						{
						fprintf (stderr, "PARAMETER ERROR: Bad q in beta distribution (%3.2f)\n\n", BBM7_q_beta);
						PrintUsage();
						}
					}
				else if (BBmodelNumber == 4) /* Heterogeneous codon models */
					{
					doBBM0 = NO;
					}
				else
					{
					fprintf(stderr, "PARAMETER ERROR: Bad effective dN/dS variation per branch (-l between 1 and 4) (%d) \n\n", BBmodelNumber);
					PrintUsage();
					}

			break;
			case 'E':
				argument = atof(argv[i]);
				N = (int) argument;
				if (N < 1) 
					{
					fprintf (stderr, "PARAMETER ERROR: Bad effective population size (e) (%d)\n\n", N);
					PrintUsage();
					}

				argument = atof(argv[++i]);
				Nscaling = (int) argument;
				if (Nscaling > 10 || Nscaling < 1) /* max 10 */
					{
					fprintf (stderr, "PARAMETER ERROR: Bad  haplid/diploid chosen (e) (%d)\n\n", Nscaling);
					PrintUsage();
					}
				if (Nscaling < 1 || Nscaling > 2)
					{
					fprintf (stderr, "PARAMETER ERROR: Haploid/diplod option (1-2) (e) (%d)\n\n", Nscaling);
					PrintUsage();
					}
			break;		
			case '=':
				doDatedTips = YES;
	        	argument = atof(argv[i]);
				numTipDates = (int) argument;
				if (numTipDates <= 0) 
					{
					fprintf (stderr, "COMMAND-LINE PARAMETER ERROR: Bad number of sampling dates (%d)\n\n", numTipDates);
					PrintUsage();
					}
				
				datedSample = 	(SampleSt *) calloc(numTipDates, sizeof(SampleSt));
				if (datedSample == NULL)
					{
					fprintf (stderr, "COMMAND-LINE PARAMETER ERROR: Could not allocate sampling dates vectors (%ld)\n", numTipDates * (long) sizeof(SampleSt));
					exit (1);
					}
	
				for (j=0; j<numTipDates; j++)
					{
					argument = atof(argv[++i]);
	        		datedSample[j].time = (float) argument;
					argument = atof(argv[++i]);
        			from = (int) argument;
					argument = atof(argv[++i]);
        			to = (int) argument;
	
					datedSample[j].member = 	(int *) calloc(to-from+1, sizeof(SampleSt));
					if (datedSample[j].member == NULL)
						{
						fprintf (stderr, "COMMAND-LINE PARAMETER ERROR: Could not allocate sampling dates vector[j=%d] (%ld)\n",j, to-from+1 * (long) sizeof(int));
						exit (1);
						}
			
					l = 0;
					for (k=from; k<=to; k++)
						datedSample[j].member[l++] = k;
					
					datedSample[j].size = l;
					}
			break;
			case '/':
				generationTime = atof(argv[i]);
				if (generationTime < 0) 
					{
					fprintf (stderr, "COMMAND-LINE PARAMETER ERROR: Bad generation time (%f)\n\n", generationTime);
					PrintUsage();
					}
			break;
			case 'R':
	        	recombinationRate = atof(argv[i]);
				if (recombinationRate < 0) 
					{
					fprintf (stderr, "PARAMETER ERROR: Bad recombination rate (%f)\n\n", recombinationRate );
					PrintUsage();
					}
			break;
			case 'U':
	        	mutationRate = atof(argv[i]);
				if (mutationRate < 0) 
					{
					fprintf (stderr, "PARAMETER ERROR: Bad mutation rate (%f)\n\n", mutationRate);
					PrintUsage();
					}
			break;

			case '_':
				ch = *argv[i];
				if(isspace(ch))
					strcpy(HetVectorFile, "HetRatesVector");
				else
					strcpy(HetVectorFile,argv[i]);
		
			doHetVectorFile = YES;
			/*fprintf(stderr, "\n Setting for Heterogeneity by a user-defined vector: \"%s\" \n\n", HetVectorFile);*/
			break;

/*			case '_':
				ch = *argv[i];
				if(isspace(ch))
					strcpy(GY94xAAmodel, "GY94xAAmodel00");
				else
					strcpy(GY94xAAmodel,argv[i]);*/
				
				/* doGY94xBlosum62 doGY94xCpRev doGY94xDayhoff doGY94xDayhoffDCMUT doGY94xHIVb doGY94xHIVw doGY94xJTT doGY94xJonesDCMUT doGY94xLG doGY94xMtart doGY94xMtmam doGY94xMtrev24 
					doGY94xRtRev doGY94xVT doGY94xWAG doGY94xEAAMUser */

/*				if (GY94xAAmodel[0] == 'B' && GY94xAAmodel[1] == 'l' && GY94xAAmodel[2] == 'o' && GY94xAAmodel[3] == 's' && GY94xAAmodel[4] == 'u' && GY94xAAmodel[5] == 'm' && GY94xAAmodel[6] == '6' && GY94xAAmodel[7] == '2')
					{
					doGY94xBlosum62 = YES;
					}
				else if (GY94xAAmodel[0] == 'C' && GY94xAAmodel[1] == 'p' && GY94xAAmodel[2] == 'R' && GY94xAAmodel[3] == 'e' && GY94xAAmodel[4] == 'v')
					{
					doGY94xCpRev = YES;
					}
				else if (GY94xAAmodel[0] == 'D' && GY94xAAmodel[1] == 'a' && GY94xAAmodel[2] == 'y' && GY94xAAmodel[3] == 'h' && GY94xAAmodel[4] == 'o' && GY94xAAmodel[5] == 'f' && GY94xAAmodel[6] == 'f'&& GY94xAAmodel[7] == 'D' && GY94xAAmodel[8] == 'C' && GY94xAAmodel[9] == 'M' && GY94xAAmodel[10] == 'U' && GY94xAAmodel[11] == 'T')
					{
					doGY94xDayhoffDCMUT = YES;
					}
				else if (GY94xAAmodel[0] == 'D' && GY94xAAmodel[1] == 'a' && GY94xAAmodel[2] == 'y' && GY94xAAmodel[3] == 'h' && GY94xAAmodel[4] == 'o' && GY94xAAmodel[5] == 'f' && GY94xAAmodel[6] == 'f' && doGY94xDayhoffDCMUT == NO)
					{
					doGY94xDayhoff = YES;
					}
				else if (GY94xAAmodel[0] == 'H' && GY94xAAmodel[1] == 'I' && GY94xAAmodel[2] == 'V' && GY94xAAmodel[3] == 'b')
					{
					doGY94xHIVb = YES;
					}
				else if (GY94xAAmodel[0] == 'H' && GY94xAAmodel[1] == 'I' && GY94xAAmodel[2] == 'V' && GY94xAAmodel[3] == 'w')
					{
					doGY94xHIVw = YES;
					}
				else if (GY94xAAmodel[0] == 'J' && GY94xAAmodel[1] == 'T' && GY94xAAmodel[2] == 'T')
					{
					doGY94xJTT = YES;
					}
				else if (GY94xAAmodel[0] == 'J' && GY94xAAmodel[1] == 'o' && GY94xAAmodel[2] == 'n' && GY94xAAmodel[3] == 'e' && GY94xAAmodel[4] == 's' && GY94xAAmodel[5] == 'D' && GY94xAAmodel[6] == 'C' && GY94xAAmodel[7] == 'M' && GY94xAAmodel[8] == 'U' && GY94xAAmodel[9] == 'T')
					{
					doGY94xJonesDCMUT = YES;
					}
				else if (GY94xAAmodel[0] == 'L' && GY94xAAmodel[1] == 'G')
					{
					doGY94xLG = YES;
					}
				else if (GY94xAAmodel[0] == 'M' && GY94xAAmodel[1] == 't' && GY94xAAmodel[2] == 'a' && GY94xAAmodel[3] == 'r' && GY94xAAmodel[4] == 't')
					{
					doGY94xMtart = YES;
					}
				else if (GY94xAAmodel[0] == 'M' && GY94xAAmodel[1] == 't' && GY94xAAmodel[2] == 'm' && GY94xAAmodel[3] == 'a' && GY94xAAmodel[4] == 'm')
					{
					doGY94xMtmam = YES;
					}
				else if (GY94xAAmodel[0] == 'M' && GY94xAAmodel[1] == 't' && GY94xAAmodel[2] == 'r' && GY94xAAmodel[3] == 'e' && GY94xAAmodel[4] == 'v' && GY94xAAmodel[5] == '2' && GY94xAAmodel[6] == '4')
					{
					doGY94xMtrev24 = YES;
					}
				else if (GY94xAAmodel[0] == 'R' && GY94xAAmodel[1] == 't' && GY94xAAmodel[2] == 'R' && GY94xAAmodel[3] == 'e' && GY94xAAmodel[4] == 'v')
					{
					doGY94xRtRev = YES;
					}
				else if (GY94xAAmodel[0] == 'V' && GY94xAAmodel[1] == 'T')
					{
					doGY94xVT = YES;
					}
				else if (GY94xAAmodel[0] == 'W' && GY94xAAmodel[1] == 'A' && GY94xAAmodel[2] == 'G')
					{
					doGY94xWAG = YES;
					}
				else*/ /* this should mean the user introduces a particular AA matrix by an input file */
/*					{
					doGY94xEAAMUser = YES;
					}*/
				/* fprintf(stderr, "\n AA matrix selected for GY94 codon model is \"%s\" \n\n", GY94xAAmodel);*/
/*			break;*/

			case 'M':
				ch = *argv[i];
				if(isspace(ch))
					strcpy(ProtStabDNAFile, "Pop_evol.in");
				else
					strcpy(ProtStabDNAFile,argv[i]);
		
			doProtStabDNAFile = YES;
			/*fprintf(stderr, "\n Setting for Structural protein stability file (DNA) selected: \"%s\" \n\n", ProtStabDNAFile);*/
			break;

//			case 'M':
				/*doCodonModel = YES;*/
//				sumPi = sumPi_b = 0.0;
//				
//				modelNumber = atof(argv[i]);
//				if (modelNumber > 10 || modelNumber < 0) /* max 10 categories */
//					{
//					fprintf (stderr, "PARAMETER ERROR: Bad model chosen (1-10) (%d)\n\n", modelNumber);
//					PrintUsage();
//					}
//				
//				if (modelNumber == 1)		/** omega constant **/
//					{
//					doOmegaCat = NO;
//					doOmegaRateHetCont = NO;
//					doOmegaRateHetDisc = NO;
//					doM0 = YES;					
//
//					argument = atof(argv[++i]);
//					omega = (double) argument;
//					if (omega < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad omega (%3.2f)\n\n", omega);
//						PrintUsage();
//						}
//					OmegaInit = omega;
//					}
//				else if (modelNumber == 2) /** omega by categories from the user **/
//					{					
//					argument = atof(argv[++i]);
//					numOmegaCat = (int) argument;
//					if (numOmegaCat < 0 || numOmegaCat > 10) /* max 10 categories */
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad number of omega categories (%d)\n\n", numOmegaCat);
//						PrintUsage();
//						}
//					omegaVal = (double *) calloc((numOmegaCat+1),(long) sizeof(double));
//					if (!omegaVal)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Could not allocate omega values of categories (%lu bytes)\n", numOmegaCat *(long) sizeof(double));
//						exit (1);
//						}
//					omegaProb = (double *) calloc((numOmegaCat+1),(long) sizeof(double));
//					if (!omegaProb)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Could not allocate omega probabilities of categories1 (%lu bytes)\n", numOmegaCat *(long) sizeof(double));
//						exit (1);
//						}
//						
//					for (j=1; j<=numOmegaCat; j++)
//						{
//						argument = atof(argv[++i]);
//						omegaVal[j] = (double) argument;
//						
//						argument = atof(argv[++i]);
//						omegaProb[j] = (double) argument;
//						
//						if (omegaProb[j] > 1)
//							{
//							fprintf (stderr, "PARAMETER ERROR: Bad number of probabilities of omega categories (%lf)\n\n", omegaProb[j]);
//							PrintUsage();
//							}
//						
//						sumPi = sumPi + omegaProb[j];
//						}						
//					if (sumPi != 1) /* update probabilities of categories */
//						{
//						if (numOmegaCat == 1)
//							omegaProb[1] = 1.0;
//						else
//							{
//							for (j=1; j<=numOmegaCat; j++)
//								{
//								omegaProb[j]/=sumPi;
//								sumPi_b = sumPi_b + omegaProb[j];
//								}
//							if ((int)sumPi_b != 1)
//								{
//								fprintf (stderr, "\n ERROR in the sum of probabilities of omega categories");
//								exit (-1);
//								}
//							}
//						}
//					doOmegaCat = YES;
//					doOmegaProb = YES;
//					doOmegaRateHetCont = NO;
//					doOmegaRateHetDisc = NO;
//					}
//				else if (modelNumber == 3) /** M1 **/
//					{
//					doM1 = YES;	
//
//					/*doOmegaCat = NO;*/
//					doOmegaRateHetCont = NO;
//					doOmegaRateHetDisc = NO;
//					
//					argument = atof(argv[++i]);
//					M1_P0_omeg0 = (double) argument;
//					if (M1_P0_omeg0 < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad P0 in model M1 (%3.2f)\n\n", M1_P0_omeg0);
//						PrintUsage();
//						}
//
//					argument = atof(argv[++i]);
//					M1_omega0 = (double) argument;
//					if (M1_omega0 < 0.0 || M1_omega0 > 1)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad omega in M1 (%3.2f)\n\n", M1_omega0);
//						PrintUsage();
//						}
//					
//
//					M1_P1_omeg1 = 1 - M1_P0_omeg0;
//
//					doOmegaCat = YES;
//					numOmegaCat = 2;
//
//					omegaVal = (double *) calloc((numOmegaCat+1),(long) sizeof(double));
//					if (!omegaVal)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Could not allocate omega values of categories (%lu bytes)\n", numOmegaCat *(long) sizeof(double));
//						exit (1);
//						}
//					omegaProb = (double *) calloc((numOmegaCat+1),(long) sizeof(double));
//					if (!omegaProb)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Could not allocate omega probabilities of categories1 (%lu bytes)\n", numOmegaCat *(long) sizeof(double));
//						exit (1);
//						}
//
//					omegaProb[1] = M1_P0_omeg0;
//					omegaProb[2] = M1_P1_omeg1;
//					omegaVal[1] = M1_omega0;
//					omegaVal[2] = 1.0;
//					}
//				else if (modelNumber == 4) /** omega by discrete gamma heterogeneous rate **/ /* max 10 categories */
//					{
//					argument = atof(argv[++i]);
//					numOmegaCat = (int) argument;
//					if (numOmegaCat < 0 || numOmegaCat > 10) 
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad number of omega categories (%d)\n\n", numOmegaCat);
//						PrintUsage();
//						}
//					argument = atof(argv[++i]);
//					OmegaRateHet = (double) argument;
//					if (OmegaRateHet <= 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad omega heterogeneous rate (%3.2f)\n\n", OmegaRateHet);
//						PrintUsage();
//						}
//					argument = atof(argv[++i]);
//					omega = (double) argument;
//					if (omega < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad omega (%3.2f)\n\n", omega);
//						PrintUsage();
//						}
//					OmegaInit = omega;
//					
//					doOmegaCat = NO;
//					doOmegaRateHetCont = NO;
//					doOmegaRateHetDisc = YES;
//					}
//				else if (modelNumber == 5) /** omega by continuous gamma heterogeneous rate **/
//					{
//					doOmegaCat = NO;
//					doOmegaRateHetCont = YES;
//					doOmegaRateHetDisc = NO;
//					
//					argument = atof(argv[++i]);
//					OmegaRateHet = (double) argument;
//					if (OmegaRateHet <= 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad omega heterogeneous rate (%3.2f)\n\n", OmegaRateHet);
//						PrintUsage();
//						}
//					argument = atof(argv[++i]);
//					omega = (double) argument;
//					if (omega < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad omega (%3.2f)\n\n", omega);
//						PrintUsage();
//						}
//					OmegaInit = omega;
//					}
//				else if (modelNumber == 6) /** M6 model (cont 2gamma): p0 p q, w **/
//					{
//					/* MIGUEL: esta en input from command line? */
//					doM6 = YES;
//	
//					doOmegaCat = NO;
//					doOmegaRateHetCont = NO;
//					doOmegaRateHetDisc = NO;
//				
//					argument = atof(argv[++i]);
//					M6_P0 = (double) argument;
//					if (M6_P0 < 0.0 || M6_P0 > 1.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad P0 in model M6 (%3.2f)\n\n", M6_P0);
//						PrintUsage();
//						}
//					M6_P1 = 1 - M6_P0;
//					
//					argument = atof(argv[++i]);
//					OmegaRateHetM6_0 = (double) argument;
//					if (OmegaRateHetM6_0 <= 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad omega heterogeneous rate(0) in M6 (%3.2f)\n\n", OmegaRateHetM6_0);
//						PrintUsage();
//						}
//				
//					argument = atof(argv[++i]);
//					OmegaM6_0 = (double) argument;
//					if (OmegaM6_0 < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad omega(0) in M6 (%3.2f)\n\n", OmegaM6_0);
//						PrintUsage();
//						}
//
//					argument = atof(argv[++i]);
//					OmegaRateHetM6_1 = (double) argument;
//					if (OmegaRateHetM6_1 <= 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad omega heterogeneous rate(1) in M6 (%3.2f)\n\n", OmegaRateHetM6_1);
//						PrintUsage();
//						}
//					OmegaM6_1 = OmegaRateHetM6_1; /* because in M6 codon model the second gamma distribution has p=q */
//
//
//					OmegaInitM6_0 = OmegaM6_0;
//					OmegaInitM6_1 = OmegaM6_1;
//					/* M6_P0, M6_P1; OmegaRateHetM6_0 OmegaM6_0 OmegaInitM6_0; OmegaRateHetM6_1 OmegaM6_1 OmegaInitM6_1 */
//					}
//				else if (modelNumber == 7) /** M7 **/
//					{
//					doM7 = YES;
//
//					doOmegaCat = NO;
//					doOmegaRateHetCont = NO;
//					doOmegaRateHetDisc = NO;
//				
//					argument = atof(argv[++i]);
//					M7_p_beta = (double) argument;
//					if (M7_p_beta < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad p in model M7 (%3.2f)\n\n", M7_p_beta);
//						PrintUsage();
//						}
//					
//					argument = atof(argv[++i]);
//					M7_q_beta = (double) argument;
//					if (M7_q_beta < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad q in model M7 (%3.2f)\n\n", M7_q_beta);
//						PrintUsage();
//						}
//
//					}
//				else if (modelNumber == 8) /** M8 **/
//					{
//					doM8 = YES;
//
//					doOmegaCat = NO;
//					doOmegaRateHetCont = NO;
//					doOmegaRateHetDisc = NO;
//
//					argument = atof(argv[++i]);
//					M8_P0_beta = (double) argument;
//					if (M8_P0_beta < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad P0 in model M8 (%3.2f)\n\n", M8_P0_beta);
//						PrintUsage();
//						}
//					M8_P1_omega = 1 - M8_P0_beta;
//
//					argument = atof(argv[++i]);
//					M8_p_beta = (double) argument;
//					if (M8_p_beta < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad p in model M8 (%3.2f)\n\n", M8_p_beta);
//						PrintUsage();
//						}
//					
//					argument = atof(argv[++i]);
//					M8_q_beta = (double) argument;
//					if (M8_q_beta < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad q in model M8 (%3.2f)\n\n", M8_q_beta);
//						PrintUsage();
//						}
//				
//					argument = atof(argv[++i]);
//					M8_omegaP1 = (double) argument;
//					if (M8_omegaP1 < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad omega for P1 in model M8 (%3.2f)\n\n", M8_omegaP1);
//						PrintUsage();
//						}
//					}
//				else if (modelNumber == 9 || modelNumber == 10) /** M9 - M10 **/
//					{ /* [M9 or M10 models: p0 p q; a b] */
//
//					if (modelNumber == 9)
//						doM9 = YES;
//					else if (modelNumber == 10)
//						doM10 = YES;
//					else
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad codon model chosen (9-10) (%d) in parameters File\n\n", modelNumber);
//						PrintUsage();
//						}
//
//					doOmegaCat = NO;
//					doOmegaRateHetCont = NO;
//					doOmegaRateHetDisc = NO;
//				
//					argument = atof(argv[++i]);
//					M910_P0 = (double) argument;
//					if (M910_P0 < 0.0 || M910_P0 > 1.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad P0 in codon model M9 or M10 (%3.2f)\n\n", M910_P0);
//						PrintUsage();
//						}
//					M910_P1 = 1 - M910_P0;
//					
//					/* beta */
//					argument = atof(argv[++i]);
//					M910_p_beta = (double) argument;
//					if (M910_p_beta < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad p in model M9 or M10 (%3.2f)\n\n", M910_p_beta);
//						PrintUsage();
//						}
//					
//					argument = atof(argv[++i]);
//					M910_q_beta = (double) argument;
//					if (M910_q_beta < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad q in model M9 or M10 (%3.2f)\n\n", M910_q_beta);
//						PrintUsage();
//						}
//
//					/* gamma */
//					argument = atof(argv[++i]);
//					OmegaRateHetM910_1 = (double) argument;
//					if (OmegaRateHetM910_1 <= 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad omega heterogeneous rate in M9 or M10 (%3.2f)\n\n", OmegaRateHetM910_1);
//						PrintUsage();
//						}
//
//					argument = atof(argv[++i]);
//					OmegaM910_1 = (double) argument;
//					if (OmegaM910_1 < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad omega in M9 or M10 (%3.2f)\n\n", OmegaM910_1);
//						PrintUsage();
//						}
//					
//					OmegaInitM910_1 = OmegaM910_1;
//					/* M910_P0, M910_P1; M910_p_beta M910_q_beta; OmegaRateHetM910_1 OmegaM910_1 OmegaInitM910_1 */
//					}
//				else if (modelNumber == 0) /** MG94 codon model **/
//					{
//					doMG94 = YES;
//
//					doOmegaCat = NO;
//					doOmegaRateHetCont = NO;
//					doOmegaRateHetDisc = NO;
//				
//					argument = atof(argv[++i]);
//					SynRate = (double) argument;
//					if (SynRate < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad synonymous rate in MG94 model (%3.2f)\n\n", SynRate);
//						PrintUsage();
//						}
//					
//					argument = atof(argv[++i]);
//					NonSynRate = (double) argument;
//					if (NonSynRate < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad non-synonymous rate in MG94 model (%3.2f)\n\n", NonSynRate);
//						PrintUsage();
//						}
//					}
//				else
//					{
//					fprintf (stderr, "PARAMETER ERROR: Bad model chosen (0-10) (%d)\n\n", (int) argument);
//					PrintUsage();
//					}
//				sumPi = sumPi_b = 0.0;
//			break;
			case 'F':
				freqNumber = atof(argv[i]);

				doFreqGiven = YES;

				if (freqNumber == 4)
					{
					p_i[0] = atof(argv[++i]);
					p_i[1] = atof(argv[++i]);
					p_i[2] = atof(argv[++i]);
					p_i[3] = atof(argv[++i]);

					if ((p_i[0] == p_i[1]) && (p_i[1] == p_i[2]) && (p_i[2] == p_i[3]))
						equalBaseFreq = YES;
					else
						equalBaseFreq = NO;
					
					sumPi = p_i[0] + p_i[1] + p_i[2] + p_i[3];
					if (sumPi !=1.0) 
						{
						p_i[0]/=sumPi;
						p_i[1]/=sumPi;
						p_i[2]/=sumPi;
						p_i[3]/=sumPi;
						}
					
					p_i_codon[0]=p_i[0];
					p_i_codon[1]=p_i[1];
					p_i_codon[2]=p_i[2];
					p_i_codon[3]=p_i[3];
					p_i_codon[4]=p_i[0];
					p_i_codon[5]=p_i[1];
					p_i_codon[6]=p_i[2];
					p_i_codon[7]=p_i[3];
					p_i_codon[8]=p_i[0];
					p_i_codon[9]=p_i[1];
					p_i_codon[10]=p_i[2];
					p_i_codon[11]=p_i[3];

					NumberFrequencies = 4;					
					}
				else if (freqNumber == 12)
					{
					p_i_codon[0] = atof(argv[++i]);
					p_i_codon[1] = atof(argv[++i]);
					p_i_codon[2] = atof(argv[++i]);
					p_i_codon[3] = atof(argv[++i]);
					
					p_i_codon[4] = atof(argv[++i]);
					p_i_codon[5] = atof(argv[++i]);
					p_i_codon[6] = atof(argv[++i]);
					p_i_codon[7] = atof(argv[++i]);
					
					p_i_codon[8] = atof(argv[++i]);
					p_i_codon[9] = atof(argv[++i]);
					p_i_codon[10] = atof(argv[++i]);
					p_i_codon[11] = atof(argv[++i]);
					
					
						
					for (k = 0; k < 12; k++)
						if (p_i_codon[k] < 0 || p_i_codon[k] > 1)
							{
							fprintf (stderr, "PARAMETER ERROR: Bad number of enter frequencies (it must to be between 0 and 1) (%lf)\n\n", p_i_codon[i]);
							PrintUsage();
							}
					equalBaseFreqCod = YES;
					for (k = 1; k < 12; k++)		
						if (p_i_codon[k] != p_i_codon[k-1])
							{
							equalBaseFreqCod = NO;
							break;
							}		
					
					sumPi_Cod_first = p_i_codon[0] + p_i_codon[1] + p_i_codon[2] + p_i_codon[3];
					sumPi_Cod_second = p_i_codon[4] + p_i_codon[5] + p_i_codon[6] + p_i_codon[7];
					sumPi_Cod_third = p_i_codon[8] + p_i_codon[9] + p_i_codon[10] + p_i_codon[11];
					if (sumPi_Cod_first != 1.0) 
						{
						p_i_codon[0]/=sumPi_Cod_first;
						p_i_codon[1]/=sumPi_Cod_first;
						p_i_codon[2]/=sumPi_Cod_first;
						p_i_codon[3]/=sumPi_Cod_first;
						}
					if (sumPi_Cod_second != 1.0) 
						{
						p_i_codon[4]/=sumPi_Cod_second;
						p_i_codon[5]/=sumPi_Cod_second;
						p_i_codon[6]/=sumPi_Cod_second;
						p_i_codon[7]/=sumPi_Cod_second;
						}
					if (sumPi_Cod_third != 1.0) 
						{
						p_i_codon[8]/=sumPi_Cod_third;
						p_i_codon[9]/=sumPi_Cod_third;
						p_i_codon[10]/=sumPi_Cod_third;
						p_i_codon[11]/=sumPi_Cod_third;
						}

					NumberFrequencies = 12;	
					}
				else if (freqNumber == 20) /* amino acid model: p_i_aa */
					{
					
					p_i_aa[0] = atof(argv[++i]);
					p_i_aa[1] = atof(argv[++i]);
					p_i_aa[2] = atof(argv[++i]);
					p_i_aa[3] = atof(argv[++i]);
					p_i_aa[4] = atof(argv[++i]);
					p_i_aa[5] = atof(argv[++i]);
					p_i_aa[6] = atof(argv[++i]);
					p_i_aa[7] = atof(argv[++i]);
					p_i_aa[8] = atof(argv[++i]);
					p_i_aa[9] = atof(argv[++i]);
					p_i_aa[10] = atof(argv[++i]);
					p_i_aa[11] = atof(argv[++i]);
					p_i_aa[12] = atof(argv[++i]); 
					p_i_aa[13] = atof(argv[++i]);
					p_i_aa[14] = atof(argv[++i]);
					p_i_aa[15] = atof(argv[++i]);
					p_i_aa[16] = atof(argv[++i]);
					p_i_aa[17] = atof(argv[++i]);
					p_i_aa[18] = atof(argv[++i]);
					p_i_aa[19] = atof(argv[++i]); 
					
					/* do not use variable i, now use k!!!  */
					if (freqNumber != 20)
						{
						fprintf (stderr, "PARAMETER ERROR: Bad parameter from frequencies. (-p) must me only used with (-f20) \n");
						fprintf (stderr, "In case you are already simulating amino acid sequences, try to introduce the argument -f before the argument -p. \n\n");
						PrintUsage();
						}

					for (k = 0; k < 20; k++)
						if (p_i_aa[k] < 0 || p_i_aa[k] > 1)
							{
							fprintf (stderr, "PARAMETER ERROR: Bad number of enter frequencies (it must to be between 0 and 1) (%lf)\n\n", p_i_aa[k]);
							PrintUsage();
							}

					equalBaseFreqAA = YES;
					for (k = 1; k < 20; k++)		
						if (p_i_aa[k] != p_i_aa[k-1])
							{
							equalBaseFreqAA = NO;
							break;
							}		

					sumPi_AA = 0.0;
					for (k = 0; k < 20; k++)
						{
						sumPi_AA = sumPi_AA + p_i_aa[k];
						}
					
					if (sumPi_AA != 1.0) 
						{
						for (k = 0; k < 20; k++)
							{
							p_i_aa[k]/=sumPi_AA;
							}
						}					
										
					NumberFrequencies = 20;
					/*fprintf (stderr, "\n valueInit (%lf), valueEnd (%lf) \n\n", p_i_aa[0], p_i_aa[9]);*/	
					}
				else
					{
					fprintf (stderr, "PARAMETER ERROR: Bad number of frequencies (4, 12 or 20) (%d)\n\n", freqNumber);
					PrintUsage();
					}
			break;
			case 'P':
				ch = *argv[i];
				if(isspace(ch))
					strcpy(treeFileName, "treefile");
				else
					strcpy(treeFileName,argv[i]);

				doGivenUserTrees = YES;
				/* fprintf(stderr, "\n Trees from the user \"%s\" \n\n", treeFileName);*/
			break;
			case 'V':
				RatesNumber = atof(argv[i]);
				if (RatesNumber != 1 && RatesNumber != 6 && RatesNumber != 12)
					{
					fprintf (stderr, "PARAMETER ERROR: Bad rates of change (-v) (1, 6, 12) (%d)\n\n", RatesNumber);
					PrintUsage();
					}
				

				if (RatesNumber == 1)
					{	
					titv = atof(argv[++i]);
					if (titv < 0) 
						{
						fprintf (stderr, "PARAMETER ERROR: Bad ti/tv (%f)\n\n", titv);
						PrintUsage();
						}
					/*else
						{
						if (doCodonModel == NO)
							doHKY = YES;
						else
							{
							doCodon_HKY = YES;
							doCodon_GTR = NO;
							doCodon_NGTR = NO;
							}
						}*/
					}
				else if (RatesNumber == 6)
					{	
		        	Rmat[0] = atof(argv[++i]);
		        	Rmat[1] = atof(argv[++i]);
	    	    	Rmat[2] = atof(argv[++i]);
	        		Rmat[3] = atof(argv[++i]);
	        		Rmat[4] = atof(argv[++i]);
	       		 	Rmat[5] = atof(argv[++i]);
					if (Rmat[5]!=1.0) 
						{
						for (j=0; j<5; j++) 
							Rmat[j]/=Rmat[5];
						Rmat[5]=1.0;
						}
					/*doGTR = YES;
					doHKY = NO;
					doGTnR = NO;
					if (doCodonModel == YES)
						{
						doGTR = NO;
						doHKY = NO;
						doCodon_GTR = YES;
						doCodon_HKY = NO;
						doCodon_NGTR = NO;
						}*/
					}
				else if (RatesNumber == 12) /* AC CA AG GA AT TA CG GC CT TC GT=1 TG */
					{	
					NRmat[0] = atof(argv[++i]);
		        	NRmat[1] = atof(argv[++i]);
		        	NRmat[2] = atof(argv[++i]);
	    	    	NRmat[3] = atof(argv[++i]);
	        		NRmat[4] = atof(argv[++i]);
	        		NRmat[5] = atof(argv[++i]);
		        	NRmat[6] = atof(argv[++i]);
		        	NRmat[7] = atof(argv[++i]);
	    	    	NRmat[8] = atof(argv[++i]);
	        		NRmat[9] = atof(argv[++i]);
		        	NRmat[10] = atof(argv[++i]); 
		        	NRmat[11] = atof(argv[++i]);
					if (NRmat[10]!=1.0) 
						{
						for (j=0; j<12; j++)
							{
							if (j != 10)
								{
								NRmat[j]/=NRmat[10];
								}
							}
						NRmat[10]=1.0;
						}
					/*doGTR = NO;
					doGTnR = YES;
					doHKY = NO;
					if (doCodonModel == YES)
						{
						doGTnR = NO;
						doGTR = NO;
						doCodon_GTR = NO;
						doCodon_HKY = NO;
						doCodon_NGTR = YES;
						}*/
					}
				else
					{
					fprintf (stderr, "PARAMETER ERROR: Bad rates of change (-v) (1, 6, 12) (%d)\n\n", RatesNumber);
					PrintUsage();
					}
			break;
			case '@':
				ch = *argv[i];
				if(isspace(ch))
					strcpy(AAmodel, "AAmodel00");
				else
					strcpy(AAmodel,argv[i]);
				
				if (AAmodel[0] == 'B' && AAmodel[1] == 'l' && AAmodel[2] == 'o' && AAmodel[3] == 's' && AAmodel[4] == 'u' && AAmodel[5] == 'm' && AAmodel[6] == '6' && AAmodel[7] == '2')
					{
					doBlosum62 = YES;
					}
				else if (AAmodel[0] == 'C' && AAmodel[1] == 'p' && AAmodel[2] == 'R' && AAmodel[3] == 'e' && AAmodel[4] == 'v')
					{
					doCpRev = YES;
					}
				else if (AAmodel[0] == 'D' && AAmodel[1] == 'a' && AAmodel[2] == 'y' && AAmodel[3] == 'h' && AAmodel[4] == 'o' && AAmodel[5] == 'f' && AAmodel[6] == 'f'&& AAmodel[7] == 'D' && AAmodel[8] == 'C' && AAmodel[9] == 'M' && AAmodel[10] == 'U' && AAmodel[11] == 'T')
					{
					doDayhoffDCMUT = YES;
					/*fprintf(stderr, "\n\ndoDayhoff-dcmut\n\n");*/
					}
				else if (AAmodel[0] == 'D' && AAmodel[1] == 'a' && AAmodel[2] == 'y' && AAmodel[3] == 'h' && AAmodel[4] == 'o' && AAmodel[5] == 'f' && AAmodel[6] == 'f' && doDayhoffDCMUT == NO)
					{
					doDayhoff = YES;
					/*fprintf(stderr, "\n\ndoDayhoff\n\n");*/
					}
				else if (AAmodel[0] == 'H' && AAmodel[1] == 'I' && AAmodel[2] == 'V' && AAmodel[3] == 'b')
					{
					doHIVb = YES;
					}
				else if (AAmodel[0] == 'H' && AAmodel[1] == 'I' && AAmodel[2] == 'V' && AAmodel[3] == 'w')
					{
					doHIVw = YES;
					}
				else if (AAmodel[0] == 'J' && AAmodel[1] == 'T' && AAmodel[2] == 'T')
					{
					doJTT = YES;
					/*fprintf(stderr, "\n OK JTT! \n\n");*/
					}
				else if (AAmodel[0] == 'J' && AAmodel[1] == 'o' && AAmodel[2] == 'n' && AAmodel[3] == 'e' && AAmodel[4] == 's' && AAmodel[5] == 'D' && AAmodel[6] == 'C' && AAmodel[7] == 'M' && AAmodel[8] == 'U' && AAmodel[9] == 'T')
					{
					doJonesDCMUT = YES;
					}
				else if (AAmodel[0] == 'L' && AAmodel[1] == 'G')
					{
					doLG = YES;
					}
				else if (AAmodel[0] == 'M' && AAmodel[1] == 't' && AAmodel[2] == 'a' && AAmodel[3] == 'r' && AAmodel[4] == 't')
					{
					doMtart = YES;
					}
				else if (AAmodel[0] == 'M' && AAmodel[1] == 't' && AAmodel[2] == 'm' && AAmodel[3] == 'a' && AAmodel[4] == 'm')
					{
					doMtmam = YES;
					}
				else if (AAmodel[0] == 'M' && AAmodel[1] == 't' && AAmodel[2] == 'r' && AAmodel[3] == 'e' && AAmodel[4] == 'v' && AAmodel[5] == '2' && AAmodel[6] == '4')
					{
					doMtrev24 = YES;
					}
				else if (AAmodel[0] == 'R' && AAmodel[1] == 't' && AAmodel[2] == 'R' && AAmodel[3] == 'e' && AAmodel[4] == 'v')
					{
					doRtRev = YES;
					}
				else if (AAmodel[0] == 'V' && AAmodel[1] == 'T')
					{
					doVT = YES;
					}
				else if (AAmodel[0] == 'W' && AAmodel[1] == 'A' && AAmodel[2] == 'G')
					{
					doWAG = YES;
					}
				else /* this should mean the user introduces a particular EAAM by an input file */
					{
					doEAAMUser = YES;
					}
	
					/* fprintf(stderr, "\n AA model selected is \"%s\" \n\n", AAmodel);*/
					/* Blosum62, CpRev, Dayhoff, DayhoffDCMUT, HIVb, HIVw, JTT, JonesDCMUT, LG, Mtart, Mtmam, Mtrev24, RtRev, VT, WAG, User */
	        break;
			case 'I':
	        	pinv = atof(argv[i]);
				if (pinv < 0) 
					{
					fprintf (stderr, "PARAMETER ERROR: Bad p-inv (%f)\n\n", pinv);
					PrintUsage();
					}
			break;
			case 'A':
	        	alpha = atof(argv[i]);
				if (alpha < 0) 
					{
					fprintf (stderr, "PARAMETER ERROR: Bad gamma shape (alpha) for rate variation among sites(%f)\n\n", alpha);
					PrintUsage();
					}
				doRateHet = YES;
			break;
			case 'N':
				argument = atof(argv[i]);
				numDataSets = (int) argument;
				if (numDataSets <1)
					{
					fprintf (stderr, "PARAMETER ERROR: Bad number of replicates (%d)\n\n", numDataSets);
					PrintUsage();
					}
			break;
			case 'Y':
				argument = atof(argv[i]);
				noisy = (int) argument;
				if (noisy < 0)
					{
					fprintf (stderr, "PARAMETER ERROR: Bad noisy value (%d)\n\n", noisy);
					PrintUsage();
					}
			break;
			case 'O':
	        	outgroupBranchLength = atof(argv[i]);
				if (outgroupBranchLength <= 0) 
					{
					fprintf (stderr, "PARAMETER ERROR: Bad outgroup branch lenght value (%f)\n\n", outgroupBranchLength);
					PrintUsage();
					}
				thereisOutgroup = YES;
			break;
			case 'G':
				argument = atof(argv[i]);
				GrowthRate_or_DemographicPeriods = (int) argument;
				if (GrowthRate_or_DemographicPeriods < 0) 
					{
					fprintf (stderr, "PARAMETER ERROR: Bad number to choose between growth rate (0) or demographic periods (1) using -g (%d)\n\n", (int) argument);
					PrintUsage();
					}

				
				if (GrowthRate_or_DemographicPeriods == 0) /* growth rate */
					{
					argument = atof(argv[++i]);
					growthRate = (double) argument;
					if (growthRate < 0)
						{
						fprintf (stderr, "PARAMETER ERROR: Bad growth rate (should be positive) (%lf)\n\n", growthRate);
						PrintUsage();
						}
					}
				else if (GrowthRate_or_DemographicPeriods == 1) /* demographic periods */
					{
					/*doDemographics = YES;*/
		     	 	/*if (doExponential == YES)
						{
						fprintf (stderr, "PARAMETER ERROR: Cannot have both demographics periods (-g) and other demographics (-p)\n\n");
						exit (1);
						}*/
	    	    	argument = atof(argv[++i]);
					numPeriods = (int) argument;
					if (numPeriods < 0) 
						{
						fprintf (stderr, "PARAMETER ERROR: Bad number of periods (%d)\n\n", numPeriods);
						PrintUsage();
						}
					/*if (numPeriods == 0)
						doDemographics = NO;*/
					if (numPeriods > 0)
						{
						Nbegin = 	(int *) calloc(numPeriods+1,(long) sizeof(int));
						Nend =		(int *) calloc(numPeriods+1,(long) sizeof(int));
						cumDuration =	(int *) calloc(numPeriods+1,(long) sizeof(int));
						periodGrowth =	(double *) calloc(numPeriods+1,(long) sizeof(double));
						if (Nbegin == NULL || Nend == NULL || cumDuration == NULL)
							{
							fprintf (stderr, "PARAMETER ERROR: Could not allocate demographic vectors (%lu bytes)\n", numPeriods *(long) sizeof(int));
							exit (1);
							}
						for (j=1; j<=numPeriods; j++)
							{
							argument = atof(argv[++i]);
							Nbegin[j] = (int) argument;
							argument = atof(argv[++i]);
							Nend[j] = (int) argument;
							argument = atof(argv[++i]);
							cumDuration[j] = (int) argument + cumDuration[j-1];
							}
						}
					}
				else
					{
					fprintf (stderr, "PARAMETER ERROR: Bad number to choose between growth rate (0) or demographic periods (1) using -g (%d)\n\n", GrowthRate_or_DemographicPeriods);
					PrintUsage();
					}
			break;
			case 'T':
	        	/* [t1 0.001] [t2 100 0.001 0.005] [t3 100 1000 0.001 0.005 0.001] */
				argument = atof(argv[i]);
				numMigRatePeriods = (int) argument;
				if (numMigRatePeriods <= 0) 
					{
					fprintf (stderr, "PARAMETER ERROR: Bad number of periods for variable migration rate (must be 1 or higher) (%d)\n\n", numPeriods);
					PrintUsage();
					}

				if (numMigRatePeriods == 1) /* 1 period */
					{
					doMigRatePeriods = NO;
					
					argument = atof(argv[++i]);
					migrationRate = (double) argument;
					if (migrationRate <= 0)
						{
						fprintf (stderr, "PARAMETER ERROR: Bad migration rate (should be higher than 0) (%lf)\n\n", migrationRate);
						PrintUsage();
						}
					}
				else /* more than 1 period */
					{
					doMigRatePeriods = YES;

					MigTbegin =	(int *) calloc(numMigRatePeriods+1,(long) sizeof(int));
					periodMigrationRate =	(double *) calloc(numMigRatePeriods+1,(long) sizeof(double));
					if (MigTbegin == NULL || periodMigrationRate == NULL)
						{
						fprintf (stderr, "PARAMETER ERROR: Could not allocate temporal migration rate vectors (%lu bytes)\n", numMigRatePeriods *(long) sizeof(int));
						exit (1);
						}
					
					for (j=1; j<=numMigRatePeriods-1; j++)
						{
						argument = atof(argv[++i]);
						MigTbegin[j] = (int) argument;
						if (MigTbegin[j] <= 0)
							{
							fprintf (stderr, "PARAMETER ERROR: Bad time for migration rate variation (should be higher than 0) (%d)\n\n", MigTbegin[j]);
							PrintUsage();
							}
						}

					for (j=1; j<=numMigRatePeriods; j++)
						{
						argument = atof(argv[++i]);
						periodMigrationRate[j] = (double) argument;
						if (periodMigrationRate[j] < 0)
							{
							fprintf (stderr, "PARAMETER ERROR: Bad migration rate (should not be negative) (%lf)\n\n", periodMigrationRate[j]);
							PrintUsage();
							}
						}
					}
			break;
			case 'Q':
				/*doMigration = YES;*/ /* migrationModel */
	        	sumPopul = 0;
				
				argument = atof(argv[i]);
				migrationModel = (int) argument;
				if (numPopulations < 1 || numPopulations > 3) /* migrationModel = 1, 2, 3 */
					{
					fprintf (stderr, "PARAMETER ERROR: Bad migration model (%d)\n\n", migrationModel);
					PrintUsage();
					}				

				
				argument = atof(argv[++i]);
				numPopulations = (int) argument;
				if (numPopulations < 1 || numPopulations > numSequences) 
					{
					fprintf (stderr, "PARAMETER ERROR: Bad number of subpopulations (%d)\n\n", numPopulations);
					PrintUsage();
					}
				
				initPopulation = (int *) calloc(numPopulations+1,(long) sizeof(int));
				if (!initPopulation)
					{
					fprintf (stderr, "PARAMETER ERROR: Could not allocate initPopulation of migration model (%lu bytes)\n", (numPopulations+1) *(long) sizeof(int));
					exit (1);
					}
				for (j=1; j<=numPopulations; j++)
					{
					argument = atof(argv[++i]);
					initPopulation[j] = (int) argument;
					if (initPopulation[j] > numSequences || initPopulation[j] <= 0)
						{
						fprintf (stderr, "PARAMETER ERROR: Bad initial population (%d)\n\n", initPopulation[j]);
						PrintUsage();
						}					
					sumPopul = sumPopul + initPopulation[j];
					}
				/*argument = atof(argv[++i]);
				migrationRate = (double) argument;
				if (migrationRate < 0)
					{
					fprintf (stderr, "PARAMETER ERROR: Bad migration rate (%lf)\n\n", migrationRate);
					PrintUsage();
					}*/
				if (sumPopul != numSequences)
					{
					fprintf (stderr, "PARAMETER ERROR: Bad initial subpopulation. The number of sequences is different that the sum of nodes in demes \n\n");
					PrintUsage();
					}

			break;
			case '%':
				argument = atof(argv[i]);
				numConvergDemes = (int) argument;
				if (numConvergDemes < 0 || numConvergDemes >= numSequences) 
					{
					fprintf(stderr, "PARAMETER ERROR: Bad number of convergencies demes events (%d) \n\n", numConvergDemes);
					PrintUsage();
					}
				/*fprintf(stderr, "\n\n numConvergDemes = %d \n", numConvergDemes);*/
				
				deme_a_old = (int *) calloc(numConvergDemes+1,(long) sizeof(int));
				if (!deme_a_old)
					{
					fprintf (stderr, "PARAMETER ERROR: Could not allocate deme_a of convergencies demes events (%lu bytes)\n", (numConvergDemes+1) *(long) sizeof(int));
					exit (1);
					}
				deme_b_old = (int *) calloc(numConvergDemes+1,(long) sizeof(int));
				if (!deme_b_old)
					{
					fprintf (stderr, "PARAMETER ERROR: Could not allocate deme_b of convergencies demes events (%lu bytes)\n", (numConvergDemes+1) *(long) sizeof(int));
					exit (1);
					}
				convDemTimes_old = (double*) calloc ((numConvergDemes+1), sizeof (double)); 
				if (convDemTimes_old == NULL)
					{
					fprintf (stderr, "PARAMETER ERROR: Could not allocate convDemTimes of convergencies demes events (%lu bytes)\n", (numConvergDemes+1) *(long) sizeof(double));
					exit (1);
					}
				if (numConvergDemes > 0)
					{
					for (j=1; j<=numConvergDemes; j++)
						{
						argument = atof(argv[++i]);
						deme_a_old[j] = (int) argument;
						argument = atof(argv[++i]);
						deme_b_old[j] = (int) argument;
						argument = atof(argv[++i]);
						convDemTimes_old[j] = (double) argument;
						}
					for (j=1; j<=numConvergDemes; j++)
						{
						/*fprintf(stderr, "\n\n deme_a_old[%d] = %d \n", j, deme_a_old[j]);
						fprintf(stderr, "\n\n deme_b_old[%d] = %d \n", j, deme_b_old[j]);
						fprintf(stderr, "\n\n convDemTimes_old[%d] = %lf \n", j, convDemTimes_old[j]);*/
						if (deme_a_old[j] == deme_b_old[j])
							{
							fprintf (stderr, "PARAMETER ERROR: Bad number of deme in convergencies demes events (%d)(%d), they must to be differents \n\n", deme_a_old[j], deme_b_old[j]);
							PrintUsage();
							}
						if (convDemTimes_old[j] <= 0)
							{
							fprintf (stderr, "PARAMETER ERROR: Bad time to convergencies demes events (%lf)\n\n", convDemTimes_old[j]);
							PrintUsage();
							}
						}
					k = h = 0;
					for (j=1; j<=numConvergDemes; j++)
						{
						k = convDemTimes_old[j];
						for (h=1; h<=numConvergDemes; h++)
							{
							if (j != h && convDemTimes_old[j] == convDemTimes_old[h])
								{
								fprintf (stderr, "PARAMETER ERROR: Bad time to convergencies demes events (%lf), it can not have two events at the same time\n\n", convDemTimes_old[h]);
								PrintUsage();
								}
							if (j != h && deme_a_old[j] == deme_a_old[h])
								{
								fprintf (stderr, "PARAMETER ERROR: Bad number of demes to convergencies demes events (%d)(%d), it can not have a same deme converging at two different times\n\n", deme_a_old[j], deme_a_old[h]);
								PrintUsage();
								}
							if (j != h && deme_b_old[j] == deme_b_old[h])
								{
								fprintf (stderr, "PARAMETER ERROR: Bad number of demes to convergencies demes events (%d)(%d), it can not have a same deme converging at two different times\n\n", deme_b_old[j], deme_b_old[h]);
								PrintUsage();
								}
							}
						}
					}
			break;
			case 'J':
				strcpy(treeFile, "trees");
				doPrintTrees = YES;
			break;
			case 'B':
				strcpy(alignmentFile, "sequences");
			break;
			case 'K':
				strcpy(timesFile, "times");
				doPrintTimes = YES;
			break;
			case 'D':
				strcpy(breakpointFile, "breakpoints");
				doPrintBreakpoints = YES;
			break;
			case 'X':
				strcpy(MRCAFile, "seqGMRCA"); 
				doMRCAFile = YES;
			break;
			case 'C':

				/* format: phylip/fasta/nexus format (1-3) */
				argument = atof(argv[i]);
				formatNumber = (int) argument;
				if (formatNumber > 3 || formatNumber < 1) 
					{
					fprintf (stderr, "PARAMETER ERROR: Bad format of output alignments files chosen (1-3) (%d)\n\n", formatNumber);
					PrintUsage();
					}
				if (formatNumber == 1) /* phylip */
					{
					doPrintFASTA = NO;
					doPrintNEXUS = NO;
					}
				if (formatNumber == 2) /* fasta */
					{
					doPrintFASTA = YES;
					doPrintNEXUS = NO;
					}
				if (formatNumber == 3) /* nexus */
					{
					doPrintFASTA = NO;
					doPrintNEXUS = YES;
					}
				if (formatNumber > 3 || formatNumber < 1)
					{
					fprintf (stderr, "PARAMETER ERROR: Bad format of output alignments files chosen (1-3) (%d)\n\n", (int) argument);
					PrintUsage();
					}

				/* multiple aligment files (0-1) */
				argument = atof(argv[++i]);
				yesHere = (int) argument;	
				if (yesHere < 0 || yesHere > 1)
					{
					fprintf (stderr, "PARAMETER ERROR: Bad print multiple aligment files option (0:no or 1:yes) (%d)\n\n", yesHere);
					PrintUsage();
					}
				if (yesHere == 1)
					doSeparatedSequences = YES;

				
				/* print ancestral states */
				yesHere = 0;
				argument = atof(argv[++i]);
				yesHere = (int) argument;
				if (yesHere < 0 || yesHere > 1)
					{
					fprintf (stderr, "PARAMETER ERROR: Bad print ancestral states  option (0:no or 1:yes) (%d)\n\n", yesHere);
					PrintUsage();
					}
				if (yesHere == 1)
					doPrintAncestralSequences = YES;

			break;
			case 'Z':
				ch = *argv[i];
				if(isspace(ch))
					strcpy(ProtStabAAFile, "Pop_evol.in");
				else
					strcpy(ProtStabAAFile,argv[i]);
		
			doProtStabAAFile = YES;
			/*fprintf(stderr, "\n Setting for Structural protein stability file (AA) selected: \"%s\" \n\n", ProtStabAAFile);*/
			break;
			/*case 'Z':
			ch = *argv[i];
				if(isspace(ch))
					strcpy(ECodonModel, "CodonModel00");
				else
					strcpy(ECodonModel,argv[i]);
				
			if (ECodonModel[0] == 'E' && ECodonModel[1] == 'C' && ECodonModel[2] == 'M' && ECodonModel[3] == 'r' && ECodonModel[4] == 'e' && ECodonModel[5] == 's' && ECodonModel[6] == 't')
				{
				doECMrest = YES;
				}
			else if (ECodonModel[0] == 'E' && ECodonModel[1] == 'C' && ECodonModel[2] == 'M' && ECodonModel[3] == 'u' && ECodonModel[4] == 'n' && ECodonModel[5] == 'r' && ECodonModel[6] == 'e' && ECodonModel[7] == 's' && ECodonModel[8] == 't')
				{
				doECMunrest = YES;
				}
			else if (ECodonModel[0] == 'E' && ECodonModel[1] == 'C' && ECodonModel[2] == 'M' && ECodonModel[3] == 'S' && ECodonModel[4] == 'c' && ECodonModel[5] == 'h' && ECodonModel[6] == 'n' && ECodonModel[7] == '2' && ECodonModel[8] == '0' && ECodonModel[9] == '0' && ECodonModel[10] == '5')
				{
				doECMSchn = YES;
				}
			else 
				{
				doECMuser = YES;
				}
	
			doOmegaCat = NO;
			doOmegaRateHetCont = NO;
			doOmegaRateHetDisc = NO;

			break;*/
			case '*':
				ch = *argv[i];
				if(isspace(ch))
					strcpy(networkOut, "networkfile");
				else
					strcpy(networkOut,argv[i]);
				
				doBranchNetfiles = YES;							
			break;
			case '$':
				doOutMRCAfiles = YES;
			break;
			case '+':
				doPrintOmegasPerSitefiles = YES;
			break;
			case 'W':
				if (recombinationRate <= 0)
					{
					fprintf (stderr, "PARAMETER ERROR: Cannot fix number of recombination events when the recombination rate is 0\n\n");
					PrintUsage();
					}	
				argument = atof(argv[i]);
				fixedNumRecEvents = (int) argument;
				if (fixedNumRecEvents <= 0)
					{
					fprintf (stderr, "PARAMETER ERROR: Bad fixed number of recombination events value (%d)\n\n", fixedNumRecEvents);
					PrintUsage();
					}
			doFixNumRecEvents = YES;
			break;
			case 'H':
				ch = *argv[i];
				if(isspace(ch))
					strcpy(HetRecFile, "HetRec");
				else
					strcpy(HetRecFile,argv[i]);
		
			doHetRecFile = YES;
			
			/*fprintf(stderr, "\n Setting for Het Rec selected: \"%s\" \n\n", HetRecFile);*/
			break;
            case ':':
                NumReplicateABC = atof(argv[i]);
                if (NumReplicateABC <= 0)
                    {
                    fprintf (stderr, "PARAMETER ERROR: Bad NumReplicateABC value (%d)\n\n", NumReplicateABC);
                    PrintUsage();
                    }
                /*fprintf(stderr, "\n\n NumReplicateABC = %d \n", NumReplicateABC);*/
                break;
			case '?':
				PrintUsage();
			break;
			/*case 'H':
				PrintUsage();
			break;*/
			default :
				fprintf(stderr, "PARAMETER ERROR: Incorrect parameter: %c\n\n", flagb);
				PrintUsage();
			break;
		}
	} 
}



/***************************** ReadParametersFromFile *******************************/
/* Reads parameter values from the parameter file */

void ReadParametersFromFile()
{
	int  	j, i, modelNumber, k, h, l, RatesNumber;
	char 	ch;
	int		to, from, yesHere;
	double	sumPi, sumPi_b, sumPi_Cod_first, sumPi_Cod_second, sumPi_Cod_third, sumPi_AA;
	int		sumPopul, GrowthRate_or_DemographicPeriods;
	float argument;
	
	/* Used: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z ? # @ $ % + * = / _    next ideas _ l */
	yesHere = 0;
	modelNumber = -1;
	GrowthRate_or_DemographicPeriods = -1;

	if(feof(stdin)){
		fprintf(stderr, "PARAMETER ERROR: Unable to read parameters from stdin\n");
		exit(0);
	}

	ch=fgetc(stdin);
	while(isspace(ch))
		ch=fgetc(stdin);
	while(ch=='[')
	{
		ReadUntil(stdin, ']', "closing bracket");
		ch=fgetc(stdin);
		while(isspace(ch))
			ch=fgetc(stdin);
	}

	while(!feof(stdin))
		{
		argument = 0;
		ch=toupper(ch);
		switch (ch) 
			{
			case '#':
				if (fscanf(stdin, "%lu bytes", &userSeed) !=1 || userSeed < 0) 
					{
					fprintf (stderr, "PARAMETER ERROR: Bad seed (%d)\n\n", (int) userSeed);
					PrintUsage();
					}
			break;
			case 'S':
				if (fscanf(stdin, "%d", &numSequences)!=1 || numSequences<1)
				 	{
					fprintf(stderr, "PARAMETER ERROR: Bad sample size (s) (%d) \n\n", numSequences);
					PrintUsage();
					}
				
				if (fscanf(stdin, "%d", &numSites)!=1 || numSites<1) 
					{
					fprintf(stderr, "PARAMETER ERROR: Bad sequence number of sites (s) (%d)\n\n", numSites);
					PrintUsage();
					}
			break;
			case 'L':
				if (fscanf(stdin, "%f", &argument)!=1) 
					{
					fprintf (stderr, "PARAMETER ERROR: Bad model chosen (0-4) (%d)\n\n", (int) argument);
					PrintUsage();
					}
				BBmodelNumber = (int) argument;

				doVariableDnDsBranches = YES;
				

				sumPi = sumPi_b = 0.0;
				if (BBmodelNumber == 1) /* categories from the user */
					{
					doBBM0 = YES;

					if (fscanf(stdin, "%f", &argument) !=1 || argument > 10) /* max 10 categories */
						{
						fprintf (stderr, "PARAMETER ERROR: Bad number of omega categories (%d)\n\n", (int) argument);
						PrintUsage();
						}
					BBnumOmegaCat = (int) argument;

					BBomegaVal = (double *) calloc((BBnumOmegaCat+1),(long) sizeof(double));
					if (!BBomegaVal)
						{
						fprintf (stderr, "PARAMETER ERROR: Could not allocate omega values of categories (-l) (%lu bytes)\n", BBnumOmegaCat *(long) sizeof(double));
						exit (1);
						}
					BBomegaProb = (double *) calloc((BBnumOmegaCat+1),(long) sizeof(double));
					if (!BBomegaProb)
						{
						fprintf (stderr, "PARAMETER ERROR: Could not allocate omega probabilities of categories1 (-l) (%lu bytes)\n", BBnumOmegaCat *(long) sizeof(double));
						exit (1);
						}
					for (j=1; j<=BBnumOmegaCat; j++)
						{
						fscanf(stdin, "%lf", &BBomegaVal[j]);
						fscanf(stdin, "%lf", &BBomegaProb[j]);

						if (BBomegaProb[j] > 1 || BBomegaProb[j] < 0)
							{
							fprintf (stderr, "PARAMETER ERROR: Bad number of probabilities of omega categories2 (%3.2f)\n\n", BBomegaProb[j]);
							PrintUsage();
							}
						sumPi = sumPi + BBomegaProb[j];
						}
					if (sumPi != 1) /* update probabilities of categories */
						{
						if (BBnumOmegaCat == 1)
							BBomegaProb[1] = 1.0;
						else
							{
							for (j=1; j<=BBnumOmegaCat; j++)
								{
								BBomegaProb[j]/=sumPi;
								sumPi_b = sumPi_b + BBomegaProb[j];
								}
							if ((int)sumPi_b != 1)
								{
								fprintf (stderr, "\n ERROR in the sum of probabilities of omega categories (-l) \n");
								exit (-1);
								}
							}
						}
					}
				else if (BBmodelNumber == 2) /* gamma distribution */
					{
					doBBM0 = YES;					

					fscanf(stdin, "%lf", &BBOmegaRateHet);
					if (BBOmegaRateHet <= 0.0)
						{
						fprintf (stderr, "PARAMETER ERROR: Bad heterogeneous rate (%3.2f)\n\n", BBOmegaRateHet);
						PrintUsage();
						}
					fscanf(stdin, "%lf", &BBomega);
					if (BBomega < 0.0)
						{
						fprintf (stderr, "PARAMETER ERROR: Bad heterogeneous rate (%3.2f)\n\n", BBomega);
						PrintUsage();
						}
					BBOmegaInit = BBomega;
					}
				else if (BBmodelNumber == 3) /* beta distribution */
					{
					doBBM0 = YES;				

					fscanf(stdin, "%lf", &BBM7_p_beta);
					if (BBM7_p_beta < 0.0)
						{
						fprintf (stderr, "PARAMETER ERROR: Bad p in beta distribution (%3.2f)\n\n", BBM7_p_beta);
						PrintUsage();
						}
					
					fscanf(stdin, "%lf", &BBM7_q_beta);
					if (BBM7_q_beta < 0.0)
						{
						fprintf (stderr, "PARAMETER ERROR: Bad q in beta distribution (%3.2f)\n\n", BBM7_q_beta);
						PrintUsage();
						}
					}
				else if (BBmodelNumber == 4) /* Heterogeneous codon models */
					{
					doBBM0 = NO;
					}
				else
					{
					fprintf(stderr, "PARAMETER ERROR: Bad effective dN/dS variation per branch (-l between 1 and 4) (%d) \n\n", BBmodelNumber);
					PrintUsage();
					}
			break;
			case 'E':
				if (fscanf(stdin, "%d", &N)!=1 || N<1) 
					{
					fprintf(stderr, "PARAMETER ERROR: Bad effective population size (%d) \n\n", N);
					PrintUsage();
					}

				if (fscanf(stdin, "%f", &argument)!=1) 
					{
					fprintf (stderr, "PARAMETER ERROR: Bad haplid/diploid chosen (%d)\n\n", (int) argument);
					PrintUsage();
					}
				Nscaling = (int) argument;
				if (Nscaling < 1 || Nscaling > 2)
					{
					fprintf (stderr, "PARAMETER ERROR: Haploid/diplod option (1-2) (%d)\n\n", Nscaling);
					PrintUsage();
					}
			break;
			case '=':
				doDatedTips = YES;
				if (fscanf(stdin, "%f", &argument) !=1 || argument < 1) 
					{
					fprintf (stderr, "PARAMETER ERROR: Bad number of periods (%d)\n\n", (int) argument);
					PrintUsage();
					}
 				numTipDates = (int) argument;
				if (numTipDates <= 0) 
					{
					fprintf (stderr, "COMMAND-LINE PARAMETER ERROR: Bad number of sampling dates (%d)\n\n", numTipDates);
					PrintUsage();
					}
				
				datedSample = 	(SampleSt *) calloc(numTipDates, sizeof(SampleSt));
				if (datedSample == NULL)
					{
					fprintf (stderr, "COMMAND-LINE PARAMETER ERROR: Could not allocate sampling dates vectors (%ld)\n", numTipDates * (long) sizeof(SampleSt));
					exit (1);
					}
	
				for (j=0; j<numTipDates; j++)
					{
					fscanf(stdin, "%f", &argument);
	        		datedSample[j].time = (float) argument;
					fscanf(stdin, "%f", &argument);
					from = (int) argument;
					fscanf(stdin, "%f", &argument);
        			to = (int) argument;
	
					datedSample[j].member = 	(int *) calloc(to-from+1, sizeof(int));
					if (datedSample[j].member == NULL)
						{
						fprintf (stderr, "COMMAND-LINE PARAMETER ERROR: Could not allocate sampling dates vector[j=%d] (%ld)\n",j, to-from+1 * (long) sizeof(int));
						exit (1);
						}

					l = 0;
					for (k=from; k<=to; k++)
						datedSample[j].member[l++] = k;
					
					datedSample[j].size = l;
					}
															
				/* debugging */
				/*for (j=0; j<numTipDates; j++)
					{
					fprintf (stderr, "\nERR: time=%f size=%d sequences=", datedSample[j].time, datedSample[j].size);
					for (k=0; k<datedSample[j].size; k++)
						fprintf (stderr, " %d", datedSample[j].member[k]);	
					}
				*/
			break;
			case '/':
				if (fscanf(stdin, "%lf", &generationTime) !=1) 
					{
					fprintf (stderr, "PARAMETER ERROR: Bad generation time (%f)\n\n", generationTime);
					PrintUsage();
					}
			break;
			case 'R':
				if (fscanf(stdin, "%lf", &recombinationRate)!=1) 
					{
					fprintf(stderr, "PARAMETER ERROR: Bad recombination rate (%f) \n\n", recombinationRate);
					PrintUsage();
					}
			break;
			case 'U':
				if (fscanf(stdin, "%lf", &mutationRate)!=1) 
					{
					fprintf(stderr, "PARAMETER ERROR: Bad mutation rate (%f) \n\n", mutationRate);
					PrintUsage();
					}
			break;

			case '_':
				ch=fgetc(stdin);
				if(isspace(ch))
					strcpy(HetVectorFile, "HetRatesVector");
				else
					{
					j=0;
					do
						{
						HetVectorFile[j]=ch;
						j++;
						ch=fgetc(stdin);
						}
					while(!isspace(ch));
					HetVectorFile[j]='\0';
					}
		
			doHetVectorFile = YES;
			/*fprintf(stderr, "\n Setting for Heterogeneity by a user-defined vector: \"%s\" \n\n", HetVectorFile);*/
			break;

/*			case '_':
				ch=fgetc(stdin);
				if(isspace(ch))
					strcpy(GY94xAAmodel, "GY94xAAmodel00");
				else
					{
					j=0;
					do
						{
						GY94xAAmodel[j]=ch;
						j++;
						ch=fgetc(stdin);
						}
					while(!isspace(ch));
					GY94xAAmodel[j]='\0';
					}
*/				
				/* doGY94xBlosum62 doGY94xCpRev doGY94xDayhoff doGY94xDayhoffDCMUT doGY94xHIVb doGY94xHIVw doGY94xJTT doGY94xJonesDCMUT doGY94xLG doGY94xMtart doGY94xMtmam doGY94xMtrev24 
					doGY94xRtRev doGY94xVT doGY94xWAG doGY94xEAAMUser */
/*
				if (GY94xAAmodel[0] == 'B' && GY94xAAmodel[1] == 'l' && GY94xAAmodel[2] == 'o' && GY94xAAmodel[3] == 's' && GY94xAAmodel[4] == 'u' && GY94xAAmodel[5] == 'm' && GY94xAAmodel[6] == '6' && GY94xAAmodel[7] == '2')
					{
					doGY94xBlosum62 = YES;
					}
				else if (GY94xAAmodel[0] == 'C' && GY94xAAmodel[1] == 'p' && GY94xAAmodel[2] == 'R' && GY94xAAmodel[3] == 'e' && GY94xAAmodel[4] == 'v')
					{
					doGY94xCpRev = YES;
					}
				else if (GY94xAAmodel[0] == 'D' && GY94xAAmodel[1] == 'a' && GY94xAAmodel[2] == 'y' && GY94xAAmodel[3] == 'h' && GY94xAAmodel[4] == 'o' && GY94xAAmodel[5] == 'f' && GY94xAAmodel[6] == 'f'&& GY94xAAmodel[7] == 'D' && GY94xAAmodel[8] == 'C' && GY94xAAmodel[9] == 'M' && GY94xAAmodel[10] == 'U' && GY94xAAmodel[11] == 'T')
					{
					doGY94xDayhoffDCMUT = YES;
					}
				else if (GY94xAAmodel[0] == 'D' && GY94xAAmodel[1] == 'a' && GY94xAAmodel[2] == 'y' && GY94xAAmodel[3] == 'h' && GY94xAAmodel[4] == 'o' && GY94xAAmodel[5] == 'f' && GY94xAAmodel[6] == 'f' && doGY94xDayhoffDCMUT == NO)
					{
					doGY94xDayhoff = YES;
					}
				else if (GY94xAAmodel[0] == 'H' && GY94xAAmodel[1] == 'I' && GY94xAAmodel[2] == 'V' && GY94xAAmodel[3] == 'b')
					{
					doGY94xHIVb = YES;
					}
				else if (GY94xAAmodel[0] == 'H' && GY94xAAmodel[1] == 'I' && GY94xAAmodel[2] == 'V' && GY94xAAmodel[3] == 'w')
					{
					doGY94xHIVw = YES;
					}
				else if (GY94xAAmodel[0] == 'J' && GY94xAAmodel[1] == 'T' && GY94xAAmodel[2] == 'T')
					{
					doGY94xJTT = YES;
					}
				else if (GY94xAAmodel[0] == 'J' && GY94xAAmodel[1] == 'o' && GY94xAAmodel[2] == 'n' && GY94xAAmodel[3] == 'e' && GY94xAAmodel[4] == 's' && GY94xAAmodel[5] == 'D' && GY94xAAmodel[6] == 'C' && GY94xAAmodel[7] == 'M' && GY94xAAmodel[8] == 'U' && GY94xAAmodel[9] == 'T')
					{
					doGY94xJonesDCMUT = YES;
					}
				else if (GY94xAAmodel[0] == 'L' && GY94xAAmodel[1] == 'G')
					{
					doGY94xLG = YES;
					}
				else if (GY94xAAmodel[0] == 'M' && GY94xAAmodel[1] == 't' && GY94xAAmodel[2] == 'a' && GY94xAAmodel[3] == 'r' && GY94xAAmodel[4] == 't')
					{
					doGY94xMtart = YES;
					}
				else if (GY94xAAmodel[0] == 'M' && GY94xAAmodel[1] == 't' && GY94xAAmodel[2] == 'm' && GY94xAAmodel[3] == 'a' && GY94xAAmodel[4] == 'm')
					{
					doGY94xMtmam = YES;
					}
				else if (GY94xAAmodel[0] == 'M' && GY94xAAmodel[1] == 't' && GY94xAAmodel[2] == 'r' && GY94xAAmodel[3] == 'e' && GY94xAAmodel[4] == 'v' && GY94xAAmodel[5] == '2' && GY94xAAmodel[6] == '4')
					{
					doGY94xMtrev24 = YES;
					}
				else if (GY94xAAmodel[0] == 'R' && GY94xAAmodel[1] == 't' && GY94xAAmodel[2] == 'R' && GY94xAAmodel[3] == 'e' && GY94xAAmodel[4] == 'v')
					{
					doGY94xRtRev = YES;
					}
				else if (GY94xAAmodel[0] == 'V' && GY94xAAmodel[1] == 'T')
					{
					doGY94xVT = YES;
					}
				else if (GY94xAAmodel[0] == 'W' && GY94xAAmodel[1] == 'A' && GY94xAAmodel[2] == 'G')
					{
					doGY94xWAG = YES;
					}
				else*/ /* this should mean the user introduces a particular AA matrix by an input file */
/*					{
					doGY94xEAAMUser = YES;
					}*/
	
				/* fprintf(stderr, "\n AA matrix selected for GY94 codon model is \"%s\" \n\n", GY94xAAmodel);*/
/*			break;*/

			case 'M':
				ch=fgetc(stdin);
				if(isspace(ch))
					strcpy(ProtStabDNAFile, "Pop_evol.in");
				else
					{
					j=0;
					do
						{
						ProtStabDNAFile[j]=ch;
						j++;
						ch=fgetc(stdin);
						}
					while(!isspace(ch));
					ProtStabDNAFile[j]='\0';
					}
		
			doProtStabDNAFile = YES;
			/*fprintf(stderr, "\n Setting for Structural protein stability (DNA) file: \"%s\" \n\n", ProtStabDNAFile);*/
			break;

//			case 'M':
				/*doCodonModel = YES;*/
//				sumPi = sumPi_b = 0.0;
//				if (fscanf(stdin, "%f", &argument)!=1) 
//					{
//					fprintf (stderr, "PARAMETER ERROR: Bad model chosen (0-10) (%d)\n\n", (int) argument);
//					PrintUsage();
//					}
//				modelNumber = (int) argument;
//				/*fscanf(stdin, "%f", &modelNumber);
//				if (modelNumber < 0.0)
//					{
//					fprintf (stderr, "PARAMETER ERROR: Bad modelNumber (%3.2f)\n\n", modelNumber);
//					PrintUsage();
//					}*/
//				
//				if (modelNumber == 1)		/** omega constant (M0) **/
//					{
//					doOmegaCat = NO;
//					doOmegaRateHetCont = NO;
//					doOmegaRateHetDisc = NO;
//					doM0 = YES;	
//					
//					fscanf(stdin, "%lf", &omega);
//					if (omega < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad omega (%3.2f)\n\n", omega);
//						PrintUsage();
//						}
//					OmegaInit = omega;
//					}
//				else if (modelNumber == 2) /** omega by categories from the user **/
//					{
//					doOmegaCat = YES;
//					doOmegaProb = YES;
//					doOmegaRateHetCont = NO;
//					doOmegaRateHetDisc = NO;
//					
//					if (fscanf(stdin, "%f", &argument) !=1 || argument > 10) /* max 10 categories */
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad number of omega categories (%d)\n\n", (int) argument);
//						PrintUsage();
//						}
//					numOmegaCat = (int) argument;
//					omegaVal = (double *) calloc((numOmegaCat+1),(long) sizeof(double));
//					if (!omegaVal)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Could not allocate omega values of categories (%lu bytes)\n", numOmegaCat *(long) sizeof(double));
//						exit (1);
//						}
//					omegaProb = (double *) calloc((numOmegaCat+1),(long) sizeof(double));
//					if (!omegaProb)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Could not allocate omega probabilities of categories1 (%lu bytes)\n", numOmegaCat *(long) sizeof(double));
//						exit (1);
//						}
//					for (j=1; j<=numOmegaCat; j++)
//						{
//						fscanf(stdin, "%lf", &omegaVal[j]);
//						fscanf(stdin, "%lf", &omegaProb[j]);
//
//						if (omegaProb[j] > 1 || omegaProb[j] < 0)
//							{
//							fprintf (stderr, "PARAMETER ERROR: Bad number of probabilities of omega categories2 (%3.2f)\n\n", omegaProb[j]);
//							PrintUsage();
//							}
//						sumPi = sumPi + omegaProb[j];
//						}
//					if (sumPi != 1) /* update probabilities of categories */
//						{
//						if (numOmegaCat == 1)
//							omegaProb[1] = 1.0;
//						else
//							{
//							for (j=1; j<=numOmegaCat; j++)
//								{
//								omegaProb[j]/=sumPi;
//								sumPi_b = sumPi_b + omegaProb[j];
//								}
//							if ((int)sumPi_b != 1)
//								{
//								fprintf (stderr, "\n ERROR in the sum of probabilities of omega categories");
//								exit (-1);
//								}
//							}
//						}
//					}
//				else if (modelNumber == 3) /** M1 **/
//					{
//					doM1 = YES;	
//					/*doOmegaCat = NO;*/
//					doOmegaRateHetCont = NO;
//					doOmegaRateHetDisc = NO;
//				
//					fscanf(stdin, "%lf", &M1_P0_omeg0);
//					if (M1_P0_omeg0 < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad P0 in model M1 (%3.2f)\n\n", M1_P0_omeg0);
//						PrintUsage();
//						}
//					fscanf(stdin, "%lf", &M1_omega0);
//					if (M1_omega0 < 0.0 || M1_omega0 > 1)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad omega for P0 in model M1 (%3.2f)\n\n", M1_omega0);
//						PrintUsage();
//						}
//
//					M1_P1_omeg1 = 1 - M1_P0_omeg0;
//					doOmegaCat = YES;
//					numOmegaCat = 2;
//					
//					omegaVal = (double *) calloc((numOmegaCat+1),(long) sizeof(double));
//					if (!omegaVal)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Could not allocate omega values of categories (%lu bytes)\n", numOmegaCat *(long) sizeof(double));
//						exit (1);
//						}
//					omegaProb = (double *) calloc((numOmegaCat+1),(long) sizeof(double));
//					if (!omegaProb)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Could not allocate omega probabilities of categories1 (%lu bytes)\n", numOmegaCat *(long) sizeof(double));
//						exit (1);
//						}
//
//					omegaProb[1] = M1_P0_omeg0;
//					omegaProb[2] = M1_P1_omeg1;
//					omegaVal[1] = M1_omega0;
//					omegaVal[2] = 1.0;
//					}
//				else if (modelNumber == 4) /** omega by discrete gamma heterogeneous rate **/
//					{
//					doOmegaCat = NO;
//					doOmegaRateHetCont = NO;
//					doOmegaRateHetDisc = YES;
//					
//					fscanf(stdin, "%d", &numOmegaCat);
//					if (numOmegaCat < 0 || numOmegaCat > 10)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad number of omega categories (%d)\n\n", numOmegaCat);
//						PrintUsage();
//						}
//					fscanf(stdin, "%lf", &OmegaRateHet);
//					if (OmegaRateHet <= 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad omega heterogeneous rate (%3.2f)\n\n", OmegaRateHet);
//						PrintUsage();
//						}
//					fscanf(stdin, "%lf", &omega);
//					if (omega < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad omega (%3.2f)\n\n", omega);
//						PrintUsage();
//						}
//					OmegaInit = omega;
//					/*fprintf (stderr, "\n\n %d %lf %lf \n",numOmegaCat, OmegaRateHet, omega);*/
//					}
//				else if (modelNumber == 5) /** omega by continuous gamma heterogeneous rate **/
//					{
//					/*fprintf (stderr, "\n lee file model M1 \n\n");*/
//					doOmegaCat = NO;
//					doOmegaRateHetCont = YES;
//					doOmegaRateHetDisc = NO;
//					
//					fscanf(stdin, "%lf", &OmegaRateHet);
//					if (OmegaRateHet <= 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad omega heterogeneous rate (%3.2f)\n\n", OmegaRateHet);
//						PrintUsage();
//						}
//					fscanf(stdin, "%lf", &omega);
//					if (omega < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad omega (%3.2f)\n\n", omega);
//						PrintUsage();
//						}
//					OmegaInit = omega;
//					}
//				else if (modelNumber == 6) /** M6 model (cont 2gamma): p0 p q, w **/
//					{
//					/* MIGUEL: esta en input from command line? */
//					doM6 = YES;
//	
//					doOmegaCat = NO;
//					doOmegaRateHetCont = NO;
//					doOmegaRateHetDisc = NO;
//				
//					fscanf(stdin, "%lf", &M6_P0);
//					if (M6_P0 < 0.0 || M6_P0 > 1.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad P0 in codon model M6 (%3.2f)\n\n", M6_P0);
//						PrintUsage();
//						}
//					M6_P1 = 1 - M6_P0;
//					
//					fscanf(stdin, "%lf", &OmegaRateHetM6_0);
//					if (OmegaRateHetM6_0 <= 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad omega heterogeneous rate(0) in M6 (%3.2f)\n\n", OmegaRateHetM6_0);
//						PrintUsage();
//						}
//					fscanf(stdin, "%lf", &OmegaM6_0);
//					if (OmegaM6_0 < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad omega(0) in codon model M6 (%3.2f)\n\n", OmegaM6_0);
//						PrintUsage();
//						}
//
//					fscanf(stdin, "%lf", &OmegaRateHetM6_1);
//					if (OmegaRateHetM6_1 <= 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad omega heterogeneous rate(1) in codon model M6 (%3.2f)\n\n", OmegaRateHetM6_1);
//						PrintUsage();
//						}
//					OmegaM6_1 = OmegaRateHetM6_1; /* because in M6 codon model the second gamma distribution has p=q */
//
//
//					OmegaInitM6_0 = OmegaM6_0;
//					OmegaInitM6_1 = OmegaM6_1;
//					/* M6_P0, M6_P1; OmegaRateHetM6_0 OmegaM6_0 OmegaInitM6_0; OmegaRateHetM6_1 OmegaM6_1 OmegaInitM6_1 */
//					}
//				else if (modelNumber == 7) /** M7 **/
//					{
//					doM7 = YES;
//
//					doOmegaCat = NO;
//					doOmegaRateHetCont = NO;
//					doOmegaRateHetDisc = NO;
//				
//					fscanf(stdin, "%lf", &M7_p_beta);
//					if (M7_p_beta < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad p in model M7 (%3.2f)\n\n", M7_p_beta);
//						PrintUsage();
//						}
//					
//					fscanf(stdin, "%lf", &M7_q_beta);
//					if (M7_q_beta < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad q in model M7 (%3.2f)\n\n", M7_q_beta);
//						PrintUsage();
//						}
//
//					}
//				else if (modelNumber == 8) /** M8 **/
//					{
//					doM8 = YES;
//
//					doOmegaCat = NO;
//					doOmegaRateHetCont = NO;
//					doOmegaRateHetDisc = NO;
//
//					fscanf(stdin, "%lf", &M8_P0_beta);
//					if (M8_P0_beta < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad P0 in model M8 (%3.2f)\n\n", M8_P0_beta);
//						PrintUsage();
//						}
//					M8_P1_omega = 1 - M8_P0_beta;
//					
//					fscanf(stdin, "%lf", &M8_p_beta);
//					if (M8_p_beta < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad p in model M8 (%3.2f)\n\n", M8_p_beta);
//						PrintUsage();
//						}
//					
//					fscanf(stdin, "%lf", &M8_q_beta);
//					if (M8_q_beta < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad q in model M8 (%3.2f)\n\n", M8_q_beta);
//						PrintUsage();
//						}
//					
//					fscanf(stdin, "%lf", &M8_omegaP1);
//					if (M8_omegaP1 < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad omega for P1 in model M8 (%3.2f)\n\n", M8_omegaP1);
//						PrintUsage();
//						}
//					}
//				else if (modelNumber == 9 || modelNumber == 10) /** M9 - M10 **/
//					{ /* [M9 or M10 models: p0 p q; a b] */
//
//					if (modelNumber == 9)
//						doM9 = YES;
//					else if (modelNumber == 10)
//						doM10 = YES;
//					else
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad codon model chosen (9-10) (%d) in parameters File\n\n", modelNumber);
//						PrintUsage();
//						}
//
//					doOmegaCat = NO;
//					doOmegaRateHetCont = NO;
//					doOmegaRateHetDisc = NO;
//				
//
//					fscanf(stdin, "%lf", &M910_P0);
//					if (M910_P0 < 0.0 || M910_P0 > 1.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad P0 in codon model M9 or M10 (%3.2f)\n\n", M910_P0);
//						PrintUsage();
//						}
//					M910_P1 = 1 - M910_P0;
//					
//					/* beta */
//					fscanf(stdin, "%lf", &M910_p_beta);
//					if (M910_p_beta < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad p in model M9 or M10 (%3.2f)\n\n", M910_p_beta);
//						PrintUsage();
//						}
//					
//					fscanf(stdin, "%lf", &M910_q_beta);
//					if (M910_q_beta < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad q in model M9 or M10 (%3.2f)\n\n", M910_q_beta);
//						PrintUsage();
//						}
//
//					/* gamma */
//					fscanf(stdin, "%lf", &OmegaRateHetM910_1);
//					if (OmegaRateHetM910_1 <= 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad omega heterogeneous rate in M9 or M10 (%3.2f)\n\n", OmegaRateHetM910_1);
//						PrintUsage();
//						}
//
//					fscanf(stdin, "%lf", &OmegaM910_1);
//					if (OmegaM910_1 < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad omega in M9 or M10 (%3.2f)\n\n", OmegaM910_1);
//						PrintUsage();
//						}
//					
//					OmegaInitM910_1 = OmegaM910_1;
//					/* M910_P0, M910_P1; M910_p_beta M910_q_beta; OmegaRateHetM910_1 OmegaM910_1 OmegaInitM910_1 */
//					}
//				else if (modelNumber == 0) /** MG94 codon model **/
//					{
//					doMG94 = YES;
//
//					doOmegaCat = NO;
//					doOmegaRateHetCont = NO;
//					doOmegaRateHetDisc = NO;
//				
//					fscanf(stdin, "%lf", &SynRate);
//					if (SynRate < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad synonymous rate in MG94 model (%3.2f)\n\n", SynRate);
//						PrintUsage();
//						}
//					
//					fscanf(stdin, "%lf", &NonSynRate);
//					if (NonSynRate < 0.0)
//						{
//						fprintf (stderr, "PARAMETER ERROR: Bad non-synonymous rate in MG94 model (%3.2f)\n\n", NonSynRate);
//						PrintUsage();
//						}
//					}
//				else
//					{
//					fprintf (stderr, "PARAMETER ERROR: Bad codon model chosen (0-10) (%d) in parameters File\n\n", modelNumber);
//					PrintUsage();
//					}
//				sumPi = sumPi_b = 0.0;
//			break;
			case 'F':
				if (fscanf(stdin, "%f", &argument) !=1 || argument > 20) 
					{
					fprintf (stderr, "PARAMETER ERROR: Bad number of frequencies (4 or 12) (%d)\n\n", (int) argument);
					PrintUsage();
					}
				freqNumber = (int) argument;
				
				doFreqGiven = YES;
				/*fprintf (stderr, ">> Reanding F\n\n");*/


				if (freqNumber == 4)
					{
					if (fscanf(stdin, "%lf %lf %lf %lf", &p_i[0], &p_i[1], &p_i[2], &p_i[3])!=4) 
						{
						fprintf(stderr, "PARAMETER ERROR: Bad Base Frequencies (put only 4 base frequencies) \n\n");
						PrintUsage();
						}
					
					equalBaseFreq = YES;
					for (i = 1; i < 4; i++)		
						if (p_i[i] != p_i[i-1])
							{
							equalBaseFreq = NO;
							break;
							}
							
					sumPi = p_i[0] + p_i[1] + p_i[2] + p_i[3];
					if (sumPi !=1.0) 
						{
						p_i[0]/=sumPi;
						p_i[1]/=sumPi;
						p_i[2]/=sumPi;
						p_i[3]/=sumPi;
						}
					p_i_codon[0]=p_i[0];
					p_i_codon[1]=p_i[1];
					p_i_codon[2]=p_i[2];
					p_i_codon[3]=p_i[3];
					p_i_codon[4]=p_i[0];
					p_i_codon[5]=p_i[1];
					p_i_codon[6]=p_i[2];
					p_i_codon[7]=p_i[3];
					p_i_codon[8]=p_i[0];
					p_i_codon[9]=p_i[1];
					p_i_codon[10]=p_i[2];
					p_i_codon[11]=p_i[3];	

					NumberFrequencies = 4;				
					}
				else if (freqNumber == 12) 
					{
					fscanf(stdin, "%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf", &p_i_codon[0], &p_i_codon[1], &p_i_codon[2], &p_i_codon[3], 
					&p_i_codon[4], &p_i_codon[5], &p_i_codon[6], &p_i_codon[7], &p_i_codon[8], &p_i_codon[9], &p_i_codon[10], &p_i_codon[11]);
						
					for (i = 0; i < 12; i++)
						if (p_i_codon[i] < 0 || p_i_codon[i] > 1)
							{
							fprintf (stderr, "PARAMETER ERROR: Bad number of enter frequencies (it must to be between 0 and 1) (%lf)\n\n", p_i_codon[i]);
							PrintUsage();
							}
					equalBaseFreqCod = YES;
					for (i = 1; i < 12; i++)		
						if (p_i_codon[i] != p_i_codon[i-1])
							{
							equalBaseFreqCod = NO;
							break;
							}		
					
					sumPi_Cod_first = p_i_codon[0] + p_i_codon[1] + p_i_codon[2] + p_i_codon[3];
					sumPi_Cod_second = p_i_codon[4] + p_i_codon[5] + p_i_codon[6] + p_i_codon[7];
					sumPi_Cod_third = p_i_codon[8] + p_i_codon[9] + p_i_codon[10] + p_i_codon[11];
					if (sumPi_Cod_first != 1.0) 
						{
						p_i_codon[0]/=sumPi_Cod_first;
						p_i_codon[1]/=sumPi_Cod_first;
						p_i_codon[2]/=sumPi_Cod_first;
						p_i_codon[3]/=sumPi_Cod_first;
						}
					if (sumPi_Cod_second != 1.0) 
						{
						p_i_codon[4]/=sumPi_Cod_second;
						p_i_codon[5]/=sumPi_Cod_second;
						p_i_codon[6]/=sumPi_Cod_second;
						p_i_codon[7]/=sumPi_Cod_second;
						}
					if (sumPi_Cod_third != 1.0) 
						{
						p_i_codon[8]/=sumPi_Cod_third;
						p_i_codon[9]/=sumPi_Cod_third;
						p_i_codon[10]/=sumPi_Cod_third;
						p_i_codon[11]/=sumPi_Cod_third;
						}

					NumberFrequencies = 12;
					}
				else if (freqNumber == 20) /* amino acid model: p_i_aa */
					{
					fscanf(stdin, "%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf", &p_i_aa[0], &p_i_aa[1], &p_i_aa[2], &p_i_aa[3], 
						&p_i_aa[4], &p_i_aa[5], &p_i_aa[6], &p_i_aa[7], &p_i_aa[8], &p_i_aa[9], &p_i_aa[10], &p_i_aa[11], &p_i_aa[12], &p_i_aa[13], 
						&p_i_aa[14], &p_i_aa[15], &p_i_aa[16], &p_i_aa[17], &p_i_aa[18], &p_i_aa[19]);
					
					
					if (freqNumber != 20)
						{
						fprintf (stderr, "PARAMETER ERROR: Bad parameter from frequencies. (-p) must me only used with (-f20) \n");
						fprintf (stderr, "In case you are already simulating amino acid sequences, try to introduce the argument -f before the argument -p. \n\n");
						PrintUsage();
						}

					for (i = 0; i < 20; i++)
						if (p_i_aa[i] < 0 || p_i_aa[i] > 1)
							{
							fprintf (stderr, "PARAMETER ERROR: Bad number of enter frequencies (it must to be between 0 and 1) (%lf)\n\n", p_i_aa[i]);
							PrintUsage();
							}

					equalBaseFreqAA = YES;
					for (i = 1; i < 20; i++)		
						if (p_i_aa[i] != p_i_aa[i-1])
							{
							equalBaseFreqAA = NO;
							break;
							}		
					

					sumPi_AA = 0.0;
					for (i = 0; i < 20; i++)
						{
						sumPi_AA = sumPi_AA + p_i_aa[i];
						}
					
					if (sumPi_AA != 1.0) 
						{
						for (i = 0; i < 20; i++)
							{
							p_i_aa[i]/=sumPi_AA;
							}
						}

					NumberFrequencies = 20;

					}
				else
					{
					fprintf (stderr, "PARAMETER ERROR: Bad number of frequencies (4, 12 or 20) (%d)\n\n", freqNumber);
					PrintUsage();
					}
			break;
			case 'P':
				ch=fgetc(stdin);
				if(isspace(ch))
					strcpy(treeFileName, "treefile");
				else
					{
					j=0;
					do
						{
						treeFileName[j]=ch;
						j++;
						ch=fgetc(stdin);
						}
					while(!isspace(ch));
					treeFileName[j]='\0';
					}

				doGivenUserTrees = YES;
				/* fprintf(stderr, "\n Trees from the user \"%s\" \n\n", treeFileName);*/
			break;
			case 'V':
				if (fscanf(stdin, "%f", &argument)!=1) 
					{
					fprintf (stderr, "PARAMETER ERROR: Bad rates of change chosen (v) (1, 6 or 12) (%d)\n\n", (int) argument);
					PrintUsage();
					}
				RatesNumber = (int) argument;
				

				if (RatesNumber == 1)
					{
					if (fscanf(stdin, "%lf", &titv)!=1) 
						{
						fprintf(stderr, "PARAMETER ERROR: Bad ti/tv (%f) \n\n", titv);
						PrintUsage();
						}
					/*else
						{
						if (doCodonModel == NO)
							doHKY = YES;
						else
							{
							doCodon_HKY = YES;
							doCodon_GTR = NO;
							doCodon_NGTR = NO;
							}
						}*/
					
					}
				else if (RatesNumber == 6)
					{
					if (fscanf(stdin, "%lf %lf %lf %lf %lf %lf", &Rmat[0], &Rmat[1], 
												&Rmat[2], &Rmat[3], &Rmat[4], &Rmat[5])!=6) 
						{
						fprintf(stderr, "PARAMETER ERROR: Bad general rate matrix (-rx x x x x x)\n\n");
						PrintUsage();
						}
					if (Rmat[5]!=1.0) 
						{
						for (j=0; j<5; j++) 
							Rmat[j]/=Rmat[5];
						Rmat[5]=1.0;
						}
					/*doGTR = YES;
					doHKY = NO;
					doGTnR = NO;
					if (doCodonModel == YES)
						{
						doGTnR = NO;
						doHKY = NO;
						doGTR = NO;
						doCodon_GTR = YES;
						doCodon_HKY = NO;
						doCodon_NGTR = NO;
						}*/
					}
				else if (RatesNumber == 12)
					{
					if (fscanf(stdin, "%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf", &NRmat[0], &NRmat[1], &NRmat[2], &NRmat[3], &NRmat[4], &NRmat[5],
									&NRmat[6], &NRmat[7], &NRmat[8], &NRmat[9], &NRmat[10], &NRmat[11])!=12) 
						{
						fprintf(stderr, "Bad general rate matrix (-rx x x x x x x x x x x) (AC CA AG GA AT TA CG GC CT TC GT=1 TG)\n\n");
						PrintUsage();
						}
					if (NRmat[10]!=1.0) 
						{
						for (j=0; j<12; j++)
							{
							/*fprintf(stderr, "j = %d \n", j);*/
							if (j != 10)
								{
								NRmat[j]/=NRmat[10];
								}	
							}
						NRmat[10]=1.0;
						
						/*fprintf(stderr, "PARAMETERS: %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf \n\n", NRmat[0], NRmat[1], NRmat[2], NRmat[3], NRmat[4], NRmat[5],
									NRmat[6], NRmat[7], NRmat[8], NRmat[9], NRmat[10], NRmat[11]);*/
						}
					/*for (j=0; j<12; j++)
						printf ("\nR-matrix                            =  %3.2f", NRmat[j]);*/
				
					/*doGTR = NO;
					doGTnR = YES;
					doHKY = NO;
					if (doCodonModel == YES)
						{
						doGTnR = NO;
						doHKY = NO;
						doGTR = NO;
						doCodon_GTR = NO;
						doCodon_HKY = NO;
						doCodon_NGTR = YES;
						}*/
					}
				else
					{
					fprintf(stderr, "PARAMETER ERROR: Bad rates of change (-v 1, 6 or 12) (%d) \n\n", RatesNumber);
					PrintUsage();
					}

			break;
			case '@':
				ch=fgetc(stdin);
				if(isspace(ch))
					strcpy(AAmodel, "AAmodel00");
				else
					{
					j=0;
					do
						{
						AAmodel[j]=ch;
						j++;
						ch=fgetc(stdin);
						}
					while(!isspace(ch));
					AAmodel[j]='\0';
					}

				if (AAmodel[0] == 'B' && AAmodel[1] == 'l' && AAmodel[2] == 'o' && AAmodel[3] == 's' && AAmodel[4] == 'u' && AAmodel[5] == 'm' && AAmodel[6] == '6' && AAmodel[7] == '2')
					{
					doBlosum62 = YES;
					}
				else if (AAmodel[0] == 'C' && AAmodel[1] == 'p' && AAmodel[2] == 'R' && AAmodel[3] == 'e' && AAmodel[4] == 'v')
					{
					doCpRev = YES;
					}
				else if (AAmodel[0] == 'D' && AAmodel[1] == 'a' && AAmodel[2] == 'y' && AAmodel[3] == 'h' && AAmodel[4] == 'o' && AAmodel[5] == 'f' && AAmodel[6] == 'f'&& AAmodel[7] == 'D' && AAmodel[8] == 'C' && AAmodel[9] == 'M' && AAmodel[10] == 'U' && AAmodel[11] == 'T')
					{
					doDayhoffDCMUT = YES;
					/*fprintf(stderr, "\n\ndoDayhoff-dcmut\n\n");*/
					}
				else if (AAmodel[0] == 'D' && AAmodel[1] == 'a' && AAmodel[2] == 'y' && AAmodel[3] == 'h' && AAmodel[4] == 'o' && AAmodel[5] == 'f' && AAmodel[6] == 'f' && doDayhoffDCMUT == NO)
					{
					doDayhoff = YES;
					/*fprintf(stderr, "\n\ndoDayhoff\n\n");*/
					}
				else if (AAmodel[0] == 'H' && AAmodel[1] == 'I' && AAmodel[2] == 'V' && AAmodel[3] == 'b')
					{
					doHIVb = YES;
					}
				else if (AAmodel[0] == 'H' && AAmodel[1] == 'I' && AAmodel[2] == 'V' && AAmodel[3] == 'w')
					{
					doHIVw = YES;
					}
				else if (AAmodel[0] == 'J' && AAmodel[1] == 'T' && AAmodel[2] == 'T')
					{
					doJTT = YES;
					/*fprintf(stderr, "\n OK JTT! \n\n");*/
					}
				else if (AAmodel[0] == 'J' && AAmodel[1] == 'o' && AAmodel[2] == 'n' && AAmodel[3] == 'e' && AAmodel[4] == 's' && AAmodel[5] == 'D' && AAmodel[6] == 'C' && AAmodel[7] == 'M' && AAmodel[8] == 'U' && AAmodel[9] == 'T')
					{
					doJonesDCMUT = YES;
					}
				else if (AAmodel[0] == 'L' && AAmodel[1] == 'G')
					{
					doLG = YES;
					}
				else if (AAmodel[0] == 'M' && AAmodel[1] == 't' && AAmodel[2] == 'a' && AAmodel[3] == 'r' && AAmodel[4] == 't')
					{
					doMtart = YES;
					}
				else if (AAmodel[0] == 'M' && AAmodel[1] == 't' && AAmodel[2] == 'm' && AAmodel[3] == 'a' && AAmodel[4] == 'm')
					{
					doMtmam = YES;
					}
				else if (AAmodel[0] == 'M' && AAmodel[1] == 't' && AAmodel[2] == 'r' && AAmodel[3] == 'e' && AAmodel[4] == 'v' && AAmodel[5] == '2' && AAmodel[6] == '4')
					{
					doMtrev24 = YES;
					}
				else if (AAmodel[0] == 'R' && AAmodel[1] == 't' && AAmodel[2] == 'R' && AAmodel[3] == 'e' && AAmodel[4] == 'v')
					{
					doRtRev = YES;
					}
				else if (AAmodel[0] == 'V' && AAmodel[1] == 'T')
					{
					doVT = YES;
					}
				else if (AAmodel[0] == 'W' && AAmodel[1] == 'A' && AAmodel[2] == 'G')
					{
					doWAG = YES;
					}
				else /* this should mean the user introduces a particular EAAM by an input file */
					{
					doEAAMUser = YES;
					}
	
				/* fprintf(stderr, "\n AA model selected is \"%s\" \n\n", AAmodel);*/
				/* Blosum62, CpRev, Dayhoff, DayhoffDCMUT, HIVb, HIVw, JTT, JonesDCMUT, LG, Mtart, Mtmam, Mtrev24, RtRev, VT, WAG, User */
			break;	
			case 'I':
				if (fscanf(stdin, "%lf", &pinv)!=1) 
					{
					fprintf(stderr, "PARAMETER ERROR: Bad p-inv (%f) \n\n", pinv);
					PrintUsage();
					}
			break;
			case 'A':
				if (fscanf(stdin, "%lf", &alpha)!=1 || alpha<=0.0) 
					{
					fprintf(stderr, "PARAMETER ERROR: Bad Gamma Shape (%f) \n", alpha);
					exit(0);
					}
				else
					doRateHet = YES;
			break;
			case 'C':
				/* format: phylip/fasta/nexus format (1-3) */
				if (fscanf(stdin, "%f", &argument) !=1 || argument > 10) 
					{
					fprintf (stderr, "PARAMETER ERROR: Bad format of output alignments files chosen (1-3) (%d)\n\n", (int) argument);
					PrintUsage();
					}
				formatNumber = (int) argument;
				
				if (formatNumber == 1) /* phylip */
					{
					doPrintFASTA = NO;
					doPrintNEXUS = NO;
					}
				if (formatNumber == 2) /* fasta */
					{
					doPrintFASTA = YES;
					doPrintNEXUS = NO;
					}
				if (formatNumber == 3) /* nexus */
					{
					doPrintFASTA = NO;
					doPrintNEXUS = YES;
					}
				if (formatNumber > 3 || formatNumber < 1)
					{
					fprintf (stderr, "PARAMETER ERROR: Bad format of output alignments files chosen (1-3) (%d)\n\n", (int) argument);
					PrintUsage();
					}

				/* multiple aligment files (0-1) */	
				fscanf(stdin, "%d", &yesHere);
				if (yesHere < 0 || yesHere > 1)
					{
					fprintf (stderr, "PARAMETER ERROR: Bad print multiple aligment files option (0:no or 1:yes) (%d)\n\n", yesHere);
					PrintUsage();
					}
				if (yesHere == 1)
					doSeparatedSequences = YES;

				
				/* print ancestral states */
				yesHere = 0;
				fscanf(stdin, "%d", &yesHere);
				if (yesHere < 0 || yesHere > 1)
					{
					fprintf (stderr, "PARAMETER ERROR: Bad print ancestral states  option (0:no or 1:yes) (%d)\n\n", yesHere);
					PrintUsage();
					}
				if (yesHere == 1)
					doPrintAncestralSequences = YES;

			break;
			case '*':
				ch=fgetc(stdin);
				if(isspace(ch))
					strcpy(networkOut, "networkfile");
				else
					{
					j=0;
					do
						{
						networkOut[j]=ch;
						j++;
						ch=fgetc(stdin);
						}
					while(!isspace(ch));
					networkOut[j]='\0';
					}
				doBranchNetfiles = YES;				
			break;
			case 'Z':
				ch=fgetc(stdin);
				if(isspace(ch))
					strcpy(ProtStabAAFile, "Pop_evol.in");
				else
					{
					j=0;
					do
						{
						ProtStabAAFile[j]=ch;
						j++;
						ch=fgetc(stdin);
						}
					while(!isspace(ch));
					ProtStabAAFile[j]='\0';
					}
		
			doProtStabAAFile = YES;
			/*fprintf(stderr, "\n Setting for Structural protein stability (AA) file: \"%s\" \n\n", ProtStabAAFile);*/
			break;
			/*case 'Z':
				ch=fgetc(stdin);
				if(isspace(ch))
					strcpy(ECodonModel, "CodonModel00");
				else
					{
					j=0;
					do
						{
						ECodonModel[j]=ch;
						j++;
						ch=fgetc(stdin);
						}
					while(!isspace(ch));
					ECodonModel[j]='\0';
					}

			if (ECodonModel[0] == 'E' && ECodonModel[1] == 'C' && ECodonModel[2] == 'M' && ECodonModel[3] == 'r' && ECodonModel[4] == 'e' && ECodonModel[5] == 's' && ECodonModel[6] == 't')
				{
				doECMrest = YES;
				}
			else if (ECodonModel[0] == 'E' && ECodonModel[1] == 'C' && ECodonModel[2] == 'M' && ECodonModel[3] == 'u' && ECodonModel[4] == 'n' && ECodonModel[5] == 'r' && ECodonModel[6] == 'e' && ECodonModel[7] == 's' && ECodonModel[8] == 't')
				{
				doECMunrest = YES;
				}
			else if (ECodonModel[0] == 'E' && ECodonModel[1] == 'C' && ECodonModel[2] == 'M' && ECodonModel[3] == 'S' && ECodonModel[4] == 'c' && ECodonModel[5] == 'h' && ECodonModel[6] == 'n' && ECodonModel[7] == '2' && ECodonModel[8] == '0' && ECodonModel[9] == '0' && ECodonModel[10] == '5')
				{
				doECMSchn = YES;
				}
			else 
				{
				doECMuser = YES;
				}
			
			doOmegaCat = NO;
			doOmegaRateHetCont = NO;
			doOmegaRateHetDisc = NO;
			break;*/
			case '$':
				doOutMRCAfiles = YES;
			break;
			case '+':
				doPrintOmegasPerSitefiles = YES;
			break;
			case 'N':
				if (fscanf(stdin, "%d", &numDataSets)!=1 || numDataSets <1)
					{
					fprintf(stderr, "PARAMETER ERROR: Bad number of replicates (%d)\n\n",numDataSets);
					PrintUsage();
					}
			break;
			case 'Y':
				if (fscanf(stdin, "%d", &noisy)!=1 || noisy <0)
					{
					fprintf(stderr, "PARAMETER ERROR: Bad noisy value (%d)\n\n", noisy);
					PrintUsage();
					}
			break;
			case 'W':
				if (recombinationRate <= 0)
					{
					fprintf (stderr, "PARAMETER ERROR: Cannot fix number of recombination events when the recombination rate is 0\n\n");
					PrintUsage();
					}	
				if (fscanf(stdin, "%d", &fixedNumRecEvents) !=1 || fixedNumRecEvents <= 0)
					{
					fprintf(stderr, "PARAMETER ERROR: Bad fixed number of recombination events (%d)\n\n", fixedNumRecEvents);
					PrintUsage();
					}
				doFixNumRecEvents = YES;
			break;
			case 'H':
				ch=fgetc(stdin);
				if(isspace(ch))
					strcpy(HetRecFile, "HetRec");
				else
					{
					j=0;
					do
						{
						HetRecFile[j]=ch;
						j++;
						ch=fgetc(stdin);
						}
					while(!isspace(ch));
					HetRecFile[j]='\0';
					}
		
			doHetRecFile = YES;
			
			/*fprintf(stderr, "\n Setting for Het Rec selected: \"%s\" \n\n", HetRecFile);*/
			break;
			case 'O':
				if (fscanf(stdin, "%lf", &outgroupBranchLength) <= 0)
					{
					fprintf(stderr, "PARAMETER ERROR: Bad outgroup branch lenght value (%f)\n\n", outgroupBranchLength);
					PrintUsage();
					}
				else
					thereisOutgroup = YES;
			break;
			case 'G':
				if (fscanf(stdin, "%f", &argument) > 1 || argument < 0) 
					{
					fprintf (stderr, "PARAMETER ERROR: Bad number to choose between growth rate (0) or demographic periods (1) using -g (%d)\n\n", (int) argument);
					PrintUsage();
					}
				GrowthRate_or_DemographicPeriods = (int) argument;
				
				if (GrowthRate_or_DemographicPeriods == 0) /* growth rate */
					{
					
					if (fscanf(stdin, "%lf", &growthRate) !=1) 
						{
						fprintf (stderr, "PARAMETER ERROR: Bad growth rate (%f)\n\n", growthRate);
						PrintUsage();
						}

					/*if (growthRate != 0) 
		    			{
	    				doExponential = YES;
		    	    	if (doDemographics == YES)
							{
							fprintf (stderr, "PARAMETER ERROR: Cannot have both exponential (-g) and other demographics(-p)\n\n");
							exit (1);
							}
						}*/

					}
				else if (GrowthRate_or_DemographicPeriods == 1) /* demographic periods */
					{
					/*doDemographics = YES;*/
					
					fscanf(stdin, "%d", &numPeriods);
					if (numPeriods < 0)
						{
						fprintf (stderr, "PARAMETER ERROR: Bad number of periods (%d)\n\n", numPeriods);
						PrintUsage();
						}	
					/*if (numPeriods == 0)
						doDemographics = NO;*/

					if (numPeriods > 0)
						{
						Nbegin =	(int *) calloc(numPeriods+1,(long) sizeof(int));
						Nend = 		(int *) calloc(numPeriods+1,(long) sizeof(int));
						cumDuration =	(int *) calloc(numPeriods+1,(long) sizeof(int));
						periodGrowth =	(double *) calloc(numPeriods+1,(long) sizeof(double));
						if (Nbegin == NULL || Nend == NULL || cumDuration == NULL)
							{
							fprintf (stderr, "PARAMETER ERROR: Could not allocate demographic vectors (%lu bytes)\n", numPeriods *(long) sizeof(int));
							exit (1);
							}
						for (j=1; j<=numPeriods; j++)
							{
							fscanf(stdin, "%f", &argument);
							Nbegin[j] = (int) argument;
							fscanf(stdin, "%f", &argument);
							Nend[j] = (int) argument;
							fscanf(stdin, "%f", &argument);
							cumDuration[j] = (int) argument + cumDuration[j-1];
							}
						}

					}
				else
					{
					fprintf (stderr, "PARAMETER ERROR: Bad number to choose between growth rate (0) or demographic periods (1) using -g (%d)\n\n", GrowthRate_or_DemographicPeriods);
					PrintUsage();
					}
				
			break;
			case 'T':
				/* [t1 0.001] [t2 100 0.001 0.005] [t3 100 1000 0.001 0.005 0.001] */
				if (fscanf(stdin, "%f", &argument) !=1 || argument <= 0) 
					{
					fprintf (stderr, "PARAMETER ERROR: Bad number of periods for variable migration rate (must be 1 or higher) (%d)\n\n", (int) argument);
					PrintUsage();
					}
				numMigRatePeriods = (int) argument;

				if (numMigRatePeriods == 1) /* 1 period */
					{
					doMigRatePeriods = NO;
					
					fscanf(stdin, "%lf", &migrationRate);
					if (migrationRate <= 0)
						{
						fprintf (stderr, "PARAMETER ERROR: Bad migration rate (should be higher than 0) (%lf)\n\n", migrationRate);
						PrintUsage();
						}
					}
				else /* more than 1 period */
					{
					doMigRatePeriods = YES;

					MigTbegin =	(int *) calloc(numMigRatePeriods+1,(long) sizeof(int));
					periodMigrationRate =	(double *) calloc(numMigRatePeriods+1,(long) sizeof(double));
					if (MigTbegin == NULL || periodMigrationRate == NULL)
						{
						fprintf (stderr, "PARAMETER ERROR: Could not allocate temporal migration rate vectors (%lu bytes)\n", numMigRatePeriods *(long) sizeof(int));
						exit (1);
						}
					
					for (j=1; j<=numMigRatePeriods-1; j++)
						{
						fscanf(stdin, "%f", &argument);
						MigTbegin[j] = (int) argument;
						if (MigTbegin[j] <= 0)
							{
							fprintf (stderr, "PARAMETER ERROR: Bad time for migration rate variation (should be higher than 0) (%d)\n\n", MigTbegin[j]);
							PrintUsage();
							}
						}
					for (j=1; j<=numMigRatePeriods; j++)
						{
						fscanf(stdin, "%f", &argument);
						periodMigrationRate[j] = (double) argument;
						if (periodMigrationRate[j] < 0)
							{
							fprintf (stderr, "PARAMETER ERROR: Bad migration rate (should not be negative) (%lf)\n\n", periodMigrationRate[j]);
							PrintUsage();
							}
						}
					}
			break;
			case 'Q':
				/*doMigration = YES;*/ 
	        	sumPopul = 0;
				
				if (fscanf(stdin, "%f", &argument) !=1 || argument < 1 || argument > 3) /* migrationModel = 1, 2, 3 */
					{
					fprintf (stderr, "PARAMETER ERROR: Bad migration model (%d)\n\n", (int) argument);
					PrintUsage();
					}
				migrationModel = (int) argument;
				

				if (fscanf(stdin, "%f", &argument) !=1 || argument < 1 || argument > numSequences) 
					{
					fprintf (stderr, "PARAMETER ERROR: Bad number of subpopulations (%d)\n\n", (int) argument);
					PrintUsage();
					}
				numPopulations = (int) argument;
				
				initPopulation = (int *) calloc(numPopulations+1,(long) sizeof(int));
				if (!initPopulation)
					{
					fprintf (stderr, "PARAMETER ERROR: Could not allocate initPopulation of migration model (%lu bytes)\n", (numPopulations+1) *(long) sizeof(int));
					exit (1);
					}
				for (j=1; j<=numPopulations; j++)
					{
					fscanf(stdin, "%d", &initPopulation[j]);
					if (initPopulation[j] > numSequences || initPopulation[j] <= 0)
						{
						fprintf (stderr, "PARAMETER ERROR: Bad initial subpopulation (%d)\n\n", initPopulation[j]);
						PrintUsage();
						}
					sumPopul = sumPopul + initPopulation[j];
					}
				/*fscanf(stdin, "%lf", &migrationRate);
				if (migrationRate < 0)
					{
					fprintf (stderr, "PARAMETER ERROR: Bad migration rate (%lf)\n\n", migrationRate);
					PrintUsage();
					}*/
				if (sumPopul != numSequences)
					{
					fprintf (stderr, "\n PARAMETER ERROR: Bad initial population. The sample size (%d) is different to the sum of nodes in demes (%d) \n\n", numSequences, sumPopul);
					PrintUsage();
					}

			break;
			case '%':
				if (fscanf(stdin, "%f", &argument) !=1 || argument < 1 || argument >= numSequences) 
					{
					fprintf(stderr, "PARAMETER ERROR: Bad number of convergencies demes events (%d) \n\n", numConvergDemes);
					PrintUsage();
					}
				numConvergDemes = (int) argument;
				/*fprintf(stderr, "\n\n numConvergDemes = %d \n", numConvergDemes);*/
				
				deme_a_old = (int *) calloc(numConvergDemes+1,(long) sizeof(int));
				if (!deme_a_old)
					{
					fprintf (stderr, "PARAMETER ERROR: Could not allocate deme_a of convergencies demes events (%lu bytes)\n", (numConvergDemes+1) *(long) sizeof(int));
					exit (1);
					}
				deme_b_old = (int *) calloc(numConvergDemes+1,(long) sizeof(int));
				if (!deme_b_old)
					{
					fprintf (stderr, "PARAMETER ERROR: Could not allocate deme_b of convergencies demes events (%lu bytes)\n", (numConvergDemes+1) *(long) sizeof(int));
					exit (1);
					}
				convDemTimes_old = (double*) calloc ((numConvergDemes+1), sizeof (double)); 
				if (convDemTimes_old == NULL)
					{
					fprintf (stderr, "PARAMETER ERROR: Could not allocate convDemTimes of convergencies demes events (%lu bytes)\n", (numConvergDemes+1) *(long) sizeof(double));
					exit (1);
					}
				if (numConvergDemes > 0)
					{
					for (j=1; j<=numConvergDemes; j++)
						{
						fscanf(stdin, "%f", &argument);
						deme_a_old[j] = (int) argument;
						fscanf(stdin, "%f", &argument);
						deme_b_old[j] = (int) argument;
						fscanf(stdin, "%f", &argument);
						convDemTimes_old[j] = (double) argument;
						}
					for (j=1; j<=numConvergDemes; j++)
						{
						/*fprintf(stderr, "\n\n deme_a_old[%d] = %d \n", j, deme_a_old[j]);
						fprintf(stderr, "\n\n deme_b_old[%d] = %d \n", j, deme_b_old[j]);
						fprintf(stderr, "\n\n convDemTimes_old[%d] = %lf \n", j, convDemTimes_old[j]);*/
						if (deme_a_old[j] == deme_b_old[j])
							{
							fprintf (stderr, "PARAMETER ERROR: Bad number of deme in convergencies demes events (%d)(%d), they must to be differents\n\n", deme_a_old[j], deme_b_old[j]);
							PrintUsage();
							}
						if (convDemTimes_old[j] <= 0)
							{
							fprintf (stderr, "PARAMETER ERROR: Bad time to convergencies demes events (%lf)\n\n", convDemTimes_old[j]);
							PrintUsage();
							}
						}
					k = h = 0;
					for (j=1; j<=numConvergDemes; j++)
						{
						k = convDemTimes_old[j];
						for (h=1; h<=numConvergDemes; h++)
							{
							if (j != h && convDemTimes_old[j] == convDemTimes_old[h])
								{
								fprintf (stderr, "PARAMETER ERROR: Bad time to convergencies demes events (%lf), it can not have two events at the same time\n\n", convDemTimes_old[h]);
								PrintUsage();
								}
							if (j != h && deme_a_old[j] == deme_a_old[h])
								{
								fprintf (stderr, "PARAMETER ERROR: Bad number of demes to convergencies demes events (%d)(%d), it can not have a same deme converging at two different times\n\n", deme_a_old[j], deme_a_old[h]);
								PrintUsage();
								}
							if (j != h && deme_b_old[j] == deme_b_old[h])
								{
								fprintf (stderr, "PARAMETER ERROR: Bad number of demes to convergencies demes events (%d)(%d), it can not have a same deme converging at two different times\n\n", deme_b_old[j], deme_b_old[h]);
								PrintUsage();
								}
							}
						}
				}
			break;
			case 'B':
				ch=fgetc(stdin);
				if(isspace(ch))
				{
					strcpy(alignmentFile, "sequences");
				}
				else
					{
					j=0;
					do
						{
						alignmentFile[j]=ch;
						j++;
						ch=fgetc(stdin);
						}
					while(!isspace(ch));
					alignmentFile[j]='\0';
					}
			break;
			case 'J':
				ch=fgetc(stdin);
				if(isspace(ch))
				{
					strcpy(treeFile, "trees");
				}
				else
					{
					j=0;
					do
						{
						treeFile[j]=ch;
						j++;
						ch=fgetc(stdin);
						}
					while(!isspace(ch));
					treeFile[j]='\0';
					}
			doPrintTrees = YES;
			break;
			case 'K':
				ch=fgetc(stdin);
				if(isspace(ch))
				{
					strcpy(timesFile, "times");
				}
				else
					{
					j=0;
					do
						{
						timesFile[j]=ch;
						j++;
						ch=fgetc(stdin);
						}
					while(!isspace(ch));
					timesFile[j]='\0';
					}
			doPrintTimes = YES;
			break;
			case 'D':
				ch=fgetc(stdin);
				if(isspace(ch))
					{
					strcpy(breakpointFile, "breakpoints");
					}
				else
					{
					j=0;
					do
						{
						breakpointFile[j]=ch;
						j++;
						ch=fgetc(stdin);
						}
					while(!isspace(ch));
					breakpointFile[j]='\0';
					}
			doPrintBreakpoints = YES;
			break;
			case 'X':
				ch=fgetc(stdin);
				if(isspace(ch))
					{
					strcpy(MRCAFile, "MRCA");
					}
				else
					{
					j=0;
					do
						{
						MRCAFile[j]=ch;
						j++;
						ch=fgetc(stdin);
						}
					while(!isspace(ch));
					MRCAFile[j]='\0';
					}
			doMRCAFile = YES;
			break;
            case ':':
                if (fscanf(stdin, "%f", &argument) !=1 || argument < 1)
                    {
                    fprintf (stderr, "PARAMETER ERROR: Bad NumReplicateABC (%d)\n\n", (int) argument);
                    PrintUsage();
                    }
                NumReplicateABC = (int) argument;
                /*fprintf(stderr, "\n\n NumReplicateABC = %d \n", NumReplicateABC);*/
            break;
			case '?':
				PrintUsage();
			break;
			/*case 'H':
				PrintUsage();
			break;*/
			default :
				fprintf(stderr, "PARAMETER ERROR: Incorrect parameter: %c\n\n", ch);
				PrintUsage();
			break;
		}
		ch=fgetc(stdin);
		while(isspace(ch) && !feof(stdin))
			ch=fgetc(stdin);
		while(ch=='[')
			{
			ReadUntil(stdin, ']', "closing bracket");
			ch=fgetc(stdin);
			while(isspace(ch))
				ch=fgetc(stdin);
			}
		}
}









/***************************** ReadEAAMfromFile *******************************/
/* Reads empirical amino acid model from the user's file */

void ReadEAAMfromFile()
{
	int  	j;
	char 	ch;
	float argument;
	
	/* Used: A R N D C Q E G H I L K M F P S T W Y V    Z */

	if(feof(stdin)){
		fprintf(stderr, "PARAMETER ERROR: Unable to read file with aa empirical model settings from stdin\n");
		exit(0);
	}

	ch=fgetc(stdin);
	while(isspace(ch))
		ch=fgetc(stdin);
	while(ch=='[')
	{
		ReadUntil(stdin, ']', "closing bracket");
		ch=fgetc(stdin);
		while(isspace(ch))
			ch=fgetc(stdin);
	}

	/* Qij_AAuser[NUMAA][NUMAA], FreqsAAUser[NUMAA]; */
	/*fprintf (stderr, "\n En ReadEAAMfromFile \n\n");*/

	while(!feof(stdin))
		{
		argument = 0;
		ch=toupper(ch);
		switch (ch) 
			{
			case 'A':
				for (j=0; j<NUMAA; j++)
					{
					fscanf(stdin, "%lf", &Qij_AAuser[0][j]);
					}
			break;
			case 'R':
				for (j=0; j<NUMAA; j++)
					{
					fscanf(stdin, "%lf", &Qij_AAuser[1][j]);
					}
			break;
			case 'N':
				for (j=0; j<NUMAA; j++)
					{
					fscanf(stdin, "%lf", &Qij_AAuser[2][j]);
					}
			break;
			case 'D':
				for (j=0; j<NUMAA; j++)
					{
					fscanf(stdin, "%lf", &Qij_AAuser[3][j]);
					}
			break;
			case 'C':
				for (j=0; j<NUMAA; j++)
					{
					fscanf(stdin, "%lf", &Qij_AAuser[4][j]);
					}
			break;
			case 'Q':
				for (j=0; j<NUMAA; j++)
					{
					fscanf(stdin, "%lf", &Qij_AAuser[5][j]);
					}
			break;
			case 'E':
				for (j=0; j<NUMAA; j++)
					{
					fscanf(stdin, "%lf", &Qij_AAuser[6][j]);
					}
			break;
			case 'G':
				for (j=0; j<NUMAA; j++)
					{
					fscanf(stdin, "%lf", &Qij_AAuser[7][j]);
					}
			break;
			case 'H':
				for (j=0; j<NUMAA; j++)
					{
					fscanf(stdin, "%lf", &Qij_AAuser[8][j]);
					}
			break;
			case 'I':
				for (j=0; j<NUMAA; j++)
					{
					fscanf(stdin, "%lf", &Qij_AAuser[9][j]);
					}
			break;
			case 'L':
				for (j=0; j<NUMAA; j++)
					{
					fscanf(stdin, "%lf", &Qij_AAuser[10][j]);
					}
			break;
			case 'K':
				for (j=0; j<NUMAA; j++)
					{
					fscanf(stdin, "%lf", &Qij_AAuser[11][j]);
					}
			break;
			case 'M':
				for (j=0; j<NUMAA; j++)
					{
					fscanf(stdin, "%lf", &Qij_AAuser[12][j]);
					}
			break;
			case 'F':
				for (j=0; j<NUMAA; j++)
					{
					fscanf(stdin, "%lf", &Qij_AAuser[13][j]);
					}
			break;
			case 'P':
				for (j=0; j<NUMAA; j++)
					{
					fscanf(stdin, "%lf", &Qij_AAuser[14][j]);
					}
			break;
			case 'S':
				for (j=0; j<NUMAA; j++)
					{
					fscanf(stdin, "%lf", &Qij_AAuser[15][j]);
					}
			break;
			case 'T':
				for (j=0; j<NUMAA; j++)
					{
					fscanf(stdin, "%lf", &Qij_AAuser[16][j]);
					}
			break;
			case 'W':
				for (j=0; j<NUMAA; j++)
					{
					fscanf(stdin, "%lf", &Qij_AAuser[17][j]);
					}
			break;
			case 'Y':
				for (j=0; j<NUMAA; j++)
					{
					fscanf(stdin, "%lf", &Qij_AAuser[18][j]);
					}
			break;
			case 'V':
				for (j=0; j<NUMAA; j++)
					{
					fscanf(stdin, "%lf", &Qij_AAuser[19][j]);
					}
			break;
			case 'Z':
				for (j=0; j<NUMAA; j++)
					{
					fscanf(stdin, "%lf", &FreqsAAUser[j]);
					}
			break;
			case '?':
				PrintUsage();
			break;
			default :
				fprintf(stderr, "Amino acid input file ERROR: Incorrect parameter: %c\n\n", ch);
				PrintUsage();
			break;
		}
		ch=fgetc(stdin);
		while(isspace(ch) && !feof(stdin))
			ch=fgetc(stdin);
		while(ch=='[')
			{
			ReadUntil(stdin, ']', "closing bracket");
			ch=fgetc(stdin);
			while(isspace(ch))
				ch=fgetc(stdin);
			}
		}
}






/***************************** ReadECMfromFile *******************************/
/* Reads empirical amino acid model from the user's file */

void ReadECMfromFile()
{
	int  	i, j;
	char 	ch;
	float argument;
	
	/*fprintf(stderr, "\n In ReadECMfromFile \n");*/


	if(feof(stdin)){
		fprintf(stderr, "PARAMETER ERROR: Unable to read file with codon empirical model settings from stdin\n");
		exit(0);
	}

	ch=fgetc(stdin);
	while(isspace(ch))
		ch=fgetc(stdin);
	while(ch=='[')
	{
		ReadUntil(stdin, ']', "closing bracket");
		ch=fgetc(stdin);
		while(isspace(ch))
			ch=fgetc(stdin);
	}

	/* Qij_CodUser[NUMCOD][NUMCOD], FreqsCodUser[NUMCOD]; */


	while(!feof(stdin))
		{
		argument = 0;
		ch=toupper(ch);
		switch (ch) 
			{
			
			case 'C':
				for (i=0; i<NUMCOD; i++)
					for (j=0; j<NUMCOD; j++)
						{
						/* this must be corrected: miguel */
						fscanf(stdin, "%lf", &Qij_CodUser[i][j]);
						}
			break;
			case 'Z':
				for (j=0; j<NUMCOD; j++)
					{
					fscanf(stdin, "%lf", &FreqsCodUser[j]);
					}
			break;
			case '?':
				PrintUsage();
			break;
			default :
				fprintf(stderr, "ECM input file ERROR: Incorrect parameter: %c\n\n", ch);
				PrintUsage();
			break;
		}
		ch=fgetc(stdin);
		while(isspace(ch) && !feof(stdin))
			ch=fgetc(stdin);
		while(ch=='[')
			{
			ReadUntil(stdin, ']', "closing bracket");
			ch=fgetc(stdin);
			while(isspace(ch))
				ch=fgetc(stdin);
			}
		}
}




/***************************** ReadHetRecfromFile *******************************/
/* Reads settings for heterogeneous recombination (hotspots) from a user's file */

void ReadHetRecfromFile()
{
	char 	ch;
	float argument;
	
	/*fprintf(stderr, "\n In ReadHetRecfromFile \n");*/


	if(feof(stdin)){
		fprintf(stderr, "PARAMETER ERROR: Unable to read file with settings for heterogeneous recombination from stdin\n");
		exit(0);
	}

	ch=fgetc(stdin);
	while(isspace(ch))
		ch=fgetc(stdin);
	while(ch=='[')
	{
		ReadUntil(stdin, ']', "closing bracket");
		ch=fgetc(stdin);
		while(isspace(ch))
			ch=fgetc(stdin);
	}


	while(!feof(stdin))
		{
		argument = 0;
		ch=toupper(ch);
		switch (ch) 
			{
			case 'K':
				if (fscanf(stdin, "%lf", &blockRecombinationRate) !=1) 
					{
					fprintf (stderr, "PARAMETER ERROR: Bad block recombination rate (%f)\n\n", blockRecombinationRate);
					PrintUsage();
					}
				if (blockRecombinationRate == 0) 
        			doBlockRecombination = NO;
        		else
        			doBlockRecombination = YES;
			break;
			case 'H':
				if (fscanf(stdin, "%lf", &expNumPoissonHotspots) !=1) 
					{
					fprintf (stderr, "PARAMETER ERROR: Bad number of expected hotspots (%f)\n\n", expNumPoissonHotspots );
					PrintUsage();
					}
				if (fixedNumHotspots > 0)
					{
					fprintf (stderr, "PARAMETER ERROR: Do not specify both an expected and a fixed number of hotspots\n\n");
					PrintUsage();
					}	
	        break;
			case 'Q':
				if (fscanf(stdin, "%lf", &fixedNumHotspots)!=1) 
					{
					fprintf (stderr, "PARAMETER ERROR: Bad fixed number of hotspots (%f)\n\n", fixedNumHotspots );
					PrintUsage();
					}
				if (expNumPoissonHotspots > 0)
					{
					fprintf (stderr, "PARAMETER ERROR: Do not specify at the same time an expected and a fixed number of hotspots\n\n");
					PrintUsage();
					}	
			break;
			case 'V':
				if (fscanf(stdin, "%lf", &hotspotImprecision) !=1) 
					{
					fprintf (stderr, "PARAMETER ERROR: Bad hotspot imprecision (%f)\n\n", hotspotImprecision);
					PrintUsage();
					}
				if (hotspotWidth > 1) 
					{
					fprintf (stderr, "PARAMETER ERROR: You cannot specify hotspot imprecision (Normal) and width (Uniform) simultaneosuly \n\n");
					PrintUsage();
					}
			break;
			case 'M':
				if (fscanf(stdin, "%f", &argument) !=1 || argument < 1) 
					{
					fprintf (stderr, "PARAMETER ERROR: Bad hotspot width (%d<1)\n\n", (int) argument);
					PrintUsage();
					}
				hotspotWidth = (int) argument;
				hotspotUniform = YES;
				if (hotspotImprecision > 0) 
					{
					fprintf (stderr, "PARAMETER ERROR: You cannot specify hotspot imprecision (Normal) and width (Uniform) simultaneosuly \n\n");
					PrintUsage();
					}
			break;
			case 'T':
				if (fscanf(stdin, "%lf", &alphaRec)!=1 || alphaRec < 0) 
					{
					fprintf (stderr, "PARAMETER ERROR: Bad alpha shape for hotspot recombination heterogeneity (%f)\n\n", alphaRec);
					PrintUsage();
					}
				hotspotHeterogeneity = YES;
			break;
			case 'Z':
				if (fscanf(stdin, "%f", &argument) !=1 || argument < 1) 
					{
					fprintf (stderr, "PARAMETER ERROR: Bad interference interval (%d)\n\n", (int) argument);
					PrintUsage();
					}
				interferenceInterval = (int) argument;
				hotspotInterference = YES;
			break;
			case '?':
				PrintUsage();
			break;
			default :
				fprintf(stderr, "Hotspot recombination input file ERROR: Incorrect parameter: %c\n\n", ch);
				PrintUsage();
			break;

			}
		ch=fgetc(stdin);
		while(isspace(ch) && !feof(stdin))
			ch=fgetc(stdin);
		while(ch=='[')
			{
			ReadUntil(stdin, ']', "closing bracket");
			ch=fgetc(stdin);
			while(isspace(ch))
				ch=fgetc(stdin);
			}
		}
}


/***************************** ReadHetVectorfromFile *******************************/
/* Reads settings for heterogeneous rates among sites from a user's file */

void ReadHetVectorfromFile()
{
	char 	ch;
	float argument;
	int numSitesHere, j;
	
	numSitesHere=0;
	/*fprintf(stderr, "\n In ReadHetVectorfromFile \n");*/

	if(feof(stdin)){
		fprintf(stderr, "PARAMETER ERROR: Unable to read file with settings for heterogeneous rates by a vector from stdin\n");
		exit(0);
	}

	ch=fgetc(stdin);
	while(isspace(ch))
		ch=fgetc(stdin);
	while(ch=='[')
	{
		ReadUntil(stdin, ']', "closing bracket");
		ch=fgetc(stdin);
		while(isspace(ch))
			ch=fgetc(stdin);
	}

	while(!feof(stdin))
		{
		argument = 0;
		ch=toupper(ch);
		switch (ch) 
			{
			case 'R':
				if (fscanf(stdin, "%f", &argument) !=1 || argument < 1) 
					{
					fprintf (stderr, "PARAMETER ERROR: Bad number of sites in the input file with the heterogeneous rates by a vector (%d)\n\n", (int) argument);
					PrintUsage();
					}
				numSitesHere = (int) argument;
				if (numSitesHere != numSites)
					{
					fprintf (stderr, "PARAMETER ERROR: Bad number of sites in the input file with the heterogeneous rates by a vector (%d)\n\n", numSitesHere);
					PrintUsage();
					}

				/*fprintf (stderr, "\n Vector:\n");*/
				for (j=0; j<numSites; j++)
					{
					fscanf(stdin, "%f", &argument);
					vectorHetRates[j] = (double) argument;
					if (vectorHetRates[j] < 0 || vectorHetRates[j] > 1)
						{
						fprintf (stderr, "PARAMETER ERROR: Bad value for the heterogeneous rate by a vector, site %d with rate %lf (should not be lower than 0 and higher than 1) \n\n", j+1, vectorHetRates[j]);
						PrintUsage();
						}
					/*fprintf (stderr, "%d: %lf - ", j, vectorHetRates[j]);*/
					}
				/*fprintf (stderr, "\n\n");*/
			break;

			case '?':
				PrintUsage();
			break;
			default :
				fprintf(stderr, "Heterogeneous substitution rate input file ERROR: Incorrect parameter: %c\n\n", ch);
				PrintUsage();
			break;

			}
		ch=fgetc(stdin);
		while(isspace(ch) && !feof(stdin))
			ch=fgetc(stdin);
		while(ch=='[')
			{
			ReadUntil(stdin, ']', "closing bracket");
			ch=fgetc(stdin);
			while(isspace(ch))
				ch=fgetc(stdin);
			}
		}
}






#ifdef USER_INPUT
/***************************** UserInput *******************************/
/* Prompts the user for parameter values */

void UserInput (long int *seed)
{
	int i, j, k, n, modelNumber;
	double sumPi, sumPi_b, sumPi_Cod_first, sumPi_Cod_second, sumPi_Cod_third;
	int sumPopul;
	i = j = k = n = 0;
	
	printf ("\n << USER INPUT >> ");
	printf ("\n\n Number of data sets      = ");
	scanf ("%d", &numDataSets);
	printf (" Number of sequences      = ");
	scanf ("%d", &numSequences);
	printf (" Number of sites (bp or codons)     = ");
	scanf ("%d", &numSites);
	printf (" Mutation rate            = ");
	scanf ("%lf", &mutationRate);
	printf (" Effective population size = ");
	scanf ("%d", &N);
	printf (" Recombination rate       = ");
	scanf ("%lf", &recombinationRate);
	
	printf (" Number fixed of recombination events       = ");
	scanf ("%d", &fixedNumRecEvents);
	
	printf (" How many frequencies value?, 4 or 12 (12 only codon model)       = ");
	scanf ("%d", &freqNumber);
	sumPi = sumPi_b = 0.0;
	if (freqNumber == 4)
		{
		printf (" Enter frequencies       = ");
		for (i = 0;i < 4;i++)
			scanf ("%lf", &p_i[i]);	
		equalBaseFreq = YES;
			for (i = 1; i < 4; i++)		
				if (p_i[i] != p_i[i-1])
					{
					equalBaseFreq = NO;
					break;
					}
							
		sumPi = p_i[0] + p_i[1] + p_i[2] + p_i[3];
		if (sumPi !=1.0) 
			{
			p_i[0]/=sumPi;
			p_i[1]/=sumPi;
			p_i[2]/=sumPi;
			p_i[3]/=sumPi;
			}
		p_i_codon[0]=p_i[0];
		p_i_codon[1]=p_i[1];
		p_i_codon[2]=p_i[2];
		p_i_codon[3]=p_i[3];
		p_i_codon[4]=p_i[0];
		p_i_codon[5]=p_i[1];
		p_i_codon[6]=p_i[2];
		p_i_codon[7]=p_i[3];
		p_i_codon[8]=p_i[0];
		p_i_codon[9]=p_i[1];
		p_i_codon[10]=p_i[2];
		p_i_codon[11]=p_i[3];					
		}
	else if (freqNumber == 12)
		{
		printf (" Enter frequencies       = ");
		for (i = 0;i < 12;i++)
			scanf ("%lf", &p_i_codon[i]);
		
		for (i = 0; i < 12; i++)
			if (p_i_codon[i] < 0 || p_i_codon[i] > 1)
				{
				fprintf (stderr, "PARAMETER ERROR: Bad number of enter frequencies (it must to be between 0 and 1) (%lf)\n\n", p_i_codon[i]);
				PrintUsage();
				}
	
		equalBaseFreqCod = YES;
		for (i = 1; i < 12; i++)		
			if (p_i_codon[i] != p_i_codon[i-1])
				{
				equalBaseFreqCod = NO;
				break;
				}		
					
		sumPi_Cod_first = p_i_codon[0] + p_i_codon[1] + p_i_codon[2] + p_i_codon[3];
		sumPi_Cod_second = p_i_codon[4] + p_i_codon[5] + p_i_codon[6] + p_i_codon[7];
		sumPi_Cod_third = p_i_codon[8] + p_i_codon[9] + p_i_codon[10] + p_i_codon[11];
		if (sumPi_Cod_first != 1.0) 
			{
			p_i_codon[0]/=sumPi_Cod_first;
			p_i_codon[1]/=sumPi_Cod_first;
			p_i_codon[2]/=sumPi_Cod_first;
			p_i_codon[3]/=sumPi_Cod_first;
			}
		if (sumPi_Cod_second != 1.0) 
			{
			p_i_codon[4]/=sumPi_Cod_second;
			p_i_codon[5]/=sumPi_Cod_second;
			p_i_codon[6]/=sumPi_Cod_second;
			p_i_codon[7]/=sumPi_Cod_second;
			}
		if (sumPi_Cod_third != 1.0) 
			{
			p_i_codon[8]/=sumPi_Cod_third;
			p_i_codon[9]/=sumPi_Cod_third;
			p_i_codon[10]/=sumPi_Cod_third;
			p_i_codon[11]/=sumPi_Cod_third;
			}
		}
	else
		{
		fprintf (stderr, "PARAMETER ERROR: Bad number of frequencies (4 or 12) (%d)\n\n", freqNumber);
		PrintUsage();
		}

	printf (" titv              = ");
	scanf ("%lf", &titv);
		
   printf (" Do you want rate heterogeneity among sites (0 = no; 1 = yes)? ");
   scanf ("%d", &doRateHet);
   if (doRateHet == YES)
           {
           printf (" Enter a shape parameter for the discrete gamma distribution: ");
           scanf ("%lf", &alpha);
           }
   else
           {
           alpha = 1.0;
           }
	printf (" Random number seed = ");
	scanf ("%lu bytes", &userSeed);
	
	printf (" Substitution Model:\n");
	printf ("  - If Codon Model enter 1\n");
	printf ("  - If Nucleotide Model enter 2\n");
	scanf ("%d", &i);
	while (i != 1 || i != 2)
		{
		printf (" You have to choose an option: Enter 1 to codon Model or 2 to Nucleotide Model \n");
		scanf ("%d", &i);
		}
		
	if (i == 2)
		{
		printf ("\n Nucleotide Model");
		doCodonModel = NO;
		
		printf ("\n Nucleotide Model can to be from types: HKY, GTR or GTR not reversible. If you want GTR Model enter number 1, GTR not reversible enter 2, and for HKY Model enter another number");
		j = 0;
		scanf ("%d", &j);
		if (j == 1)
			{
			doGTR = YES;
			doHKY = NO;
			printf ("\n You have to introduce the relative substitution rates to changes (rate matrix A-C A-G A-T C-G C-T G-T, for GTR models)(e.g. -v1 3 0.2 0.5 5 1)");
			scanf ("%lf", &Rmat[0]);			
			scanf ("%lf", &Rmat[1]);
			scanf ("%lf", &Rmat[2]);
			scanf ("%lf", &Rmat[3]);
			scanf ("%lf", &Rmat[4]);
			scanf ("%lf", &Rmat[5]);
			if (Rmat[5]!=1.0) 
				{
				for (j=0; j<5; j++) 
					Rmat[j]/=Rmat[5];
				Rmat[5]=1.0;
				}
			}
		else if (j == 2)
			{
			doHKY = NO;
			doGTnR = YES;
			printf("\n Introduce the vale rates for changes: AC CA AG GA AT TA CG GC CT TC GT");
			for (n=0;n<12;n++)
				scanf ("%lf", &NRmat[n]);
			if (NRmat[10]!=1.0) 
				{
				for (j=0; j<12 && j!=10; j++) 
					NRmat[j]/=NRmat[10];
				NRmat[10]=1.0;
				}
			}
		else
			{
			doHKY = YES;
			doGTR = NO;
			}
		}
	if (i == 1)
		{
		printf ("\n Codon Model");
		doCodonModel = YES;
		doGTR = NO;
		doHKY = NO;
		
		printf ("\n Omega values: You have to Introduce 1 (omega is constant), or 2 (omega categories), or 3 (discrete hetereogeneous rate), or 4 (continuous hetereogeneous rate)");
		scanf ("%d", &modelNumber);
		if (modelNumber > 4 || modelNumber < 1)
			{
			printf("\n Bad number of type of omega model");
			exit(-1);
			}
		
		if (modelNumber == 1) /* omega constant */
			{
			doOmegaCat = NO;
			doOmegaRateHetCont = NO;
			doOmegaRateHetDisc = NO;
			
			printf ("\n Introduce the omega value");
			scanf("%lf", &omega);
			OmegaInit = omega;
			}
		
		if (modelNumber == 2) /* omega by categories */
			{
			doOmegaProb = YES;
			doOmegaCat = YES;
			doOmegaRateHetCont = NO;
			doOmegaRateHetDisc = NO;
			
			sumPi = sumPi_b = 0.0;
			printf ("\n Introduce the number of categories");
			scanf ("%d", &numOmegaCat);
			if (numOmegaCat < 1 || numOmegaCat > 10)
				{
				printf ("PARAMETER ERROR: Bad number of omega categories (%d)\n\n", numOmegaCat);
				exit (-1);
				}
			omegaVal = (double *) calloc((numOmegaCat+1),(long) sizeof(double));
			if (!omegaVal)
				{
				fprintf (stderr, "PARAMETER ERROR: Could not allocate omega values of categories (%lu bytes)\n", (numOmegaCat+1) *(long) sizeof(double));
				exit (1);
				}
			omegaProb = (double *) calloc((numOmegaCat+1),(long) sizeof(double));
			if (!omegaProb)
				{
				fprintf (stderr, "PARAMETER ERROR: Could not allocate omega probabilities of categories (%lu bytes)\n", (numOmegaCat+1) *(long) sizeof(double));
				exit (1);
				}
			for (j=1; j<=numOmegaCat; j++)
				{
				printf ("\n Introduce the value of omega for the category %d", j);
				scanf("%lf", &omegaVal[j]);
				printf ("\n Introduce the value of omega for the category %d", j);
				scanf("%lf", &omegaProb[j]);
					
				if (omegaProb[j] > 1)
					{
					printf ("PARAMETER ERROR: Bad number of probabilities of omega categories (%lf)\n\n", omegaProb[j]);
					exit (-1);
					}
				sumPi = sumPi + omegaProb[j];
				}
					
			if (sumPi != 1) /* update probabilities of categories */
				{
				if (numOmegaCat == 1)
					omegaProb[1] = 1.0;
				else
					{
					for (j=1; j<=numOmegaCat; j++)
						{
						omegaProb[j]/=sumPi;
						sumPi_b = sumPi_b + omegaProb[j];
						}
					if ((int)sumPi_b != 1)
						{
						fprintf (stderr, "\n ERROR in the sum of probabilities of omega categories");
						exit (-1);
						}
					}
				}
			}
		



		if (modelNumber == 4) /* omega by a discrete gamma hetereogeneous rate */
			{
			doOmegaCat = NO;
			doOmegaRateHetCont = NO;
			doOmegaRateHetDisc = YES;
			
			printf ("\n Introduce the number of categories");
			scanf ("%d", &numOmegaCat);
			if (numOmegaCat < 1 || numOmegaCat > 10)
				{
				printf ("PARAMETER ERROR: Bad number of omega categories (%d)\n\n", numOmegaCat);
				exit (-1);
				}
			printf ("\n Introduce the Omega rate heterogeneous");
			scanf("%lf", &OmegaRateHet);
			if (OmegaRateHet <= 0.0)
				{
				fprintf (stderr, "PARAMETER ERROR: Bad omega heterogeneous rate (%3.2f)\n\n", OmegaRateHet);
				PrintUsage();
				}
			printf ("\n Introduce the omega value");
			scanf("%lf", &omega);
			if (omega < 0.0)
				{
				fprintf (stderr, "PARAMETER ERROR: Bad omega (%3.2f)\n\n", omega);
				PrintUsage();
				}
			OmegaInit = omega;
			}
		
		if (modelNumber == 5)	/* omega by a continuous gamma hetereogeneous rate */
			{
			doOmegaCat = NO;
			doOmegaRateHetCont = YES;
			doOmegaRateHetDisc = NO;
			
			printf ("\n Introduce the Omega rate heterogeneous");
			scanf("%lf", &OmegaRateHet);
			if (OmegaRateHet <= 0.0)
				{
				fprintf (stderr, "PARAMETER ERROR: Bad omega heterogeneous rate (%3.2f)\n\n", OmegaRateHet);
				PrintUsage();
				}
			printf ("\n Introduce the omega value");
			scanf("%lf", &omega);
			if (omega < 0.0)
				{
				fprintf (stderr, "PARAMETER ERROR: Bad omega (%3.2f)\n\n", omega);
				PrintUsage();
				}
			OmegaInit = omega;
			}
		


		printf ("\n Codon Model can to be derived from: HKY, GTR or GTR not reversible. If you want GTR Model enter number 1, GTR not reversible enter 2, and for HKY Model enter another number");
		i = 0;
		scanf ("%d", &i);
		if (i == 1)
			{
			doCodon_NGTR = NO;
			doCodon_GTR = YES;
			doCodon_HKY = NO;
			printf ("\n You have to introduce the relative substitution rates to changes (rate matrix A-C A-G A-T C-G C-T G-T, for GTR models)(e.g. -v1 3 0.2 0.5 5 1)");
			scanf ("%lf", &Rmat[0]);			
			scanf ("%lf", &Rmat[1]);
			scanf ("%lf", &Rmat[2]);
			scanf ("%lf", &Rmat[3]);
			scanf ("%lf", &Rmat[4]);
			scanf ("%lf", &Rmat[5]);
			if (Rmat[5]!=1.0) 
				{
				for (j=0; j<5; j++) 
					Rmat[j]/=Rmat[5];
				Rmat[5]=1.0;
				}
			}
		else if (i == 2)
			{
			doHKY = NO;
			doCodon_NGTR = YES;
			doCodon_GTR = NO;
			doCodon_HKY = NO;
			printf("\n Introduce the vale rates for changes: AC CA AG GA AT TA CG GC CT TC GT");
			for (n=0;n<12;n++)
				scanf ("%lf", &NRmat[n]);
			if (NRmat[10]!=1.0) 
				{
				for (j=0; j<12 && j!=10; j++) 
					NRmat[j]/=NRmat[10];
				NRmat[10]=1.0;
				}
			}
		else
			{
			doCodon_NGTR = NO;
			doCodon_HKY = YES;
			doCodon_GTR = NO;
			}
		}
	
	printf ("\n proportion of invariable sites (e.g. -p0.6)");
	scanf ("%lf", &pinv);

	printf (" Noisy level ");
	printf ("\n   noisy = 0: does not print run information");
	printf ("\n   noisy = 1: + run settings");
	printf ("\n   noisy = 2: + calculation status and event information");
	printf ("\n   noisy = 3: + print ancestral status for each sequence at each event + MRCA");
	printf ("\n   noisy = 4: + gi's and Gi");
	printf ("\n   noisy = 5: + tree for each site");
	printf ("\n Noisy level (0-5) = ");
	scanf ("%d", &noisy);

   printf ("\n Do you want to simulate an outgroup (0 = no; 1 = yes)? ");
	scanf ("%d", &thereisOutgroup);

	if (thereisOutgroup == YES)
    	{       
    	printf ("\n Enter the length of the branch to the outgroup: ");
       scanf ("%lf", &outgroupBranchLength);
		}

	printf ("\n rate of exponential growth (e.g. 1e-6) = ");
	scanf ("%lf", &growthRate);
	fprintf (stderr, "\n If you want to introduce periods demographics enter 1 or enter another number if it doesnt ");
	i = 0;
	scanf ("%d", &i);
	if (i == 1)
		{
		printf ("\n Enter number of periods");
		scanf ("%d", &numPeriods);
		if (numPeriods == 0)
			doDemographics = NO;
		else
			{
			doDemographics = YES;
			Nbegin =	(int *) calloc(numPeriods+1,(long) sizeof(int));
			Nend = 		(int *) calloc(numPeriods+1,(long) sizeof(int));
			cumDuration =	(int *) calloc(numPeriods+1,(long) sizeof(int));
			periodGrowth =	(double *) calloc(numPeriods+1,(long) sizeof(double));
			if (Nbegin == NULL || Nend == NULL || cumDuration == NULL)
				{
				fprintf (stderr, "PARAMETER ERROR: Could not allocate demographic vectors (%lu bytes)\n", numPeriods *(long) sizeof(int));
				exit (1);
				}
			printf ("\n Now, you have to introduce the Start, End and Duration (1 or 2 * N units) for each period:");
			for (j=1; j<=numPeriods; j++)
				{
				printf ("\n Period %d:", j);
				printf ("\n begin = ");
				scanf("%d", &Nbegin[j]);
				printf ("\n end = ");
				scanf("%d", &Nend[j]);
				printf ("\n duration = ");
				scanf("%d", &cumDuration[j]);
				cumDuration[j] = cumDuration[j] + cumDuration[j-1];
				}
			}
		}
	
   printf ("\n Enter the name of sequences file to be created: ");
	scanf ("%s", alignmentFile);
	i = 0;
	printf ("\n If you want Separated sets of sequences, you can introduce 1. If you do not, you can introduce another number");
	scanf ("%d", &i);
	if (i == 1)
		doSeparatedSequences = YES;
	else
		doSeparatedSequences = NO;
	i = 0;
	printf ("\n Enter number 1 to print the ancestral sequences in the sequences file or enter another number if it doesnt ");
	scanf ("%d", &i);
	if (i == 1)
		doPrintAncestralSequences = YES;
	else
		doPrintAncestralSequences = NO;
	i = 0;
	
	printf ("\n\n Printed files:");
	printf ("\n Do you want an output Tree file?. Enter 1 to YES or press another number to NO");
	scanf ("%d", &i);
	if (i == 1)
		{
		printf ("\n Enter the name of tree file to be created: ");
		scanf ("%s", treeFile);
		doPrintTrees = YES;
		i = 0;
		}
	printf ("\n Do you want an output Times file?. Enter 1 to YES or press another number to NO");
	scanf ("%d", &i);
	if (i == 1)
		{
		printf ("\n Enter the name of times file to be created: ");
		scanf ("%s", timesFile);
		doPrintTimes = YES;
		i = 0;
		}
	printf ("\n Do you want an output breakpoints file?. Enter 1 to YES or press another number to NO");
	scanf ("%d", &i);
	if (i == 1)
		{	
		printf ("\n Enter the name of breakpoints file to be created: ");
		scanf ("%s", breakpointFile);
		doPrintBreakpoints = YES;
		}
	i = 0;
	
	printf ("\n\n Migration model. Enter 1 to YES or press another number to NO");
	scanf ("%d", &i);
	if (i == 1)
		{
		doMigration = YES;
		sumPopul = 0;
		
		printf ("\n First. You can enter the number of subpopulation/s");		
		scanf ("%d", &numPopulations);		
		if (numPopulations < 1 || numPopulations > numSequences) 
			{
			printf ("PARAMETER ERROR: Bad number of subpopulations (%d)\n\n", numPopulations);
			PrintUsage();
			}
				
		initPopulation = (int *) calloc(numPopulations+1,(long) sizeof(int));
		if (!initPopulation)
			{
			fprintf (stderr, "PARAMETER ERROR: Could not allocate initPopulation of migration model (%lu bytes)\n", (numPopulations+1) *(long) sizeof(int));
			exit (1);
			}
				
		printf ("\n Second. You can enter the proportions of tip sequences to each subpopulation/s. Each proportion will be a number between 0 and 1. The sum of all proportions will be 1\n");
		for (j=1; j<=numPopulations; j++)
			{
			scanf("%d", &initPopulation[j]);
			if (initPopulation[j] > numSequences || initPopulation[j] <= 0)
				{
				fprintf (stderr, "PARAMETER ERROR: Bad subpopulation proportion (%d)\n\n", initPopulation[j]);
				PrintUsage();
				}
			sumPopul = sumPopul + initPopulation[j];
			}
		printf ("\nNow you can enter the migration rate");	
		scanf("%lf", &migrationRate);
		if (migrationRate < 0)
			{
			fprintf (stderr, "PARAMETER ERROR: Bad migration rate (%lf)\n\n", migrationRate);
			PrintUsage();
			}
		if (sumPopul != numSequences)
			{
			fprintf (stderr, "PARAMETER ERROR: Bad initial subpopulation. The number of sequences is different to the sum of nodes in demes \n\n");
			PrintUsage();
			}
		}
	else
		doMigration = NO;
	i = 0;
	
	printf ("\n Enter number 1 to make the MRCA sequence from your input file or enter another number if you want to make the MRCA sequence from nucleotide frequencies");
	scanf ("%d", &i);
	if (i == 1)
		{
		printf ("\n Now, you have to introduce the name of your MRCA file \n (if you have problems with this you have to check the input file name and if the location of your file is correct)");
		scanf ("%s", MRCAFile);
		doMRCAFile = YES;
		}
	else
		doMRCAFile = NO;
	i = 0;
	

	printf ("\n Enter number 1 to print the sumMRCA/GMRCA sequence in separate files");
	scanf ("%d", &i);
	if (i == 1)
		{
		doOutMRCAfiles = YES;
		}
	i = 0;


	printf ("\n Finally, if you want to see more information about input parameters enter 1, to run the program enter another number");
	scanf ("%d", &i);
	if (i == 1)
		PrintUsage();
		
	printf ("\n\n");
}

#endif



void ReadUntil(FILE *fv, char stopChar, char *what)
{
	char ch;
	
	ch=fgetc(fv);
	while (!feof(fv) && ch!=stopChar) 
		ch=fgetc(fv);

	if (feof(fv) || ch!=stopChar) {
		fprintf(stderr, "%s missing", what);
		exit(0);
	}
}




/***************************** PrintTitle *******************************/
/* Prints program header */

static void PrintTitle(FILE *filep)
{
	FILE *file;
	file = filep;
	fprintf(filep,"%s - Simulation of protein evolution accouting for structural stability and under diverse evolutionary scenarios", PROGRAM_NAME);
	fprintf(filep, "\nVersion %s", VERSION_NUMBER);
	fprintf(filep, "\nWritten by Miguel Arenas (miguelmmmab@gmail.com), David Posada (dposada@uvigo.es) and Ugo Bastolla (ubastolla@cbm.uam.es)");
	fprintf(filep,"\n__________________________________________________________________________________________________________________________\n\n");
}






/***************************** PrintUsage *******************************/
/* Prints a short description of program usage */ 
static void PrintUsage()
{
	
#ifdef MPI
	if (rank==root)
		{
#endif
		fprintf (stderr, "\n\nUsage: %s%s [-n# -s# # -e# # -=# (#) -/# -g# (#) -q# (#) -t# (#) -%%# # -r# -w# -hNAME -u# -o# -pNAME -f# (#) -v# (#) -mNAME -@NAME -zNAME -a# -i# -_NAME -xNAME -bsequences -c# # # -$ -jtrees -ktimes -*NAME -dbreakpoints -## -y# -? -h]", PROGRAM_NAME, VERSION_NUMBER);
		/*fprintf (stderr, "\n\nUsage: %s%s [-n# -s# -=# -/# -l# -e# -_name -g# -p# -q# -%%# -r# -w# -u# -m# -f# -v# -@name -a# -i# -o# -xseqGMRCA -bsequences -c# -*# -zname -$ -jtrees -ktimes -*name -dbreakpoints -+ -## -y# -? -h]", PROGRAM_NAME, VERSION_NUMBER);*/
		
		fprintf (stderr,"\n-n: number of replicates (e.g. -n1000)");
		fprintf (stderr,"\n-s: sample size (#haplotypes); number of sites (bp, codons or amino acids) (e.g. -s8 150)");
		fprintf (stderr,"\n-e: effective population size; haploid/diploid (1 for haploid, 2 for diploid) (e.g. -e1000 1)");

		fprintf (stderr,"\n-=: tip dates. (e.g. for 4 samples: 1995:node 1; 2003:nodes 4 and 6; 1997:nodes 2 and 3; 2001:nodes 7 and 8.   -=4 1995 1 1 2003 4 6 1997 2 3 2001 7 8)");
		fprintf (stderr,"\n-/: generation time (e.g. -/300)");

		fprintf (stderr,"\n-g: rate of exponential growth (e.g. -g1e-6) (default is constant population size)");
		fprintf (stderr,"\n-p: number of demographic periods followed by effective population size at the beginning and at the end of the period, ");
		fprintf (stderr, "\n   and the duration of the period in generations. (e.g. -p1 100 200 30000) (e.g. -p2 100 100 40000 1000 2000 20000)");

		fprintf (stderr,"\n-q: migration model has three sets of numbers: (e.g. -q1 4 2 2 1 3) ");
		fprintf (stderr,"\n		the first number indicates the migration model (1 means island model, 2 means stepping-stone model, 3 means island-continent model)");
		fprintf (stderr,"\n		the second number is the number of subpopulations that you want on tip nodes, at present time.");
		fprintf (stderr,"\n		the next numbers are the number of nodes for each subpopulation. Note that the sum must to be equal to the sample size.");
		fprintf (stderr,"\n-t: migration rate with/without temporal variation: ");
		fprintf (stderr,"\n		the first number indicates the number of periods with different migration rate");
		fprintf (stderr,"\n		If the first name was 1 (only 1 period), then the second number is the migration name. (e.g. -t1 0.001)");
		fprintf (stderr,"\n		If the first name was higher than 1 (several periods), then it follows with the times where migration rate changes (note that the number of such times should be equal to the number of periods minus one). After that, introduce a migration rate for each period. (e.g. -t3 100 800 0.002 0.001 0.003)");

		fprintf (stderr,"\n-%%: convergence demes events: (e.g. -%%3 1 2 200 3 4 1000 5 6 2000) ");
		fprintf (stderr,"\n		the first number is the number of convergence events. Then each 3 numbers are for one convergence event, where: the first and the second numbers ");
		fprintf (stderr,"\n		are the number of the demes, the third number is the time to the event. When two demes are converging the resulting deme was named as the next number of the demes list. ");
		fprintf (stderr,"\n		So, the number of the convergence demes cannot be repeated in the enter instruction. ");
		
		fprintf (stderr,"\n-r: homogeneous recombination rate (e.g. -r1e-6)");
		fprintf (stderr,"\n-w: fixed number of recombination events (e.g. -w3)");
		fprintf (stderr,"\n-h: heterogeneous recombination - input file (e.g. -hUserHetRec)");

		fprintf (stderr,"\n-u: substitution rate (e.g. -u1e-8). It's for nucleotide model or for codon model");
		fprintf (stderr,"\n-o: branch length to the outgroup (e.g. -o0.0325) (default is no outgroup)");

		fprintf (stderr,"\n-p: input tree file - input file (e.g. -ptreefile_DNA)");

		/* substitution models */
		fprintf (stderr,"\n-f: frequencies for nucleotides (ACGT) or amino acids (ARNDCQEGHILKMFPSTWYV) ");
		fprintf (stderr,"\n		the first number indicates the number of frequencies: 4 for nucleotide, 20 for amino acids ");
		fprintf (stderr,"\n		the following numbers are the frequencies."); 
		fprintf (stderr,"\n		(e.g. -f4 0.4 0.3 0.2 0.1), (e.g., f20 0.1 0.4 0.3 0.2 0.4 0.4 0.1 0.1 0.3 0.3 0.3 0.1 0.3 0.1 0.5 0.6 0.7 0.1 0.2 0.3)"); 
		
		/* freqs */
		fprintf (stderr,"\n-v: relative substitution rates between nucleotides. The first number indicates the number of rates and the following numbers are the rates:"); 
		fprintf (stderr,"\n		if the first number = 1, the following number is the transition/transversion ratio (e.g. -v1 2.5)");
		fprintf (stderr,"\n		if the first number = 6, the following numbers are the substitution rates for the symmetrical changes AC AG AT CG CT GT (e.g. -v6 1.0 0.5 0.1 0.3 1.7 0.5)");
		fprintf (stderr,"\n		if the first number = 12, the following numbers are the substitution rates for the nonsymmetrical changes AC CA AG GA AT TA CG GC CT TC GT=1 TG (e.g. -v12 0.1 0.2 0.3 0.4 0.9 0.6 0.9 0.8 0.9 0.1 0.2 0.3)");

		/* codon models  */
/*		fprintf (stderr,"\n-m: GY94 and MG94 codon models. There are 11 models which are selected by the first number (see below). m1-m10 are GY94 codon models while m0 is for MG94 codon model.");
		fprintf (stderr,"\n		1. Constant dN/dS among sites. Intoduce 1 and then the value of omega (e.g. -m1 0.9)");
		fprintf (stderr,"\n		2. Categories from the user: the max number of categories is 10, category probabibilities cannot be > 1 or negative:");
		fprintf (stderr,"\n		   First number must be 2, and then the number of categories.");
		fprintf (stderr,"\n		   The following numbers are, for each category, first its omega value and then its probability. (e.g. -m2 2 0.2 0.4 1.5 0.6)");
		fprintf (stderr,"\n		3. M1 model (neutral). Introduce 3, and then the proportion of sites for this omega (P0) and the omega value (omega0). Note that P1=1-P0 and omega1 = 1 (e.g. -m3 0.9 0.3)");
		fprintf (stderr,"\n		4. M5 model (discr gamma). Introduce 4, then the number of categories, the discrete heterogeneous rate and the omega value (e.g. -m4 4 0.78 1.4)");
		fprintf (stderr,"\n		5. M5 model (cont gamma). Introduce 5, and then the continuous heterogeneous rate and the omega value (e.g. -m5 0.5 0.86)");
		fprintf (stderr,"\n		6. M6 model (cont 2gamma) model. Introduce 6, then the proportion of sites for the first distribution, followed by its heterogeneous rate and the omega value. Finally heterogeneous rate for the second distribution (e.g. -m6 0.5 5 3 0.54)");
		fprintf (stderr,"\n		7. M7 model (cont beta). Introduce 7, and then p and q for the beta distribution (e.g. -m7 0.4 0.3)");
		fprintf (stderr,"\n		8. M8 model (cont beta&omg). Introduce 8, and then: The proportion of sites of the beta distribution, and its p and q. Finally omega for P1 (e.g. -m8 0.4 0.3 0.6 1.4)");
		fprintf (stderr,"\n		9. M9 model (cont beta&gamma). Introduce 9, and then the proportion of sites of the beta distributionp, and its p and q.");
		fprintf (stderr,"\n		   Then, the two parameters for the gamma distribution. (e.g. -m9 0.80 5.5 3.3 1.9 3.8)");
		fprintf (stderr,"\n		10. M9 model (cont beta&gamma+1). Introduce 10, and then the proportion of sites of the beta distributionp, and its p and q.");
		fprintf (stderr,"\n		   Then, the two parameters for the gamma distribution. (e.g. -m10 0.60 2.5 1.3 0.9 0.8)");
		fprintf (stderr,"\n		0. MG94 codon model. Introduce 0, and then the synonymous and non-synonymous substitution rates (e.g. -m0 1.70 1.10)");

		fprintf (stderr,"\n-_: M0-M10 GY94 with amino acid constrains. Introduce one of the following amino acid models: ");
		fprintf (stderr,"\n		   Blosum62, CpRev, Dayhoff, DayhoffDCMUT, HIVb, HIVw, JTT, JonesDCMUT, LG, Mtart, Mtmam, Mtrev24, RtRev, VT, WAG, UserEAAM.");
		fprintf (stderr,"\n		   Note that the last one (UserEAAM) means a user-given amino acid matrix, and such name is the name of the input file with the matrix (see examples of input files).");
		fprintf (stderr,"\n		   (e.g., -_WAG)");

		fprintf (stderr,"\n-l: variable dN/dS per branch in GY94 codon models. 4 models can be specified here by the first number (see below):");
		fprintf (stderr,"\n		Importanly models 1-3 only work for M0 codon model (activated by -m1) and model 4 is for all other GY94 heterogeneous models (activated by -m2 to -m10)");
		fprintf (stderr,"\n		These models require more computational time");
		fprintf (stderr,"\n		1. categories from the user: the max number of categories is 10, category probabibilities cannot be > 1 or negative:");
		fprintf (stderr,"\n		   First number must be 1, and then the number of categories.");
		fprintf (stderr,"\n		   The following numbers are, for each category, first its omega value and then its probability. (e.g. -l1 3 0.1 0.2 3.4 0.3 1.0 0.5)");
		fprintf (stderr,"\n		  This only works for M0 codon model where each branch will simulate under a particular dN/dS for all sites!");
		fprintf (stderr,"\n		2. Continuous gamma distribution. Introduce 2, and then the continuous heterogeneous rate and the omega value (e.g. -l2 0.9 0.96)");
		fprintf (stderr,"\n		  This only works for M0 codon model where each branch will simulate under a particular dN/dS for all sites!");
		fprintf (stderr,"\n		3. Continuous beta distribution. Introduce 3, and then p and q for the beta distribution (e.g. -l3 0.5 0.7)");
		fprintf (stderr,"\n		  This only works for M0 codon model where each branch will simulate under a particular dN/dS for all sites!");
		fprintf (stderr,"\n		4. Continuous beta distribution. Introduce 4. (e.g. -l4)");
		fprintf (stderr,"\n		  This only works for M1-M10 codon models for a dN/dS value for each branch and site!");

		fprintf (stderr,"\n-z: empirical codon models. Introduce one of the following empirical codon models:");
		fprintf (stderr,"\n		   ECMrest, ECMunrest, ECMSchn2005, UserECM.");
		fprintf (stderr,"\n		   Note that the last one (UserECM) means a user-given codon matrix, and such name is the name of the input file with the matrix (see examples of input files).");
		fprintf (stderr,"\n		   (e.g., -zECMSchn2005)");*/

		fprintf (stderr,"\n-m: protein stability model for DNA evolution - input file (e.g. -mPop_evol.in)");

		/* amino acid models  */
		fprintf (stderr,"\n-@: empirical amino a cid models. Introduce one of the following empirical amino acid models:");
		fprintf (stderr,"\n		   Blosum62, CpRev, Dayhoff, DayhoffDCMUT, HIVb, HIVw, JTT, JonesDCMUT, LG, Mtart, Mtmam, Mtrev24, RtRev, VT, WAG, UserEAAM.");
		fprintf (stderr,"\n		   Note that the last one (UserEAAM) means a user-given amino acid matrix, and such name is the name of the input file with the matrix (see examples of input files).");
		fprintf (stderr,"\n		   (e.g., -@JTT)");
		fprintf (stderr,"\n-z: protein stability model for amino acid evolution - input file (e.g. -zPop_evol.in)");

		/* general parameters */
		fprintf (stderr,"\n-a: alpha shape of the gamma distribution for rate heterogeneity (e.g. -a0.05)");
		fprintf (stderr,"\n-i: proportion of invariable sites (e.g. -p0.6)");
		fprintf (stderr,"\n-_: vector with proportional rates for each site (e.g. _HetRatesVector_DNA2)");
		fprintf (stderr,"\n-x: input MRCA file name. It cannot have stop codons (e.g. -xseqGMRCA_DNA)");

		/* outputs */
		fprintf (stderr,"\n-b: output sequences file name (e.g. -bsequences)");
		fprintf (stderr,"\n-c: print in phylip/fasta/nexus format (1/2/3); multiple aligment files (0=no, 1=yes); include ancestral sequences in alignment (0=no, 1=yes) (e.g. -c1 1 0)");
		fprintf (stderr,"\n-$: print to files sumMRCAs and GMRCAs (e.g. -$)");
		fprintf (stderr,"\n-j: tree file name (e.g. -jtrees)");
		fprintf (stderr,"\n-k: times file name (e.g. -ktimes)");
		fprintf (stderr,"\n-*: print ARG (branches format). (e.g. -*NetworkFile)");
		fprintf (stderr,"\n-d: breakpoints file name (e.g. -dbreakpoints)");
/*		fprintf (stderr,"\n-+: print simulate omegas per site/branch (e.g. -+)");*/

		/* other settings */
		fprintf (stderr,"\n-y: noisy (e.g. -y2)");
		fprintf (stderr,"\n-#: seed (e.g. -#37864287)");
		fprintf (stderr,"\n-? -h: Print help");


		/* recombination hotspots - from inputfile */
		fprintf (stderr,"\n\n>> Recombination hotspots input file");
		fprintf (stderr,"\n-k: hotspot recombination rate (e.g. -k1e-4)");
		fprintf (stderr,"\n-q: fixed number of hotspots (e.g. -q4)");
		fprintf (stderr,"\n-h: expected number of hotspots (e.g. -h4)");
		fprintf (stderr,"\n-v: hotspot imprecision (e.g. -v100)");
		fprintf (stderr,"\n-m: hotspot width (e.g. -m20)");
		fprintf (stderr,"\n-t: hotspot heterogeneity (e.g. -t0.5)");
		fprintf (stderr,"\n-t: hotspot interference (e.g. -z4)");
		
	#ifdef MPI
		}
	#endif

	exit(-1);
}




/***************************** PrintDate *******************************/
/* Prints date and time */

static void PrintDate (FILE *filep)
{
	char *date;				/* define date */
	time_t now;
	FILE *file;
	file = filep;		/* define */
	
	now=time(NULL);
	date= ctime(&now);
	fprintf(filep,"%s\n",date);
}



/*********************** RandomizeArray ***********************/
/* Randomizes elements of a given array */

/*static void RandomizeArray (int array[],int first, int last)
{
	int i, r, tmp, length;
	
	length = last - first;
	for (i=first; i<last; i++) */        /* iterate through the array */
		/*{              
		r = Rand(length-(i-first)) + i; *//* get random number */
		
		/*tmp = array[r];*/               /* swap (change) elements.   e.j., array[2](=1) = array[4](goes from =3 to =1) */
		/*array[r] = array[i];
		array[i] = tmp ;
		}
}*/



/********************** Rand ****************************/
/* it returns random uniform in range 0...max-1  */

/*static int Rand(int max)
{
	double	rd;
	rd = Rndu();
	return (floor(rd*max));*/		/* floor returns the entire nearer to rd*max */
/*}*/


	
/********************** Rndu ****************************/
/* it returns random uniform                */

/*static double Rndu (void)
{
  static int x_rndu=11, y_rndu=23, z_rndu=137;
  double r;

  x_rndu = 171*(x_rndu%177) - 2*(x_rndu/177);
  y_rndu = 172*(y_rndu%176) - 35*(y_rndu/176);
  z_rndu = 170*(z_rndu%178) - 63*(z_rndu/178);
  if (x_rndu<0) x_rndu+=30269;
  if (y_rndu<0) y_rndu+=30307;
  if (z_rndu<0) z_rndu+=30323;
  r = x_rndu/30269.0 + y_rndu/30307.0 + z_rndu/30323.0;
  return (r-(int)r);
}*/





/**************		The next functions are for recombination, they return the new segments of the new ancestral nodes			*************/
/********************************************************************************************************************************************/

/************** recSegmentsGeneratesLeft ****************/
/* It builds the new segments on the left of the breakpoint */
static int		recSegmentsGeneratesLeft(int nodeValue, TreeSegment *s, TreeSegment *n, int numNuc, int whichSite, int *actSegIndex)
{
	int breakp;

	breakp = whichSite;
	if (s->sStart < breakp)
		{
		if (breakp >= s->sEnd)
			{
			if (s->sStart == 1 && s->sEnd == breakp)
				{
				s->before1 = n;
				n->before1 = NULL;
				n->before2 = NULL;
				n->after1 = s;
				n->after2 = NULL;
				n->sIndex = *actSegIndex;
				n->sStart = s->sStart;
				n->sEnd = breakp-1;				/* the breakpoint site will be in the other segment */
				n->sIndexNode = nodeValue;
				
				*actSegIndex = *actSegIndex+1;
				
				return (1);
				}
			else if (s->sStart == 1 && s->sEnd != breakp)
				{
				s->before1 = n;
				n->before1 = NULL;
				n->before2 = NULL;
				n->after1 = s;
				n->after2 = NULL;
				n->sIndex = *actSegIndex;
				n->sStart = s->sStart;
				n->sEnd = s->sEnd;	
				n->sIndexNode = nodeValue;
				
				*actSegIndex = *actSegIndex+1;
				
				return (1);
				}
			else if (s->sStart != 1 && s->sEnd == breakp)
				{
				s->before1 = n;
				n->before1 = NULL;
				n->before2 = NULL;
				n->after1 = s;
				n->after2 = NULL;
				n->sIndex = *actSegIndex;
				n->sStart = s->sStart;
				n->sEnd = breakp-1;				/* the breakpoint site will be in the other segment */
				n->sIndexNode = nodeValue;
				
				*actSegIndex = *actSegIndex+1;
				
				return (1);
				}
			else
				{
				s->before1 = n;
				n->before1 = NULL;
				n->before2 = NULL;
				n->after1 = s;
				n->after2 = NULL;
				n->sIndex = *actSegIndex;
				n->sStart = s->sStart;
				n->sEnd = s->sEnd;	
				n->sIndexNode = nodeValue;
				
				*actSegIndex = *actSegIndex+1;
				
				return (1);
				}
			}
		else if (s->sStart == 1)
			{
			if (s->sEnd != numNuc)
				{
				s->before1 = n;
				n->before1 = NULL;
				n->before2 = NULL;
				n->after1 = s;
				n->after2 = NULL;
				n->sIndex = *actSegIndex;
				n->sStart = s->sStart;
				n->sEnd = breakp-1;
				n->sIndexNode = nodeValue;
				
				*actSegIndex = *actSegIndex+1;
				
				return (1);
				}
			else
				{
				s->before1 = n;
				n->before1 = NULL;
				n->before2 = NULL;
				n->after1 = s;
				n->after2 = NULL;
				n->sIndex = *actSegIndex;
				n->sStart = s->sStart;
				n->sEnd = breakp-1;
				n->sIndexNode = nodeValue;
				
				*actSegIndex = *actSegIndex+1;
				
				return (1);
				}
			}
		else if (s->sEnd == numNuc)
			{
			if (s->sStart != 1)
				{
				s->before1 = n;
				n->before1 = NULL;
				n->before2 = NULL;
				n->after1 = s;
				n->after2 = NULL;
				n->sIndex = *actSegIndex;
				n->sStart = s->sStart;
				n->sEnd = breakp-1;
				n->sIndexNode = nodeValue;
				
				*actSegIndex = *actSegIndex+1;
				
				return (1);
				}
			else
				{
				fprintf (fpmpi, "\n\nWarning in recSegmentsGeneratesLeft1, it can't never here");			
				exit(-1);
				}
			}
		else if (s->sStart >= 1 && s->sEnd > breakp)
			{
			s->before1 = n;
			n->before1 = NULL;
			n->before2 = NULL;
			n->after1 = s;
			n->after2 = NULL;
			n->sIndex = *actSegIndex;
			n->sStart = s->sStart;
			n->sEnd = breakp-1;
			n->sIndexNode = nodeValue;
			
			*actSegIndex = *actSegIndex+1;
				
			return (1);
			}
		
		else
			{
			fprintf (fpmpi, "\n\nWarning in recSegmentsGeneratesLeft2, breakp = %d, it can't never here", breakp);			
			exit(-1);
			}
		}
	else		
		{
		fprintf (fpmpi, "\n\nWarning in recSegmentsGeneratesLeft3, it can't never here");			
		exit(-1);
		}

return (0);
}




/************** recSegmentsGeneratesRight ****************/
/* It builds the new segments on the right of the breakpoint */

static int		recSegmentsGeneratesRight(int nodeValue, TreeSegment *s, TreeSegment *m, int numNuc, int whichSite, int *actSegIndex)
{
	int breakp;
	
	breakp = whichSite;
	if (s->sEnd >= breakp)
		{
		if (breakp <= s->sStart)
			{
			if (s->sStart == breakp && s->sEnd == numNuc)
				{
				s->before2 = m;
				m->before1 = NULL;
				m->before2 = NULL;
				m->after1 = s;
				m->after2 = NULL;
				m->sIndex = *actSegIndex;
				m->sStart = s->sStart;
				m->sEnd = s->sEnd;	
				m->sIndexNode = nodeValue;
				
				*actSegIndex = *actSegIndex+1;
				
				return (1);
				}
			else if (s->sStart == breakp && s->sEnd != numNuc)
				{
				s->before2 = m;
				m->before1 = NULL;
				m->before2 = NULL;
				m->after1 = s;
				m->after2 = NULL;
				m->sIndex = *actSegIndex;
				m->sStart = s->sStart;
				m->sEnd = s->sEnd;	
				m->sIndexNode = nodeValue;
				
				*actSegIndex = *actSegIndex+1;
				
				return (1);
				}
			else if (s->sStart != breakp && s->sEnd == numNuc)
				{
				s->before2 = m;
				m->before1 = NULL;
				m->before2 = NULL;
				m->after1 = s;
				m->after2 = NULL;
				m->sIndex = *actSegIndex;
				m->sStart = s->sStart;
				m->sEnd = s->sEnd;	
				m->sIndexNode = nodeValue;
				
				*actSegIndex = *actSegIndex+1;

				return (1);
				}
			else
				{
				s->before2 = m;
				m->before1 = NULL;
				m->before2 = NULL;
				m->after1 = s;
				m->after2 = NULL;
				m->sIndex = *actSegIndex;
				m->sStart = s->sStart;
				m->sEnd = s->sEnd;	
				m->sIndexNode = nodeValue;
				
				*actSegIndex = *actSegIndex+1;

				return (1);
				}
			}
			
		else if (s->sStart == 1)
			{
			if (s->sEnd != numNuc)
				{
				s->before2 = m;
				m->before1 = NULL;
				m->before2 = NULL;
				m->after1 = s;
				m->after2 = NULL;
				m->sIndex = *actSegIndex;
				m->sStart = breakp;
				m->sEnd = s->sEnd;
				m->sIndexNode = nodeValue;
				
				*actSegIndex = *actSegIndex+1;
				
				return (1);
				}
			else
				{
				s->before2 = m;
				m->before1 = NULL;
				m->before2 = NULL;
				m->after1 = s;
				m->after2 = NULL;
				m->sIndex = *actSegIndex;
				m->sStart = breakp;
				m->sEnd = s->sEnd;
				m->sIndexNode = nodeValue;
				
				*actSegIndex = *actSegIndex+1;
				
				return (1);
				}
			}
		else if (s->sEnd == numNuc)
			{
			if (s->sStart != 1)
				{
				s->before2 = m;
				m->before1 = NULL;
				m->before2 = NULL;
				m->after1 = s;
				m->after2 = NULL;
				m->sIndex = *actSegIndex;
				m->sStart = breakp;
				m->sEnd = s->sEnd;
				m->sIndexNode = nodeValue;
				
				*actSegIndex = *actSegIndex+1;
				
				return (1);
				}
			else
				{
				fprintf (fpmpi, "\n\nWarning in recSegmentsGeneratesRight1, it can't never here");			
				exit(-1);
				}
			}
		else if (s->sStart <= breakp && s->sEnd >= breakp)
			{
			s->before2 = m;
			m->before1 = NULL;
			m->before2 = NULL;
			m->after1 = s;
			m->after2 = NULL;
			m->sIndex = *actSegIndex;
			m->sStart = breakp;
			m->sEnd = s->sEnd;
			m->sIndexNode = nodeValue;
			
			*actSegIndex = *actSegIndex+1;
				
			return (1);
			}
		else
			{
			fprintf (fpmpi, "\n\nWarning in recSegmentsGeneratesRight2, breakp = %d, it can't never here", breakp);			
			exit(-1);
			}
		}
	else
		{
		fprintf (fpmpi, "\n\nWarning in recSegmentsGeneratesRight3, it can't never here");			
		exit(-1);

		}

return (0);
}



/** Broken Codons **/
/************** recSegmentsGeneratesLeftBrokenCodon ****************/
/* It builds the new segments on the left of the breakpoint */
static int		recSegmentsGeneratesLeftBrokenCodon(int nodeValue, TreeSegment *s, TreeSegment *n, int numNuc, int whichSite, int LeftLess, int RightHigh, int *actSegIndex)
{
	int breakp;
	int HereLeftLess, HereRightHigh;

	HereLeftLess = LeftLess;
	HereRightHigh = RightHigh;

	breakp = whichSite;

	if (s->sStart < breakp)
		{
		if (breakp >= s->sEnd)
			{
			if (s->sStart == 1 && s->sEnd == breakp)
				{
				s->before1 = n;
				n->before1 = NULL;
				n->before2 = NULL;
				n->after1 = s;
				n->after2 = NULL;
				n->sIndex = *actSegIndex;
				n->sStart = s->sStart;
				n->sEnd = HereRightHigh;				/* the breakpoint site will be in the other segment */
				n->sIndexNode = nodeValue;
				
				*actSegIndex = *actSegIndex+1;
				
				return (1);
				}
			else if (s->sStart == 1 && s->sEnd != breakp)
				{
				s->before1 = n;
				n->before1 = NULL;
				n->before2 = NULL;
				n->after1 = s;
				n->after2 = NULL;
				n->sIndex = *actSegIndex;
				n->sStart = s->sStart;
				n->sEnd = HereRightHigh;	
				n->sIndexNode = nodeValue;
				
				*actSegIndex = *actSegIndex+1;
				
				return (1);
				}
			else if (s->sStart != 1 && s->sEnd == breakp)
				{
				s->before1 = n;
				n->before1 = NULL;
				n->before2 = NULL;
				n->after1 = s;
				n->after2 = NULL;
				n->sIndex = *actSegIndex;
				n->sStart = s->sStart;
				n->sEnd = HereRightHigh;				/* the breakpoint site will be in the other segment */
				n->sIndexNode = nodeValue;
				
				*actSegIndex = *actSegIndex+1;
				
				return (1);
				}
			else
				{
				s->before1 = n;
				n->before1 = NULL;
				n->before2 = NULL;
				n->after1 = s;
				n->after2 = NULL;
				n->sIndex = *actSegIndex;
				n->sStart = s->sStart;
				n->sEnd = HereRightHigh;	
				n->sIndexNode = nodeValue;
				
				*actSegIndex = *actSegIndex+1;
				
				return (1);
				}
			}
		else if (s->sStart == 1)
			{
			if (s->sEnd != numNuc)
				{
				s->before1 = n;
				n->before1 = NULL;
				n->before2 = NULL;
				n->after1 = s;
				n->after2 = NULL;
				n->sIndex = *actSegIndex;
				n->sStart = s->sStart;
				n->sEnd = HereRightHigh;
				n->sIndexNode = nodeValue;
				
				*actSegIndex = *actSegIndex+1;
				
				return (1);
				}
			else
				{
				s->before1 = n;
				n->before1 = NULL;
				n->before2 = NULL;
				n->after1 = s;
				n->after2 = NULL;
				n->sIndex = *actSegIndex;
				n->sStart = s->sStart;
				n->sEnd = HereRightHigh;
				n->sIndexNode = nodeValue;
				
				*actSegIndex = *actSegIndex+1;
				
				return (1);
				}
			}
		else if (s->sEnd == numNuc)
			{
			if (s->sStart != 1)
				{
				s->before1 = n;
				n->before1 = NULL;
				n->before2 = NULL;
				n->after1 = s;
				n->after2 = NULL;
				n->sIndex = *actSegIndex;
				n->sStart = s->sStart;
				n->sEnd = HereRightHigh;
				n->sIndexNode = nodeValue;
				
				*actSegIndex = *actSegIndex+1;
				
				return (1);
				}
			else
				{
				fprintf (fpmpi, "\n\nWarning in recSegmentsGeneratesLeft1, it can't never here");			
				exit(-1);
				}
			}
		else if (s->sStart >= 1 && s->sEnd > breakp)
			{
			s->before1 = n;
			n->before1 = NULL;
			n->before2 = NULL;
			n->after1 = s;
			n->after2 = NULL;
			n->sIndex = *actSegIndex;
			n->sStart = s->sStart;
			n->sEnd = HereRightHigh;
			n->sIndexNode = nodeValue;
			
			*actSegIndex = *actSegIndex+1;
				
			return (1);
			}
		
		else
			{
			fprintf (fpmpi, "\n\nWarning in recSegmentsGeneratesLeft2, breakp = %d, it can't never here", breakp);			
			exit(-1);
			}
		}
	else		
		{
		fprintf (fpmpi, "\n\nWarning in recSegmentsGeneratesLeft3, it can't never here");			
		exit(-1);
		}

return (0);
}




/************** recSegmentsGeneratesRightBrokenCodon ****************/
/* It builds the new segments on the right of the breakpoint */

static int		recSegmentsGeneratesRightBrokenCodon(int nodeValue, TreeSegment *s, TreeSegment *m, int numNuc, int whichSite, int LeftLess, int RightHigh, int *actSegIndex)
{
	int breakp;
	int HereLeftLess, HereRightHigh;
	
	HereLeftLess = LeftLess;
	HereRightHigh = RightHigh;

	breakp = whichSite;

	if (s->sEnd >= breakp)
		{
		if (breakp <= s->sStart)
			{
			if (s->sStart == breakp && s->sEnd == numNuc)
				{
				s->before2 = m;
				m->before1 = NULL;
				m->before2 = NULL;
				m->after1 = s;
				m->after2 = NULL;
				m->sIndex = *actSegIndex;
				m->sStart = HereLeftLess;
				m->sEnd = s->sEnd;	
				m->sIndexNode = nodeValue;
				
				*actSegIndex = *actSegIndex+1;
				
				return (1);
				}
			else if (s->sStart == breakp && s->sEnd != numNuc)
				{
				s->before2 = m;
				m->before1 = NULL;
				m->before2 = NULL;
				m->after1 = s;
				m->after2 = NULL;
				m->sIndex = *actSegIndex;
				m->sStart = HereLeftLess;
				m->sEnd = s->sEnd;	
				m->sIndexNode = nodeValue;
				
				*actSegIndex = *actSegIndex+1;
				
				return (1);
				}
			else if (s->sStart != breakp && s->sEnd == numNuc)
				{
				s->before2 = m;
				m->before1 = NULL;
				m->before2 = NULL;
				m->after1 = s;
				m->after2 = NULL;
				m->sIndex = *actSegIndex;
				m->sStart = HereLeftLess;
				m->sEnd = s->sEnd;	
				m->sIndexNode = nodeValue;
				
				*actSegIndex = *actSegIndex+1;

				return (1);
				}
			else
				{
				s->before2 = m;
				m->before1 = NULL;
				m->before2 = NULL;
				m->after1 = s;
				m->after2 = NULL;
				m->sIndex = *actSegIndex;
				m->sStart = HereLeftLess;
				m->sEnd = s->sEnd;	
				m->sIndexNode = nodeValue;
				
				*actSegIndex = *actSegIndex+1;

				return (1);
				}
			}
			
		else if (s->sStart == 1)
			{
			if (s->sEnd != numNuc)
				{
				s->before2 = m;
				m->before1 = NULL;
				m->before2 = NULL;
				m->after1 = s;
				m->after2 = NULL;
				m->sIndex = *actSegIndex;
				m->sStart = HereLeftLess;
				m->sEnd = s->sEnd;
				m->sIndexNode = nodeValue;
				
				*actSegIndex = *actSegIndex+1;
				
				return (1);
				}
			else
				{
				s->before2 = m;
				m->before1 = NULL;
				m->before2 = NULL;
				m->after1 = s;
				m->after2 = NULL;
				m->sIndex = *actSegIndex;
				m->sStart = HereLeftLess;
				m->sEnd = s->sEnd;
				m->sIndexNode = nodeValue;
				
				*actSegIndex = *actSegIndex+1;
				
				return (1);
				}
			}
		else if (s->sEnd == numNuc)
			{
			if (s->sStart != 1)
				{
				s->before2 = m;
				m->before1 = NULL;
				m->before2 = NULL;
				m->after1 = s;
				m->after2 = NULL;
				m->sIndex = *actSegIndex;
				m->sStart = HereLeftLess;
				m->sEnd = s->sEnd;
				m->sIndexNode = nodeValue;
				
				*actSegIndex = *actSegIndex+1;
				
				return (1);
				}
			else
				{
				fprintf (fpmpi, "\n\nWarning in recSegmentsGeneratesRight1, it can't never here");			
				exit(-1);
				}
			}
		else if (s->sStart <= breakp && s->sEnd >= breakp)
			{
			s->before2 = m;
			m->before1 = NULL;
			m->before2 = NULL;
			m->after1 = s;
			m->after2 = NULL;
			m->sIndex = *actSegIndex;
			m->sStart = HereLeftLess;
			m->sEnd = s->sEnd;
			m->sIndexNode = nodeValue;
			
			*actSegIndex = *actSegIndex+1;
				
			return (1);
			}
		else
			{
			fprintf (fpmpi, "\n\nWarning in recSegmentsGeneratesRight2, breakp = %d, it can't never here", breakp);			
			exit(-1);
			}
		}
	else
		{
		fprintf (fpmpi, "\n\nWarning in recSegmentsGeneratesRight3, it can't never here");			
		exit(-1);
		}

return (0);
}






/*********************** coalescence overlap segments ************************/
/* When 2 nodes have a coalescence, this function returns YES 
if the site is contained in some segment of both nodes (reduces MRCA) or NO 
if the site is not in both nodes (does not reduce MRCA)*/
static int overLapSegmentsCoalMRCA (TreeNode *p, TreeNode *q, int sizeNode_p, int sizeNode_q, int site)
{
	int a, b, position;
	TreeSegment *s, *n;
	
	position = a = b = 0;
	
			
	for (position = 0; position < sizeNode_p; position++)
		{
		s = segments + post(position,p->index,distance);
		if (site >= s->sStart && site <= s->sEnd)
			{
			a = 1;
			break;
			}
		}
			
	for (position = 0; position < sizeNode_q; position++)
		{
		n = segments + post(position,q->index,distance);
		if (site >= n->sStart && site <= n->sEnd)
			{
			b = 1;
			break;
			}
		}
			
	if (a == 1 && b == 1)
		return YES;
	else
		return NO;
							
}






/************************************************/
/*************** BUILDING TREES *****************/
/* These functions build the genealogies of the trees from a net. 
These functions belong to MakeCoalescenceTree functions */

/************ buildTreeCoal *************/
/* It builds the tree when there aren't recombinations */
static void		buildTreeCoal (TreeNode *p, TreeNodex *f, int numSequences, int *numActNodex)
	{		
	TreeNodex *g, *h;
	
	g = NULL;
	h = NULL;
	
	if (p->left != NULL) 
		{
		*numActNodex = *numActNodex+1; 
		g = nodex + *numActNodex;
						
		g->index = *numActNodex;
		g->NetIndex = p->left->index;
		g->length = p->left->length;
		g->time = p->left->time;
		g->indexOldMigPop = p->left->indexOldMigPop;
		f->left = g;
		g->anc1 = f;
		}
	
	if (p->right != NULL)
		{
		*numActNodex = *numActNodex +1;
		h = nodex + *numActNodex;
				
		h->index = *numActNodex;
		h->NetIndex = p->right->index;
		h->length = p->right->length;
		h->time = p->right->time;
		h->indexOldMigPop = p->right->indexOldMigPop;
		f->right = h;
		h->anc1 = f;
		}
	
	if (p->left != NULL)
		buildTreeCoal (p->left, g, numSequences, numActNodex);
	if (p->right != NULL)
		buildTreeCoal (p->right, h, numSequences, numActNodex);
	}



/* Building with recombination */
/************* buildTreeInit ************/
/* It builds the initial tree of a net */
static void		buildTreeInit (TreeNode *p, TreeNodex *f, int numNuc, int *arrayIndBreakpointsOrd, int whoBreakp, int numSequences, int *numActNodex/*, int *numNodex*/)
	{		/*buildTreeInit(p, f, numNuc, arrayIndBreakpointsOrd, j, numSequences, &numActNodex);*/
	int hind, gind, a, w, j, x, k, step, numSegInit;
	int *arrayIndexTreeSegments;
	int numberNq, numberNr;
	
	TreeSegment *s;
	TreeNode *q, *r;
	TreeNodex *g, *h;
	
	r = NULL;
	q = NULL;
	g = NULL;
	h = NULL;
	w = x = k = a = j = hind = gind = step = numSegInit = numberNq = numberNr = 0;

	arrayIndexTreeSegments = (int *) calloc((p->numSegNode +1),(long) sizeof(int));
	if (!arrayIndexTreeSegments)
		{
		fprintf (fpmpi, "Could not allocate arrayIndexTreeSegments (%lu bytes)\n", (p->numSegNode*2 +1) *(long) sizeof(int));
		exit (-1);
		}
		
	for (w = 0; w < p->numSegNode; w++)
		{
		s = segments + post(w,p->index,distance);
		
		if (s->sStart == 1 && s->sEnd >= (arrayIndBreakpointsOrd[whoBreakp]-1) && s->after1 != NULL) /* first tree */
			{
			arrayIndexTreeSegments[x] = s->sIndex;
			x++;
			}
		}
	numSegInit = x;
	for (w = 0; w < numSegInit; w++) 
		{
		if (arrayIndexTreeSegments[w] < numSequences)
			step++;
		}
	
	if (step < numSegInit)
		{
		for (w = 0; w < p->numSegNode; w++)
			{
			s = segments + post(w,p->index,distance);
	
			if (s->sIndex == arrayIndexTreeSegments[a] && a <= numSegInit) 
				{
				if (k == 0) /* first segment that make a nodex */
					{
					if (s->after1 != NULL) 
						{
						gind++;
						*numActNodex = *numActNodex+1;
						
						g = nodex + *numActNodex;
												
						numberNq = s->after1->sIndexNode;
						q = nodes + numberNq;
												
						g->index = *numActNodex;

						g->MRCAfrom = 1;
						g->MRCAto = arrayIndBreakpointsOrd[whoBreakp]-1;

						g->NetIndex = q->index;
						g->length = q->length;
						g->time = q->time;
						g->indexOldMigPop = q->indexOldMigPop;
						f->left = g;
						g->anc1 = f;
						
						if (s->after2 != NULL)
							{
							if (s->after2->sIndexNode != s->after1->sIndexNode)
								{
								*numActNodex = *numActNodex +1;
								hind++;
								
								h = nodex + *numActNodex;
								numberNr = s->after2->sIndexNode;
								r = nodes + numberNr;

								h->index = *numActNodex;
								h->NetIndex = r->index;

								h->MRCAfrom = 1;
								h->MRCAto = arrayIndBreakpointsOrd[whoBreakp]-1;

								h->length = r->length;
								h->time = r->time;
								h->indexOldMigPop = r->indexOldMigPop;
								f->right = h;
								h->anc1 = f;
								}
							}
						}
					}
	
	
			if ((k > 0) && (gind == 0 || hind == 0)) /* others segments */
				{
				if (s->after1 != NULL) 
					{
					if (s->after2 == NULL && hind == 0 && s->after1->sIndexNode != numberNq)
						{
						hind++;	
						*numActNodex = *numActNodex+1;
								
						h = nodex + *numActNodex;
						numberNr = s->after1->sIndexNode;
						r = nodes + numberNr;
						
						h->index = *numActNodex;
						h->NetIndex = r->index;

						h->MRCAfrom = 1;
						h->MRCAto = arrayIndBreakpointsOrd[whoBreakp]-1;

						h->length = r->length;
						h->time = r->time;
						h->indexOldMigPop = r->indexOldMigPop;
						f->right = h;
						h->anc1 = f;
						}
					if (s->after2 != NULL)
						{
						if (hind == 0)	
							{
							if (s->after1->sIndexNode == numberNq && s->after2->sIndexNode != numberNq)
								{
								hind++;
								*numActNodex=*numActNodex+1;
								
								h = nodex + *numActNodex;
								numberNr = s->after2->sIndexNode;
								r = nodes + numberNr;
								
								h->index = *numActNodex;
								h->NetIndex = r->index;

								h->MRCAfrom = 1;
								h->MRCAto = arrayIndBreakpointsOrd[whoBreakp]-1;

								h->length = r->length;
								h->time = r->time;
								h->indexOldMigPop = r->indexOldMigPop;
								f->right = h;
								h->anc1 = f;
								}
							}
						}
					}
				}
				k++;
				if (a < numSegInit)
					w = 0;
				a++;
			}
			if (a >= numSegInit)
				break;
		}
		
		free (arrayIndexTreeSegments);
				
		if (q != NULL && gind != 0)
			buildTreeInit (q, g, numNuc, arrayIndBreakpointsOrd, whoBreakp, numSequences, numActNodex);
		if (r != NULL && hind != 0)
			buildTreeInit (r, h, numNuc, arrayIndBreakpointsOrd, whoBreakp, numSequences, numActNodex);
		}
	}






/************* buildTreeEnd ************/
/* It builds the final tree of a net */
static void		buildTreeEnd (TreeNode *p, TreeNodex *f, int numNuc, int *arrayIndBreakpointsOrd, int whoBreakp, int numSequences, int *numActNodex)
	{		
	int hind, gind, end_b, end_c, a, w, j, x, k, step, counter, numSegInit;
	int numberNr, numberNq;
	int *arrayIndexTreeSegments;

	TreeSegment *s;
	TreeNode *q, *r;
	TreeNodex *g, *h;
					
	r = NULL;
	q = NULL;
	g = NULL;
	h = NULL;
	w = x = k = a = j = counter = end_b = end_c = hind = gind = step = numSegInit = numberNr = numberNq = 0;
	
	arrayIndexTreeSegments = (int *) calloc((p->numSegNode +1),(long) sizeof(int));
	if (!arrayIndexTreeSegments)
		{
		fprintf (fpmpi, "Could not allocate arrayIndexTreeSegments (%lu bytes)\n", (p->numSegNode*2 +1) *(long) sizeof(int));
		exit (-1);
		}
	
	for (w = 0; w < p->numSegNode; w++) 
		{
		s = segments + post(w,p->index,distance);
	
		if (s->sStart <= arrayIndBreakpointsOrd[whoBreakp] && s->sEnd == numNuc && s->after1 != NULL)		/* last tree */		/* j = indNumRE-1 */
			{
			arrayIndexTreeSegments[x] = s->sIndex;
			x++;
			}
		}
	numSegInit = x;

	for (w = 0; w < numSegInit; w++) 
		{
		if (arrayIndexTreeSegments[w] < numSequences)
			step++;
		}

	
	if (step < numSegInit)
		{
		for (w = 0; w < p->numSegNode; w++)
			{
			s = segments + post(w,p->index,distance);
	
			if (s->sIndex == arrayIndexTreeSegments[a] && a <= numSegInit) 
				{
				if (k == 0) /* first segment that make a nodex */
					{
					if (s->after1 != NULL) 
						{				
						gind++;
						*numActNodex = *numActNodex+1;
						
						g = nodex + *numActNodex;
						numberNq = s->after1->sIndexNode;
						q = nodes + numberNq;

						g->index = *numActNodex;
						g->NetIndex = q->index;
						g->length = q->length;
						g->time = q->time;

						g->MRCAfrom = arrayIndBreakpointsOrd[whoBreakp];
						g->MRCAto = numNuc;

						g->indexOldMigPop = q->indexOldMigPop;
						f->left = g;
						g->anc1 = f;
						
						if (s->after2 != NULL)
							{
							if (s->after2->sIndexNode != s->after1->sIndexNode)
								{						
								*numActNodex = *numActNodex +1;
								hind++;
								
								h = nodex + *numActNodex;
								numberNr = s->after2->sIndexNode;
								r = nodes + numberNr;
								
								h->index = *numActNodex;
								h->NetIndex = r->index;

								h->MRCAfrom = arrayIndBreakpointsOrd[whoBreakp];
								h->MRCAto = numNuc;

								h->length = r->length;
								h->time = r->time;
								h->indexOldMigPop = r->indexOldMigPop;
								f->right = h;
								h->anc1 = f;
								}
							}
						}
					}
	
				if ((k > 0) && (gind == 0 || hind == 0)) /* others segments */
					{
					if (s->after1 != NULL) 
						{
						if (s->after2 == NULL && hind == 0 && s->after1->sIndexNode != numberNq)
							{
							hind++;	
							*numActNodex = *numActNodex+1;
							
							h = nodex + *numActNodex;
							numberNr = s->after1->sIndexNode;
							r = nodes + numberNr;
							
							h->index = *numActNodex;
							h->NetIndex = r->index;

							h->MRCAfrom = arrayIndBreakpointsOrd[whoBreakp];
							h->MRCAto = numNuc;

							h->length = r->length;
							h->time = r->time;
							h->indexOldMigPop = r->indexOldMigPop;
							f->right = h;
							h->anc1 = f;
							}
						if (s->after2 != NULL)
							{
							if (s->after1->sIndexNode == numberNq && s->after2->sIndexNode != numberNq && hind == 0) /* h aun no se ha creado */
								{
								hind++;
								*numActNodex=*numActNodex+1;
								
								h = nodex + *numActNodex;
								numberNr = s->after2->sIndexNode;
								r = nodes + numberNr;
								
								h->index = *numActNodex;
								h->NetIndex = r->index;
								
								h->MRCAfrom = arrayIndBreakpointsOrd[whoBreakp];
								h->MRCAto = numNuc;

								h->length = r->length;
								h->time = r->time;
								h->indexOldMigPop = r->indexOldMigPop;
								f->right = h;
								h->anc1 = f;
								}
								
							}
						}
					}
					k++;
					if (a < numSegInit)
						w = 0;
					a++; 
				}
				if (a >= numSegInit)
					break;
			}
	
		free (arrayIndexTreeSegments);
	
		if (q != NULL && gind == 1)
			buildTreeEnd (q, g, numNuc, arrayIndBreakpointsOrd, whoBreakp, numSequences, numActNodex);
		if (r != NULL && hind == 1)
			buildTreeEnd (r, h, numNuc, arrayIndBreakpointsOrd, whoBreakp, numSequences, numActNodex);
		}
	}








/************ buildTreeIntern *************/
/* It builds the internal trees of a net */
static void		buildTreeIntern (TreeNode *p, TreeNodex *f, int numNuc, int *arrayIndBreakpointsOrd, int whoBreakp, int numSequences, int *numActNodex)
	{		
	int hind, gind, a, w, j, x, k, step, numSegInit;
	int numberNq, numberNr;
	int *arrayIndexTreeSegments;

	TreeSegment *s;
	TreeNode *q, *r;
	TreeNodex *g, *h;
	
	r = NULL;
	q = NULL;
	g = NULL;
	h = NULL;
	w = x = k = a = j = hind = gind = step = numSegInit = numberNq = numberNr = 0;
	
	arrayIndexTreeSegments = (int *) calloc((p->numSegNode +1),(long) sizeof(int));
	if (!arrayIndexTreeSegments)
		{
		fprintf (fpmpi, "Could not allocate arrayIndexTreeSegments (%lu bytes)\n", (p->numSegNode*2 +1) *(long) sizeof(int));
		exit (-1);
		}
	
	for (w = 0; w < p->numSegNode; w++)
		{
		s = segments + post(w,p->index,distance);
	
		if (s->sStart <= (arrayIndBreakpointsOrd[whoBreakp]) && s->sEnd >= (arrayIndBreakpointsOrd[whoBreakp+1]-1) && s->after1 != NULL) /* internal trees */
			{
			arrayIndexTreeSegments[x] = s->sIndex;
			x++;
			}
		}
	numSegInit = x;
	for (w = 0; w < numSegInit; w++) 
		{
		if (arrayIndexTreeSegments[w] < numSequences)
			step++;
		}
	
	if (step < numSegInit)
		{
		for (w = 0; w < p->numSegNode; w++)
			{
			s = segments + post(w,p->index,distance);
	
			if (s->sIndex == arrayIndexTreeSegments[a] && a <= numSegInit)
				{
									
				if (k == 0) /* first segment that make a nodex */
					{
					if (s->after1 != NULL) 
						{
						gind++;
						*numActNodex = *numActNodex+1;
						
						g = nodex + *numActNodex;
						numberNq = s->after1->sIndexNode;
						q = nodes + numberNq;
						
						g->index = *numActNodex;

						g->MRCAfrom = arrayIndBreakpointsOrd[whoBreakp];
						g->MRCAto = arrayIndBreakpointsOrd[whoBreakp+1]-1;

						g->NetIndex = q->index;
						g->length = q->length;
						g->time = q->time;
						g->indexOldMigPop = q->indexOldMigPop;
						f->left = g;
						g->anc1 = f;
							
						if (s->after2 != NULL)
							{
							if (s->after2->sIndexNode != s->after1->sIndexNode)
								{
								*numActNodex = *numActNodex +1;
								hind++;
							
								h = nodex + *numActNodex;
								numberNr = s->after2->sIndexNode;
								r = nodes + numberNr;
								
								h->index = *numActNodex;
								h->NetIndex = r->index;

								h->MRCAfrom = arrayIndBreakpointsOrd[whoBreakp];
								h->MRCAto = arrayIndBreakpointsOrd[whoBreakp+1]-1;								

								h->length = r->length;
								h->time = r->time;
								h->indexOldMigPop = r->indexOldMigPop;
								f->right = h;
								h->anc1 = f;
								}
							}
						}
					}
	

				if ((k > 0) && (gind == 0 || hind == 0)) /* others segments */
					{
					if (s->after1 != NULL) 
						{
						if (s->after2 == NULL && hind == 0 && s->after1->sIndexNode != numberNq)
							{
							hind++;	
							*numActNodex = *numActNodex+1;
							
							h = nodex + *numActNodex;
							numberNr = s->after1->sIndexNode;
							r = nodes + numberNr;
							
							h->index = *numActNodex;
							h->NetIndex = r->index;

							h->MRCAfrom = arrayIndBreakpointsOrd[whoBreakp];
							h->MRCAto = arrayIndBreakpointsOrd[whoBreakp+1]-1;

							h->length = r->length;
							h->time = r->time;
							h->indexOldMigPop = r->indexOldMigPop;
							f->right = h;
							h->anc1 = f;
							}
						if (s->after2 != NULL)
							{
							if (hind == 0 && s->after1->sIndexNode == numberNq && s->after2->sIndexNode != numberNq)
								{
								hind++;
								*numActNodex=*numActNodex+1;
							
								h = nodex + *numActNodex;
								numberNr = s->after2->sIndexNode;
								r = nodes + numberNr;
								
								h->index = *numActNodex;
								h->NetIndex = r->index;

								h->MRCAfrom = arrayIndBreakpointsOrd[whoBreakp];
								h->MRCAto = arrayIndBreakpointsOrd[whoBreakp+1]-1;	

								h->length = r->length;
								h->time = r->time;
								h->indexOldMigPop = r->indexOldMigPop;
								f->right = h;
								h->anc1 = f;
								}
							}
						}
					}
					k++;
					if (a < numSegInit)
						w = 0;
					a++;
				}
				if (a >= numSegInit)
					break;
			}
			
		free (arrayIndexTreeSegments);
	
		if (q != NULL && gind != 0)
			buildTreeIntern (q, g, numNuc, arrayIndBreakpointsOrd, whoBreakp, numSequences, numActNodex);
			
		if (r != NULL && hind != 0)
			buildTreeIntern (r, h, numNuc, arrayIndBreakpointsOrd, whoBreakp, numSequences, numActNodex);
		}
	}





/**************** Functions to print output files **************/

/****************** Print Segments Trees *****************/
/* Print unrooted trees to treefile in Newick format */
void PrintTreesSeg(int replicate, int indNumRE, int numNuc, int *arrayIndBreakpointsOrd)
	{
	int		step, z, currentNumber;
	int		*listVisitedNodes;
	
	if (numRE == 0)			/* there aren't recombinations */
		{
		step = 0;
		fprintf(fpTrees, "Dataset %d \n", replicate+1);
		fprintf (fpTrees, "Tree %05d_%05d [1-%d] = ", replicate+1, step+1, numNuc);
		/*fprintf(fpTrees,"Tree.%05d = ", replicate+1);*/
		WriteTreeSeg (treeRootNodex[0]);
		fprintf(fpTrees,");\n");
		fprintf(fpTrees,"\n\n");
		}
	else					/* there are recombinations */
		{
		fprintf(fpTrees, "Dataset %d \n", replicate+1);
		for (step = 0; step <= indNumRE; step++)
			{
			if (step == 0)	
				fprintf (fpTrees, "Tree %05d_%05d [1-%d] = ", replicate+1, step+1, arrayIndBreakpointsOrd[0]-1);
			if (step == indNumRE)
				fprintf (fpTrees, "Tree %05d_%05d [%d-%d] = ", replicate+1, step+1, arrayIndBreakpointsOrd[indNumRE-1], numNuc);
			if (step > 0 && step < indNumRE)
				fprintf (fpTrees, "Tree %05d_%05d [%d-%d] = ", replicate+1, step+1, arrayIndBreakpointsOrd[step-1], arrayIndBreakpointsOrd[step]-1); 
			
			if (doCodonModel == YES && doDayhoff == YES) /* NEVER, remove this if and derived staff */
				{
				listVisitedNodes = (int *) calloc((2*numSequences+numSequences),(long) sizeof(int)); /* to check nodes visited */
				if (!listVisitedNodes)
					{
					fprintf (stderr, "Could not allocate listVisitedNodes (%lu)\n", (2*numSequences+numSequences) * (long) sizeof(int));
					exit (-1);
					}
				for (z = 0; z <= 2*numSequences+numSequences-1; z++)
					listVisitedNodes[z] = -1;
				currentNumber = 0;
				WriteTreeSegCodonModel (treeRootNodex[step], listVisitedNodes, currentNumber);
				free (listVisitedNodes);
				}
			else
				WriteTreeSeg (treeRootNodex[step]);
			fprintf (fpTrees, ");\n");
			}
		fprintf(fpTrees,"\n\n");
		}
	/*fprintf (fpTrees,"\n");*/
	}



/******************* WriteTreeSeg ****************/
/* Writes a given (unrooted) tree from PrintTrees */

void WriteTreeSeg (TreeNodex *f)
	{		
	if (f != NULL)
		{
		if (doMigration == YES)
			{
			if (f->isOutgroup == YES)			/* outgroup */
				fprintf (fpTrees, ",outgroup_pop%d:%8.6f", f->indexOldMigPop, f->length*mutationRate);
			else if (f->left == NULL && f->right == NULL)		/* tip of the tree */
				fprintf (fpTrees, "seq%05d_pop%d:%8.6f", LabelSeg(f), f->indexOldMigPop, (f->anc1->time - f->time)*mutationRate);
			else								/* all ancester */
				{
				fprintf (fpTrees, "(");
				WriteTreeSeg (f->left);
				fprintf (fpTrees, ",");
				WriteTreeSeg (f->right);	
				if (f->anc1 != NULL)
					fprintf (fpTrees, "):%8.6f", (f->anc1->time - f->time)*mutationRate);
				WriteTreeSeg (f->outgroup);	
				}
			}
		else
			{
			if (f->isOutgroup == YES)			/* outgroup */
				fprintf (fpTrees, ",outgroup:%8.6f", f->length*mutationRate);
			else if (f->left == NULL && f->right == NULL)		/* tip of the tree */
				fprintf (fpTrees, "seq%05d:%8.6f", LabelSeg(f), (f->anc1->time - f->time)*mutationRate);
			else								/* all ancester */
				{
				fprintf (fpTrees, "(");
				WriteTreeSeg (f->left);
				fprintf (fpTrees, ",");
				WriteTreeSeg (f->right);	
				if (f->anc1 != NULL)
					fprintf (fpTrees, ")%d:%8.6f",f->NetIndex+1, (f->anc1->time - f->time)*mutationRate);
				WriteTreeSeg (f->outgroup);	
				}
			}
		}
	}


/******************* WriteTreeSegCodonModel ****************/
/* Writes a given (unrooted) tree from PrintTrees */

void WriteTreeSegCodonModel (TreeNodex *f, int *listVisitedNodes, int currentNumber)
	{
	int control, z;

	control = 1;
	
	for (z = 0; z <= 2*numSequences+numSequences-1; z++)
		{
		if (f->NetIndex == listVisitedNodes[z])
			{
			control = 0;
			fprintf(stderr, "\n This node is revisited (f->NetIndex = %d) and not considered \n", f->NetIndex);
			}
		}
	listVisitedNodes[currentNumber] = f->NetIndex;
	currentNumber++;
	fprintf(stderr, "currentNumber = %d\n\n", currentNumber);
		
	if (f != NULL)
		{
		if (doMigration == YES)
			{
			if (control == 0)
				fprintf(stderr, "Out\n\n");
			else
				{
				if (f->isOutgroup == YES)			/* outgroup */
					fprintf (fpTrees, ",outgroup_pop%d:%8.6f", f->indexOldMigPop, f->length*mutationRate);
				else if (f->left == NULL && f->right == NULL)		/* tip of the tree */
					fprintf (fpTrees, "seq%05d_pop%d:%8.6f", LabelSeg(f), f->indexOldMigPop, (f->anc1->time - f->time)*mutationRate);
				else								/* all ancester */
					{
					fprintf (fpTrees, "(");
					WriteTreeSegCodonModel (f->left, listVisitedNodes, currentNumber);
					fprintf (fpTrees, ",");
					WriteTreeSegCodonModel (f->right, listVisitedNodes, currentNumber);	
					if (f->anc1 != NULL)
						fprintf (fpTrees, "):%8.6f",(f->anc1->time - f->time)*mutationRate);
					WriteTreeSegCodonModel (f->outgroup, listVisitedNodes, currentNumber);	
					}
				}
			}
		else
			{
			if (control == 0)
				fprintf(stderr, "Out\n\n");
			else 
				{
				if (f->isOutgroup == YES)			/* outgroup */
					fprintf (fpTrees, ",outgroup:%8.6f", f->length*mutationRate);
				else if (f->left == NULL && f->right == NULL)		/* tip of the tree */
					fprintf (fpTrees, "seq%05d:%8.6f", LabelSeg(f), (f->anc1->time - f->time)*mutationRate);
				else								/* all ancester */
					{
					fprintf (fpTrees, "(");
					WriteTreeSegCodonModel (f->left, listVisitedNodes, currentNumber);
					fprintf (fpTrees, ",");
					WriteTreeSegCodonModel (f->right, listVisitedNodes, currentNumber);	
					if (f->anc1 != NULL)
						fprintf (fpTrees, "):%8.6f",(f->anc1->time - f->time)*mutationRate);
					WriteTreeSegCodonModel (f->outgroup, listVisitedNodes, currentNumber);	
					}
				}
			}
		}
	}






/********************* PrintTimes **********************/
/* Prints to timesfile a detailed description of
the tree: nodes, times, branch lengths */

void PrintTimesSeg(int replicate, int indNumRE, int numNuc, int *arrayIndBreakpointsOrd)
	{

	int		step;
	step = 0;
	
	if (doMigration == NO)
		{
		if (numRE == 0)				/* there aren't recombinations */
			{
			fprintf (fpTimes, "\n\nDataset_%d Fragment_1 [1-%d]", replicate+1, numNuc);
			fprintf (fpTimes, "\n----------------- Nodes -----------------------");
			fprintf (fpTimes, "\n  class  label index (left right anc) | NetNode[info]       (left right anc) |        time    time length   branch lenght");
			fprintf (fpTimes, "\n---------------------------------------------------------------------------------------------------------------\n");
			ListTimesSeg (treeRootNodex[0]);
			}
		else						/* there are recombinations */
			{
			for (step = 0; step <= indNumRE; step++)
				{
				if (step == 0)
					fprintf (fpTimes, "\n\nDataset_%d Fragment_%d [1-%d]", replicate+1, step+1, arrayIndBreakpointsOrd[0]-1);
				if (step == indNumRE)
					fprintf (fpTimes, "\n\nDataset_%d Fragment_%d [%d-%d]", replicate+1, step+1, arrayIndBreakpointsOrd[indNumRE-1], numNuc);
				if (step > 0 && step < indNumRE)
					fprintf (fpTimes, "\n\nDataset_%d Fragment_%d [%d-%d]", replicate+1, step+1, arrayIndBreakpointsOrd[step-1], arrayIndBreakpointsOrd[step]-1);
		
				fprintf (fpTimes, "\n----------------- Nodes -------------------");
			fprintf (fpTimes, "\n  class  label index (left right anc) | NetNode[info]       (left right anc) |        time    time length   branch lenght");
				fprintf (fpTimes, "\n---------------------------------------------------------------------------------------------------------------\n");
				
				ListTimesSeg (treeRootNodex[step]);
				}
			}
		}
	else
		{
		if (numRE == 0)				/* there aren't recombinations */
			{
			fprintf (fpTimes, "\n\nDataset_%d Fragment_1 [1-%d]", replicate+1, numNuc);
			fprintf (fpTimes, "\n-------------------- Nodes -------------------------");
			fprintf (fpTimes, "\n  class  label index (left right anc) | NetNode[info]       (left right anc) | deme |        time    time length   branch lenght");
			fprintf (fpTimes, "\n----------------------------------------------------------------------------------------------------------------------\n");
			ListTimesSeg (treeRootNodex[0]);
			}
		else						/* there are recombinations */
			{
			for (step = 0; step <= indNumRE; step++)
				{
				if (step == 0)
					fprintf (fpTimes, "\n\nDataset_%d Fragment_%d [1-%d]", replicate+1, step+1, arrayIndBreakpointsOrd[0]-1);
				if (step == indNumRE)
					fprintf (fpTimes, "\n\nDataset_%d Fragment_%d [%d-%d]", replicate+1, step+1, arrayIndBreakpointsOrd[indNumRE-1], numNuc);
				if (step > 0 && step < indNumRE)
					fprintf (fpTimes, "\n\nDataset_%d Fragment_%d [%d-%d]", replicate+1, step+1, arrayIndBreakpointsOrd[step-1], arrayIndBreakpointsOrd[step]-1);
		
				fprintf (fpTimes, "\n-------------------- Nodes -------------------------");
			fprintf (fpTimes, "\n  class  label index (left right anc) | NetNode[info]       (left right anc) | deme |        time    time length   branch lenght");
				fprintf (fpTimes, "\n----------------------------------------------------------------------------------------------------------------------\n");
				
				ListTimesSeg (treeRootNodex[step]);
				}
			}
		}
	
	}






/******************* ListTimes ****************/
/* It makes a list of the nodes with information as time, lenght.. */
void ListTimesSeg (TreeNodex *f)
	{
	if (doMigration == NO)
		{
		if (f != NULL)			
			{
			if (f->isOutgroup == YES)			/* Outgroup */
				{
				fprintf (fpTimes, "%8s  %4d  %4d (%4d %4d %4d) |  %5d[outgroup] (%5d %5d %5d) |  %10.2lf     %10.2lf      %10.6lf\n", 
						"outgroup", LabelSeg(f), IndexSeg(f), IndexSeg(f->left), IndexSeg(f->right), IndexSeg(f->anc1), IndexSegNet(f), IndexSegNet(f->left), IndexSegNet(f->right), IndexSegNet(f->anc1), f->time, f->length, f->length*mutationRate);
				}
			else if (f->anc1 != NULL && f->left != NULL && f->right != NULL)				/* No MRCA, no tip (internal ancester) */
				{
				fprintf (fpTimes, "%8s  %4d  %4d (%4d %4d %4d) |  %5d           (%5d %5d %5d) |  %10.2lf     %10.2lf      %10.6lf\n", 
						"internal", LabelSeg(f), IndexSeg(f), IndexSeg(f->left), IndexSeg(f->right), IndexSeg(f->anc1), IndexSegNet(f), IndexSegNet(f->left), IndexSegNet(f->right), IndexSegNet(f->anc1), f->time, f->anc1->time - f->time, (f->anc1->time - f->time)*mutationRate);
				}
			else if (f->anc1 != NULL && f->left == NULL && f->right == NULL)				/* tip */
				{
				fprintf (fpTimes, "%8s  %4d  %4d (%4d %4d %4d) |  %5d[seq%05d] (%5d %5d %5d) |  %10.2lf     %10.2lf      %10.6lf\n", 
						"tip", LabelSeg(f), IndexSeg(f), IndexSeg(f->left), IndexSeg(f->right), IndexSeg(f->anc1), IndexSegNet(f), IndexSegNet(f)+1, IndexSegNet(f->left), IndexSegNet(f->right), IndexSegNet(f->anc1), f->time, f->anc1->time - f->time, (f->anc1->time - f->time)*mutationRate);
				}
			else if (f->anc1 == NULL && f->left != NULL && f->right != NULL)				/* root, MRCA */
				{
				fprintf (fpTimes, "%8s  %4d  %4d (%4d %4d %4d) |  %5d[root]     (%5d %5d %5d) |  %10.2lf     %10.2lf      %10.6lf\n", 
						"root", LabelSeg(f), IndexSeg(f), IndexSeg(f->left), IndexSeg(f->right), IndexSeg(f->anc1), IndexSegNet(f), IndexSegNet(f->left), IndexSegNet(f->right), IndexSegNet(f->anc1), f->time, 0.0, 0.0);
				}
			else
				fprintf (fpTimes," ");
		
			ListTimesSeg (f->left);
			ListTimesSeg (f->right);
			ListTimesSeg (f->outgroup);
			}
		}
	else
		{
		if (f != NULL)			
			{
			if (f->isOutgroup == YES)			/* Outgroup */
				{
				fprintf (fpTimes, "%8s %4d %4d   (%4d %4d %4d) |  %5d[outgroup] (%5d %5d %5d) | %2d |  %10.2lf     %10.2lf      %10.6lf\n", 
						"outgroup", LabelSeg(f), IndexSeg(f), IndexSeg(f->left), IndexSeg(f->right), IndexSeg(f->anc1),  IndexSegNet(f), IndexSegNet(f->left), IndexSegNet(f->right), IndexSegNet(f->anc1),  f->indexOldMigPop, f->time, f->length, f->length*mutationRate);
				}
			else if (f->anc1 != NULL && f->left != NULL && f->right != NULL)				/* No MRCA, no tip (internal ancester) */
				{
				fprintf (fpTimes, "%8s %4d %4d   (%4d %4d %4d) |  %5d           (%5d %5d %5d) | %2d |  %10.2lf     %10.2lf      %10.6lf\n", 
						"internal", LabelSeg(f), IndexSeg(f), IndexSeg(f->left), IndexSeg(f->right), IndexSeg(f->anc1),  IndexSegNet(f), IndexSegNet(f->left), IndexSegNet(f->right), IndexSegNet(f->anc1),  f->indexOldMigPop, f->time, f->anc1->time - f->time, (f->anc1->time - f->time)*mutationRate);
				}
			else if (f->anc1 != NULL && f->left == NULL && f->right == NULL)				/* tip */
				{
				fprintf (fpTimes, "%8s %4d %4d   (%4d %4d %4d) |  %5d[seq%05d] (%5d %5d %5d) | %2d |  %10.2lf     %10.2lf      %10.6lf\n", 
						"tip", LabelSeg(f), IndexSeg(f), IndexSeg(f->left), IndexSeg(f->right), IndexSeg(f->anc1),  IndexSegNet(f), IndexSegNet(f)+1, IndexSegNet(f->left), IndexSegNet(f->right), IndexSegNet(f->anc1),  f->indexOldMigPop, f->time, f->anc1->time - f->time, (f->anc1->time - f->time)*mutationRate);
				}
			else if (f->anc1 == NULL && f->left != NULL && f->right != NULL)				/* root, MRCA */
				{
				fprintf (fpTimes, "%8s %4d %4d   (%4d %4d %4d) |  %5d[root]     (%5d %5d %5d) | %2d |  %10.2lf     %10.2lf      %10.6lf\n", 
						"root", LabelSeg(f), IndexSeg(f), IndexSeg(f->left), IndexSeg(f->right), IndexSeg(f->anc1),  IndexSegNet(f), IndexSegNet(f->left), IndexSegNet(f->right), IndexSegNet(f->anc1),  f->indexOldMigPop, f->time, 0.0, 0.0);
				}
			else
				fprintf (fpTimes," ");
		
			ListTimesSeg (f->left);
			ListTimesSeg (f->right);
			ListTimesSeg (f->outgroup);
			}
		}
	}





/***************** IndexSeg ***************/
/* Returns index for a given node */

int IndexSeg (TreeNodex *f)
{
	return (f == NULL) ? -1 : f->index+1; /* If the node haven't got bond => index = -1, else index = index+1 */
}


/***************** IndexSegNet ***************/
/* Returns NetIndex for a given node */

int IndexSegNet (TreeNodex *f)
{
	return (f == NULL) ? -1 : f->NetIndex; /* If the node haven't got bond => index = -1, else NetIndex */
}



/***************** LabelSeg ***************/
/* Returns label for a given node */

int LabelSeg (TreeNodex *f)
{
	return (f->anc1 == NULL && f->left == NULL && f->right == NULL) ? -1 : f->label+1; /* If the node have not got ancester and descendants => label = -1, else label = label+1 */
}





/**************** RelabelNodes **************/
/*	After getting rid of superfluos node, we
	need to relabel those so they are consecutive 
	Use the indexes as labels when there
	is recombination
*/
void RelabelNodesSeg (TreeNodex *f)
	{
	if (f != NULL)
		{
		RelabelNodesSeg (f->left);
		RelabelNodesSeg (f->right);
		
		
		if (f->left == NULL && f->right == NULL) /* is tip */
			f->label = /*tipLabel++;*/f->NetIndex;
		else /* all ancester */
			f->label = intLabel++;/*f->NetIndex*/;

		/*if (f->left != NULL && f->right != NULL && f->anc1 == NULL)
			{
			fprintf (fpmpi, "\n Relabel, MRCA, f->label = %d, f->index = %d \n", f->label, f->index);
			}*/

		/*if (f->NetIndex == 0)
				fprintf(stderr,"\n\n  ********************** f->NetIndex = 0 y f->label = %d \n\n", f->label);*/
			
		/*if (tipLabel > intLabel)
			{
			fprintf (fpmpi, "\n\nWarning in RelabelNodesSeg, intLabel %d and tipLabel %d", intLabel, tipLabel);
			exit (-1);
			}*/
		}
	}
	
	














